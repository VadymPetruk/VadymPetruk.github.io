<!doctype html>
<html>
<head>
    <meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no' />
    <meta charset='utf-8'>
    
    
    <style>html {
    height: 100%;
    background-color: #1d292c;
}
body {
    margin: 0;
    max-height: 100%;
    height: 100%;
    overflow: hidden;
    background-color: #1d292c;
    font-family: Helvetica, arial, sans-serif;
    position: relative;
    width: 100%;

    -webkit-tap-highlight-color: transparent;
}

#application-canvas {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
}
#application-canvas.fill-mode-NONE {
    margin: auto;
}
#application-canvas.fill-mode-KEEP_ASPECT {
    width: 100%;
    height: auto;
    margin: 0;
}
#application-canvas.fill-mode-FILL_WINDOW {
    width: 100%;
    height: 100%;
    margin: 0;
}

canvas:focus {
    outline: none;
}
</style>
    <title>Zoocraft Playable Ads</title>
    <script>;(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof module === 'object' && module.exports) {
        try {
            var JSDOM = require("jsdom").JSDOM;
            var DOM = new JSDOM();
            var window = DOM.window;
            var navigator = window.navigator;
            module.exports = factory(window, navigator);
        } catch (error) {
            module.exports = factory();
        }
    } else {
        root.pc = factory(root, root.navigator);
  }
}(this, function (_window, _navigator) {
  window = _window || window;
  navigator = _navigator || navigator;

  /*
 PlayCanvas Engine v1.15.4 revision cbd03f66
 http://playcanvas.com
 Copyright 2011-2018 PlayCanvas Ltd. All rights reserved.
*/
var _typeLookup = function() {
  var result = {};
  var names = ["Array", "Object", "Function", "Date", "RegExp", "Float32Array"];
  for (var i = 0; i < names.length; i++) {
    result["[object " + names[i] + "]"] = names[i].toLowerCase();
  }
  return result;
}();
var pc = {version:"1.15.4", revision:"cbd03f66", config:{}, common:{}, apps:{}, data:{}, unpack:function() {
  console.warn("pc.unpack has been deprecated and will be removed shortly. Please update your code.");
}, makeArray:function(arr) {
  var i, ret = [], length = arr.length;
  for (i = 0; i < length; ++i) {
    ret.push(arr[i]);
  }
  return ret;
}, type:function(obj) {
  if (obj === null) {
    return "null";
  }
  var type = typeof obj;
  if (type === "undefined" || type === "number" || type === "string" || type === "boolean") {
    return type;
  }
  return _typeLookup[Object.prototype.toString.call(obj)];
}, extend:function(target, ex) {
  var prop, copy;
  for (prop in ex) {
    copy = ex[prop];
    if (pc.type(copy) == "object") {
      target[prop] = pc.extend({}, copy);
    } else {
      if (pc.type(copy) == "array") {
        target[prop] = pc.extend([], copy);
      } else {
        target[prop] = copy;
      }
    }
  }
  return target;
}, isDefined:function(o) {
  var a;
  return o !== a;
}};
if (typeof exports !== "undefined") {
  exports.pc = pc;
}
;(function() {
  if (typeof document === "undefined") {
    return;
  }
  var fullscreenchange = function(event) {
    var e = document.createEvent("CustomEvent");
    e.initCustomEvent("fullscreenchange", true, false, null);
    event.target.dispatchEvent(e);
  };
  var fullscreenerror = function(event) {
    var e = document.createEvent("CustomEvent");
    e.initCustomEvent("fullscreenerror", true, false, null);
    event.target.dispatchEvent(e);
  };
  document.addEventListener("webkitfullscreenchange", fullscreenchange, false);
  document.addEventListener("mozfullscreenchange", fullscreenchange, false);
  document.addEventListener("MSFullscreenChange", fullscreenchange, false);
  document.addEventListener("webkitfullscreenerror", fullscreenerror, false);
  document.addEventListener("mozfullscreenerror", fullscreenerror, false);
  document.addEventListener("MSFullscreenError", fullscreenerror, false);
  if (Element.prototype.mozRequestFullScreen) {
    Element.prototype.requestFullscreen = function() {
      this.mozRequestFullScreen();
    };
  } else {
    Element.prototype.requestFullscreen = Element.prototype.requestFullscreen || Element.prototype.webkitRequestFullscreen || Element.prototype.msRequestFullscreen;
  }
  document.exitFullscreen = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
  if (!document.hasOwnProperty("fullscreenElement")) {
    Object.defineProperty(document, "fullscreenElement", {enumerable:true, configurable:false, get:function() {
      return document.webkitCurrentFullScreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
    }});
  }
  if (!document.hasOwnProperty("fullscreenEnabled")) {
    Object.defineProperty(document, "fullscreenEnabled", {enumerable:true, configurable:false, get:function() {
      return document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
    }});
  }
})();
Math.log2 = Math.log2 || function(x) {
  return Math.log(x) * Math.LOG2E;
};
if (typeof Object.assign != "function") {
  Object.defineProperty(Object, "assign", {value:function assign(target, varArgs) {
    if (target == null) {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    var to = Object(target);
    for (var index = 1; index < arguments.length; index++) {
      var nextSource = arguments[index];
      if (nextSource != null) {
        for (var nextKey in nextSource) {
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
    return to;
  }, writable:true, configurable:true});
}
;(function() {
  if (typeof navigator === "undefined" || typeof document === "undefined") {
    return;
  }
  navigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer;
  var pointerlockchange = function() {
    var e = document.createEvent("CustomEvent");
    e.initCustomEvent("pointerlockchange", true, false, null);
    document.dispatchEvent(e);
  };
  var pointerlockerror = function() {
    var e = document.createEvent("CustomEvent");
    e.initCustomEvent("pointerlockerror", true, false, null);
    document.dispatchEvent(e);
  };
  document.addEventListener("webkitpointerlockchange", pointerlockchange, false);
  document.addEventListener("webkitpointerlocklost", pointerlockchange, false);
  document.addEventListener("mozpointerlockchange", pointerlockchange, false);
  document.addEventListener("mozpointerlocklost", pointerlockchange, false);
  document.addEventListener("webkitpointerlockerror", pointerlockerror, false);
  document.addEventListener("mozpointerlockerror", pointerlockerror, false);
  if (Element.prototype.mozRequestPointerLock) {
    Element.prototype.requestPointerLock = function() {
      this.mozRequestPointerLock();
    };
  } else {
    Element.prototype.requestPointerLock = Element.prototype.requestPointerLock || Element.prototype.webkitRequestPointerLock || Element.prototype.mozRequestPointerLock;
  }
  if (!Element.prototype.requestPointerLock && navigator.pointer) {
    Element.prototype.requestPointerLock = function() {
      var el = this;
      document.pointerLockElement = el;
      navigator.pointer.lock(el, pointerlockchange, pointerlockerror);
    };
  }
  document.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;
  if (!document.exitPointerLock) {
    document.exitPointerLock = function() {
      if (navigator.pointer) {
        document.pointerLockElement = null;
        navigator.pointer.unlock();
      }
    };
  }
})();
(function() {
  var lastTime = 0;
  var vendors = ["ms", "moz", "webkit", "o"];
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
    window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
  }
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback, element) {
      var currTime = (new Date).getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function() {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }
  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };
  }
})();
if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(search, this_len) {
    if (this_len === undefined || this_len > this.length) {
      this_len = this.length;
    }
    return this.substring(this_len - search.length, this_len) === search;
  };
}
if (!String.prototype.includes) {
  String.prototype.includes = function(search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > this.length) {
      return false;
    } else {
      return this.indexOf(search, start) !== -1;
    }
  };
}
if (!String.prototype.startsWith) {
  String.prototype.startsWith = function(search, pos) {
    return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  };
}
;Object.assign(pc, function() {
  var Color = function(r, g, b, a) {
    var length = r && r.length;
    if (length === 3 || length === 4) {
      this.r = r[0];
      this.g = r[1];
      this.b = r[2];
      this.a = r[3] !== undefined ? r[3] : 1;
    } else {
      this.r = r || 0;
      this.g = g || 0;
      this.b = b || 0;
      this.a = a !== undefined ? a : 1;
    }
  };
  Object.assign(Color.prototype, {clone:function() {
    return new pc.Color(this.r, this.g, this.b, this.a);
  }, copy:function(rhs) {
    this.r = rhs.r;
    this.g = rhs.g;
    this.b = rhs.b;
    this.a = rhs.a;
    return this;
  }, set:function(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a === undefined ? 1 : a;
    return this;
  }, lerp:function(lhs, rhs, alpha) {
    this.r = lhs.r + alpha * (rhs.r - lhs.r);
    this.g = lhs.g + alpha * (rhs.g - lhs.g);
    this.b = lhs.b + alpha * (rhs.b - lhs.b);
    this.a = lhs.a + alpha * (rhs.a - lhs.a);
    return this;
  }, fromString:function(hex) {
    var i = parseInt(hex.replace("#", "0x"), 16);
    var bytes;
    if (hex.length > 7) {
      bytes = pc.math.intToBytes32(i);
    } else {
      bytes = pc.math.intToBytes24(i);
      bytes[3] = 255;
    }
    this.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
    return this;
  }, toString:function(alpha) {
    var s = "#" + ((1 << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1);
    if (alpha === true) {
      var a = Math.round(this.a * 255).toString(16);
      if (this.a < 16 / 255) {
        s += "0" + a;
      } else {
        s += a;
      }
    }
    return s;
  }});
  return {Color:Color};
}());
pc.guid = function() {
  return {create:function() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }};
}();
Object.assign(pc, function() {
  var Timer = function Timer() {
    this._isRunning = false;
    this._a = 0;
    this._b = 0;
  };
  Object.assign(Timer.prototype, {start:function() {
    this._isRunning = true;
    this._a = pc.now();
  }, stop:function() {
    this._isRunning = false;
    this._b = pc.now();
  }, getMilliseconds:function() {
    return this._b - this._a;
  }});
  return {Timer:Timer, now:!window.performance || !window.performance.now || !window.performance.timing ? Date.now : function() {
    return window.performance.now();
  }};
}());
Object.assign(pc, function() {
  return {hashCode:function(str) {
    var hash = 0;
    for (var i = 0, len = str.length; i < len; i++) {
      hash = (hash << 5) - hash + str.charCodeAt(i);
      hash |= 0;
    }
    return hash;
  }};
}());
Object.assign(pc, function() {
  return {createURI:function(options) {
    var s = "";
    if ((options.authority || options.scheme) && (options.host || options.hostpath)) {
      throw new Error("Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option");
    }
    if (options.host && options.hostpath) {
      throw new Error("Can't have 'host' and 'hostpath' option");
    }
    if (options.path && options.hostpath) {
      throw new Error("Can't have 'path' and 'hostpath' option");
    }
    if (options.scheme) {
      s += options.scheme + ":";
    }
    if (options.authority) {
      s += "//" + options.authority;
    }
    if (options.host) {
      s += options.host;
    }
    if (options.path) {
      s += options.path;
    }
    if (options.hostpath) {
      s += options.hostpath;
    }
    if (options.query) {
      s += "?" + options.query;
    }
    if (options.fragment) {
      s += "#" + options.fragment;
    }
    return s;
  }, URI:function(uri) {
    var re = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, result = uri.match(re);
    this.scheme = result[2];
    this.authority = result[4];
    this.path = result[5];
    this.query = result[7];
    this.fragment = result[9];
    this.toString = function() {
      var s = "";
      if (this.scheme) {
        s += this.scheme + ":";
      }
      if (this.authority) {
        s += "//" + this.authority;
      }
      s += this.path;
      if (this.query) {
        s += "?" + this.query;
      }
      if (this.fragment) {
        s += "#" + this.fragment;
      }
      return s;
    };
    this.getQuery = function() {
      var vars;
      var pair;
      var result = {};
      if (this.query) {
        vars = decodeURIComponent(this.query).split("&");
        vars.forEach(function(item, index, arr) {
          pair = item.split("=");
          result[pair[0]] = pair[1];
        }, this);
      }
      return result;
    };
    this.setQuery = function(params) {
      var q = "";
      for (var key in params) {
        if (params.hasOwnProperty(key)) {
          if (q !== "") {
            q += "&";
          }
          q += encodeURIComponent(key) + "=" + encodeURIComponent(params[key]);
        }
      }
      this.query = q;
    };
  }};
}());
Object.assign(pc, function() {
  var log = {write:function(text) {
    console.log(text);
  }, open:function() {
  }, info:function(text) {
    console.info("INFO:    " + text);
  }, debug:function(text) {
    console.debug("DEBUG:   " + text);
  }, error:function(text) {
    console.error("ERROR:   " + text);
  }, warning:function(text) {
    console.warn("WARNING: " + text);
  }, alert:function(text) {
    pc.log.write("ALERT:   " + text);
    alert(text);
  }, assert:function(condition, text) {
    if (condition === false) {
      pc.log.write("ASSERT:  " + text);
    }
  }};
  return {log:log};
}());
var logINFO = pc.log.info;
var logDEBUG = pc.log.debug;
var logWARNING = pc.log.warning;
var logERROR = pc.log.error;
var logALERT = pc.log.alert;
var logASSERT = pc.log.assert;
pc.path = function() {
  return {delimiter:"/", join:function() {
    var index;
    var num = arguments.length;
    var result = arguments[0];
    for (index = 0; index < num - 1; ++index) {
      var one = arguments[index];
      var two = arguments[index + 1];
      if (!pc.isDefined(one) || !pc.isDefined(two)) {
        throw new Error("undefined argument to pc.path.join");
      }
      if (two[0] === pc.path.delimiter) {
        result = two;
        continue;
      }
      if (one && two && one[one.length - 1] !== pc.path.delimiter && two[0] !== pc.path.delimiter) {
        result += pc.path.delimiter + two;
      } else {
        result += two;
      }
    }
    return result;
  }, normalize:function(path) {
    var lead = path.startsWith(pc.path.delimiter);
    var trail = path.endsWith(pc.path.delimiter);
    var parts = path.split("/");
    var result = "";
    var cleaned = [];
    for (var i = 0; i < parts.length; i++) {
      if (parts[i] === "") {
        continue;
      }
      if (parts[i] === ".") {
        continue;
      }
      if (parts[i] === ".." && cleaned.length > 0) {
        cleaned = cleaned.slice(0, cleaned.length - 2);
        continue;
      }
      if (i > 0) {
        cleaned.push(pc.path.delimiter);
      }
      cleaned.push(parts[i]);
    }
    result = cleaned.join("");
    if (!lead && result[0] === pc.path.delimiter) {
      result = result.slice(1);
    }
    if (trail && result[result.length - 1] !== pc.path.delimiter) {
      result += pc.path.delimiter;
    }
    return result;
  }, split:function(path) {
    var parts = path.split(pc.path.delimiter);
    var tail = parts.slice(parts.length - 1)[0];
    var head = parts.slice(0, parts.length - 1).join(pc.path.delimiter);
    return [head, tail];
  }, getBasename:function(path) {
    return pc.path.split(path)[1];
  }, getDirectory:function(path) {
    var parts = path.split(pc.path.delimiter);
    return parts.slice(0, parts.length - 1).join(pc.path.delimiter);
  }, getExtension:function(path) {
    var ext = path.split("?")[0].split(".").pop();
    if (ext !== path) {
      return "." + ext;
    }
    return "";
  }, isRelativePath:function(s) {
    return s.charAt(0) !== "/" && s.match(/:\/\//) === null;
  }, extractPath:function(s) {
    var path = ".", parts = s.split("/"), i = 0;
    if (parts.length > 1) {
      if (pc.path.isRelativePath(s) === false) {
        path = "";
      }
      for (i = 0; i < parts.length - 1; ++i) {
        path += "/" + parts[i];
      }
    }
    return path;
  }};
}();
pc.string = function() {
  var ASCII_LOWERCASE = "abcdefghijklmnopqrstuvwxyz";
  var ASCII_UPPERCASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  var ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;
  var HIGH_SURROGATE_BEGIN = 55296;
  var HIGH_SURROGATE_END = 56319;
  var LOW_SURROGATE_BEGIN = 56320;
  var LOW_SURROGATE_END = 57343;
  var ZERO_WIDTH_JOINER = 8205;
  var REGIONAL_INDICATOR_BEGIN = 127462;
  var REGIONAL_INDICATOR_END = 127487;
  var FITZPATRICK_MODIFIER_BEGIN = 127995;
  var FITZPATRICK_MODIFIER_END = 127999;
  var DIACRITICAL_MARKS_BEGIN = 8400;
  var DIACRITICAL_MARKS_END = 8447;
  var VARIATION_MODIFIER_BEGIN = 65024;
  var VARIATION_MODIFIER_END = 65039;
  function getCodePointData(string, i) {
    var size = string.length;
    i = i || 0;
    if (i < 0 || i >= size) {
      return null;
    }
    var first = string.charCodeAt(i);
    var second;
    if (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {
      second = string.charCodeAt(i + 1);
      if (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {
        return {code:(first - HIGH_SURROGATE_BEGIN) * 1024 + second - LOW_SURROGATE_BEGIN + 65536, long:true};
      }
    }
    return {code:first, long:false};
  }
  function isCodeBetween(string, begin, end) {
    if (!string) {
      return false;
    }
    var codeData = getCodePointData(string);
    if (codeData) {
      var code = codeData.code;
      return code >= begin && code <= end;
    }
    return false;
  }
  function numCharsToTakeForNextSymbol(string, index) {
    if (index === string.length - 1) {
      return 1;
    }
    if (isCodeBetween(string[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {
      var first = string.substring(index, index + 2);
      var second = string.substring(index + 2, index + 4);
      if (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) || isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) && isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END)) {
        return 4;
      }
      if (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
        return 3;
      }
      return 2;
    }
    if (isCodeBetween(string[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
      return 2;
    }
    return 1;
  }
  return {ASCII_LOWERCASE:ASCII_LOWERCASE, ASCII_UPPERCASE:ASCII_UPPERCASE, ASCII_LETTERS:ASCII_LETTERS, format:function(s) {
    var i = 0, regexp, args = pc.makeArray(arguments);
    args.shift();
    for (i = 0; i < args.length; i++) {
      regexp = new RegExp("\\{" + i + "\\}", "gi");
      s = s.replace(regexp, args[i]);
    }
    return s;
  }, startsWith:function(s, subs) {
    console.warn("WARNING: startsWith: Function is deprecated. Use String.startsWith instead.");
    return s.startsWith(subs);
  }, endsWith:function(s, subs) {
    console.warn("WARNING: endsWith: Function is deprecated. Use String.endsWith instead.");
    return s.endsWith(subs);
  }, toBool:function(s, strict) {
    if (s === "true") {
      return true;
    }
    if (strict) {
      if (s === "false") {
        return false;
      }
      throw new TypeError("Not a boolean string");
    }
    return false;
  }, getCodePoint:function(string, i) {
    var codePointData = getCodePointData(string, i);
    return codePointData && codePointData.code;
  }, getCodePoints:function(string) {
    if (typeof string !== "string") {
      throw new TypeError("Not a string");
    }
    var i = 0;
    var arr = [];
    var codePoint;
    while (!!(codePoint = getCodePointData(string, i))) {
      arr.push(codePoint.code);
      i += codePoint.long ? 2 : 1;
    }
    return arr;
  }, getSymbols:function(string) {
    if (typeof string !== "string") {
      throw new TypeError("Not a string");
    }
    var index = 0;
    var length = string.length;
    var output = [];
    var take = 0;
    var ch;
    while (index < length) {
      take += numCharsToTakeForNextSymbol(string, index + take);
      ch = string[index + take];
      if (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {
        ch = string[index + take++];
      }
      if (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
        ch = string[index + take++];
      }
      if (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {
        ch = string[index + take++];
        continue;
      }
      var char = string.substring(index, index + take);
      output.push(char);
      index += take;
      take = 0;
    }
    return output;
  }, fromCodePoint:function() {
    var chars = [];
    var current;
    var codePoint;
    var units;
    for (var i = 0; i < arguments.length; ++i) {
      current = Number(arguments[i]);
      codePoint = current - 65536;
      units = current > 65535 ? [(codePoint >> 10) + 55296, codePoint % 1024 + 56320] : [current];
      chars.push(String.fromCharCode.apply(null, units));
    }
    return chars.join("");
  }};
}();
pc.debug = function() {
  var table = null;
  var row = null;
  var title = null;
  var field = null;
  return {display:function(data) {
    function init() {
      table = document.createElement("table");
      row = document.createElement("tr");
      title = document.createElement("td");
      field = document.createElement("td");
      table.style.cssText = "position:absolute;font-family:sans-serif;font-size:12px;color:#cccccc";
      table.style.top = "0px";
      table.style.left = "0px";
      table.style.border = "thin solid #cccccc";
      document.body.appendChild(table);
    }
    if (!table) {
      init();
    }
    console.log(">>>> INNER HTML 1");
    table.innerHTML = "";
          console.log("<<<<< INNER HTML 1");

          for (var key in data) {
      var r = row.cloneNode();
      var t = title.cloneNode();
      var f = field.cloneNode();
      t.textContent = key;
      f.textContent = data[key];
      r.appendChild(t);
      r.appendChild(f);
      table.appendChild(r);
    }
  }};
}();
pc.events = {attach:function(target) {
  var ev = pc.events;
  target.on = ev.on;
  target.off = ev.off;
  target.fire = ev.fire;
  target.once = ev.once;
  target.hasEvent = ev.hasEvent;
  target._callbackActive = {};
  return target;
}, on:function(name, callback, scope) {
  if (!name || typeof name !== "string" || !callback) {
    return this;
  }
  if (!this._callbacks) {
    this._callbacks = {};
  }
  if (!this._callbacks[name]) {
    this._callbacks[name] = [];
  }
  if (!this._callbackActive) {
    this._callbackActive = {};
  }
  if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) {
    this._callbackActive[name] = this._callbackActive[name].slice();
  }
  this._callbacks[name].push({callback:callback, scope:scope || this});
  return this;
}, off:function(name, callback, scope) {
  if (!this._callbacks) {
    return this;
  }
  if (this._callbackActive) {
    if (name) {
      if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) {
        this._callbackActive[name] = this._callbackActive[name].slice();
      }
    } else {
      for (var key in this._callbackActive) {
        if (!this._callbacks[key]) {
          continue;
        }
        if (this._callbacks[key] !== this._callbackActive[key]) {
          continue;
        }
        this._callbackActive[key] = this._callbackActive[key].slice();
      }
    }
  }
  if (!name) {
    this._callbacks = null;
  } else {
    if (!callback) {
      if (this._callbacks[name]) {
        delete this._callbacks[name];
      }
    } else {
      var events = this._callbacks[name];
      if (!events) {
        return this;
      }
      var i = events.length;
      while (i--) {
        if (events[i].callback !== callback) {
          continue;
        }
        if (scope && events[i].scope !== scope) {
          continue;
        }
        events.splice(i, 1);
      }
    }
  }
  return this;
}, fire:function(name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
  if (!name || !this._callbacks || !this._callbacks[name]) {
    return this;
  }
  var callbacks;
  if (!this._callbackActive) {
    this._callbackActive = {};
  }
  if (!this._callbackActive[name]) {
    this._callbackActive[name] = this._callbacks[name];
  } else {
    if (this._callbackActive[name] === this._callbacks[name]) {
      this._callbackActive[name] = this._callbackActive[name].slice();
    }
    callbacks = this._callbacks[name].slice();
  }
  for (var i = 0; (callbacks || this._callbackActive[name]) && i < (callbacks || this._callbackActive[name]).length; i++) {
    var evt = (callbacks || this._callbackActive[name])[i];
    evt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    if (evt.callback.once) {
      var ind = this._callbacks[name].indexOf(evt);
      if (ind !== -1) {
        if (this._callbackActive[name] === this._callbacks[name]) {
          this._callbackActive[name] = this._callbackActive[name].slice();
        }
        this._callbacks[name].splice(ind, 1);
      }
    }
  }
  if (!callbacks) {
    this._callbackActive[name] = null;
  }
  return this;
}, once:function(name, callback, scope) {
  callback.once = true;
  this.on(name, callback, scope);
  return this;
}, hasEvent:function(name) {
  return this._callbacks && this._callbacks[name] && this._callbacks[name].length !== 0 || false;
}};
Object.assign(pc, function() {
  var TagsCache = function(key) {
    this._index = {};
    this._key = key || null;
  };
  Object.assign(TagsCache.prototype, {addItem:function(item) {
    var tags = item.tags._list;
    for (var i = 0; i < tags.length; i++) {
      this.add(tags[i], item);
    }
  }, removeItem:function(item) {
    var tags = item.tags._list;
    for (var i = 0; i < tags.length; i++) {
      this.remove(tags[i], item);
    }
  }, add:function(tag, item) {
    if (this._index[tag] && this._index[tag].list.indexOf(item) !== -1) {
      return;
    }
    if (!this._index[tag]) {
      this._index[tag] = {list:[]};
      if (this._key) {
        this._index[tag].keys = {};
      }
    }
    this._index[tag].list.push(item);
    if (this._key) {
      this._index[tag].keys[item[this._key]] = item;
    }
  }, remove:function(tag, item) {
    if (!this._index[tag]) {
      return;
    }
    if (this._key) {
      if (!this._index[tag].keys[item[this._key]]) {
        return;
      }
    }
    var ind = this._index[tag].indexOf(item);
    if (ind === -1) {
      return;
    }
    this._index[tag].list.splice(ind, 1);
    if (this._key) {
      delete this._index[tag].keys[item[this._key]];
    }
    if (this._index[tag].list.length === 0) {
      delete this._index[tag];
    }
  }, find:function(args) {
    var self = this;
    var index = {};
    var items = [];
    var i, n, t;
    var item, tag, tags, tagsRest, missingIndex;
    var sort = function(a, b) {
      return self._index[a].list.length - self._index[b].list.length;
    };
    for (i = 0; i < args.length; i++) {
      tag = args[i];
      if (tag instanceof Array) {
        if (tag.length === 0) {
          continue;
        }
        if (tag.length === 1) {
          tag = tag[0];
        } else {
          missingIndex = false;
          for (t = 0; t < tag.length; t++) {
            if (!this._index[tag[t]]) {
              missingIndex = true;
              break;
            }
          }
          if (missingIndex) {
            continue;
          }
          tags = tag.slice(0).sort(sort);
          tagsRest = tags.slice(1);
          if (tagsRest.length === 1) {
            tagsRest = tagsRest[0];
          }
          for (n = 0; n < this._index[tags[0]].list.length; n++) {
            item = this._index[tags[0]].list[n];
            if ((this._key ? !index[item[this._key]] : items.indexOf(item) === -1) && item.tags.has(tagsRest)) {
              if (this._key) {
                index[item[this._key]] = true;
              }
              items.push(item);
            }
          }
          continue;
        }
      }
      if (tag && typeof tag === "string" && this._index[tag]) {
        for (n = 0; n < this._index[tag].list.length; n++) {
          item = this._index[tag].list[n];
          if (this._key) {
            if (!index[item[this._key]]) {
              index[item[this._key]] = true;
              items.push(item);
            }
          } else {
            if (items.indexOf(item) === -1) {
              items.push(item);
            }
          }
        }
      }
    }
    return items;
  }});
  var Tags = function(parent) {
    this._index = {};
    this._list = [];
    this._parent = parent;
    pc.events.attach(this);
  };
  Object.assign(Tags.prototype, {add:function() {
    var changed = false;
    var tags = this._processArguments(arguments, true);
    if (!tags.length) {
      return changed;
    }
    for (var i = 0; i < tags.length; i++) {
      if (this._index[tags[i]]) {
        continue;
      }
      changed = true;
      this._index[tags[i]] = true;
      this._list.push(tags[i]);
      this.fire("add", tags[i], this._parent);
    }
    if (changed) {
      this.fire("change", this._parent);
    }
    return changed;
  }, remove:function() {
    var changed = false;
    if (!this._list.length) {
      return changed;
    }
    var tags = this._processArguments(arguments, true);
    if (!tags.length) {
      return changed;
    }
    for (var i = 0; i < tags.length; i++) {
      if (!this._index[tags[i]]) {
        continue;
      }
      changed = true;
      delete this._index[tags[i]];
      this._list.splice(this._list.indexOf(tags[i]), 1);
      this.fire("remove", tags[i], this._parent);
    }
    if (changed) {
      this.fire("change", this._parent);
    }
    return changed;
  }, clear:function() {
    if (!this._list.length) {
      return;
    }
    var tags = this._list.slice(0);
    this._list = [];
    this._index = {};
    for (var i = 0; i < tags.length; i++) {
      this.fire("remove", tags[i], this._parent);
    }
    this.fire("change", this._parent);
  }, has:function() {
    if (!this._list.length) {
      return false;
    }
    return this._has(this._processArguments(arguments));
  }, _has:function(tags) {
    if (!this._list.length || !tags.length) {
      return false;
    }
    for (var i = 0; i < tags.length; i++) {
      if (tags[i].length === 1) {
        if (this._index[tags[i][0]]) {
          return true;
        }
      } else {
        var multiple = true;
        for (var t = 0; t < tags[i].length; t++) {
          if (this._index[tags[i][t]]) {
            continue;
          }
          multiple = false;
          break;
        }
        if (multiple) {
          return true;
        }
      }
    }
    return false;
  }, list:function() {
    return this._list.slice(0);
  }, _processArguments:function(args, flat) {
    var tags = [];
    var tmp = [];
    if (!args || !args.length) {
      return tags;
    }
    for (var i = 0; i < args.length; i++) {
      if (args[i] instanceof Array) {
        if (!flat) {
          tmp = [];
        }
        for (var t = 0; t < args[i].length; t++) {
          if (typeof args[i][t] !== "string") {
            continue;
          }
          if (flat) {
            tags.push(args[i][t]);
          } else {
            tmp.push(args[i][t]);
          }
        }
        if (!flat && tmp.length) {
          tags.push(tmp);
        }
      } else {
        if (typeof args[i] === "string") {
          if (flat) {
            tags.push(args[i]);
          } else {
            tags.push([args[i]]);
          }
        }
      }
    }
    return tags;
  }});
  Object.defineProperty(Tags.prototype, "size", {get:function() {
    return this._list.length;
  }});
  return {TagsCache:TagsCache, Tags:Tags};
}());
Object.assign(pc, function() {
  var AllocatePool = function(constructor, size) {
    this._constructor = constructor;
    this._pool = [];
    this._count = 0;
    this._resize(size);
  };
  Object.assign(AllocatePool.prototype, {_resize:function(size) {
    if (size > this._pool.length) {
      for (var i = this._pool.length; i < size; i++) {
        this._pool[i] = new this._constructor;
      }
    }
  }, allocate:function() {
    if (this._count >= this._pool.length) {
      this._resize(this._pool.length * 2);
    }
    return this._pool[this._count++];
  }, freeAll:function() {
    this._count = 0;
  }});
  return {AllocatePool:AllocatePool};
}());
Object.assign(pc, function() {
  var platform = {desktop:false, mobile:false, ios:false, android:false, windows:false, cocoonjs:false, xbox:false, gamepads:false, touch:false, workers:false};
  var ua = navigator.userAgent;
  if (/(windows|mac os|linux|cros)/i.test(ua)) {
    platform.desktop = true;
  }
  if (/xbox/i.test(ua)) {
    platform.xbox = true;
  }
  if (/(windows phone|iemobile|wpdesktop)/i.test(ua)) {
    platform.desktop = false;
    platform.mobile = true;
    platform.windows = true;
  } else {
    if (/android/i.test(ua)) {
      platform.desktop = false;
      platform.mobile = true;
      platform.android = true;
    } else {
      if (/ip([ao]d|hone)/i.test(ua)) {
        platform.desktop = false;
        platform.mobile = true;
        platform.ios = true;
      }
    }
  }
  if (navigator.isCocoonJS) {
    platform.cocoonjs = true;
  }
  platform.touch = "ontouchstart" in window || "maxTouchPoints" in navigator && navigator.maxTouchPoints > 0;
  platform.gamepads = "getGamepads" in navigator;
  platform.workers = typeof Worker !== "undefined";
  return {platform:platform};
}());
Object.assign(pc, function() {
  var IndexedList = function() {
    this._list = [];
    this._index = {};
  };
  Object.assign(IndexedList.prototype, {push:function(key, item) {
    if (this._index[key]) {
      throw Error("Key already in index " + key);
    }
    var location = this._list.push(item) - 1;
    this._index[key] = location;
  }, has:function(key) {
    return this._index[key] !== undefined;
  }, get:function(key) {
    var location = this._index[key];
    if (location !== undefined) {
      return this._list[location];
    }
    return null;
  }, remove:function(key) {
    var location = this._index[key];
    if (location !== undefined) {
      this._list.splice(location, 1);
      delete this._index[key];
      for (key in this._index) {
        var idx = this._index[key];
        if (idx > location) {
          this._index[key] = idx - 1;
        }
      }
      return true;
    }
    return false;
  }, list:function() {
    return this._list;
  }, clear:function() {
    this._list.length = 0;
    for (var prop in this._index) {
      delete this._index[prop];
    }
  }});
  return {IndexedList:IndexedList};
}());
pc.math = {DEG_TO_RAD:Math.PI / 180, RAD_TO_DEG:180 / Math.PI, clamp:function(value, min, max) {
  if (value >= max) {
    return max;
  }
  if (value <= min) {
    return min;
  }
  return value;
}, intToBytes24:function(i) {
  var r, g, b;
  r = i >> 16 & 255;
  g = i >> 8 & 255;
  b = i & 255;
  return [r, g, b];
}, intToBytes32:function(i) {
  var r, g, b, a;
  r = i >> 24 & 255;
  g = i >> 16 & 255;
  b = i >> 8 & 255;
  a = i & 255;
  return [r, g, b, a];
}, bytesToInt24:function(r, g, b) {
  if (r.length) {
    b = r[2];
    g = r[1];
    r = r[0];
  }
  return r << 16 | g << 8 | b;
}, bytesToInt32:function(r, g, b, a) {
  if (r.length) {
    a = r[3];
    b = r[2];
    g = r[1];
    r = r[0];
  }
  return (r << 24 | g << 16 | b << 8 | a) >>> 32;
}, lerp:function(a, b, alpha) {
  return a + (b - a) * pc.math.clamp(alpha, 0, 1);
}, lerpAngle:function(a, b, alpha) {
  if (b - a > 180) {
    b -= 360;
  }
  if (b - a < -180) {
    b += 360;
  }
  return pc.math.lerp(a, b, pc.math.clamp(alpha, 0, 1));
}, powerOfTwo:function(x) {
  return x !== 0 && !(x & x - 1);
}, nextPowerOfTwo:function(val) {
  val--;
  val |= val >> 1;
  val |= val >> 2;
  val |= val >> 4;
  val |= val >> 8;
  val |= val >> 16;
  val++;
  return val;
}, random:function(min, max) {
  var diff = max - min;
  return Math.random() * diff + min;
}, smoothstep:function(min, max, x) {
  if (x <= min) {
    return 0;
  }
  if (x >= max) {
    return 1;
  }
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}, smootherstep:function(min, max, x) {
  if (x <= min) {
    return 0;
  }
  if (x >= max) {
    return 1;
  }
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
}};
Object.assign(pc, function() {
  var Vec2 = function(x, y) {
    if (x && x.length === 2) {
      this.x = x[0];
      this.y = x[1];
    } else {
      this.x = x || 0;
      this.y = y || 0;
    }
  };
  Object.assign(Vec2.prototype, {add:function(rhs) {
    this.x += rhs.x;
    this.y += rhs.y;
    return this;
  }, add2:function(lhs, rhs) {
    this.x = lhs.x + rhs.x;
    this.y = lhs.y + rhs.y;
    return this;
  }, clone:function() {
    return (new Vec2).copy(this);
  }, copy:function(rhs) {
    this.x = rhs.x;
    this.y = rhs.y;
    return this;
  }, dot:function(rhs) {
    return this.x * rhs.x + this.y * rhs.y;
  }, equals:function(rhs) {
    return this.x === rhs.x && this.y === rhs.y;
  }, length:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, lengthSq:function() {
    return this.x * this.x + this.y * this.y;
  }, lerp:function(lhs, rhs, alpha) {
    this.x = lhs.x + alpha * (rhs.x - lhs.x);
    this.y = lhs.y + alpha * (rhs.y - lhs.y);
    return this;
  }, mul:function(rhs) {
    this.x *= rhs.x;
    this.y *= rhs.y;
    return this;
  }, mul2:function(lhs, rhs) {
    this.x = lhs.x * rhs.x;
    this.y = lhs.y * rhs.y;
    return this;
  }, normalize:function() {
    var lengthSq = this.x * this.x + this.y * this.y;
    if (lengthSq > 0) {
      var invLength = 1 / Math.sqrt(lengthSq);
      this.x *= invLength;
      this.y *= invLength;
    }
    return this;
  }, scale:function(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }, set:function(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }, sub:function(rhs) {
    this.x -= rhs.x;
    this.y -= rhs.y;
    return this;
  }, sub2:function(lhs, rhs) {
    this.x = lhs.x - rhs.x;
    this.y = lhs.y - rhs.y;
    return this;
  }, toString:function() {
    return "[" + this.x + ", " + this.y + "]";
  }});
  Object.defineProperty(Vec2, "ONE", {get:function() {
    var one = new Vec2(1, 1);
    return function() {
      return one;
    };
  }()});
  Object.defineProperty(Vec2, "RIGHT", {get:function() {
    var right = new Vec2(1, 0);
    return function() {
      return right;
    };
  }()});
  Object.defineProperty(Vec2, "UP", {get:function() {
    var down = new Vec2(0, 1);
    return function() {
      return down;
    };
  }()});
  Object.defineProperty(Vec2, "ZERO", {get:function() {
    var zero = new Vec2(0, 0);
    return function() {
      return zero;
    };
  }()});
  return {Vec2:Vec2};
}());
Object.assign(pc, function() {
  var Vec3 = function(x, y, z) {
    if (x && x.length === 3) {
      this.x = x[0];
      this.y = x[1];
      this.z = x[2];
    } else {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
    }
  };
  Object.assign(Vec3.prototype, {add:function(rhs) {
    this.x += rhs.x;
    this.y += rhs.y;
    this.z += rhs.z;
    return this;
  }, add2:function(lhs, rhs) {
    this.x = lhs.x + rhs.x;
    this.y = lhs.y + rhs.y;
    this.z = lhs.z + rhs.z;
    return this;
  }, clone:function() {
    return (new Vec3).copy(this);
  }, copy:function(rhs) {
    this.x = rhs.x;
    this.y = rhs.y;
    this.z = rhs.z;
    return this;
  }, cross:function(lhs, rhs) {
    var lx = lhs.x;
    var ly = lhs.y;
    var lz = lhs.z;
    var rx = rhs.x;
    var ry = rhs.y;
    var rz = rhs.z;
    this.x = ly * rz - ry * lz;
    this.y = lz * rx - rz * lx;
    this.z = lx * ry - rx * ly;
    return this;
  }, dot:function(rhs) {
    return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
  }, equals:function(rhs) {
    return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
  }, length:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }, lengthSq:function() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }, lerp:function(lhs, rhs, alpha) {
    this.x = lhs.x + alpha * (rhs.x - lhs.x);
    this.y = lhs.y + alpha * (rhs.y - lhs.y);
    this.z = lhs.z + alpha * (rhs.z - lhs.z);
    return this;
  }, mul:function(rhs) {
    this.x *= rhs.x;
    this.y *= rhs.y;
    this.z *= rhs.z;
    return this;
  }, mul2:function(lhs, rhs) {
    this.x = lhs.x * rhs.x;
    this.y = lhs.y * rhs.y;
    this.z = lhs.z * rhs.z;
    return this;
  }, normalize:function() {
    var lengthSq = this.x * this.x + this.y * this.y + this.z * this.z;
    if (lengthSq > 0) {
      var invLength = 1 / Math.sqrt(lengthSq);
      this.x *= invLength;
      this.y *= invLength;
      this.z *= invLength;
    }
    return this;
  }, project:function(rhs) {
    var a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
    var b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;
    var s = a_dot_b / b_dot_b;
    this.x = rhs.x * s;
    this.y = rhs.y * s;
    this.z = rhs.z * s;
    return this;
  }, scale:function(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }, set:function(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }, sub:function(rhs) {
    this.x -= rhs.x;
    this.y -= rhs.y;
    this.z -= rhs.z;
    return this;
  }, sub2:function(lhs, rhs) {
    this.x = lhs.x - rhs.x;
    this.y = lhs.y - rhs.y;
    this.z = lhs.z - rhs.z;
    return this;
  }, toString:function() {
    return "[" + this.x + ", " + this.y + ", " + this.z + "]";
  }});
  Object.defineProperty(Vec3, "BACK", {get:function() {
    var back = new Vec3(0, 0, 1);
    return function() {
      return back;
    };
  }()});
  Object.defineProperty(Vec3, "DOWN", {get:function() {
    var down = new Vec3(0, -1, 0);
    return function() {
      return down;
    };
  }()});
  Object.defineProperty(Vec3, "FORWARD", {get:function() {
    var forward = new Vec3(0, 0, -1);
    return function() {
      return forward;
    };
  }()});
  Object.defineProperty(Vec3, "LEFT", {get:function() {
    var left = new Vec3(-1, 0, 0);
    return function() {
      return left;
    };
  }()});
  Object.defineProperty(Vec3, "ONE", {get:function() {
    var one = new Vec3(1, 1, 1);
    return function() {
      return one;
    };
  }()});
  Object.defineProperty(Vec3, "RIGHT", {get:function() {
    var right = new Vec3(1, 0, 0);
    return function() {
      return right;
    };
  }()});
  Object.defineProperty(Vec3, "UP", {get:function() {
    var down = new Vec3(0, 1, 0);
    return function() {
      return down;
    };
  }()});
  Object.defineProperty(Vec3, "ZERO", {get:function() {
    var zero = new Vec3(0, 0, 0);
    return function() {
      return zero;
    };
  }()});
  return {Vec3:Vec3};
}());
Object.assign(pc, function() {
  var Vec4 = function(x, y, z, w) {
    if (x && x.length === 4) {
      this.x = x[0];
      this.y = x[1];
      this.z = x[2];
      this.w = x[3];
    } else {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      this.w = w || 0;
    }
  };
  Object.assign(Vec4.prototype, {add:function(rhs) {
    this.x += rhs.x;
    this.y += rhs.y;
    this.z += rhs.z;
    this.w += rhs.w;
    return this;
  }, add2:function(lhs, rhs) {
    this.x = lhs.x + rhs.x;
    this.y = lhs.y + rhs.y;
    this.z = lhs.z + rhs.z;
    this.w = lhs.w + rhs.w;
    return this;
  }, clone:function() {
    return (new Vec4).copy(this);
  }, copy:function(rhs) {
    this.x = rhs.x;
    this.y = rhs.y;
    this.z = rhs.z;
    this.w = rhs.w;
    return this;
  }, dot:function(rhs) {
    return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;
  }, equals:function(rhs) {
    return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
  }, length:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }, lengthSq:function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }, lerp:function(lhs, rhs, alpha) {
    this.x = lhs.x + alpha * (rhs.x - lhs.x);
    this.y = lhs.y + alpha * (rhs.y - lhs.y);
    this.z = lhs.z + alpha * (rhs.z - lhs.z);
    this.w = lhs.w + alpha * (rhs.w - lhs.w);
    return this;
  }, mul:function(rhs) {
    this.x *= rhs.x;
    this.y *= rhs.y;
    this.z *= rhs.z;
    this.w *= rhs.w;
    return this;
  }, mul2:function(lhs, rhs) {
    this.x = lhs.x * rhs.x;
    this.y = lhs.y * rhs.y;
    this.z = lhs.z * rhs.z;
    this.w = lhs.w * rhs.w;
    return this;
  }, normalize:function() {
    var lengthSq = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    if (lengthSq > 0) {
      var invLength = 1 / Math.sqrt(lengthSq);
      this.x *= invLength;
      this.y *= invLength;
      this.z *= invLength;
      this.w *= invLength;
    }
    return this;
  }, scale:function(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }, set:function(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }, sub:function(rhs) {
    this.x -= rhs.x;
    this.y -= rhs.y;
    this.z -= rhs.z;
    this.w -= rhs.w;
    return this;
  }, sub2:function(lhs, rhs) {
    this.x = lhs.x - rhs.x;
    this.y = lhs.y - rhs.y;
    this.z = lhs.z - rhs.z;
    this.w = lhs.w - rhs.w;
    return this;
  }, toString:function() {
    return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]";
  }});
  Object.defineProperty(Vec4, "ONE", {get:function() {
    var one = new Vec4(1, 1, 1, 1);
    return function() {
      return one;
    };
  }()});
  Object.defineProperty(Vec4, "ZERO", {get:function() {
    var zero = new Vec4(0, 0, 0, 0);
    return function() {
      return zero;
    };
  }()});
  return {Vec4:Vec4};
}());
Object.assign(pc, function() {
  var Mat3 = function() {
    var data;
    data = new Float32Array(9);
    data[0] = data[4] = data[8] = 1;
    this.data = data;
  };
  Object.assign(Mat3.prototype, {clone:function() {
    return (new pc.Mat3).copy(this);
  }, copy:function(rhs) {
    var src = rhs.data;
    var dst = this.data;
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    dst[4] = src[4];
    dst[5] = src[5];
    dst[6] = src[6];
    dst[7] = src[7];
    dst[8] = src[8];
    return this;
  }, set:function(src) {
    var dst = this.data;
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    dst[4] = src[4];
    dst[5] = src[5];
    dst[6] = src[6];
    dst[7] = src[7];
    dst[8] = src[8];
    return this;
  }, equals:function(rhs) {
    var l = this.data;
    var r = rhs.data;
    return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];
  }, isIdentity:function() {
    var m = this.data;
    return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;
  }, setIdentity:function() {
    var m = this.data;
    m[0] = 1;
    m[1] = 0;
    m[2] = 0;
    m[3] = 0;
    m[4] = 1;
    m[5] = 0;
    m[6] = 0;
    m[7] = 0;
    m[8] = 1;
    return this;
  }, toString:function() {
    var t = "[";
    for (var i = 0; i < 9; i++) {
      t += this.data[i];
      t += i !== 8 ? ", " : "";
    }
    t += "]";
    return t;
  }, transpose:function() {
    var m = this.data;
    var tmp;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }});
  Object.defineProperty(Mat3, "IDENTITY", {get:function() {
    var identity = new Mat3;
    return function() {
      return identity;
    };
  }()});
  Object.defineProperty(Mat3, "ZERO", {get:function() {
    var zero = (new Mat3).set([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    return function() {
      return zero;
    };
  }()});
  return {Mat3:Mat3};
}());
Object.assign(pc, function() {
  var Mat4 = function() {
    var data = new Float32Array(16);
    data[0] = data[5] = data[10] = data[15] = 1;
    this.data = data;
  };
  Object.assign(Mat4.prototype, {add2:function(lhs, rhs) {
    var a = lhs.data, b = rhs.data, r = this.data;
    r[0] = a[0] + b[0];
    r[1] = a[1] + b[1];
    r[2] = a[2] + b[2];
    r[3] = a[3] + b[3];
    r[4] = a[4] + b[4];
    r[5] = a[5] + b[5];
    r[6] = a[6] + b[6];
    r[7] = a[7] + b[7];
    r[8] = a[8] + b[8];
    r[9] = a[9] + b[9];
    r[10] = a[10] + b[10];
    r[11] = a[11] + b[11];
    r[12] = a[12] + b[12];
    r[13] = a[13] + b[13];
    r[14] = a[14] + b[14];
    r[15] = a[15] + b[15];
    return this;
  }, add:function(rhs) {
    return this.add2(this, rhs);
  }, clone:function() {
    return (new pc.Mat4).copy(this);
  }, copy:function(rhs) {
    var src = rhs.data, dst = this.data;
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    dst[4] = src[4];
    dst[5] = src[5];
    dst[6] = src[6];
    dst[7] = src[7];
    dst[8] = src[8];
    dst[9] = src[9];
    dst[10] = src[10];
    dst[11] = src[11];
    dst[12] = src[12];
    dst[13] = src[13];
    dst[14] = src[14];
    dst[15] = src[15];
    return this;
  }, equals:function(rhs) {
    var l = this.data, r = rhs.data;
    return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8] && l[9] === r[9] && l[10] === r[10] && l[11] === r[11] && l[12] === r[12] && l[13] === r[13] && l[14] === r[14] && l[15] === r[15];
  }, isIdentity:function() {
    var m = this.data;
    return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
  }, mul2:function(lhs, rhs) {
    var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b0, b1, b2, b3, a = lhs.data, b = rhs.data, r = this.data;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a30 = a[12];
    a31 = a[13];
    a32 = a[14];
    a33 = a[15];
    b0 = b[0];
    b1 = b[1];
    b2 = b[2];
    b3 = b[3];
    r[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
    r[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
    r[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
    r[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    r[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
    r[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
    r[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
    r[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    r[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
    r[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
    r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
    r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
    r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
    r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
    r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
    return this;
  }, mul:function(rhs) {
    return this.mul2(this, rhs);
  }, transformPoint:function(vec, res) {
    var x, y, z, m;
    m = this.data;
    x = vec.x;
    y = vec.y;
    z = vec.z;
    res = res === undefined ? new pc.Vec3 : res;
    res.x = x * m[0] + y * m[4] + z * m[8] + m[12];
    res.y = x * m[1] + y * m[5] + z * m[9] + m[13];
    res.z = x * m[2] + y * m[6] + z * m[10] + m[14];
    return res;
  }, transformVector:function(vec, res) {
    var x, y, z, m;
    m = this.data;
    x = vec.x;
    y = vec.y;
    z = vec.z;
    res = res === undefined ? new pc.Vec3 : res;
    res.x = x * m[0] + y * m[4] + z * m[8];
    res.y = x * m[1] + y * m[5] + z * m[9];
    res.z = x * m[2] + y * m[6] + z * m[10];
    return res;
  }, transformVec4:function(vec, res) {
    var x, y, z, w, m;
    m = this.data;
    x = vec.x;
    y = vec.y;
    z = vec.z;
    w = vec.w;
    res = res === undefined ? new pc.Vec4 : res;
    res.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];
    res.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];
    res.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];
    res.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];
    return res;
  }, setLookAt:function() {
    var x, y, z;
    x = new pc.Vec3;
    y = new pc.Vec3;
    z = new pc.Vec3;
    return function(position, target, up) {
      z.sub2(position, target).normalize();
      y.copy(up).normalize();
      x.cross(y, z).normalize();
      y.cross(z, x);
      var r = this.data;
      r[0] = x.x;
      r[1] = x.y;
      r[2] = x.z;
      r[3] = 0;
      r[4] = y.x;
      r[5] = y.y;
      r[6] = y.z;
      r[7] = 0;
      r[8] = z.x;
      r[9] = z.y;
      r[10] = z.z;
      r[11] = 0;
      r[12] = position.x;
      r[13] = position.y;
      r[14] = position.z;
      r[15] = 1;
      return this;
    };
  }(), setFrustum:function(left, right, bottom, top, znear, zfar) {
    var temp1, temp2, temp3, temp4, r;
    temp1 = 2 * znear;
    temp2 = right - left;
    temp3 = top - bottom;
    temp4 = zfar - znear;
    r = this.data;
    r[0] = temp1 / temp2;
    r[1] = 0;
    r[2] = 0;
    r[3] = 0;
    r[4] = 0;
    r[5] = temp1 / temp3;
    r[6] = 0;
    r[7] = 0;
    r[8] = (right + left) / temp2;
    r[9] = (top + bottom) / temp3;
    r[10] = (-zfar - znear) / temp4;
    r[11] = -1;
    r[12] = 0;
    r[13] = 0;
    r[14] = -temp1 * zfar / temp4;
    r[15] = 0;
    return this;
  }, setPerspective:function(fov, aspect, znear, zfar, fovIsHorizontal) {
    var xmax, ymax;
    if (!fovIsHorizontal) {
      ymax = znear * Math.tan(fov * Math.PI / 360);
      xmax = ymax * aspect;
    } else {
      xmax = znear * Math.tan(fov * Math.PI / 360);
      ymax = xmax / aspect;
    }
    return this.setFrustum(-xmax, xmax, -ymax, ymax, znear, zfar);
  }, setOrtho:function(left, right, bottom, top, near, far) {
    var r = this.data;
    r[0] = 2 / (right - left);
    r[1] = 0;
    r[2] = 0;
    r[3] = 0;
    r[4] = 0;
    r[5] = 2 / (top - bottom);
    r[6] = 0;
    r[7] = 0;
    r[8] = 0;
    r[9] = 0;
    r[10] = -2 / (far - near);
    r[11] = 0;
    r[12] = -(right + left) / (right - left);
    r[13] = -(top + bottom) / (top - bottom);
    r[14] = -(far + near) / (far - near);
    r[15] = 1;
    return this;
  }, setFromAxisAngle:function(axis, angle) {
    var x, y, z, c, s, t, tx, ty, m;
    angle *= pc.math.DEG_TO_RAD;
    x = axis.x;
    y = axis.y;
    z = axis.z;
    c = Math.cos(angle);
    s = Math.sin(angle);
    t = 1 - c;
    tx = t * x;
    ty = t * y;
    m = this.data;
    m[0] = tx * x + c;
    m[1] = tx * y + s * z;
    m[2] = tx * z - s * y;
    m[3] = 0;
    m[4] = tx * y - s * z;
    m[5] = ty * y + c;
    m[6] = ty * z + s * x;
    m[7] = 0;
    m[8] = tx * z + s * y;
    m[9] = ty * z - x * s;
    m[10] = t * z * z + c;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    return this;
  }, setTranslate:function(x, y, z) {
    var m = this.data;
    m[0] = 1;
    m[1] = 0;
    m[2] = 0;
    m[3] = 0;
    m[4] = 0;
    m[5] = 1;
    m[6] = 0;
    m[7] = 0;
    m[8] = 0;
    m[9] = 0;
    m[10] = 1;
    m[11] = 0;
    m[12] = x;
    m[13] = y;
    m[14] = z;
    m[15] = 1;
    return this;
  }, setScale:function(x, y, z) {
    var m = this.data;
    m[0] = x;
    m[1] = 0;
    m[2] = 0;
    m[3] = 0;
    m[4] = 0;
    m[5] = y;
    m[6] = 0;
    m[7] = 0;
    m[8] = 0;
    m[9] = 0;
    m[10] = z;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    return this;
  }, invert:function() {
    var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10, b11, det, invDet, m;
    m = this.data;
    a00 = m[0];
    a01 = m[1];
    a02 = m[2];
    a03 = m[3];
    a10 = m[4];
    a11 = m[5];
    a12 = m[6];
    a13 = m[7];
    a20 = m[8];
    a21 = m[9];
    a22 = m[10];
    a23 = m[11];
    a30 = m[12];
    a31 = m[13];
    a32 = m[14];
    a33 = m[15];
    b00 = a00 * a11 - a01 * a10;
    b01 = a00 * a12 - a02 * a10;
    b02 = a00 * a13 - a03 * a10;
    b03 = a01 * a12 - a02 * a11;
    b04 = a01 * a13 - a03 * a11;
    b05 = a02 * a13 - a03 * a12;
    b06 = a20 * a31 - a21 * a30;
    b07 = a20 * a32 - a22 * a30;
    b08 = a20 * a33 - a23 * a30;
    b09 = a21 * a32 - a22 * a31;
    b10 = a21 * a33 - a23 * a31;
    b11 = a22 * a33 - a23 * a32;
    det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (det === 0) {
      this.setIdentity();
    } else {
      invDet = 1 / det;
      m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
      m[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
      m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
      m[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
      m[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
      m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
      m[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
      m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
      m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
      m[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
      m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
      m[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
      m[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
      m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
      m[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
      m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
    }
    return this;
  }, set:function(src) {
    var dst = this.data;
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    dst[4] = src[4];
    dst[5] = src[5];
    dst[6] = src[6];
    dst[7] = src[7];
    dst[8] = src[8];
    dst[9] = src[9];
    dst[10] = src[10];
    dst[11] = src[11];
    dst[12] = src[12];
    dst[13] = src[13];
    dst[14] = src[14];
    dst[15] = src[15];
    return this;
  }, setIdentity:function() {
    var m = this.data;
    m[0] = 1;
    m[1] = 0;
    m[2] = 0;
    m[3] = 0;
    m[4] = 0;
    m[5] = 1;
    m[6] = 0;
    m[7] = 0;
    m[8] = 0;
    m[9] = 0;
    m[10] = 1;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    return this;
  }, setTRS:function(t, r, s) {
    var tx, ty, tz, qx, qy, qz, qw, sx, sy, sz, x2, y2, z2, xx, xy, xz, yy, yz, zz, wx, wy, wz, m;
    tx = t.x;
    ty = t.y;
    tz = t.z;
    qx = r.x;
    qy = r.y;
    qz = r.z;
    qw = r.w;
    sx = s.x;
    sy = s.y;
    sz = s.z;
    x2 = qx + qx;
    y2 = qy + qy;
    z2 = qz + qz;
    xx = qx * x2;
    xy = qx * y2;
    xz = qx * z2;
    yy = qy * y2;
    yz = qy * z2;
    zz = qz * z2;
    wx = qw * x2;
    wy = qw * y2;
    wz = qw * z2;
    m = this.data;
    m[0] = (1 - (yy + zz)) * sx;
    m[1] = (xy + wz) * sx;
    m[2] = (xz - wy) * sx;
    m[3] = 0;
    m[4] = (xy - wz) * sy;
    m[5] = (1 - (xx + zz)) * sy;
    m[6] = (yz + wx) * sy;
    m[7] = 0;
    m[8] = (xz + wy) * sz;
    m[9] = (yz - wx) * sz;
    m[10] = (1 - (xx + yy)) * sz;
    m[11] = 0;
    m[12] = tx;
    m[13] = ty;
    m[14] = tz;
    m[15] = 1;
    return this;
  }, transpose:function() {
    var tmp, m = this.data;
    tmp = m[1];
    m[1] = m[4];
    m[4] = tmp;
    tmp = m[2];
    m[2] = m[8];
    m[8] = tmp;
    tmp = m[3];
    m[3] = m[12];
    m[12] = tmp;
    tmp = m[6];
    m[6] = m[9];
    m[9] = tmp;
    tmp = m[7];
    m[7] = m[13];
    m[13] = tmp;
    tmp = m[11];
    m[11] = m[14];
    m[14] = tmp;
    return this;
  }, invertTo3x3:function(res) {
    var a11, a21, a31, a12, a22, a32, a13, a23, a33, m, r, det, idet;
    m = this.data;
    r = res.data;
    var m0 = m[0];
    var m1 = m[1];
    var m2 = m[2];
    var m4 = m[4];
    var m5 = m[5];
    var m6 = m[6];
    var m8 = m[8];
    var m9 = m[9];
    var m10 = m[10];
    a11 = m10 * m5 - m6 * m9;
    a21 = -m10 * m1 + m2 * m9;
    a31 = m6 * m1 - m2 * m5;
    a12 = -m10 * m4 + m6 * m8;
    a22 = m10 * m0 - m2 * m8;
    a32 = -m6 * m0 + m2 * m4;
    a13 = m9 * m4 - m5 * m8;
    a23 = -m9 * m0 + m1 * m8;
    a33 = m5 * m0 - m1 * m4;
    det = m0 * a11 + m1 * a12 + m2 * a13;
    if (det === 0) {
      return this;
    }
    idet = 1 / det;
    r[0] = idet * a11;
    r[1] = idet * a21;
    r[2] = idet * a31;
    r[3] = idet * a12;
    r[4] = idet * a22;
    r[5] = idet * a32;
    r[6] = idet * a13;
    r[7] = idet * a23;
    r[8] = idet * a33;
    return this;
  }, getTranslation:function(t) {
    t = t === undefined ? new pc.Vec3 : t;
    return t.set(this.data[12], this.data[13], this.data[14]);
  }, getX:function(x) {
    x = x === undefined ? new pc.Vec3 : x;
    return x.set(this.data[0], this.data[1], this.data[2]);
  }, getY:function(y) {
    y = y === undefined ? new pc.Vec3 : y;
    return y.set(this.data[4], this.data[5], this.data[6]);
  }, getZ:function(z) {
    z = z === undefined ? new pc.Vec3 : z;
    return z.set(this.data[8], this.data[9], this.data[10]);
  }, getScale:function() {
    var x, y, z;
    x = new pc.Vec3;
    y = new pc.Vec3;
    z = new pc.Vec3;
    return function(scale) {
      scale = scale === undefined ? new pc.Vec3 : scale;
      this.getX(x);
      this.getY(y);
      this.getZ(z);
      scale.set(x.length(), y.length(), z.length());
      return scale;
    };
  }(), setFromEulerAngles:function(ex, ey, ez) {
    var s1, c1, s2, c2, s3, c3, m;
    ex *= pc.math.DEG_TO_RAD;
    ey *= pc.math.DEG_TO_RAD;
    ez *= pc.math.DEG_TO_RAD;
    s1 = Math.sin(-ex);
    c1 = Math.cos(-ex);
    s2 = Math.sin(-ey);
    c2 = Math.cos(-ey);
    s3 = Math.sin(-ez);
    c3 = Math.cos(-ez);
    m = this.data;
    m[0] = c2 * c3;
    m[1] = -c2 * s3;
    m[2] = s2;
    m[3] = 0;
    m[4] = c1 * s3 + c3 * s1 * s2;
    m[5] = c1 * c3 - s1 * s2 * s3;
    m[6] = -c2 * s1;
    m[7] = 0;
    m[8] = s1 * s3 - c1 * c3 * s2;
    m[9] = c3 * s1 + c1 * s2 * s3;
    m[10] = c1 * c2;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    return this;
  }, getEulerAngles:function() {
    var scale = new pc.Vec3;
    return function(eulers) {
      var x, y, z, sx, sy, sz, m, halfPi;
      eulers = eulers === undefined ? new pc.Vec3 : eulers;
      this.getScale(scale);
      sx = scale.x;
      sy = scale.y;
      sz = scale.z;
      m = this.data;
      y = Math.asin(-m[2] / sx);
      halfPi = Math.PI * 0.5;
      if (y < halfPi) {
        if (y > -halfPi) {
          x = Math.atan2(m[6] / sy, m[10] / sz);
          z = Math.atan2(m[1] / sx, m[0] / sx);
        } else {
          z = 0;
          x = -Math.atan2(m[4] / sy, m[5] / sy);
        }
      } else {
        z = 0;
        x = Math.atan2(m[4] / sy, m[5] / sy);
      }
      return eulers.set(x, y, z).scale(pc.math.RAD_TO_DEG);
    };
  }(), toString:function() {
    var i, t;
    t = "[";
    for (i = 0; i < 16; i += 1) {
      t += this.data[i];
      t += i !== 15 ? ", " : "";
    }
    t += "]";
    return t;
  }});
  Object.defineProperty(Mat4, "IDENTITY", {get:function() {
    var identity = new Mat4;
    return function() {
      return identity;
    };
  }()});
  Object.defineProperty(Mat4, "ZERO", {get:function() {
    var zero = (new Mat4).set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    return function() {
      return zero;
    };
  }()});
  return {Mat4:Mat4};
}());
Object.assign(pc, function() {
  var Quat = function(x, y, z, w) {
    if (x && x.length === 4) {
      this.x = x[0];
      this.y = x[1];
      this.z = x[2];
      this.w = x[3];
    } else {
      this.x = x === undefined ? 0 : x;
      this.y = y === undefined ? 0 : y;
      this.z = z === undefined ? 0 : z;
      this.w = w === undefined ? 1 : w;
    }
  };
  Object.assign(Quat.prototype, {clone:function() {
    return new pc.Quat(this.x, this.y, this.z, this.w);
  }, conjugate:function() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    return this;
  }, copy:function(rhs) {
    this.x = rhs.x;
    this.y = rhs.y;
    this.z = rhs.z;
    this.w = rhs.w;
    return this;
  }, equals:function(rhs) {
    return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
  }, getAxisAngle:function(axis) {
    var rad = Math.acos(this.w) * 2;
    var s = Math.sin(rad / 2);
    if (s !== 0) {
      axis.x = this.x / s;
      axis.y = this.y / s;
      axis.z = this.z / s;
      if (axis.x < 0 || axis.y < 0 || axis.z < 0) {
        axis.x *= -1;
        axis.y *= -1;
        axis.z *= -1;
        rad *= -1;
      }
    } else {
      axis.x = 1;
      axis.y = 0;
      axis.z = 0;
    }
    return rad * pc.math.RAD_TO_DEG;
  }, getEulerAngles:function(eulers) {
    var x, y, z, qx, qy, qz, qw, a2;
    eulers = eulers === undefined ? new pc.Vec3 : eulers;
    qx = this.x;
    qy = this.y;
    qz = this.z;
    qw = this.w;
    a2 = 2 * (qw * qy - qx * qz);
    if (a2 <= -0.99999) {
      x = 2 * Math.atan2(qx, qw);
      y = -Math.PI / 2;
      z = 0;
    } else {
      if (a2 >= 0.99999) {
        x = 2 * Math.atan2(qx, qw);
        y = Math.PI / 2;
        z = 0;
      } else {
        x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
        y = Math.asin(a2);
        z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
      }
    }
    return eulers.set(x, y, z).scale(pc.math.RAD_TO_DEG);
  }, invert:function() {
    return this.conjugate().normalize();
  }, length:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }, lengthSq:function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }, mul:function(rhs) {
    var q1x, q1y, q1z, q1w, q2x, q2y, q2z, q2w;
    q1x = this.x;
    q1y = this.y;
    q1z = this.z;
    q1w = this.w;
    q2x = rhs.x;
    q2y = rhs.y;
    q2z = rhs.z;
    q2w = rhs.w;
    this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
    this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
    this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
    this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
    return this;
  }, mul2:function(lhs, rhs) {
    var q1x, q1y, q1z, q1w, q2x, q2y, q2z, q2w;
    q1x = lhs.x;
    q1y = lhs.y;
    q1z = lhs.z;
    q1w = lhs.w;
    q2x = rhs.x;
    q2y = rhs.y;
    q2z = rhs.z;
    q2w = rhs.w;
    this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
    this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
    this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
    this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
    return this;
  }, normalize:function() {
    var len = this.length();
    if (len === 0) {
      this.x = this.y = this.z = 0;
      this.w = 1;
    } else {
      len = 1 / len;
      this.x *= len;
      this.y *= len;
      this.z *= len;
      this.w *= len;
    }
    return this;
  }, set:function(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }, setFromAxisAngle:function(axis, angle) {
    var sa, ca;
    angle *= 0.5 * pc.math.DEG_TO_RAD;
    sa = Math.sin(angle);
    ca = Math.cos(angle);
    this.x = sa * axis.x;
    this.y = sa * axis.y;
    this.z = sa * axis.z;
    this.w = ca;
    return this;
  }, setFromEulerAngles:function(ex, ey, ez) {
    var sx, cx, sy, cy, sz, cz, halfToRad;
    halfToRad = 0.5 * pc.math.DEG_TO_RAD;
    ex *= halfToRad;
    ey *= halfToRad;
    ez *= halfToRad;
    sx = Math.sin(ex);
    cx = Math.cos(ex);
    sy = Math.sin(ey);
    cy = Math.cos(ey);
    sz = Math.sin(ez);
    cz = Math.cos(ez);
    this.x = sx * cy * cz - cx * sy * sz;
    this.y = cx * sy * cz + sx * cy * sz;
    this.z = cx * cy * sz - sx * sy * cz;
    this.w = cx * cy * cz + sx * sy * sz;
    return this;
  }, setFromMat4:function(m) {
    var m00, m01, m02, m10, m11, m12, m20, m21, m22, tr, s, rs, lx, ly, lz;
    m = m.data;
    m00 = m[0];
    m01 = m[1];
    m02 = m[2];
    m10 = m[4];
    m11 = m[5];
    m12 = m[6];
    m20 = m[8];
    m21 = m[9];
    m22 = m[10];
    lx = 1 / Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
    ly = 1 / Math.sqrt(m10 * m10 + m11 * m11 + m12 * m12);
    lz = 1 / Math.sqrt(m20 * m20 + m21 * m21 + m22 * m22);
    m00 *= lx;
    m01 *= lx;
    m02 *= lx;
    m10 *= ly;
    m11 *= ly;
    m12 *= ly;
    m20 *= lz;
    m21 *= lz;
    m22 *= lz;
    tr = m00 + m11 + m22;
    if (tr >= 0) {
      s = Math.sqrt(tr + 1);
      this.w = s * 0.5;
      s = 0.5 / s;
      this.x = (m12 - m21) * s;
      this.y = (m20 - m02) * s;
      this.z = (m01 - m10) * s;
    } else {
      if (m00 > m11) {
        if (m00 > m22) {
          rs = m00 - (m11 + m22) + 1;
          rs = Math.sqrt(rs);
          this.x = rs * 0.5;
          rs = 0.5 / rs;
          this.w = (m12 - m21) * rs;
          this.y = (m01 + m10) * rs;
          this.z = (m02 + m20) * rs;
        } else {
          rs = m22 - (m00 + m11) + 1;
          rs = Math.sqrt(rs);
          this.z = rs * 0.5;
          rs = 0.5 / rs;
          this.w = (m01 - m10) * rs;
          this.x = (m20 + m02) * rs;
          this.y = (m21 + m12) * rs;
        }
      } else {
        if (m11 > m22) {
          rs = m11 - (m22 + m00) + 1;
          rs = Math.sqrt(rs);
          this.y = rs * 0.5;
          rs = 0.5 / rs;
          this.w = (m20 - m02) * rs;
          this.z = (m12 + m21) * rs;
          this.x = (m10 + m01) * rs;
        } else {
          rs = m22 - (m00 + m11) + 1;
          rs = Math.sqrt(rs);
          this.z = rs * 0.5;
          rs = 0.5 / rs;
          this.w = (m01 - m10) * rs;
          this.x = (m20 + m02) * rs;
          this.y = (m21 + m12) * rs;
        }
      }
    }
    return this;
  }, slerp:function(lhs, rhs, alpha) {
    var lx, ly, lz, lw, rx, ry, rz, rw;
    lx = lhs.x;
    ly = lhs.y;
    lz = lhs.z;
    lw = lhs.w;
    rx = rhs.x;
    ry = rhs.y;
    rz = rhs.z;
    rw = rhs.w;
    var cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;
    if (cosHalfTheta < 0) {
      rw = -rw;
      rx = -rx;
      ry = -ry;
      rz = -rz;
      cosHalfTheta = -cosHalfTheta;
    }
    if (Math.abs(cosHalfTheta) >= 1) {
      this.w = lw;
      this.x = lx;
      this.y = ly;
      this.z = lz;
      return this;
    }
    var halfTheta = Math.acos(cosHalfTheta);
    var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
    if (Math.abs(sinHalfTheta) < 0.001) {
      this.w = lw * 0.5 + rw * 0.5;
      this.x = lx * 0.5 + rx * 0.5;
      this.y = ly * 0.5 + ry * 0.5;
      this.z = lz * 0.5 + rz * 0.5;
      return this;
    }
    var ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;
    var ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;
    this.w = lw * ratioA + rw * ratioB;
    this.x = lx * ratioA + rx * ratioB;
    this.y = ly * ratioA + ry * ratioB;
    this.z = lz * ratioA + rz * ratioB;
    return this;
  }, transformVector:function(vec, res) {
    if (res === undefined) {
      res = new pc.Vec3;
    }
    var x = vec.x, y = vec.y, z = vec.z;
    var qx = this.x, qy = this.y, qz = this.z, qw = this.w;
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return res;
  }, toString:function() {
    return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]";
  }});
  Object.defineProperty(Quat, "IDENTITY", {get:function() {
    var identity = new Quat;
    return function() {
      return identity;
    };
  }()});
  Object.defineProperty(Quat, "ZERO", {get:function() {
    var zero = new Quat(0, 0, 0, 0);
    return function() {
      return zero;
    };
  }()});
  return {Quat:Quat};
}());
Object.assign(pc, function() {
  var CURVE_LINEAR = 0;
  var CURVE_SMOOTHSTEP = 1;
  var CURVE_CATMULL = 2;
  var CURVE_CARDINAL = 3;
  var Curve = function(data) {
    this.keys = [];
    this.type = CURVE_SMOOTHSTEP;
    this.tension = 0.5;
    if (data) {
      for (var i = 0; i < data.length - 1; i += 2) {
        this.keys.push([data[i], data[i + 1]]);
      }
    }
    this.sort();
  };
  Object.assign(Curve.prototype, {add:function(time, value) {
    var keys = this.keys;
    var len = keys.length;
    var i = 0;
    for (; i < len; i++) {
      if (keys[i][0] > time) {
        break;
      }
    }
    var key = [time, value];
    this.keys.splice(i, 0, key);
    return key;
  }, get:function(index) {
    return this.keys[index];
  }, sort:function() {
    this.keys.sort(function(a, b) {
      return a[0] - b[0];
    });
  }, value:function(time) {
    var i, len;
    var keys = this.keys;
    if (!keys.length) {
      return 0;
    }
    if (time < keys[0][0]) {
      return keys[0][1];
    } else {
      if (time > keys[keys.length - 1][0]) {
        return keys[keys.length - 1][1];
      }
    }
    var leftTime = 0;
    var leftValue = keys.length ? keys[0][1] : 0;
    var rightTime = 1;
    var rightValue = 0;
    for (i = 0, len = keys.length; i < len; i++) {
      if (keys[i][0] === time) {
        return keys[i][1];
      }
      rightValue = keys[i][1];
      if (time < keys[i][0]) {
        rightTime = keys[i][0];
        break;
      }
      leftTime = keys[i][0];
      leftValue = keys[i][1];
    }
    var div = rightTime - leftTime;
    var interpolation = div === 0 ? 0 : (time - leftTime) / div;
    if (this.type === CURVE_SMOOTHSTEP) {
      interpolation *= interpolation * (3 - 2 * interpolation);
    } else {
      if (this.type === CURVE_CATMULL || this.type === CURVE_CARDINAL) {
        var p1 = leftValue;
        var p2 = rightValue;
        var p0 = p1 + (p1 - p2);
        var p3 = p2 + (p2 - p1);
        var dt1 = rightTime - leftTime;
        var dt0 = dt1;
        var dt2 = dt1;
        if (i > 0) {
          i--;
        }
        if (i > 0) {
          p0 = keys[i - 1][1];
          dt0 = keys[i][0] - keys[i - 1][0];
        }
        if (keys.length > i + 1) {
          dt1 = keys[i + 1][0] - keys[i][0];
        }
        if (keys.length > i + 2) {
          dt2 = keys[i + 2][0] - keys[i + 1][0];
          p3 = keys[i + 2][1];
        }
        p0 = p1 + (p0 - p1) * dt1 / dt0;
        p3 = p2 + (p3 - p2) * dt1 / dt2;
        if (this.type === CURVE_CATMULL) {
          return this._interpolateCatmullRom(p0, p1, p2, p3, interpolation);
        }
        return this._interpolateCardinal(p0, p1, p2, p3, interpolation, this.tension);
      }
    }
    return pc.math.lerp(leftValue, rightValue, interpolation);
  }, _interpolateHermite:function(p0, p1, t0, t1, s) {
    var s2 = s * s;
    var s3 = s * s * s;
    var h0 = 2 * s3 - 3 * s2 + 1;
    var h1 = -2 * s3 + 3 * s2;
    var h2 = s3 - 2 * s2 + s;
    var h3 = s3 - s2;
    return p0 * h0 + p1 * h1 + t0 * h2 + t1 * h3;
  }, _interpolateCardinal:function(p0, p1, p2, p3, s, t) {
    var t0 = t * (p2 - p0);
    var t1 = t * (p3 - p1);
    return this._interpolateHermite(p1, p2, t0, t1, s);
  }, _interpolateCatmullRom:function(p0, p1, p2, p3, s) {
    return this._interpolateCardinal(p0, p1, p2, p3, s, 0.5);
  }, closest:function(time) {
    var keys = this.keys;
    var length = keys.length;
    var min = 2;
    var result = null;
    for (var i = 0; i < length; i++) {
      var diff = Math.abs(time - keys[i][0]);
      if (min >= diff) {
        min = diff;
        result = keys[i];
      } else {
        break;
      }
    }
    return result;
  }, clone:function() {
    var result = new pc.Curve;
    result.keys = pc.extend(result.keys, this.keys);
    result.type = this.type;
    return result;
  }, quantize:function(precision) {
    precision = Math.max(precision, 2);
    var values = new Float32Array(precision);
    var step = 1.0 / (precision - 1);
    for (var i = 0; i < precision; i++) {
      var value = this.value(step * i);
      values[i] = value;
    }
    return values;
  }});
  Object.defineProperty(Curve.prototype, "length", {get:function() {
    return this.keys.length;
  }});
  return {Curve:Curve, CURVE_LINEAR:CURVE_LINEAR, CURVE_SMOOTHSTEP:CURVE_SMOOTHSTEP, CURVE_CATMULL:CURVE_CATMULL, CURVE_CARDINAL:CURVE_CARDINAL};
}());
Object.assign(pc, function() {
  var CurveSet = function() {
    var i;
    this.curves = [];
    this._type = pc.CURVE_SMOOTHSTEP;
    if (arguments.length > 1) {
      for (i = 0; i < arguments.length; i++) {
        this.curves.push(new pc.Curve(arguments[i]));
      }
    } else {
      if (arguments.length === 0) {
        this.curves.push(new pc.Curve);
      } else {
        var arg = arguments[0];
        if (pc.type(arg) === "number") {
          for (i = 0; i < arg; i++) {
            this.curves.push(new pc.Curve);
          }
        } else {
          for (i = 0; i < arg.length; i++) {
            this.curves.push(new pc.Curve(arg[i]));
          }
        }
      }
    }
  };
  Object.assign(CurveSet.prototype, {get:function(index) {
    return this.curves[index];
  }, value:function(time, result) {
    var length = this.curves.length;
    result = result || [];
    result.length = length;
    for (var i = 0; i < length; i++) {
      result[i] = this.curves[i].value(time);
    }
    return result;
  }, clone:function() {
    var result = new pc.CurveSet;
    result.curves = [];
    for (var i = 0; i < this.curves.length; i++) {
      result.curves.push(this.curves[i].clone());
    }
    result._type = this._type;
    return result;
  }, quantize:function(precision) {
    precision = Math.max(precision, 2);
    var numCurves = this.curves.length;
    var values = new Float32Array(precision * numCurves);
    var step = 1.0 / (precision - 1);
    var temp = [];
    for (var i = 0; i < precision; i++) {
      var value = this.value(step * i, temp);
      if (numCurves == 1) {
        values[i] = value[0];
      } else {
        for (var j = 0; j < numCurves; j++) {
          values[i * numCurves + j] = value[j];
        }
      }
    }
    return values;
  }});
  Object.defineProperty(CurveSet.prototype, "length", {get:function() {
    return this.curves.length;
  }});
  Object.defineProperty(CurveSet.prototype, "type", {get:function() {
    return this._type;
  }, set:function(value) {
    this._type = value;
    for (var i = 0; i < this.curves.length; i++) {
      this.curves[i].type = value;
    }
  }});
  return {CurveSet:CurveSet};
}());
Object.assign(pc, function() {
  var tmpVecA = new pc.Vec3;
  var tmpVecB = new pc.Vec3;
  var tmpVecC = new pc.Vec3;
  var tmpVecD = new pc.Vec3;
  var tmpVecE = new pc.Vec3;
  var BoundingBox = function BoundingBox(center, halfExtents) {
    this.center = center || new pc.Vec3(0, 0, 0);
    this.halfExtents = halfExtents || new pc.Vec3(0.5, 0.5, 0.5);
    this._min = new pc.Vec3;
    this._max = new pc.Vec3;
  };
  Object.assign(BoundingBox.prototype, {add:function(other) {
    var tc = this.center;
    var tcx = tc.x;
    var tcy = tc.y;
    var tcz = tc.z;
    var th = this.halfExtents;
    var thx = th.x;
    var thy = th.y;
    var thz = th.z;
    var tminx = tcx - thx;
    var tmaxx = tcx + thx;
    var tminy = tcy - thy;
    var tmaxy = tcy + thy;
    var tminz = tcz - thz;
    var tmaxz = tcz + thz;
    var oc = other.center;
    var ocx = oc.x;
    var ocy = oc.y;
    var ocz = oc.z;
    var oh = other.halfExtents;
    var ohx = oh.x;
    var ohy = oh.y;
    var ohz = oh.z;
    var ominx = ocx - ohx;
    var omaxx = ocx + ohx;
    var ominy = ocy - ohy;
    var omaxy = ocy + ohy;
    var ominz = ocz - ohz;
    var omaxz = ocz + ohz;
    if (ominx < tminx) {
      tminx = ominx;
    }
    if (omaxx > tmaxx) {
      tmaxx = omaxx;
    }
    if (ominy < tminy) {
      tminy = ominy;
    }
    if (omaxy > tmaxy) {
      tmaxy = omaxy;
    }
    if (ominz < tminz) {
      tminz = ominz;
    }
    if (omaxz > tmaxz) {
      tmaxz = omaxz;
    }
    tc.x = (tminx + tmaxx) * 0.5;
    tc.y = (tminy + tmaxy) * 0.5;
    tc.z = (tminz + tmaxz) * 0.5;
    th.x = (tmaxx - tminx) * 0.5;
    th.y = (tmaxy - tminy) * 0.5;
    th.z = (tmaxz - tminz) * 0.5;
  }, copy:function(src) {
    this.center.copy(src.center);
    this.halfExtents.copy(src.halfExtents);
    this.type = src.type;
  }, clone:function() {
    return new pc.BoundingBox(this.center.clone(), this.halfExtents.clone());
  }, intersects:function(other) {
    var aMax = this.getMax();
    var aMin = this.getMin();
    var bMax = other.getMax();
    var bMin = other.getMin();
    return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
  }, _intersectsRay:function(ray, point) {
    var tMin = tmpVecA.copy(this.getMin()).sub(ray.origin);
    var tMax = tmpVecB.copy(this.getMax()).sub(ray.origin);
    var dir = ray.direction;
    if (dir.x === 0) {
      tMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
      tMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
    } else {
      tMin.x /= dir.x;
      tMax.x /= dir.x;
    }
    if (dir.y === 0) {
      tMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
      tMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
    } else {
      tMin.y /= dir.y;
      tMax.y /= dir.y;
    }
    if (dir.z === 0) {
      tMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
      tMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
    } else {
      tMin.z /= dir.z;
      tMax.z /= dir.z;
    }
    var realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));
    var realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));
    var minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);
    var maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);
    var intersects = minMax >= maxMin && maxMin >= 0;
    if (intersects) {
      point.copy(ray.direction).scale(maxMin).add(ray.origin);
    }
    return intersects;
  }, _fastIntersectsRay:function(ray) {
    var diff = tmpVecA;
    var cross = tmpVecB;
    var prod = tmpVecC;
    var absDiff = tmpVecD;
    var absDir = tmpVecE;
    var rayDir = ray.direction;
    diff.sub2(ray.origin, this.center);
    absDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));
    prod.mul2(diff, rayDir);
    if (absDiff.x > this.halfExtents.x && prod.x >= 0) {
      return false;
    }
    if (absDiff.y > this.halfExtents.y && prod.y >= 0) {
      return false;
    }
    if (absDiff.z > this.halfExtents.z && prod.z >= 0) {
      return false;
    }
    absDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));
    cross.cross(rayDir, diff);
    cross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));
    if (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y) {
      return false;
    }
    if (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x) {
      return false;
    }
    if (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x) {
      return false;
    }
    return true;
  }, intersectsRay:function(ray, point) {
    if (point) {
      return this._intersectsRay(ray, point);
    }
    return this._fastIntersectsRay(ray);
  }, setMinMax:function(min, max) {
    this.center.add2(max, min).scale(0.5);
    this.halfExtents.sub2(max, min).scale(0.5);
  }, getMin:function() {
    return this._min.copy(this.center).sub(this.halfExtents);
  }, getMax:function() {
    return this._max.copy(this.center).add(this.halfExtents);
  }, containsPoint:function(point) {
    var min = this.getMin();
    var max = this.getMax();
    if (point.x < min.x || point.x > max.x || point.y < min.y || point.y > max.y || point.z < min.z || point.z > max.z) {
      return false;
    }
    return true;
  }, setFromTransformedAabb:function(aabb, m) {
    var bc = this.center;
    var br = this.halfExtents;
    var ac = aabb.center;
    var ar = aabb.halfExtents;
    m = m.data;
    var mx0 = m[0];
    var mx1 = m[4];
    var mx2 = m[8];
    var my0 = m[1];
    var my1 = m[5];
    var my2 = m[9];
    var mz0 = m[2];
    var mz1 = m[6];
    var mz2 = m[10];
    var mx0a = Math.abs(mx0);
    var mx1a = Math.abs(mx1);
    var mx2a = Math.abs(mx2);
    var my0a = Math.abs(my0);
    var my1a = Math.abs(my1);
    var my2a = Math.abs(my2);
    var mz0a = Math.abs(mz0);
    var mz1a = Math.abs(mz1);
    var mz2a = Math.abs(mz2);
    bc.set(m[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z, m[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z, m[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z);
    br.set(mx0a * ar.x + mx1a * ar.y + mx2a * ar.z, my0a * ar.x + my1a * ar.y + my2a * ar.z, mz0a * ar.x + mz1a * ar.y + mz2a * ar.z);
  }, compute:function(vertices) {
    var min = tmpVecA.set(vertices[0], vertices[1], vertices[2]);
    var max = tmpVecB.set(vertices[0], vertices[1], vertices[2]);
    var numVerts = vertices.length / 3;
    for (var i = 1; i < numVerts; i++) {
      var x = vertices[i * 3 + 0];
      var y = vertices[i * 3 + 1];
      var z = vertices[i * 3 + 2];
      if (x < min.x) {
        min.x = x;
      }
      if (y < min.y) {
        min.y = y;
      }
      if (z < min.z) {
        min.z = z;
      }
      if (x > max.x) {
        max.x = x;
      }
      if (y > max.y) {
        max.y = y;
      }
      if (z > max.z) {
        max.z = z;
      }
    }
    this.setMinMax(min, max);
  }, intersectsBoundingSphere:function(sphere) {
    var sq = this._distanceToBoundingSphereSq(sphere);
    if (sq <= sphere.radius * sphere.radius) {
      return true;
    }
    return false;
  }, _distanceToBoundingSphereSq:function(sphere) {
    var boxMin = this.getMin();
    var boxMax = this.getMax();
    var sq = 0;
    var axis = ["x", "y", "z"];
    for (var i = 0; i < 3; ++i) {
      var out = 0;
      var pn = sphere.center[axis[i]];
      var bMin = boxMin[axis[i]];
      var bMax = boxMax[axis[i]];
      var val = 0;
      if (pn < bMin) {
        val = bMin - pn;
        out += val * val;
      }
      if (pn > bMax) {
        val = pn - bMax;
        out += val * val;
      }
      sq += out;
    }
    return sq;
  }});
  return {BoundingBox:BoundingBox};
}());
Object.assign(pc, function() {
  var tmpVecA = new pc.Vec3;
  var tmpVecB = new pc.Vec3;
  var tmpVecC = new pc.Vec3;
  var tmpVecD = new pc.Vec3;
  function BoundingSphere(center, radius) {
    this.center = center || new pc.Vec3(0, 0, 0);
    this.radius = radius === undefined ? 0.5 : radius;
  }
  Object.assign(BoundingSphere.prototype, {containsPoint:function(point) {
    var lenSq = tmpVecA.sub2(point, this.center).lengthSq();
    var r = this.radius;
    return lenSq < r * r;
  }, compute:function(vertices) {
    var i;
    var numVerts = vertices.length / 3;
    var vertex = tmpVecA;
    var avgVertex = tmpVecB;
    var sum = tmpVecC;
    for (i = 0; i < numVerts; i++) {
      vertex.set(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]);
      sum.addSelf(vertex);
      if (i % 100 === 0) {
        sum.scale(1 / numVerts);
        avgVertex.add(sum);
        sum.set(0, 0, 0);
      }
    }
    sum.scale(1 / numVerts);
    avgVertex.add(sum);
    this.center.copy(avgVertex);
    var maxDistSq = 0;
    var centerToVert = tmpVecD;
    for (i = 0; i < numVerts; i++) {
      vertex.set(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]);
      centerToVert.sub2(vertex, this.center);
      maxDistSq = Math.max(centerToVert.lengthSq(), maxDistSq);
    }
    this.radius = Math.sqrt(maxDistSq);
  }, intersectsRay:function(ray, point) {
    var m = tmpVecA.copy(ray.origin).sub(this.center);
    var b = m.dot(tmpVecB.copy(ray.direction).normalize());
    var c = m.dot(m) - this.radius * this.radius;
    if (c > 0 && b > 0) {
      return null;
    }
    var discr = b * b - c;
    if (discr < 0) {
      return false;
    }
    var t = Math.abs(-b - Math.sqrt(discr));
    if (point) {
      point.copy(ray.direction).scale(t).add(ray.origin);
    }
    return true;
  }, intersectsBoundingSphere:function(sphere) {
    tmpVecA.sub2(sphere.center, this.center);
    var totalRadius = sphere.radius + this.radius;
    if (tmpVecA.lengthSq() <= totalRadius * totalRadius) {
      return true;
    }
    return false;
  }});
  return {BoundingSphere:BoundingSphere};
}());
Object.assign(pc, function() {
  var viewProj = new pc.Mat4;
  var Frustum = function Frustum(projectionMatrix, viewMatrix) {
    projectionMatrix = projectionMatrix || (new pc.Mat4).setPerspective(90, 16 / 9, 0.1, 1000);
    viewMatrix = viewMatrix || new pc.Mat4;
    this.planes = [];
    for (var i = 0; i < 6; i++) {
      this.planes[i] = [];
    }
    this.update(projectionMatrix, viewMatrix);
  };
  Object.assign(Frustum.prototype, {update:function(projectionMatrix, viewMatrix) {
    viewProj.mul2(projectionMatrix, viewMatrix);
    var vpm = viewProj.data;
    this.planes[0][0] = vpm[3] - vpm[0];
    this.planes[0][1] = vpm[7] - vpm[4];
    this.planes[0][2] = vpm[11] - vpm[8];
    this.planes[0][3] = vpm[15] - vpm[12];
    var t = Math.sqrt(this.planes[0][0] * this.planes[0][0] + this.planes[0][1] * this.planes[0][1] + this.planes[0][2] * this.planes[0][2]);
    this.planes[0][0] /= t;
    this.planes[0][1] /= t;
    this.planes[0][2] /= t;
    this.planes[0][3] /= t;
    this.planes[1][0] = vpm[3] + vpm[0];
    this.planes[1][1] = vpm[7] + vpm[4];
    this.planes[1][2] = vpm[11] + vpm[8];
    this.planes[1][3] = vpm[15] + vpm[12];
    t = Math.sqrt(this.planes[1][0] * this.planes[1][0] + this.planes[1][1] * this.planes[1][1] + this.planes[1][2] * this.planes[1][2]);
    this.planes[1][0] /= t;
    this.planes[1][1] /= t;
    this.planes[1][2] /= t;
    this.planes[1][3] /= t;
    this.planes[2][0] = vpm[3] + vpm[1];
    this.planes[2][1] = vpm[7] + vpm[5];
    this.planes[2][2] = vpm[11] + vpm[9];
    this.planes[2][3] = vpm[15] + vpm[13];
    t = Math.sqrt(this.planes[2][0] * this.planes[2][0] + this.planes[2][1] * this.planes[2][1] + this.planes[2][2] * this.planes[2][2]);
    this.planes[2][0] /= t;
    this.planes[2][1] /= t;
    this.planes[2][2] /= t;
    this.planes[2][3] /= t;
    this.planes[3][0] = vpm[3] - vpm[1];
    this.planes[3][1] = vpm[7] - vpm[5];
    this.planes[3][2] = vpm[11] - vpm[9];
    this.planes[3][3] = vpm[15] - vpm[13];
    t = Math.sqrt(this.planes[3][0] * this.planes[3][0] + this.planes[3][1] * this.planes[3][1] + this.planes[3][2] * this.planes[3][2]);
    this.planes[3][0] /= t;
    this.planes[3][1] /= t;
    this.planes[3][2] /= t;
    this.planes[3][3] /= t;
    this.planes[4][0] = vpm[3] - vpm[2];
    this.planes[4][1] = vpm[7] - vpm[6];
    this.planes[4][2] = vpm[11] - vpm[10];
    this.planes[4][3] = vpm[15] - vpm[14];
    t = Math.sqrt(this.planes[4][0] * this.planes[4][0] + this.planes[4][1] * this.planes[4][1] + this.planes[4][2] * this.planes[4][2]);
    this.planes[4][0] /= t;
    this.planes[4][1] /= t;
    this.planes[4][2] /= t;
    this.planes[4][3] /= t;
    this.planes[5][0] = vpm[3] + vpm[2];
    this.planes[5][1] = vpm[7] + vpm[6];
    this.planes[5][2] = vpm[11] + vpm[10];
    this.planes[5][3] = vpm[15] + vpm[14];
    t = Math.sqrt(this.planes[5][0] * this.planes[5][0] + this.planes[5][1] * this.planes[5][1] + this.planes[5][2] * this.planes[5][2]);
    this.planes[5][0] /= t;
    this.planes[5][1] /= t;
    this.planes[5][2] /= t;
    this.planes[5][3] /= t;
  }, containsPoint:function(point) {
    for (var p = 0; p < 6; p++) {
      if (this.planes[p][0] * point.x + this.planes[p][1] * point.y + this.planes[p][2] * point.z + this.planes[p][3] <= 0) {
        return false;
      }
    }
    return true;
  }, containsSphere:function(sphere) {
    var c = 0;
    var d;
    var p;
    var sr = sphere.radius;
    var sc = sphere.center;
    var scx = sc.x;
    var scy = sc.y;
    var scz = sc.z;
    var planes = this.planes;
    var plane;
    for (p = 0; p < 6; p++) {
      plane = planes[p];
      d = plane[0] * scx + plane[1] * scy + plane[2] * scz + plane[3];
      if (d <= -sr) {
        return 0;
      }
      if (d > sr) {
        c++;
      }
    }
    return c === 6 ? 2 : 1;
  }});
  return {Frustum:Frustum};
}());
Object.assign(pc, function() {
  var tmpVecA = new pc.Vec3;
  var Plane = function Plane(point, normal) {
    this.normal = normal || new pc.Vec3(0, 0, 1);
    this.point = point || new pc.Vec3(0, 0, 0);
  };
  Object.assign(Plane.prototype, {intersectsLine:function(start, end, point) {
    var d = -this.normal.dot(this.point);
    var d0 = this.normal.dot(start) + d;
    var d1 = this.normal.dot(end) + d;
    var t = d0 / (d0 - d1);
    var intersects = t >= 0 && t <= 1;
    if (intersects && point) {
      point.lerp(start, end, t);
    }
    return intersects;
  }, intersectsRay:function(ray, point) {
    var pointToOrigin = tmpVecA.sub2(this.point, ray.origin);
    var t = this.normal.dot(pointToOrigin) / this.normal.dot(ray.direction);
    var intersects = t >= 0;
    if (intersects && point) {
      point.copy(ray.direction).scale(t).add(ray.origin);
    }
    return intersects;
  }});
  return {Plane:Plane};
}());
Object.assign(pc, function() {
  var Ray = function Ray(origin, direction) {
    this.origin = origin || new pc.Vec3(0, 0, 0);
    this.direction = direction || new pc.Vec3(0, 0, -1);
  };
  return {Ray:Ray};
}());
Object.assign(pc, function() {
  var tmpRay = new pc.Ray;
  var tmpVec3 = new pc.Vec3;
  var tmpSphere = new pc.BoundingSphere;
  var tmpMat4 = new pc.Mat4;
  var OrientedBox = function OrientedBox(worldTransform, halfExtents) {
    this.halfExtents = halfExtents || new pc.Vec3(0.5, 0.5, 0.5);
    worldTransform = worldTransform || tmpMat4.setIdentity();
    this._modelTransform = worldTransform.clone().invert();
    this._worldTransform = worldTransform.clone();
    this._aabb = new pc.BoundingBox(new pc.Vec3, this.halfExtents);
  };
  Object.assign(OrientedBox.prototype, {intersectsRay:function(ray, point) {
    this._modelTransform.transformPoint(ray.origin, tmpRay.origin);
    this._modelTransform.transformVector(ray.direction, tmpRay.direction);
    if (point) {
      var result = this._aabb._intersectsRay(tmpRay, point);
      tmpMat4.copy(this._modelTransform).invert().transformPoint(point, point);
      return result;
    }
    return this._aabb._fastIntersectsRay(tmpRay);
  }, containsPoint:function(point) {
    this._modelTransform.transformPoint(point, tmpVec3);
    return this._aabb.containsPoint(tmpVec3);
  }, intersectsBoundingSphere:function(sphere) {
    this._modelTransform.transformPoint(sphere.center, tmpSphere.center);
    tmpSphere.radius = sphere.radius;
    if (this._aabb.intersectsBoundingSphere(tmpSphere)) {
      return true;
    }
    return false;
  }});
  Object.defineProperty(OrientedBox.prototype, "worldTransform", {get:function() {
    return this._worldTransform;
  }, set:function(value) {
    this._worldTransform.copy(value);
    this._modelTransform.copy(value).invert();
  }});
  return {OrientedBox:OrientedBox};
}());
(function() {
  var enums = {ADDRESS_REPEAT:0, ADDRESS_CLAMP_TO_EDGE:1, ADDRESS_MIRRORED_REPEAT:2, BLENDMODE_ZERO:0, BLENDMODE_ONE:1, BLENDMODE_SRC_COLOR:2, BLENDMODE_ONE_MINUS_SRC_COLOR:3, BLENDMODE_DST_COLOR:4, BLENDMODE_ONE_MINUS_DST_COLOR:5, BLENDMODE_SRC_ALPHA:6, BLENDMODE_SRC_ALPHA_SATURATE:7, BLENDMODE_ONE_MINUS_SRC_ALPHA:8, BLENDMODE_DST_ALPHA:9, BLENDMODE_ONE_MINUS_DST_ALPHA:10, BLENDEQUATION_ADD:0, BLENDEQUATION_SUBTRACT:1, BLENDEQUATION_REVERSE_SUBTRACT:2, BLENDEQUATION_MIN:3, BLENDEQUATION_MAX:4, BUFFER_STATIC:0, 
  BUFFER_DYNAMIC:1, BUFFER_STREAM:2, BUFFER_GPUDYNAMIC:3, CLEARFLAG_COLOR:1, CLEARFLAG_DEPTH:2, CLEARFLAG_STENCIL:4, CUBEFACE_POSX:0, CUBEFACE_NEGX:1, CUBEFACE_POSY:2, CUBEFACE_NEGY:3, CUBEFACE_POSZ:4, CUBEFACE_NEGZ:5, CULLFACE_NONE:0, CULLFACE_BACK:1, CULLFACE_FRONT:2, CULLFACE_FRONTANDBACK:3, TYPE_INT8:0, TYPE_UINT8:1, TYPE_INT16:2, TYPE_UINT16:3, TYPE_INT32:4, TYPE_UINT32:5, TYPE_FLOAT32:6, FILTER_NEAREST:0, FILTER_LINEAR:1, FILTER_NEAREST_MIPMAP_NEAREST:2, FILTER_NEAREST_MIPMAP_LINEAR:3, FILTER_LINEAR_MIPMAP_NEAREST:4, 
  FILTER_LINEAR_MIPMAP_LINEAR:5, FUNC_NEVER:0, FUNC_LESS:1, FUNC_EQUAL:2, FUNC_LESSEQUAL:3, FUNC_GREATER:4, FUNC_NOTEQUAL:5, FUNC_GREATEREQUAL:6, FUNC_ALWAYS:7, INDEXFORMAT_UINT8:0, INDEXFORMAT_UINT16:1, INDEXFORMAT_UINT32:2, PIXELFORMAT_A8:0, PIXELFORMAT_L8:1, PIXELFORMAT_L8_A8:2, PIXELFORMAT_R5_G6_B5:3, PIXELFORMAT_R5_G5_B5_A1:4, PIXELFORMAT_R4_G4_B4_A4:5, PIXELFORMAT_R8_G8_B8:6, PIXELFORMAT_R8_G8_B8_A8:7, PIXELFORMAT_DXT1:8, PIXELFORMAT_DXT3:9, PIXELFORMAT_DXT5:10, PIXELFORMAT_RGB16F:11, PIXELFORMAT_RGBA16F:12, 
  PIXELFORMAT_RGB32F:13, PIXELFORMAT_RGBA32F:14, PIXELFORMAT_R32F:15, PIXELFORMAT_DEPTH:16, PIXELFORMAT_DEPTHSTENCIL:17, PIXELFORMAT_111110F:18, PIXELFORMAT_SRGB:19, PIXELFORMAT_SRGBA:20, PIXELFORMAT_ETC1:21, PIXELFORMAT_ETC2_RGB:22, PIXELFORMAT_ETC2_RGBA:23, PIXELFORMAT_PVRTC_2BPP_RGB_1:24, PIXELFORMAT_PVRTC_2BPP_RGBA_1:25, PIXELFORMAT_PVRTC_4BPP_RGB_1:26, PIXELFORMAT_PVRTC_4BPP_RGBA_1:27, PRIMITIVE_POINTS:0, PRIMITIVE_LINES:1, PRIMITIVE_LINELOOP:2, PRIMITIVE_LINESTRIP:3, PRIMITIVE_TRIANGLES:4, 
  PRIMITIVE_TRISTRIP:5, PRIMITIVE_TRIFAN:6, SEMANTIC_POSITION:"POSITION", SEMANTIC_NORMAL:"NORMAL", SEMANTIC_TANGENT:"TANGENT", SEMANTIC_BLENDWEIGHT:"BLENDWEIGHT", SEMANTIC_BLENDINDICES:"BLENDINDICES", SEMANTIC_COLOR:"COLOR", SEMANTIC_TEXCOORD0:"TEXCOORD0", SEMANTIC_TEXCOORD1:"TEXCOORD1", SEMANTIC_TEXCOORD2:"TEXCOORD2", SEMANTIC_TEXCOORD3:"TEXCOORD3", SEMANTIC_TEXCOORD4:"TEXCOORD4", SEMANTIC_TEXCOORD5:"TEXCOORD5", SEMANTIC_TEXCOORD6:"TEXCOORD6", SEMANTIC_TEXCOORD7:"TEXCOORD7", SEMANTIC_ATTR0:"ATTR0", 
  SEMANTIC_ATTR1:"ATTR1", SEMANTIC_ATTR2:"ATTR2", SEMANTIC_ATTR3:"ATTR3", SEMANTIC_ATTR4:"ATTR4", SEMANTIC_ATTR5:"ATTR5", SEMANTIC_ATTR6:"ATTR6", SEMANTIC_ATTR7:"ATTR7", SEMANTIC_ATTR8:"ATTR8", SEMANTIC_ATTR9:"ATTR9", SEMANTIC_ATTR10:"ATTR10", SEMANTIC_ATTR11:"ATTR11", SEMANTIC_ATTR12:"ATTR12", SEMANTIC_ATTR13:"ATTR13", SEMANTIC_ATTR14:"ATTR14", SEMANTIC_ATTR15:"ATTR15", SHADERTAG_MATERIAL:1, STENCILOP_KEEP:0, STENCILOP_ZERO:1, STENCILOP_REPLACE:2, STENCILOP_INCREMENT:3, STENCILOP_INCREMENTWRAP:4, 
  STENCILOP_DECREMENT:5, STENCILOP_DECREMENTWRAP:6, STENCILOP_INVERT:7, TEXTURELOCK_READ:1, TEXTURELOCK_WRITE:2, TEXHINT_NONE:0, TEXHINT_SHADOWMAP:1, TEXHINT_ASSET:2, TEXHINT_LIGHTMAP:3, UNIFORMTYPE_BOOL:0, UNIFORMTYPE_INT:1, UNIFORMTYPE_FLOAT:2, UNIFORMTYPE_VEC2:3, UNIFORMTYPE_VEC3:4, UNIFORMTYPE_VEC4:5, UNIFORMTYPE_IVEC2:6, UNIFORMTYPE_IVEC3:7, UNIFORMTYPE_IVEC4:8, UNIFORMTYPE_BVEC2:9, UNIFORMTYPE_BVEC3:10, UNIFORMTYPE_BVEC4:11, UNIFORMTYPE_MAT2:12, UNIFORMTYPE_MAT3:13, UNIFORMTYPE_MAT4:14, UNIFORMTYPE_TEXTURE2D:15, 
  UNIFORMTYPE_TEXTURECUBE:16, UNIFORMTYPE_FLOATARRAY:17, UNIFORMTYPE_TEXTURE2D_SHADOW:18, UNIFORMTYPE_TEXTURECUBE_SHADOW:19, UNIFORMTYPE_TEXTURE3D:20};
  Object.assign(pc, enums);
  pc.gfx = {};
  Object.assign(pc.gfx, enums);
})();
Object.assign(pc, function() {
  var ScopeId = function(name) {
    this.name = name;
    this.value = null;
    this.versionObject = new pc.VersionedObject;
  };
  Object.assign(ScopeId.prototype, {setValue:function(value) {
    this.value = value;
    this.versionObject.increment();
  }, getValue:function(value) {
    return this.value;
  }});
  return {ScopeId:ScopeId};
}());
Object.assign(pc, function() {
  var ScopeSpace = function(name) {
    this.name = name;
    this.variables = {};
    this.namespaces = {};
  };
  Object.assign(ScopeSpace.prototype, {resolve:function(name) {
    if (!this.variables.hasOwnProperty(name)) {
      this.variables[name] = new pc.ScopeId(name);
    }
    return this.variables[name];
  }, getSubSpace:function(name) {
    if (!this.namespaces.hasOwnProperty(name)) {
      this.namespaces[name] = new pc.ScopeSpace(name);
    }
    return this.namespaces[name];
  }});
  return {ScopeSpace:ScopeSpace};
}());
Object.assign(pc, function() {
  var Version = function() {
    this.globalId = 0;
    this.revision = 0;
  };
  Object.assign(Version.prototype, {equals:function(other) {
    return this.globalId === other.globalId && this.revision === other.revision;
  }, notequals:function(other) {
    return this.globalId !== other.globalId || this.revision !== other.revision;
  }, copy:function(other) {
    this.globalId = other.globalId;
    this.revision = other.revision;
  }, reset:function() {
    this.globalId = 0;
    this.revision = 0;
  }});
  return {Version:Version};
}());
Object.assign(pc, function() {
  var idCounter = 0;
  var VersionedObject = function() {
    idCounter++;
    this.version = new pc.Version;
    this.version.globalId = idCounter;
  };
  Object.assign(VersionedObject.prototype, {increment:function() {
    this.version.revision++;
  }});
  return {VersionedObject:VersionedObject};
}());
Object.assign(pc, function() {
  function VertexIteratorAccessor(buffer, vertexElement) {
    this.index = 0;
    switch(vertexElement.dataType) {
      case pc.TYPE_INT8:
        this.array = new Int8Array(buffer, vertexElement.offset);
        break;
      case pc.TYPE_UINT8:
        this.array = new Uint8Array(buffer, vertexElement.offset);
        break;
      case pc.TYPE_INT16:
        this.array = new Int16Array(buffer, vertexElement.offset);
        break;
      case pc.TYPE_UINT16:
        this.array = new Uint16Array(buffer, vertexElement.offset);
        break;
      case pc.TYPE_INT32:
        this.array = new Int32Array(buffer, vertexElement.offset);
        break;
      case pc.TYPE_UINT32:
        this.array = new Uint32Array(buffer, vertexElement.offset);
        break;
      case pc.TYPE_FLOAT32:
        this.array = new Float32Array(buffer, vertexElement.offset);
        break;
    }
    switch(vertexElement.numComponents) {
      case 1:
        this.set = VertexIteratorAccessor_set1;
        break;
      case 2:
        this.set = VertexIteratorAccessor_set2;
        break;
      case 3:
        this.set = VertexIteratorAccessor_set3;
        break;
      case 4:
        this.set = VertexIteratorAccessor_set4;
        break;
    }
  }
  VertexIteratorAccessor.prototype.get = function(offset) {
    return this.array[this.index + offset];
  };
  function VertexIteratorAccessor_set1(a) {
    this.array[this.index] = a;
  }
  function VertexIteratorAccessor_set2(a, b) {
    this.array[this.index] = a;
    this.array[this.index + 1] = b;
  }
  function VertexIteratorAccessor_set3(a, b, c) {
    this.array[this.index] = a;
    this.array[this.index + 1] = b;
    this.array[this.index + 2] = c;
  }
  function VertexIteratorAccessor_set4(a, b, c, d) {
    this.array[this.index] = a;
    this.array[this.index + 1] = b;
    this.array[this.index + 2] = c;
    this.array[this.index + 3] = d;
  }
  function VertexIterator(vertexBuffer) {
    this.vertexBuffer = vertexBuffer;
    this.buffer = this.vertexBuffer.lock();
    this.accessors = [];
    this.element = {};
    var vertexFormat = this.vertexBuffer.getFormat();
    for (var i = 0; i < vertexFormat.elements.length; i++) {
      var vertexElement = vertexFormat.elements[i];
      this.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement);
      this.element[vertexElement.name] = this.accessors[i];
    }
  }
  Object.assign(VertexIterator.prototype, {next:function(count) {
    if (count === undefined) {
      count = 1;
    }
    var i = 0;
    var accessors = this.accessors;
    var numAccessors = this.accessors.length;
    var vertexFormat = this.vertexBuffer.getFormat();
    while (i < numAccessors) {
      var accessor = accessors[i++];
      accessor.index += count * vertexFormat.size / accessor.array.constructor.BYTES_PER_ELEMENT;
    }
  }, end:function() {
    this.vertexBuffer.unlock();
  }});
  return {VertexIterator:VertexIterator};
}());
Object.assign(pc, function() {
  var _typeSize = [];
  _typeSize[pc.TYPE_INT8] = 1;
  _typeSize[pc.TYPE_UINT8] = 1;
  _typeSize[pc.TYPE_INT16] = 2;
  _typeSize[pc.TYPE_UINT16] = 2;
  _typeSize[pc.TYPE_INT32] = 4;
  _typeSize[pc.TYPE_UINT32] = 4;
  _typeSize[pc.TYPE_FLOAT32] = 4;
  var VertexFormat = function(graphicsDevice, description) {
    var i, len, element;
    this.elements = [];
    this.hasUv0 = false;
    this.hasUv1 = false;
    this.hasColor = false;
    this.hasTangents = false;
    this.size = 0;
    for (i = 0, len = description.length; i < len; i++) {
      var elementDesc = description[i];
      element = {name:elementDesc.semantic, offset:0, stride:0, stream:-1, scopeId:graphicsDevice.scope.resolve(elementDesc.semantic), dataType:elementDesc.type, numComponents:elementDesc.components, normalize:elementDesc.normalize === undefined ? false : elementDesc.normalize, size:elementDesc.components * _typeSize[elementDesc.type]};
      this.elements.push(element);
      this.size += Math.ceil(element.size / 4) * 4;
      if (elementDesc.semantic === pc.SEMANTIC_TEXCOORD0) {
        this.hasUv0 = true;
      } else {
        if (elementDesc.semantic === pc.SEMANTIC_TEXCOORD1) {
          this.hasUv1 = true;
        } else {
          if (elementDesc.semantic === pc.SEMANTIC_COLOR) {
            this.hasColor = true;
          } else {
            if (elementDesc.semantic === pc.SEMANTIC_TANGENT) {
              this.hasTangents = true;
            }
          }
        }
      }
    }
    var offset = 0;
    for (i = 0, len = this.elements.length; i < len; i++) {
      element = this.elements[i];
      element.offset = offset;
      element.stride = this.size;
      offset += element.size;
    }
  };
  return {VertexFormat:VertexFormat};
}());
Object.assign(pc, function() {
  var VertexBuffer = function(graphicsDevice, format, numVertices, usage, initialData) {
    this.usage = usage || pc.BUFFER_STATIC;
    this.format = format;
    this.numVertices = numVertices;
    this.numBytes = format.size * numVertices;
    graphicsDevice._vram.vb += this.numBytes;
    this.device = graphicsDevice;
    if (initialData) {
      this.setData(initialData);
    } else {
      this.storage = new ArrayBuffer(this.numBytes);
    }
    this.device.buffers.push(this);
  };
  Object.assign(VertexBuffer.prototype, {destroy:function() {
    var device = this.device;
    var idx = device.buffers.indexOf(this);
    if (idx !== -1) {
      device.buffers.splice(idx, 1);
    }
    if (this.bufferId) {
      var gl = device.gl;
      gl.deleteBuffer(this.bufferId);
      device._vram.vb -= this.storage.byteLength;
      this.bufferId = null;
      device.boundBuffer = null;
      device.vertexBuffers.length = 0;
      device.vbOffsets.length = 0;
      device.attributesInvalidated = true;
      for (var loc in device.enabledAttributes) {
        gl.disableVertexAttribArray(loc);
      }
      device.enabledAttributes = {};
    }
  }, getFormat:function() {
    return this.format;
  }, getUsage:function() {
    return this.usage;
  }, getNumVertices:function() {
    return this.numVertices;
  }, lock:function() {
    return this.storage;
  }, unlock:function() {
    var gl = this.device.gl;
    if (!this.bufferId) {
      this.bufferId = gl.createBuffer();
    }
    var glUsage;
    switch(this.usage) {
      case pc.BUFFER_STATIC:
        glUsage = gl.STATIC_DRAW;
        break;
      case pc.BUFFER_DYNAMIC:
        glUsage = gl.DYNAMIC_DRAW;
        break;
      case pc.BUFFER_STREAM:
        glUsage = gl.STREAM_DRAW;
        break;
      case pc.BUFFER_GPUDYNAMIC:
        if (this.device.webgl2) {
          glUsage = gl.DYNAMIC_COPY;
        } else {
          glUsage = gl.STATIC_DRAW;
        }
        break;
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, this.bufferId);
    gl.bufferData(gl.ARRAY_BUFFER, this.storage, glUsage);
  }, setData:function(data) {
    if (data.byteLength !== this.numBytes) {
      console.error("VertexBuffer: wrong initial data size: expected " + this.numBytes + ", got " + data.byteLength);
      return false;
    }
    this.storage = data;
    this.unlock();
    return true;
  }});
  return {VertexBuffer:VertexBuffer};
}());
Object.assign(pc, function() {
  var IndexBuffer = function(graphicsDevice, format, numIndices, usage, initialData) {
    this.usage = usage || pc.BUFFER_STATIC;
    this.format = format;
    this.numIndices = numIndices;
    this.device = graphicsDevice;
    var gl = this.device.gl;
    var bytesPerIndex;
    if (format === pc.INDEXFORMAT_UINT8) {
      bytesPerIndex = 1;
      this.glFormat = gl.UNSIGNED_BYTE;
    } else {
      if (format === pc.INDEXFORMAT_UINT16) {
        bytesPerIndex = 2;
        this.glFormat = gl.UNSIGNED_SHORT;
      } else {
        if (format === pc.INDEXFORMAT_UINT32) {
          bytesPerIndex = 4;
          this.glFormat = gl.UNSIGNED_INT;
        }
      }
    }
    this.bytesPerIndex = bytesPerIndex;
    this.numBytes = this.numIndices * bytesPerIndex;
    if (initialData) {
      this.setData(initialData);
    } else {
      this.storage = new ArrayBuffer(this.numBytes);
    }
    graphicsDevice._vram.ib += this.numBytes;
    this.device.buffers.push(this);
  };
  Object.assign(IndexBuffer.prototype, {destroy:function() {
    var device = this.device;
    var idx = device.buffers.indexOf(this);
    if (idx !== -1) {
      device.buffers.splice(idx, 1);
    }
    if (this.bufferId) {
      var gl = this.device.gl;
      gl.deleteBuffer(this.bufferId);
      this.device._vram.ib -= this.storage.byteLength;
      this.bufferId = null;
      if (this.device.indexBuffer === this) {
        this.device.indexBuffer = null;
      }
    }
  }, getFormat:function() {
    return this.format;
  }, getNumIndices:function() {
    return this.numIndices;
  }, lock:function() {
    return this.storage;
  }, unlock:function() {
    var gl = this.device.gl;
    if (!this.bufferId) {
      this.bufferId = gl.createBuffer();
    }
    var glUsage;
    switch(this.usage) {
      case pc.BUFFER_STATIC:
        glUsage = gl.STATIC_DRAW;
        break;
      case pc.BUFFER_DYNAMIC:
        glUsage = gl.DYNAMIC_DRAW;
        break;
      case pc.BUFFER_STREAM:
        glUsage = gl.STREAM_DRAW;
        break;
      case pc.BUFFER_GPUDYNAMIC:
        if (this.device.webgl2) {
          glUsage = gl.DYNAMIC_COPY;
        } else {
          glUsage = gl.STATIC_DRAW;
        }
        break;
    }
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufferId);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.storage, glUsage);
  }, setData:function(data) {
    if (data.byteLength !== this.numBytes) {
      console.error("IndexBuffer: wrong initial data size: expected " + this.numBytes + ", got " + data.byteLength);
      return false;
    }
    this.storage = data;
    this.unlock();
    return true;
  }});
  return {IndexBuffer:IndexBuffer};
}());
Object.assign(pc, function() {
  var TransformFeedback = function(inputBuffer, usage) {
    usage = usage || pc.BUFFER_GPUDYNAMIC;
    this.device = inputBuffer.device;
    var gl = this.device.gl;
    this._inputBuffer = inputBuffer;
    if (usage === pc.BUFFER_GPUDYNAMIC && inputBuffer.usage !== usage) {
      gl.bindBuffer(gl.ARRAY_BUFFER, inputBuffer.bufferId);
      gl.bufferData(gl.ARRAY_BUFFER, inputBuffer.storage, gl.DYNAMIC_COPY);
    }
    this._outputBuffer = new pc.VertexBuffer(inputBuffer.device, inputBuffer.format, inputBuffer.numVertices, usage, inputBuffer.storage);
  };
  TransformFeedback.createShader = function(graphicsDevice, vsCode, name) {
    return pc.shaderChunks.createShaderFromCode(graphicsDevice, vsCode, null, name, true);
  };
  Object.assign(TransformFeedback.prototype, {destroy:function() {
    this._outputBuffer.destroy();
  }, process:function(shader, swap) {
    if (swap === undefined) {
      swap = true;
    }
    var device = this.device;
    device.setRenderTarget(null);
    device.updateBegin();
    device.setVertexBuffer(this._inputBuffer, 0);
    device.setRaster(false);
    device.setTransformFeedbackBuffer(this._outputBuffer);
    device.setShader(shader);
    device.draw({type:pc.PRIMITIVE_POINTS, base:0, count:this._inputBuffer.numVertices, indexed:false});
    device.setTransformFeedbackBuffer(null);
    device.setRaster(true);
    device.updateEnd();
    if (swap) {
      var tmp = this._inputBuffer.bufferId;
      this._inputBuffer.bufferId = this._outputBuffer.bufferId;
      this._outputBuffer.bufferId = tmp;
    }
  }});
  Object.defineProperty(TransformFeedback.prototype, "inputBuffer", {get:function() {
    return this._inputBuffer;
  }});
  Object.defineProperty(TransformFeedback.prototype, "outputBuffer", {get:function() {
    return this._outputBuffer;
  }});
  return {TransformFeedback:TransformFeedback};
}());
Object.assign(pc, function() {
  var Texture = function(graphicsDevice, options) {
    this.device = graphicsDevice;
    this.name = null;
    this._width = 4;
    this._height = 4;
    this._depth = 1;
    this._pot = true;
    this._format = pc.PIXELFORMAT_R8_G8_B8_A8;
    this.rgbm = false;
    this._cubemap = false;
    this._volume = false;
    this.fixCubemapSeams = false;
    this._flipY = true;
    this._premultiplyAlpha = false;
    this._mipmaps = true;
    this._minFilter = pc.FILTER_LINEAR_MIPMAP_LINEAR;
    this._magFilter = pc.FILTER_LINEAR;
    this._anisotropy = 1;
    this._addressU = pc.ADDRESS_REPEAT;
    this._addressV = pc.ADDRESS_REPEAT;
    this._addressW = pc.ADDRESS_REPEAT;
    this._compareOnRead = false;
    this._compareFunc = pc.FUNC_LESS;
    if (options !== undefined) {
      this._width = options.width !== undefined ? options.width : this._width;
      this._height = options.height !== undefined ? options.height : this._height;
      this._pot = pc.math.powerOfTwo(this._width) && pc.math.powerOfTwo(this._height);
      this._format = options.format !== undefined ? options.format : this._format;
      this.rgbm = options.rgbm !== undefined ? options.rgbm : this.rgbm;
      if (options.mipmaps !== undefined) {
        this._mipmaps = options.mipmaps;
      } else {
        this._mipmaps = options.autoMipmap !== undefined ? options.autoMipmap : this._mipmaps;
      }
      this._levels = options.levels;
      this._cubemap = options.cubemap !== undefined ? options.cubemap : this._cubemap;
      this.fixCubemapSeams = options.fixCubemapSeams !== undefined ? options.fixCubemapSeams : this.fixCubemapSeams;
      this._minFilter = options.minFilter !== undefined ? options.minFilter : this._minFilter;
      this._magFilter = options.magFilter !== undefined ? options.magFilter : this._magFilter;
      this._anisotropy = options.anisotropy !== undefined ? options.anisotropy : this._anisotropy;
      this._addressU = options.addressU !== undefined ? options.addressU : this._addressU;
      this._addressV = options.addressV !== undefined ? options.addressV : this._addressV;
      this._compareOnRead = options.compareOnRead !== undefined ? options.compareOnRead : this._compareOnRead;
      this._compareFunc = options._compareFunc !== undefined ? options._compareFunc : this._compareFunc;
      this._flipY = options.flipY !== undefined ? options.flipY : this._flipY;
      this._premultiplyAlpha = options.premultiplyAlpha !== undefined ? options.premultiplyAlpha : this._premultiplyAlpha;
      if (graphicsDevice.webgl2) {
        this._depth = options.depth !== undefined ? options.depth : this._depth;
        this._volume = options.volume !== undefined ? options.volume : this._volume;
        this._addressW = options.addressW !== undefined ? options.addressW : this._addressW;
      }
    }
    this._compressed = this._format === pc.PIXELFORMAT_DXT1 || this._format === pc.PIXELFORMAT_DXT3 || this._format === pc.PIXELFORMAT_DXT5 || this._format >= pc.PIXELFORMAT_ETC1;
    this._invalid = false;
    this._lockedLevel = -1;
    if (!this._levels) {
      this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];
    }
    this.dirtyAll();
    this._gpuSize = 0;
  };
  Object.defineProperty(Texture.prototype, "minFilter", {get:function() {
    return this._minFilter;
  }, set:function(v) {
    if (this._minFilter !== v) {
      this._minFilter = v;
      this._parameterFlags |= 1;
    }
  }});
  Object.defineProperty(Texture.prototype, "magFilter", {get:function() {
    return this._magFilter;
  }, set:function(v) {
    if (this._magFilter !== v) {
      this._magFilter = v;
      this._parameterFlags |= 2;
    }
  }});
  Object.defineProperty(Texture.prototype, "addressU", {get:function() {
    return this._addressU;
  }, set:function(v) {
    if (this._addressU !== v) {
      this._addressU = v;
      this._parameterFlags |= 4;
    }
  }});
  Object.defineProperty(Texture.prototype, "addressV", {get:function() {
    return this._addressV;
  }, set:function(v) {
    if (this._addressV !== v) {
      this._addressV = v;
      this._parameterFlags |= 8;
    }
  }});
  Object.defineProperty(Texture.prototype, "addressW", {get:function() {
    return this._addressW;
  }, set:function(addressW) {
    if (!this.device.webgl2) {
      return;
    }
    if (!this._volume) {
      return;
    }
    if (addressW !== this._addressW) {
      this._addressW = addressW;
      this._parameterFlags |= 16;
    }
  }});
  Object.defineProperty(Texture.prototype, "compareOnRead", {get:function() {
    return this._compareOnRead;
  }, set:function(v) {
    if (this._compareOnRead !== v) {
      this._compareOnRead = v;
      this._parameterFlags |= 32;
    }
  }});
  Object.defineProperty(Texture.prototype, "compareFunc", {get:function() {
    return this._compareFunc;
  }, set:function(v) {
    if (this._compareFunc !== v) {
      this._compareFunc = v;
      this._parameterFlags |= 64;
    }
  }});
  Object.defineProperty(Texture.prototype, "anisotropy", {get:function() {
    return this._anisotropy;
  }, set:function(v) {
    if (this._anisotropy !== v) {
      this._anisotropy = v;
      this._parameterFlags |= 128;
    }
  }});
  Object.defineProperty(Texture.prototype, "autoMipmap", {get:function() {
    return this._mipmaps;
  }, set:function(v) {
    this._mipmaps = v;
  }});
  Object.defineProperty(Texture.prototype, "mipmaps", {get:function() {
    return this._mipmaps;
  }, set:function(v) {
    if (this._mipmaps !== v) {
      this._mipmaps = v;
      this._minFilterDirty = true;
      if (v) {
        this._needsMipmapsUpload = true;
      }
    }
  }});
  Object.defineProperty(Texture.prototype, "width", {get:function() {
    return this._width;
  }});
  Object.defineProperty(Texture.prototype, "height", {get:function() {
    return this._height;
  }});
  Object.defineProperty(Texture.prototype, "depth", {get:function() {
    return this._depth;
  }});
  Object.defineProperty(Texture.prototype, "format", {get:function() {
    return this._format;
  }});
  Object.defineProperty(Texture.prototype, "cubemap", {get:function() {
    return this._cubemap;
  }});
  var _pixelFormat2Size = null;
  Object.defineProperty(Texture.prototype, "gpuSize", {get:function() {
    if (!_pixelFormat2Size) {
      _pixelFormat2Size = [];
      _pixelFormat2Size[pc.PIXELFORMAT_A8] = 1;
      _pixelFormat2Size[pc.PIXELFORMAT_L8] = 1;
      _pixelFormat2Size[pc.PIXELFORMAT_L8_A8] = 1;
      _pixelFormat2Size[pc.PIXELFORMAT_R5_G6_B5] = 2;
      _pixelFormat2Size[pc.PIXELFORMAT_R5_G5_B5_A1] = 2;
      _pixelFormat2Size[pc.PIXELFORMAT_R4_G4_B4_A4] = 2;
      _pixelFormat2Size[pc.PIXELFORMAT_R8_G8_B8] = 4;
      _pixelFormat2Size[pc.PIXELFORMAT_R8_G8_B8_A8] = 4;
      _pixelFormat2Size[pc.PIXELFORMAT_RGB16F] = 8;
      _pixelFormat2Size[pc.PIXELFORMAT_RGBA16F] = 8;
      _pixelFormat2Size[pc.PIXELFORMAT_RGB32F] = 16;
      _pixelFormat2Size[pc.PIXELFORMAT_RGBA32F] = 16;
      _pixelFormat2Size[pc.PIXELFORMAT_R32F] = 4;
      _pixelFormat2Size[pc.PIXELFORMAT_DEPTH] = 4;
      _pixelFormat2Size[pc.PIXELFORMAT_DEPTHSTENCIL] = 4;
      _pixelFormat2Size[pc.PIXELFORMAT_111110F] = 4;
      _pixelFormat2Size[pc.PIXELFORMAT_SRGB] = 4;
      _pixelFormat2Size[pc.PIXELFORMAT_SRGBA] = 4;
    }
    var mips = 1;
    if (this._pot && (this._mipmaps || this._minFilter === pc.FILTER_NEAREST_MIPMAP_NEAREST || this._minFilter === pc.FILTER_NEAREST_MIPMAP_LINEAR || this._minFilter === pc.FILTER_LINEAR_MIPMAP_NEAREST || this._minFilter === pc.FILTER_LINEAR_MIPMAP_LINEAR) && !(this._compressed && this._levels.length === 1)) {
      mips = Math.round(Math.log2(Math.max(this._width, this._height)) + 1);
    }
    var mipWidth = this._width;
    var mipHeight = this._height;
    var mipDepth = this._depth;
    var size = 0;
    for (var i = 0; i < mips; i++) {
      if (!this._compressed) {
        size += mipWidth * mipHeight * mipDepth * _pixelFormat2Size[this._format];
      } else {
        if (this._format === pc.PIXELFORMAT_ETC1) {
          size += Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8 * mipDepth;
        } else {
          if (this._format === pc.PIXELFORMAT_PVRTC_2BPP_RGB_1 || this._format === pc.PIXELFORMAT_PVRTC_2BPP_RGBA_1) {
            size += Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4 * mipDepth;
          } else {
            if (this._format === pc.PIXELFORMAT_PVRTC_4BPP_RGB_1 || this._format === pc.PIXELFORMAT_PVRTC_4BPP_RGBA_1) {
              size += Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2 * mipDepth;
            } else {
              var DXT_BLOCK_WIDTH = 4;
              var DXT_BLOCK_HEIGHT = 4;
              var blockSize = this._format === pc.PIXELFORMAT_DXT1 ? 8 : 16;
              var numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);
              var numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);
              var numBlocks = numBlocksAcross * numBlocksDown;
              size += numBlocks * blockSize * mipDepth;
            }
          }
        }
      }
      mipWidth = Math.max(mipWidth * 0.5, 1);
      mipHeight = Math.max(mipHeight * 0.5, 1);
      mipDepth = Math.max(mipDepth * 0.5, 1);
    }
    if (this._cubemap) {
      size *= 6;
    }
    return size;
  }});
  Object.defineProperty(Texture.prototype, "volume", {get:function() {
    return this._volume;
  }});
  Object.defineProperty(Texture.prototype, "flipY", {get:function() {
    return this._flipY;
  }, set:function(flipY) {
    if (this._flipY !== flipY) {
      this._flipY = flipY;
      this._needsUpload = true;
    }
  }});
  Object.defineProperty(Texture.prototype, "premultiplyAlpha", {get:function() {
    return this._premultiplyAlpha;
  }, set:function(premultiplyAlpha) {
    if (this._premultiplyAlpha !== premultiplyAlpha) {
      this._premultiplyAlpha = premultiplyAlpha;
      this._needsUpload = true;
    }
  }});
  Object.assign(Texture.prototype, {destroy:function() {
    if (this.device) {
      this.device.destroyTexture(this);
    }
    this.device = null;
    this._levels = null;
  }, dirtyAll:function() {
    this._levelsUpdated = this._cubemap ? [[true, true, true, true, true, true]] : [true];
    this._needsUpload = true;
    this._needsMipmapsUpload = this._mipmaps;
    this._mipmapsUploaded = false;
    this._parameterFlags = 255;
  }, lock:function(options) {
    options = options || {level:0, face:0, mode:pc.TEXTURELOCK_WRITE};
    if (options.level === undefined) {
      options.level = 0;
    }
    if (options.face === undefined) {
      options.face = 0;
    }
    if (options.mode === undefined) {
      options.mode = pc.TEXTURELOCK_WRITE;
    }
    this._lockedLevel = options.level;
    if (this._levels[options.level] === null) {
      switch(this._format) {
        case pc.PIXELFORMAT_A8:
        case pc.PIXELFORMAT_L8:
          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth);
          break;
        case pc.PIXELFORMAT_L8_A8:
          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 2);
          break;
        case pc.PIXELFORMAT_R5_G6_B5:
        case pc.PIXELFORMAT_R5_G5_B5_A1:
        case pc.PIXELFORMAT_R4_G4_B4_A4:
          this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth);
          break;
        case pc.PIXELFORMAT_R8_G8_B8:
          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 3);
          break;
        case pc.PIXELFORMAT_R8_G8_B8_A8:
          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 4);
          break;
        case pc.PIXELFORMAT_DXT1:
          this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 8 * this._depth);
          break;
        case pc.PIXELFORMAT_DXT3:
        case pc.PIXELFORMAT_DXT5:
          this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 16 * this._depth);
          break;
        case pc.PIXELFORMAT_RGB16F:
          this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 3);
          break;
        case pc.PIXELFORMAT_RGB32F:
          this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 3);
          break;
        case pc.PIXELFORMAT_RGBA16F:
          this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 4);
          break;
        case pc.PIXELFORMAT_RGBA32F:
          this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 4);
          break;
      }
    }
    return this._levels[options.level];
  }, setSource:function(source) {
    var i;
    var invalid = false;
    var width, height;
    if (this._cubemap) {
      if (source[0]) {
        width = source[0].width || 0;
        height = source[0].height || 0;
        for (i = 0; i < 6; i++) {
          if (!source[i] || source[i].width !== width || source[i].height !== height || !(source[i] instanceof HTMLImageElement) && !(source[i] instanceof HTMLCanvasElement) && !(source[i] instanceof HTMLVideoElement)) {
            invalid = true;
            break;
          }
        }
      } else {
        invalid = true;
      }
      if (!invalid) {
        for (i = 0; i < 6; i++) {
          if (this._levels[0][i] !== source[i]) {
            this._levelsUpdated[0][i] = true;
          }
        }
      }
    } else {
      if (!(source instanceof HTMLImageElement) && !(source instanceof HTMLCanvasElement) && !(source instanceof HTMLVideoElement)) {
        invalid = true;
      }
      if (!invalid) {
        if (source !== this._levels[0]) {
          this._levelsUpdated[0] = true;
        }
        width = source.width;
        height = source.height;
      }
    }
    if (invalid) {
      this._width = 4;
      this._height = 4;
      this._pot = true;
      if (this._cubemap) {
        for (i = 0; i < 6; i++) {
          this._levels[0][i] = null;
          this._levelsUpdated[0][i] = true;
        }
      } else {
        this._levels[0] = null;
        this._levelsUpdated[0] = true;
      }
    } else {
      this._width = width;
      this._height = height;
      this._pot = pc.math.powerOfTwo(this._width) && pc.math.powerOfTwo(this._height);
      this._levels[0] = source;
    }
    if (this._invalid !== invalid || !invalid) {
      this._invalid = invalid;
      this.upload();
    }
  }, getSource:function() {
    return this._levels[0];
  }, unlock:function() {
    this.upload();
    this._lockedLevel = -1;
  }, upload:function() {
    this._needsUpload = true;
    this._needsMipmapsUpload = this._mipmaps;
  }, getDds:function() {
    if (this.format !== pc.PIXELFORMAT_R8_G8_B8_A8) {
      console.error("This format is not implemented yet");
    }
    var fsize = 128;
    var i = 0;
    var j;
    var face;
    while (this._levels[i]) {
      var mipSize;
      if (!this.cubemap) {
        mipSize = this._levels[i].length;
        if (!mipSize) {
          console.error("No byte array for mip " + i);
          return;
        }
        fsize += mipSize;
      } else {
        for (face = 0; face < 6; face++) {
          if (!this._levels[i][face]) {
            console.error("No level data for mip " + i + ", face " + face);
            return;
          }
          mipSize = this._levels[i][face].length;
          if (!mipSize) {
            console.error("No byte array for mip " + i + ", face " + face);
            return;
          }
          fsize += mipSize;
        }
      }
      fsize += this._levels[i].length;
      i++;
    }
    var buff = new ArrayBuffer(fsize);
    var header = new Uint32Array(buff, 0, 128 / 4);
    var DDS_MAGIC = 542327876;
    var DDS_HEADER_SIZE = 124;
    var DDS_FLAGS_REQUIRED = 1 | 2 | 4 | 4096 | 524288;
    var DDS_FLAGS_MIPMAP = 131072;
    var DDS_PIXELFORMAT_SIZE = 32;
    var DDS_PIXELFLAGS_RGBA8 = 1 | 64;
    var DDS_CAPS_REQUIRED = 4096;
    var DDS_CAPS_MIPMAP = 4194304;
    var DDS_CAPS_COMPLEX = 8;
    var DDS_CAPS2_CUBEMAP = 512 | 1024 | 2048 | 4096 | 8192 | 16384 | 32768;
    var flags = DDS_FLAGS_REQUIRED;
    if (this._levels.length > 1) {
      flags |= DDS_FLAGS_MIPMAP;
    }
    var caps = DDS_CAPS_REQUIRED;
    if (this._levels.length > 1) {
      caps |= DDS_CAPS_MIPMAP;
    }
    if (this._levels.length > 1 || this.cubemap) {
      caps |= DDS_CAPS_COMPLEX;
    }
    var caps2 = this.cubemap ? DDS_CAPS2_CUBEMAP : 0;
    header[0] = DDS_MAGIC;
    header[1] = DDS_HEADER_SIZE;
    header[2] = flags;
    header[3] = this.height;
    header[4] = this.width;
    header[5] = this.width * this.height * 4;
    header[6] = 0;
    header[7] = this._levels.length;
    for (i = 0; i < 11; i++) {
      header[8 + i] = 0;
    }
    header[19] = DDS_PIXELFORMAT_SIZE;
    header[20] = DDS_PIXELFLAGS_RGBA8;
    header[21] = 0;
    header[22] = 32;
    header[23] = 16711680;
    header[24] = 65280;
    header[25] = 255;
    header[26] = 4278190080;
    header[27] = caps;
    header[28] = caps2;
    header[29] = 0;
    header[30] = 0;
    header[31] = 0;
    var offset = 128;
    var level, mip;
    if (!this.cubemap) {
      for (i = 0; i < this._levels.length; i++) {
        level = this._levels[i];
        mip = new Uint8Array(buff, offset, level.length);
        for (j = 0; j < level.length; j++) {
          mip[j] = level[j];
        }
        offset += level.length;
      }
    } else {
      for (face = 0; face < 6; face++) {
        for (i = 0; i < this._levels.length; i++) {
          level = this._levels[i][face];
          mip = new Uint8Array(buff, offset, level.length);
          for (j = 0; j < level.length; j++) {
            mip[j] = level[j];
          }
          offset += level.length;
        }
      }
    }
    return buff;
  }});
  return {Texture:Texture};
}());
Object.assign(pc, function() {
  var defaultOptions = {depth:true, face:0};
  var RenderTarget = function(options) {
    var _arg2 = arguments[1];
    var _arg3 = arguments[2];
    if (options instanceof pc.GraphicsDevice) {
      this._colorBuffer = _arg2;
      options = _arg3;
    } else {
      this._colorBuffer = options.colorBuffer;
    }
    this._glFrameBuffer = null;
    this._glDepthBuffer = null;
    options = options !== undefined ? options : defaultOptions;
    this._depthBuffer = options.depthBuffer;
    this._face = options.face !== undefined ? options.face : 0;
    if (this._depthBuffer) {
      var format = this._depthBuffer._format;
      if (format === pc.PIXELFORMAT_DEPTH) {
        this._depth = true;
        this._stencil = false;
      } else {
        if (format === pc.PIXELFORMAT_DEPTHSTENCIL) {
          this._depth = true;
          this._stencil = true;
        } else {
          this._depth = false;
          this._stencil = false;
        }
      }
    } else {
      this._depth = options.depth !== undefined ? options.depth : true;
      this._stencil = options.stencil !== undefined ? options.stencil : false;
    }
    this._samples = options.samples !== undefined ? options.samples : 1;
    this.autoResolve = options.autoResolve !== undefined ? options.autoResolve : true;
    this._glResolveFrameBuffer = null;
    this._glMsaaColorBuffer = null;
    this._glMsaaDepthBuffer = null;
  };
  Object.assign(RenderTarget.prototype, {destroy:function() {
    if (!this._device) {
      return;
    }
    var device = this._device;
    var idx = device.targets.indexOf(this);
    if (idx !== -1) {
      device.targets.splice(idx, 1);
    }
    var gl = device.gl;
    if (this._glFrameBuffer) {
      gl.deleteFramebuffer(this._glFrameBuffer);
      this._glFrameBuffer = null;
    }
    if (this._glDepthBuffer) {
      gl.deleteRenderbuffer(this._glDepthBuffer);
      this._glDepthBuffer = null;
    }
    if (this._glResolveFrameBuffer) {
      gl.deleteFramebuffer(this._glResolveFrameBuffer);
      this._glResolveFrameBuffer = null;
    }
    if (this._glMsaaColorBuffer) {
      gl.deleteRenderbuffer(this._glMsaaColorBuffer);
      this._glMsaaColorBuffer = null;
    }
    if (this._glMsaaDepthBuffer) {
      gl.deleteRenderbuffer(this._glMsaaDepthBuffer);
      this._glMsaaDepthBuffer = null;
    }
  }, resolve:function(color, depth) {
    if (!this._device) {
      return;
    }
    if (!this._device.webgl2) {
      return;
    }
    var gl = this._device.gl;
    if (color === undefined) {
      color = true;
    }
    if (depth === undefined && this._depthBuffer) {
      depth = true;
    }
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._glFrameBuffer);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._glResolveFrameBuffer);
    gl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
  }, copy:function(source, color, depth) {
    if (!this._device) {
      if (source._device) {
        this._device = source._device;
      } else {
        return false;
      }
    }
    return this._device.copyRenderTarget(source, this, color, depth);
  }});
  Object.defineProperty(RenderTarget.prototype, "colorBuffer", {get:function() {
    return this._colorBuffer;
  }});
  Object.defineProperty(RenderTarget.prototype, "depthBuffer", {get:function() {
    return this._depthBuffer;
  }});
  Object.defineProperty(RenderTarget.prototype, "face", {get:function() {
    return this._face;
  }});
  Object.defineProperty(RenderTarget.prototype, "width", {get:function() {
    return this._colorBuffer ? this._colorBuffer.width : this._depthBuffer.width;
  }});
  Object.defineProperty(RenderTarget.prototype, "height", {get:function() {
    return this._colorBuffer ? this._colorBuffer.height : this._depthBuffer.height;
  }});
  return {RenderTarget:RenderTarget};
}());
Object.assign(pc, function() {
  var ShaderInput = function(graphicsDevice, name, type, locationId) {
    this.locationId = locationId;
    this.scopeId = graphicsDevice.scope.resolve(name);
    this.version = new pc.Version;
    if (type === pc.UNIFORMTYPE_FLOAT) {
      if (name.substr(name.length - 3) === "[0]") {
        type = pc.UNIFORMTYPE_FLOATARRAY;
      }
    }
    this.dataType = type;
    this.value = [null, null, null, null];
    this.array = [];
  };
  return {ShaderInput:ShaderInput};
}());
Object.assign(pc, function() {
  var Shader = function(graphicsDevice, definition) {
    this.device = graphicsDevice;
    this.definition = definition;
    this.attributes = [];
    this.uniforms = [];
    this.samplers = [];
    this.ready = false;
    this.device.createShader(this);
  };
  Object.assign(Shader.prototype, {destroy:function() {
    this.device.destroyShader(this);
  }});
  return {Shader:Shader};
}());
Object.assign(pc, function() {
  var ProgramLibrary = function(device) {
    this._device = device;
    this._cache = {};
    this._generators = {};
    this._isClearingCache = false;
    this._precached = false;
    this._programsCollection = [];
    this._defaultStdMatOption = {};
    this._defaultStdMatOptionMin = {};
    var m = new pc.StandardMaterial;
    m.shaderOptBuilder.updateRef(this._defaultStdMatOption, device, {}, m, null, [], pc.SHADER_FORWARD, null, null);
    m.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, device, {}, m, null, [], pc.SHADER_SHADOW, null, null);
  };
  ProgramLibrary.prototype.register = function(name, generator) {
    if (!this.isRegistered(name)) {
      this._generators[name] = generator;
    }
  };
  ProgramLibrary.prototype.unregister = function(name) {
    if (this.isRegistered(name)) {
      delete this._generators[name];
    }
  };
  ProgramLibrary.prototype.isRegistered = function(name) {
    var generator = this._generators[name];
    return generator !== undefined;
  };
  ProgramLibrary.prototype.getProgram = function(name, options) {
    var generator = this._generators[name];
    if (generator === undefined) {
      return null;
    }
    var gd = this._device;
    var key = generator.generateKey(options);
    var shader = this._cache[key];
    if (!shader) {
      var lights;
      if (options.lights) {
        lights = options.lights;
        options.lights = lights.map(function(l) {
          var lcopy = l.clone ? l.clone() : l;
          lcopy.key = l.key;
          return lcopy;
        });
      }
      this.storeNewProgram(name, options);
      if (options.lights) {
        options.lights = lights;
      }
      if (this._precached) {
        console.warn("ProgramLibrary#getProgram: Cache miss for shader", name, "key", key, "after shaders precaching");
      }
      var shaderDefinition = generator.createShaderDefinition(gd, options);
      shader = this._cache[key] = new pc.Shader(gd, shaderDefinition);
    }
    return shader;
  };
  ProgramLibrary.prototype.storeNewProgram = function(name, options) {
    var opt = {};
    if (name === "standard") {
      var defaultMat = this._getDefaultStdMatOptions(options.pass);
      for (var p in options) {
        if (options.hasOwnProperty(p) && defaultMat[p] !== options[p] || p === "pass") {
          opt[p] = options[p];
        }
      }
    } else {
      opt = options;
    }
    this._programsCollection.push(JSON.stringify({name:name, options:opt}));
  };
  ProgramLibrary.prototype.dumpPrograms = function() {
    var text = "var device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n";
    text += "var shaders = [";
    if (this._programsCollection[0]) {
      text += "\n\t" + this._programsCollection[0];
    }
    for (var i = 1; i < this._programsCollection.length; ++i) {
      text += ",\n\t" + this._programsCollection[i];
    }
    text += "\n];\n";
    text += "device.programLib.precompile(shaders);\n";
    text += 'if (pc.version != "' + pc.version + '" || pc.revision != "' + pc.revision + '")\n';
    text += '\tconsole.warn("precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine");';
    var element = document.createElement("a");
    element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
    element.setAttribute("download", "precompile-shaders.js");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  };
  ProgramLibrary.prototype.clearCache = function() {
    var cache = this._cache;
    this._isClearingCache = true;
    for (var key in cache) {
      if (cache.hasOwnProperty(key)) {
        cache[key].destroy();
      }
    }
    this._cache = {};
    this._isClearingCache = false;
  };
  ProgramLibrary.prototype.removeFromCache = function(shader) {
    if (this._isClearingCache) {
      return;
    }
    var cache = this._cache;
    for (var key in cache) {
      if (cache.hasOwnProperty(key)) {
        if (cache[key] === shader) {
          delete cache[key];
          break;
        }
      }
    }
  };
  ProgramLibrary.prototype._getDefaultStdMatOptions = function(pass) {
    return pass > pc.SHADER_FORWARDHDR && pass <= pc.SHADER_PICK ? this._defaultStdMatOptionMin : this._defaultStdMatOption;
  };
  ProgramLibrary.prototype.precompile = function(cache) {
    if (cache) {
      var shaders = new Array(cache.length);
      for (var i = 0; i < cache.length; i++) {
        if (cache[i].name === "standard") {
          var opt = cache[i].options;
          var defaultMat = this._getDefaultStdMatOptions(opt.pass);
          for (var p in defaultMat) {
            if (defaultMat.hasOwnProperty(p) && opt[p] === undefined) {
              opt[p] = defaultMat[p];
            }
          }
          opt.useTexCubeLod = this._device.useTexCubeLod;
        }
        shaders[i] = this.getProgram(cache[i].name, cache[i].options);
      }
    }
    this._precached = true;
  };
  return {ProgramLibrary:ProgramLibrary};
}());
Object.assign(pc, function() {
  var EVENT_RESIZE = "resizecanvas";
  var _downsampleImage = function(image, size) {
    var srcW = image.width;
    var srcH = image.height;
    if (srcW > size || srcH > size) {
      var scale = size / Math.max(srcW, srcH);
      var dstW = Math.floor(srcW * scale);
      var dstH = Math.floor(srcH * scale);
      console.warn("Image dimensions larger than max supported texture size of " + size + ". " + "Resizing from " + srcW + ", " + srcH + " to " + dstW + ", " + dstH + ".");
      var canvas = document.createElement("canvas");
      canvas.width = dstW;
      canvas.height = dstH;
      var context = canvas.getContext("2d");
      context.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);
      return canvas;
    }
    return image;
  };
  function testRenderable(gl, pixelFormat) {
    var result = true;
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, null);
    var framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
      result = false;
    }
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.deleteTexture(texture);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(framebuffer);
    return result;
  }
  function testTextureFloatHighPrecision(device) {
    if (!device.textureFloatRenderable) {
      return false;
    }
    var chunks = pc.shaderChunks;
    var test1 = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.precisionTestPS, "ptest1");
    var test2 = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.precisionTest2PS, "ptest2");
    var textureOptions = {format:pc.PIXELFORMAT_RGBA32F, width:1, height:1, mipmaps:false, minFilter:pc.FILTER_NEAREST, magFilter:pc.FILTER_NEAREST};
    var tex1 = new pc.Texture(device, textureOptions);
    tex1.name = "testFHP";
    var targ1 = new pc.RenderTarget(device, tex1, {depth:false});
    pc.drawQuadWithShader(device, targ1, test1);
    textureOptions.format = pc.PIXELFORMAT_R8_G8_B8_A8;
    var tex2 = new pc.Texture(device, textureOptions);
    tex2.name = "testFHP";
    var targ2 = new pc.RenderTarget(device, tex2, {depth:false});
    device.constantTexSource.setValue(tex1);
    pc.drawQuadWithShader(device, targ2, test2);
    var prevFramebuffer = device.activeFramebuffer;
    device.setFramebuffer(targ2._glFrameBuffer);
    var pixels = new Uint8Array(4);
    device.readPixels(0, 0, 1, 1, pixels);
    device.setFramebuffer(prevFramebuffer);
    var x = pixels[0] / 255;
    var y = pixels[1] / 255;
    var z = pixels[2] / 255;
    var w = pixels[3] / 255;
    var f = x / (256 * 256 * 256) + y / (256 * 256) + z / 256 + w;
    tex1.destroy();
    targ1.destroy();
    tex2.destroy();
    targ2.destroy();
    return f === 0;
  }
  var GraphicsDevice = function(canvas, options) {
    var i;
    this.canvas = canvas;
    this.shader = null;
    this.indexBuffer = null;
    this.vertexBuffers = [];
    this.vbOffsets = [];
    this._enableAutoInstancing = false;
    this.autoInstancingMaxObjects = 16384;
    this.attributesInvalidated = true;
    this.boundBuffer = null;
    this.boundElementBuffer = null;
    this.instancedAttribs = {};
    this.enabledAttributes = {};
    this.transformFeedbackBuffer = null;
    this.activeFramebuffer = null;
    this.textureUnit = 0;
    this.textureUnits = [];
    this._maxPixelRatio = 1;
    this.renderTarget = null;
    this.feedback = null;
    this._width = 0;
    this._height = 0;
    this.updateClientRect();
    this.vertexShaderCache = {};
    this.fragmentShaderCache = {};
    this.shaders = [];
    this.buffers = [];
    this.textures = [];
    this.targets = [];
    this.contextLost = false;
    this._contextLostHandler = function(event) {
      event.preventDefault();
      this.contextLost = true;
      this.fire("devicelost");
    }.bind(this);
    this._contextRestoredHandler = function() {
      this.initializeContext();
      this.contextLost = false;
      this.fire("devicerestored");
    }.bind(this);
    canvas.addEventListener("webglcontextlost", this._contextLostHandler, false);
    canvas.addEventListener("webglcontextrestored", this._contextRestoredHandler, false);
    var preferWebGl2 = options && options.preferWebGl2 !== undefined ? options.preferWebGl2 : true;
    var names = preferWebGl2 ? ["webgl2", "experimental-webgl2", "webgl", "experimental-webgl"] : ["webgl", "experimental-webgl"];
    var gl = null;
    options = options || {};
    options.stencil = true;
    for (i = 0; i < names.length; i++) {
      try {
        gl = canvas.getContext(names[i], options);
      } catch (e) {
      }
      if (gl) {
        this.webgl2 = preferWebGl2 && i < 2;
        break;
      }
    }
    if (!gl) {
      throw new Error("WebGL not supported");
    }
    this.gl = gl;
    this.initializeExtensions();
    this.initializeCapabilities();
    this.initializeRenderState();
    for (i = 0; i < this.maxCombinedTextures; i++) {
      this.textureUnits.push([null, null, null]);
    }
    this.defaultClearOptions = {color:[0, 0, 0, 1], depth:1, stencil:0, flags:pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH};
    this.glAddress = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];
    this.glBlendEquation = [gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT, this.webgl2 ? gl.MIN : this.extBlendMinmax ? this.extBlendMinmax.MIN_EXT : gl.FUNC_ADD, this.webgl2 ? gl.MAX : this.extBlendMinmax ? this.extBlendMinmax.MAX_EXT : gl.FUNC_ADD];
    this.glBlendFunction = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA];
    this.glComparison = [gl.NEVER, gl.LESS, gl.EQUAL, gl.LEQUAL, gl.GREATER, gl.NOTEQUAL, gl.GEQUAL, gl.ALWAYS];
    this.glStencilOp = [gl.KEEP, gl.ZERO, gl.REPLACE, gl.INCR, gl.INCR_WRAP, gl.DECR, gl.DECR_WRAP, gl.INVERT];
    this.glClearFlag = [0, gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT];
    this.glCull = [0, gl.BACK, gl.FRONT, gl.FRONT_AND_BACK];
    this.glFilter = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];
    this.glPrimitive = [gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN];
    this.glType = [gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT, gl.FLOAT];
    this.pcUniformType = {};
    this.pcUniformType[gl.BOOL] = pc.UNIFORMTYPE_BOOL;
    this.pcUniformType[gl.INT] = pc.UNIFORMTYPE_INT;
    this.pcUniformType[gl.FLOAT] = pc.UNIFORMTYPE_FLOAT;
    this.pcUniformType[gl.FLOAT_VEC2] = pc.UNIFORMTYPE_VEC2;
    this.pcUniformType[gl.FLOAT_VEC3] = pc.UNIFORMTYPE_VEC3;
    this.pcUniformType[gl.FLOAT_VEC4] = pc.UNIFORMTYPE_VEC4;
    this.pcUniformType[gl.INT_VEC2] = pc.UNIFORMTYPE_IVEC2;
    this.pcUniformType[gl.INT_VEC3] = pc.UNIFORMTYPE_IVEC3;
    this.pcUniformType[gl.INT_VEC4] = pc.UNIFORMTYPE_IVEC4;
    this.pcUniformType[gl.BOOL_VEC2] = pc.UNIFORMTYPE_BVEC2;
    this.pcUniformType[gl.BOOL_VEC3] = pc.UNIFORMTYPE_BVEC3;
    this.pcUniformType[gl.BOOL_VEC4] = pc.UNIFORMTYPE_BVEC4;
    this.pcUniformType[gl.FLOAT_MAT2] = pc.UNIFORMTYPE_MAT2;
    this.pcUniformType[gl.FLOAT_MAT3] = pc.UNIFORMTYPE_MAT3;
    this.pcUniformType[gl.FLOAT_MAT4] = pc.UNIFORMTYPE_MAT4;
    this.pcUniformType[gl.SAMPLER_2D] = pc.UNIFORMTYPE_TEXTURE2D;
    this.pcUniformType[gl.SAMPLER_CUBE] = pc.UNIFORMTYPE_TEXTURECUBE;
    if (this.webgl2) {
      this.pcUniformType[gl.SAMPLER_2D_SHADOW] = pc.UNIFORMTYPE_TEXTURE2D_SHADOW;
      this.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = pc.UNIFORMTYPE_TEXTURECUBE_SHADOW;
      this.pcUniformType[gl.SAMPLER_3D] = pc.UNIFORMTYPE_TEXTURE3D;
    }
    this.targetToSlot = {};
    this.targetToSlot[gl.TEXTURE_2D] = 0;
    this.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;
    this.targetToSlot[gl.TEXTURE_3D] = 2;
    var scopeX, scopeY, scopeZ, scopeW;
    var uniformValue;
    this.commitFunction = [];
    this.commitFunction[pc.UNIFORMTYPE_BOOL] = function(uniform, value) {
      if (uniform.value !== value) {
        gl.uniform1i(uniform.locationId, value);
        uniform.value = value;
      }
    };
    this.commitFunction[pc.UNIFORMTYPE_INT] = this.commitFunction[pc.UNIFORMTYPE_BOOL];
    this.commitFunction[pc.UNIFORMTYPE_FLOAT] = function(uniform, value) {
      if (uniform.value !== value) {
        gl.uniform1f(uniform.locationId, value);
        uniform.value = value;
      }
    };
    this.commitFunction[pc.UNIFORMTYPE_VEC2] = function(uniform, value) {
      uniformValue = uniform.value;
      scopeX = value[0];
      scopeY = value[1];
      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
        gl.uniform2fv(uniform.locationId, value);
        uniformValue[0] = scopeX;
        uniformValue[1] = scopeY;
      }
    };
    this.commitFunction[pc.UNIFORMTYPE_VEC3] = function(uniform, value) {
      uniformValue = uniform.value;
      scopeX = value[0];
      scopeY = value[1];
      scopeZ = value[2];
      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
        gl.uniform3fv(uniform.locationId, value);
        uniformValue[0] = scopeX;
        uniformValue[1] = scopeY;
        uniformValue[2] = scopeZ;
      }
    };
    this.commitFunction[pc.UNIFORMTYPE_VEC4] = function(uniform, value) {
      uniformValue = uniform.value;
      scopeX = value[0];
      scopeY = value[1];
      scopeZ = value[2];
      scopeW = value[3];
      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
        gl.uniform4fv(uniform.locationId, value);
        uniformValue[0] = scopeX;
        uniformValue[1] = scopeY;
        uniformValue[2] = scopeZ;
        uniformValue[3] = scopeW;
      }
    };
    this.commitFunction[pc.UNIFORMTYPE_IVEC2] = function(uniform, value) {
      uniformValue = uniform.value;
      scopeX = value[0];
      scopeY = value[1];
      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
        gl.uniform2iv(uniform.locationId, value);
        uniformValue[0] = scopeX;
        uniformValue[1] = scopeY;
      }
    };
    this.commitFunction[pc.UNIFORMTYPE_BVEC2] = this.commitFunction[pc.UNIFORMTYPE_IVEC2];
    this.commitFunction[pc.UNIFORMTYPE_IVEC3] = function(uniform, value) {
      uniformValue = uniform.value;
      scopeX = value[0];
      scopeY = value[1];
      scopeZ = value[2];
      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
        gl.uniform3iv(uniform.locationId, value);
        uniformValue[0] = scopeX;
        uniformValue[1] = scopeY;
        uniformValue[2] = scopeZ;
      }
    };
    this.commitFunction[pc.UNIFORMTYPE_BVEC3] = this.commitFunction[pc.UNIFORMTYPE_IVEC3];
    this.commitFunction[pc.UNIFORMTYPE_IVEC4] = function(uniform, value) {
      uniformValue = uniform.value;
      scopeX = value[0];
      scopeY = value[1];
      scopeZ = value[2];
      scopeW = value[3];
      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
        gl.uniform4iv(uniform.locationId, value);
        uniformValue[0] = scopeX;
        uniformValue[1] = scopeY;
        uniformValue[2] = scopeZ;
        uniformValue[3] = scopeW;
      }
    };
    this.commitFunction[pc.UNIFORMTYPE_BVEC4] = this.commitFunction[pc.UNIFORMTYPE_IVEC4];
    this.commitFunction[pc.UNIFORMTYPE_MAT2] = function(uniform, value) {
      gl.uniformMatrix2fv(uniform.locationId, false, value);
    };
    this.commitFunction[pc.UNIFORMTYPE_MAT3] = function(uniform, value) {
      gl.uniformMatrix3fv(uniform.locationId, false, value);
    };
    this.commitFunction[pc.UNIFORMTYPE_MAT4] = function(uniform, value) {
      gl.uniformMatrix4fv(uniform.locationId, false, value);
    };
    this.commitFunction[pc.UNIFORMTYPE_FLOATARRAY] = function(uniform, value) {
      gl.uniform1fv(uniform.locationId, value);
    };
    this.scope = new pc.ScopeSpace("Device");
    this.programLib = new pc.ProgramLibrary(this);
    for (var generator in pc.programlib) {
      this.programLib.register(generator, pc.programlib[generator]);
    }
    pc.events.attach(this);
    this.supportsBoneTextures = this.extTextureFloat && this.maxVertexTextures > 0;
    this.useTexCubeLod = this.extTextureLod && this.maxTextures < 16;
    var numUniforms = this.vertexUniformsCount;
    numUniforms -= 4 * 4;
    numUniforms -= 8;
    numUniforms -= 1;
    numUniforms -= 4 * 4;
    this.boneLimit = Math.floor(numUniforms / 4);
    this.boneLimit = Math.min(this.boneLimit, 128);
    if (this.unmaskedRenderer === "Mali-450 MP") {
      this.boneLimit = 34;
    }
    if (this.unmaskedRenderer === "Apple A8 GPU") {
      this.forceCpuParticles = true;
    }
    this._drawCallsPerFrame = 0;
    this._shaderSwitchesPerFrame = 0;
    this._primsPerFrame = [];
    for (i = pc.PRIMITIVE_POINTS; i <= pc.PRIMITIVE_TRIFAN; i++) {
      this._primsPerFrame[i] = 0;
    }
    this._renderTargetCreationTime = 0;
    this._vram = {tex:0, vb:0, ib:0};
    this._shaderStats = {vsCompiled:0, fsCompiled:0, linked:0, materialShaders:0, compileTime:0};
    this.constantTexSource = this.scope.resolve("source");
    if (this.extTextureFloat) {
      if (this.webgl2) {
        this.textureFloatRenderable = !!this.extColorBufferFloat;
      } else {
        this.textureFloatRenderable = testRenderable(gl, gl.FLOAT);
      }
    } else {
      this.textureFloatRenderable = false;
    }
    if (this.extTextureHalfFloat) {
      if (this.webgl2) {
        this.textureHalfFloatRenderable = !!this.extColorBufferFloat;
      } else {
        this.textureHalfFloatRenderable = testRenderable(gl, this.extTextureHalfFloat.HALF_FLOAT_OES);
      }
    } else {
      this.textureHalfFloatRenderable = false;
    }
    this._textureFloatHighPrecision = undefined;
    this.initializeGrabPassTexture();
  };
  Object.assign(GraphicsDevice.prototype, {getPrecision:function() {
    var gl = this.gl;
    var precision = "highp";
    if (gl.getShaderPrecisionFormat) {
      var vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
      var vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);
      var fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
      var fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);
      var highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;
      var mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;
      if (!highpAvailable) {
        if (mediumpAvailable) {
          precision = "mediump";
        } else {
          precision = "lowp";
        }
      }
    }
    return precision;
  }, initializeExtensions:function() {
    var gl = this.gl;
    var ext;
    var supportedExtensions = gl.getSupportedExtensions();
    var getExtension = function() {
      var extension = null;
      for (var i = 0; i < arguments.length; i++) {
        if (supportedExtensions.indexOf(arguments[i]) !== -1) {
          extension = gl.getExtension(arguments[i]);
        }
      }
      return extension;
    };
    if (this.webgl2) {
      this.extBlendMinmax = true;
      this.extDrawBuffers = true;
      this.extInstancing = true;
      this.extStandardDerivatives = true;
      this.extTextureFloat = true;
      this.extTextureHalfFloat = true;
      this.extTextureHalfFloatLinear = true;
      this.extTextureLod = true;
      this.extUintElement = true;
      this.extVertexArrayObject = true;
      this.extColorBufferFloat = getExtension("EXT_color_buffer_float");
    } else {
      this.extBlendMinmax = getExtension("EXT_blend_minmax");
      this.extDrawBuffers = getExtension("EXT_draw_buffers");
      this.extInstancing = getExtension("ANGLE_instanced_arrays");
      if (this.extInstancing) {
        ext = this.extInstancing;
        gl.drawArraysInstanced = ext.drawArraysInstancedANGLE.bind(ext);
        gl.drawElementsInstanced = ext.drawElementsInstancedANGLE.bind(ext);
        gl.vertexAttribDivisor = ext.vertexAttribDivisorANGLE.bind(ext);
      }
      this.extStandardDerivatives = getExtension("OES_standard_derivatives");
      this.extTextureFloat = getExtension("OES_texture_float");
      this.extTextureHalfFloat = getExtension("OES_texture_half_float");
      this.extTextureHalfFloatLinear = getExtension("OES_texture_half_float_linear");
      this.extTextureLod = getExtension("EXT_shader_texture_lod");
      this.extUintElement = getExtension("OES_element_index_uint");
      this.extVertexArrayObject = getExtension("OES_vertex_array_object");
      if (this.extVertexArrayObject) {
        ext = this.extVertexArrayObject;
        gl.createVertexArray = ext.createVertexArrayOES.bind(ext);
        gl.deleteVertexArray = ext.deleteVertexArrayOES.bind(ext);
        gl.isVertexArray = ext.isVertexArrayOES.bind(ext);
        gl.bindVertexArray = ext.bindVertexArrayOES.bind(ext);
      }
      this.extColorBufferFloat = null;
    }
    this.extDebugRendererInfo = getExtension("WEBGL_debug_renderer_info");
    this.extTextureFloatLinear = getExtension("OES_texture_float_linear");
    this.extTextureFilterAnisotropic = getExtension("EXT_texture_filter_anisotropic", "WEBKIT_EXT_texture_filter_anisotropic");
    this.extCompressedTextureETC1 = getExtension("WEBGL_compressed_texture_etc1");
    this.extCompressedTextureETC = getExtension("WEBGL_compressed_texture_etc");
    this.extCompressedTexturePVRTC = getExtension("WEBGL_compressed_texture_pvrtc", "WEBKIT_WEBGL_compressed_texture_pvrtc");
    this.extCompressedTextureS3TC = getExtension("WEBGL_compressed_texture_s3tc", "WEBKIT_WEBGL_compressed_texture_s3tc");
    this.extParallelShaderCompile = getExtension("KHR_parallel_shader_compile");
  }, initializeCapabilities:function() {
    var gl = this.gl;
    var ext;
    this.maxPrecision = this.precision = this.getPrecision();
    var contextAttribs = gl.getContextAttributes();
    this.supportsMsaa = contextAttribs.antialias;
    this.supportsStencil = contextAttribs.stencil;
    this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    this.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
    this.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
    this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    this.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    this.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
    if (this.webgl2) {
      this.maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);
      this.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);
      this.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
    } else {
      ext = this.extDrawBuffers;
      this.maxDrawBuffers = ext ? gl.getParameter(ext.MAX_DRAW_BUFFERS_EXT) : 1;
      this.maxColorAttachments = ext ? gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_EXT) : 1;
      this.maxVolumeSize = 1;
    }
    ext = this.extDebugRendererInfo;
    this.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : "";
    this.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : "";
    ext = this.extTextureFilterAnisotropic;
    this.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
  }, initializeRenderState:function() {
    var gl = this.gl;
    this.blending = false;
    gl.disable(gl.BLEND);
    this.blendSrc = pc.BLENDMODE_ONE;
    this.blendDst = pc.BLENDMODE_ZERO;
    this.blendSrcAlpha = pc.BLENDMODE_ONE;
    this.blendDstAlpha = pc.BLENDMODE_ZERO;
    this.separateAlphaBlend = false;
    this.blendEquation = pc.BLENDEQUATION_ADD;
    this.blendAlphaEquation = pc.BLENDEQUATION_ADD;
    this.separateAlphaEquation = false;
    gl.blendFunc(gl.ONE, gl.ZERO);
    gl.blendEquation(gl.FUNC_ADD);
    this.writeRed = true;
    this.writeGreen = true;
    this.writeBlue = true;
    this.writeAlpha = true;
    gl.colorMask(true, true, true, true);
    this.cullMode = pc.CULLFACE_BACK;
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    this.depthTest = true;
    gl.enable(gl.DEPTH_TEST);
    this.depthFunc = pc.FUNC_LESSEQUAL;
    gl.depthFunc(gl.LEQUAL);
    this.depthWrite = true;
    gl.depthMask(true);
    this.stencil = false;
    gl.disable(gl.STENCIL_TEST);
    this.stencilFuncFront = this.stencilFuncBack = pc.FUNC_ALWAYS;
    this.stencilRefFront = this.stencilRefBack = 0;
    this.stencilMaskFront = this.stencilMaskBack = 255;
    gl.stencilFunc(gl.ALWAYS, 0, 255);
    this.stencilFailFront = this.stencilFailBack = pc.STENCILOP_KEEP;
    this.stencilZfailFront = this.stencilZfailBack = pc.STENCILOP_KEEP;
    this.stencilZpassFront = this.stencilZpassBack = pc.STENCILOP_KEEP;
    this.stencilWriteMaskFront = 255;
    this.stencilWriteMaskBack = 255;
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilMask(255);
    this.alphaToCoverage = false;
    this.raster = true;
    if (this.webgl2) {
      gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
      gl.disable(gl.RASTERIZER_DISCARD);
    }
    this.depthBiasEnabled = false;
    gl.disable(gl.POLYGON_OFFSET_FILL);
    this.clearDepth = 1;
    gl.clearDepth(1);
    this.clearRed = 0;
    this.clearBlue = 0;
    this.clearGreen = 0;
    this.clearAlpha = 0;
    gl.clearColor(0, 0, 0, 0);
    this.clearStencil = 0;
    gl.clearStencil(0);
    this.vx = this.vy = this.vw = this.vh = 0;
    this.sx = this.sy = this.sw = this.sh = 0;
    if (this.webgl2) {
      gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);
    } else {
      if (this.extStandardDerivatives) {
        gl.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, gl.NICEST);
      }
    }
    gl.enable(gl.SCISSOR_TEST);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    this.unpackFlipY = false;
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    this.unpackPremultiplyAlpha = false;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
  }, initializeContext:function() {
    this.initializeExtensions();
    this.initializeCapabilities();
    this.initializeRenderState();
    var i, len;
    for (i = 0, len = this.shaders.length; i < len; i++) {
      this.compileAndLinkShader(this.shaders[i]);
    }
    this.shader = null;
    for (i = 0, len = this.buffers.length; i < len; i++) {
      this.buffers[i].bufferId = undefined;
      this.buffers[i].unlock();
    }
    this.boundBuffer = null;
    this.boundElementBuffer = null;
    this.indexBuffer = null;
    this.attributesInvalidated = true;
    this.enabledAttributes = {};
    this.vertexBuffers = [];
    for (i = 0, len = this.textures.length; i < len; i++) {
      var texture = this.textures[i];
      this.destroyTexture(texture);
      texture.dirtyAll();
    }
    this.textureUnit = 0;
    this.textureUnits.length = 0;
    for (i = 0; i < this.maxCombinedTextures; i++) {
      this.textureUnits.push([null, null, null]);
    }
    for (i = 0, len = this.targets.length; i < len; i++) {
      this.targets[i]._glFrameBuffer = undefined;
      this.targets[i]._glDepthBuffer = undefined;
      this.targets[i]._glResolveFrameBuffer = undefined;
      this.targets[i]._glMsaaColorBuffer = undefined;
      this.targets[i]._glMsaaDepthBuffer = undefined;
    }
    this.renderTarget = null;
    this.activeFramebuffer = null;
    this.feedback = null;
    this.transformFeedbackBuffer = null;
  }, initializeGrabPassTexture:function() {
    if (this.grabPassTexture) {
      return;
    }
    var grabPassTexture = new pc.Texture(this, {format:pc.PIXELFORMAT_R8_G8_B8_A8, autoMipmap:false});
    grabPassTexture.minFilter = pc.FILTER_LINEAR;
    grabPassTexture.magFilter = pc.FILTER_LINEAR;
    grabPassTexture.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
    grabPassTexture.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
    grabPassTexture.name = "texture_grabPass";
    grabPassTexture.setSource(this.canvas);
    var grabPassTextureId = this.scope.resolve(grabPassTexture.name);
    grabPassTextureId.setValue(grabPassTexture);
    this.grabPassTextureId = grabPassTextureId;
    this.grabPassTexture = grabPassTexture;
  }, updateClientRect:function() {
    this.clientRect = this.canvas.getBoundingClientRect();
  }, setViewport:function(x, y, w, h) {
    if (this.vx !== x || this.vy !== y || this.vw !== w || this.vh !== h) {
      this.gl.viewport(x, y, w, h);
      this.vx = x;
      this.vy = y;
      this.vw = w;
      this.vh = h;
    }
  }, setScissor:function(x, y, w, h) {
    if (this.sx !== x || this.sy !== y || this.sw !== w || this.sh !== h) {
      this.gl.scissor(x, y, w, h);
      this.sx = x;
      this.sy = y;
      this.sw = w;
      this.sh = h;
    }
  }, getProgramLibrary:function() {
    return this.programLib;
  }, setProgramLibrary:function(programLib) {
    this.programLib = programLib;
  }, setFramebuffer:function(fb) {
    if (this.activeFramebuffer !== fb) {
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, fb);
      this.activeFramebuffer = fb;
    }
  }, _checkFbo:function() {
    var gl = this.gl;
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    switch(status) {
      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        console.error("ERROR: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
        break;
      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        console.error("ERROR: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
        break;
      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        console.error("ERROR: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
        break;
      case gl.FRAMEBUFFER_UNSUPPORTED:
        console.error("ERROR: FRAMEBUFFER_UNSUPPORTED");
        break;
      case gl.FRAMEBUFFER_COMPLETE:
        break;
      default:
        break;
    }
  }, copyRenderTarget:function(source, dest, color, depth) {
    var gl = this.gl;
    if (!this.webgl2 && depth) {
      return false;
    }
    if (color) {
      if (!dest) {
        if (!source._colorBuffer) {
          return false;
        }
      } else {
        if (!source._colorBuffer || !dest._colorBuffer) {
          return false;
        }
        if (source._colorBuffer._format !== dest._colorBuffer._format) {
          return false;
        }
      }
    }
    if (depth) {
      if (!source._depthBuffer || !dest._depthBuffer) {
        return false;
      }
      if (source._depthBuffer._format !== dest._depthBuffer._format) {
        return false;
      }
    }
    if (this.webgl2 && dest) {
      var prevRt = this.renderTarget;
      this.renderTarget = dest;
      this.updateBegin();
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, source ? source._glFrameBuffer : null);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dest._glFrameBuffer);
      var w = source ? source.width : dest.width;
      var h = source ? source.height : dest.height;
      gl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
      this.renderTarget = prevRt;
      gl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt._glFrameBuffer : null);
    } else {
      if (!this._copyShader) {
        var chunks = pc.shaderChunks;
        this._copyShader = chunks.createShaderFromCode(this, chunks.fullscreenQuadVS, chunks.outputTex2DPS, "outputTex2D");
      }
      this.constantTexSource.setValue(source._colorBuffer);
      pc.drawQuadWithShader(this, dest, this._copyShader);
    }
    return true;
  }, updateBegin:function() {
    var gl = this.gl;
    this.boundBuffer = null;
    this.boundElementBuffer = null;
    var target = this.renderTarget;
    if (target) {
      if (!target._glFrameBuffer) {
        target._device = this;
        target._glFrameBuffer = gl.createFramebuffer();
        this.setFramebuffer(target._glFrameBuffer);
        var colorBuffer = target._colorBuffer;
        if (colorBuffer) {
          if (!colorBuffer._glTexture) {
            colorBuffer._width = Math.min(colorBuffer.width, this.maxRenderBufferSize);
            colorBuffer._height = Math.min(colorBuffer.height, this.maxRenderBufferSize);
            this.setTexture(colorBuffer, 0);
          }
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer._glTexture, 0);
        }
        var depthBuffer = target._depthBuffer;
        if (depthBuffer && this.webgl2) {
          if (!depthBuffer._glTexture) {
            depthBuffer._width = Math.min(depthBuffer.width, this.maxRenderBufferSize);
            depthBuffer._height = Math.min(depthBuffer.height, this.maxRenderBufferSize);
            this.setTexture(depthBuffer, 0);
          }
          if (target._stencil) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer._glTexture, 0);
          } else {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer._glTexture, 0);
          }
        } else {
          if (target._depth) {
            var willRenderMsaa = target._samples > 1 && this.webgl2;
            if (!willRenderMsaa) {
              if (!target._glDepthBuffer) {
                target._glDepthBuffer = gl.createRenderbuffer();
              }
              gl.bindRenderbuffer(gl.RENDERBUFFER, target._glDepthBuffer);
              if (target._stencil) {
                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, target.width, target.height);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);
              } else {
                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, target.width, target.height);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);
              }
              gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            }
          }
        }
        if (this.webgl2 && target._samples > 1) {
          target._glResolveFrameBuffer = target._glFrameBuffer;
          target._glFrameBuffer = gl.createFramebuffer();
          this.setFramebuffer(target._glFrameBuffer);
          if (colorBuffer) {
            if (!target._glMsaaColorBuffer) {
              target._glMsaaColorBuffer = gl.createRenderbuffer();
            }
            gl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaColorBuffer);
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer._glInternalFormat, target.width, target.height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, target._glMsaaColorBuffer);
          }
          if (target._depth) {
            if (!target._glMsaaDepthBuffer) {
              target._glMsaaDepthBuffer = gl.createRenderbuffer();
            }
            gl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaDepthBuffer);
            if (target._stencil) {
              gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH24_STENCIL8, target.width, target.height);
              gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);
            } else {
              gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH_COMPONENT32F, target.width, target.height);
              gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);
            }
          }
        }
        this.targets.push(target);
      } else {
        this.setFramebuffer(target._glFrameBuffer);
      }
    } else {
      this.setFramebuffer(null);
    }
  }, updateEnd:function() {
    var gl = this.gl;
    var target = this.renderTarget;
    if (target) {
      var colorBuffer = target._colorBuffer;
      if (colorBuffer && colorBuffer._glTexture && colorBuffer.mipmaps && colorBuffer._pot) {
        this.activeTexture(this.maxCombinedTextures - 1);
        this.bindTexture(colorBuffer);
        gl.generateMipmap(colorBuffer._glTarget);
      }
      if (this.webgl2 && target._samples > 1 && target.autoResolve) {
        target.resolve();
      }
    }
  }, initializeTexture:function(texture) {
    var gl = this.gl;
    var ext;
    texture._glTexture = gl.createTexture();
    texture._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP : texture._volume ? gl.TEXTURE_3D : gl.TEXTURE_2D;
    switch(texture._format) {
      case pc.PIXELFORMAT_A8:
        texture._glFormat = gl.ALPHA;
        texture._glInternalFormat = gl.ALPHA;
        texture._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case pc.PIXELFORMAT_L8:
        texture._glFormat = gl.LUMINANCE;
        texture._glInternalFormat = gl.LUMINANCE;
        texture._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case pc.PIXELFORMAT_L8_A8:
        texture._glFormat = gl.LUMINANCE_ALPHA;
        texture._glInternalFormat = gl.LUMINANCE_ALPHA;
        texture._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case pc.PIXELFORMAT_R5_G6_B5:
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = gl.RGB;
        texture._glPixelType = gl.UNSIGNED_SHORT_5_6_5;
        break;
      case pc.PIXELFORMAT_R5_G5_B5_A1:
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = gl.RGBA;
        texture._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;
        break;
      case pc.PIXELFORMAT_R4_G4_B4_A4:
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = gl.RGBA;
        texture._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;
        break;
      case pc.PIXELFORMAT_R8_G8_B8:
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = this.webgl2 ? gl.RGB8 : gl.RGB;
        texture._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case pc.PIXELFORMAT_R8_G8_B8_A8:
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = this.webgl2 ? gl.RGBA8 : gl.RGBA;
        texture._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case pc.PIXELFORMAT_DXT1:
        ext = this.extCompressedTextureS3TC;
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;
        break;
      case pc.PIXELFORMAT_DXT3:
        ext = this.extCompressedTextureS3TC;
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        break;
      case pc.PIXELFORMAT_DXT5:
        ext = this.extCompressedTextureS3TC;
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        break;
      case pc.PIXELFORMAT_ETC1:
        ext = this.extCompressedTextureETC1;
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = ext.COMPRESSED_RGB_ETC1_WEBGL;
        break;
      case pc.PIXELFORMAT_PVRTC_2BPP_RGB_1:
        ext = this.extCompressedTexturePVRTC;
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        break;
      case pc.PIXELFORMAT_PVRTC_2BPP_RGBA_1:
        ext = this.extCompressedTexturePVRTC;
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        break;
      case pc.PIXELFORMAT_PVRTC_4BPP_RGB_1:
        ext = this.extCompressedTexturePVRTC;
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        break;
      case pc.PIXELFORMAT_PVRTC_4BPP_RGBA_1:
        ext = this.extCompressedTexturePVRTC;
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        break;
      case pc.PIXELFORMAT_ETC2_RGB:
        ext = this.extCompressedTextureETC;
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = ext.COMPRESSED_RGB8_ETC2;
        break;
      case pc.PIXELFORMAT_ETC2_RGBA:
        ext = this.extCompressedTextureETC;
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = ext.COMPRESSED_RGBA8_ETC2_EAC;
        break;
      case pc.PIXELFORMAT_RGB16F:
        ext = this.extTextureHalfFloat;
        texture._glFormat = gl.RGB;
        if (this.webgl2) {
          texture._glInternalFormat = gl.RGB16F;
          texture._glPixelType = gl.HALF_FLOAT;
        } else {
          texture._glInternalFormat = gl.RGB;
          texture._glPixelType = ext.HALF_FLOAT_OES;
        }
        break;
      case pc.PIXELFORMAT_RGBA16F:
        ext = this.extTextureHalfFloat;
        texture._glFormat = gl.RGBA;
        if (this.webgl2) {
          texture._glInternalFormat = gl.RGBA16F;
          texture._glPixelType = gl.HALF_FLOAT;
        } else {
          texture._glInternalFormat = gl.RGBA;
          texture._glPixelType = ext.HALF_FLOAT_OES;
        }
        break;
      case pc.PIXELFORMAT_RGB32F:
        texture._glFormat = gl.RGB;
        if (this.webgl2) {
          texture._glInternalFormat = gl.RGB32F;
        } else {
          texture._glInternalFormat = gl.RGB;
        }
        texture._glPixelType = gl.FLOAT;
        break;
      case pc.PIXELFORMAT_RGBA32F:
        texture._glFormat = gl.RGBA;
        if (this.webgl2) {
          texture._glInternalFormat = gl.RGBA32F;
        } else {
          texture._glInternalFormat = gl.RGBA;
        }
        texture._glPixelType = gl.FLOAT;
        break;
      case pc.PIXELFORMAT_R32F:
        texture._glFormat = gl.RED;
        texture._glInternalFormat = gl.R32F;
        texture._glPixelType = gl.FLOAT;
        break;
      case pc.PIXELFORMAT_DEPTH:
        if (this.webgl2) {
          texture._glFormat = gl.DEPTH_COMPONENT;
          texture._glInternalFormat = gl.DEPTH_COMPONENT32F;
          texture._glPixelType = gl.FLOAT;
        } else {
          texture._glFormat = gl.DEPTH_COMPONENT;
          texture._glInternalFormat = gl.DEPTH_COMPONENT;
          texture._glPixelType = gl.UNSIGNED_SHORT;
        }
        break;
      case pc.PIXELFORMAT_DEPTHSTENCIL:
        texture._glFormat = gl.DEPTH_STENCIL;
        texture._glInternalFormat = gl.DEPTH24_STENCIL8;
        texture._glPixelType = gl.UNSIGNED_INT_24_8;
        break;
      case pc.PIXELFORMAT_111110F:
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = gl.R11F_G11F_B10F;
        texture._glPixelType = gl.FLOAT;
        break;
      case pc.PIXELFORMAT_SRGB:
        texture._glFormat = gl.RGB;
        texture._glInternalFormat = gl.SRGB8;
        texture._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case pc.PIXELFORMAT_SRGBA:
        texture._glFormat = gl.RGBA;
        texture._glInternalFormat = gl.SRGB8_ALPHA8;
        texture._glPixelType = gl.UNSIGNED_BYTE;
        break;
    }
    this.textures.push(texture);
  }, destroyTexture:function(texture) {
    if (texture._glTexture) {
      var idx = this.textures.indexOf(texture);
      if (idx !== -1) {
        this.textures.splice(idx, 1);
      }
      for (var uniformName in this.scope.variables) {
        var uniform = this.scope.variables[uniformName];
        if (uniform.value === texture) {
          uniform.value = null;
        }
      }
      for (var i = 0; i < this.textureUnits.length; i++) {
        var textureUnit = this.textureUnits[i];
        for (var j = 0; j < textureUnit.length; j++) {
          if (textureUnit[j] === texture._glTexture) {
            textureUnit[j] = null;
          }
        }
      }
      var gl = this.gl;
      gl.deleteTexture(texture._glTexture);
      delete texture._glTexture;
      delete texture._glTarget;
      delete texture._glFormat;
      delete texture._glInternalFormat;
      delete texture._glPixelType;
      this._vram.tex -= texture._gpuSize;
    }
  }, setUnpackFlipY:function(flipY) {
    if (this.unpackFlipY !== flipY) {
      this.unpackFlipY = flipY;
      var gl = this.gl;
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
    }
  }, setUnpackPremultiplyAlpha:function(premultiplyAlpha) {
    if (this.unpackPremultiplyAlpha !== premultiplyAlpha) {
      this.unpackPremultiplyAlpha = premultiplyAlpha;
      var gl = this.gl;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
    }
  }, uploadTexture:function(texture) {
    var gl = this.gl;
    if (!texture._needsUpload && (texture._needsMipmapsUpload && texture._mipmapsUploaded || !texture._pot)) {
      return;
    }
    var mipLevel = 0;
    var mipObject;
    var resMult;
    while (texture._levels[mipLevel] || mipLevel === 0) {
      if (!texture._needsUpload && mipLevel === 0) {
        mipLevel++;
        continue;
      } else {
        if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {
          break;
        }
      }
      mipObject = texture._levels[mipLevel];
      if (mipLevel == 1 && !texture._compressed) {
        gl.generateMipmap(texture._glTarget);
        texture._mipmapsUploaded = true;
      }
      if (texture._cubemap) {
        var face;
        if (mipObject[0] instanceof HTMLCanvasElement || mipObject[0] instanceof HTMLImageElement || mipObject[0] instanceof HTMLVideoElement) {
          for (face = 0; face < 6; face++) {
            if (!texture._levelsUpdated[0][face]) {
              continue;
            }
            var src = mipObject[face];
            if (src instanceof HTMLImageElement) {
              if (src.width > this.maxCubeMapSize || src.height > this.maxCubeMapSize) {
                src = _downsampleImage(src, this.maxCubeMapSize);
                if (mipLevel === 0) {
                  texture.width = src.width;
                  texture.height = src.height;
                }
              }
            }
            this.setUnpackFlipY(false);
            this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, texture._glInternalFormat, texture._glFormat, texture._glPixelType, src);
          }
        } else {
          resMult = 1 / Math.pow(2, mipLevel);
          for (face = 0; face < 6; face++) {
            if (!texture._levelsUpdated[0][face]) {
              continue;
            }
            var texData = mipObject[face];
            if (texture._compressed) {
              gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texData);
            } else {
              this.setUnpackFlipY(false);
              this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
              gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texture._glFormat, texture._glPixelType, texData);
            }
          }
        }
      } else {
        if (texture._volume) {
          resMult = 1 / Math.pow(2, mipLevel);
          if (texture._compressed) {
            gl.compressedTexImage3D(gl.TEXTURE_3D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, mipObject);
          } else {
            this.setUnpackFlipY(false);
            this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
            gl.texImage3D(gl.TEXTURE_3D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, texture._glFormat, texture._glPixelType, mipObject);
          }
        } else {
          if (mipObject instanceof HTMLCanvasElement || mipObject instanceof HTMLImageElement || mipObject instanceof HTMLVideoElement) {
            if (mipObject instanceof HTMLImageElement) {
              if (mipObject.width > this.maxTextureSize || mipObject.height > this.maxTextureSize) {
                mipObject = _downsampleImage(mipObject, this.maxTextureSize);
                if (mipLevel === 0) {
                  texture.width = mipObject.width;
                  texture.height = mipObject.height;
                }
              }
            }
            this.setUnpackFlipY(texture._flipY);
            this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
            gl.texImage2D(gl.TEXTURE_2D, mipLevel, texture._glInternalFormat, texture._glFormat, texture._glPixelType, mipObject);
          } else {
            resMult = 1 / Math.pow(2, mipLevel);
            if (texture._compressed) {
              gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, mipObject);
            } else {
              this.setUnpackFlipY(false);
              this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
              gl.texImage2D(gl.TEXTURE_2D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texture._glFormat, texture._glPixelType, mipObject);
            }
          }
          if (mipLevel === 0) {
            texture._mipmapsUploaded = false;
          } else {
            texture._mipmapsUploaded = true;
          }
        }
      }
      mipLevel++;
    }
    if (texture._needsUpload) {
      if (texture._cubemap) {
        for (var i = 0; i < 6; i++) {
          texture._levelsUpdated[0][i] = false;
        }
      } else {
        texture._levelsUpdated[0] = false;
      }
    }
    if (!texture._compressed && texture._mipmaps && texture._needsMipmapsUpload && texture._pot && texture._levels.length === 1) {
      gl.generateMipmap(texture._glTarget);
      texture._mipmapsUploaded = true;
    }
    if (texture._gpuSize) {
      this._vram.tex -= texture._gpuSize;
    }
    texture._gpuSize = texture.gpuSize;
    this._vram.tex += texture._gpuSize;
  }, activeTexture:function(textureUnit) {
    if (this.textureUnit !== textureUnit) {
      this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);
      this.textureUnit = textureUnit;
    }
  }, bindTexture:function(texture) {
    var textureTarget = texture._glTarget;
    var textureObject = texture._glTexture;
    var textureUnit = this.textureUnit;
    var slot = this.targetToSlot[textureTarget];
    if (this.textureUnits[textureUnit][slot] !== textureObject) {
      this.gl.bindTexture(textureTarget, textureObject);
      this.textureUnits[textureUnit][slot] = textureObject;
    }
  }, bindTextureOnUnit:function(texture, textureUnit) {
    var textureTarget = texture._glTarget;
    var textureObject = texture._glTexture;
    var slot = this.targetToSlot[textureTarget];
    if (this.textureUnits[textureUnit][slot] !== textureObject) {
      this.activeTexture(textureUnit);
      this.gl.bindTexture(textureTarget, textureObject);
      this.textureUnits[textureUnit][slot] = textureObject;
    }
  }, setTextureParameters:function(texture) {
    var gl = this.gl;
    var flags = texture._parameterFlags;
    var target = texture._glTarget;
    if (flags & 1) {
      var filter = texture._minFilter;
      if (!texture._pot || !texture._mipmaps || texture._compressed && texture._levels.length === 1) {
        if (filter === pc.FILTER_NEAREST_MIPMAP_NEAREST || filter === pc.FILTER_NEAREST_MIPMAP_LINEAR) {
          filter = pc.FILTER_NEAREST;
        } else {
          if (filter === pc.FILTER_LINEAR_MIPMAP_NEAREST || filter === pc.FILTER_LINEAR_MIPMAP_LINEAR) {
            filter = pc.FILTER_LINEAR;
          }
        }
      }
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);
    }
    if (flags & 2) {
      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);
    }
    if (flags & 4) {
      if (this.webgl2) {
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);
      } else {
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._pot ? texture._addressU : pc.ADDRESS_CLAMP_TO_EDGE]);
      }
    }
    if (flags & 8) {
      if (this.webgl2) {
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);
      } else {
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._pot ? texture._addressV : pc.ADDRESS_CLAMP_TO_EDGE]);
      }
    }
    if (flags & 16) {
      if (this.webgl2) {
        gl.texParameteri(target, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);
      }
    }
    if (flags & 32) {
      if (this.webgl2) {
        gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
      }
    }
    if (flags & 64) {
      if (this.webgl2) {
        gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);
      }
    }
    if (flags & 128) {
      var ext = this.extTextureFilterAnisotropic;
      if (ext) {
        gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.max(1, Math.min(Math.round(texture._anisotropy), this.maxAnisotropy)));
      }
    }
  }, setTexture:function(texture, textureUnit) {
    if (!texture._glTexture) {
      this.initializeTexture(texture);
    }
    if (texture._parameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload) {
      this.activeTexture(textureUnit);
      this.bindTexture(texture);
      if (texture._parameterFlags) {
        this.setTextureParameters(texture);
        texture._parameterFlags = 0;
      }
      if (texture._needsUpload || texture._needsMipmapsUpload) {
        this.uploadTexture(texture);
        if (texture !== this.grabPassTexture) {
          texture._needsUpload = false;
          texture._needsMipmapsUpload = false;
        }
      }
    } else {
      this.bindTextureOnUnit(texture, textureUnit);
    }
  }, setBuffers:function(numInstances) {
    var gl = this.gl;
    var attribute, element, vertexBuffer, vbOffset, bufferId, locationId;
    var attributes = this.shader.attributes;
    if (this.attributesInvalidated) {
      for (var i = 0, len = attributes.length; i < len; i++) {
        attribute = attributes[i];
        element = attribute.scopeId.value;
        if (element !== null) {
          vertexBuffer = this.vertexBuffers[element.stream];
          vbOffset = this.vbOffsets[element.stream] || 0;
          bufferId = vertexBuffer.bufferId;
          if (this.boundBuffer !== bufferId) {
            gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);
            this.boundBuffer = bufferId;
          }
          locationId = attribute.locationId;
          if (!this.enabledAttributes[locationId]) {
            gl.enableVertexAttribArray(locationId);
            this.enabledAttributes[locationId] = true;
          }
          gl.vertexAttribPointer(locationId, element.numComponents, this.glType[element.dataType], element.normalize, element.stride, element.offset + vbOffset);
          if (element.stream === 1 && numInstances > 1) {
            if (!this.instancedAttribs[locationId]) {
              gl.vertexAttribDivisor(locationId, 1);
              this.instancedAttribs[locationId] = true;
            }
          } else {
            if (this.instancedAttribs[locationId]) {
              gl.vertexAttribDivisor(locationId, 0);
              this.instancedAttribs[locationId] = false;
            }
          }
        }
      }
      this.attributesInvalidated = false;
    }
    bufferId = this.indexBuffer ? this.indexBuffer.bufferId : null;
    if (this.boundElementBuffer !== bufferId) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);
      this.boundElementBuffer = bufferId;
    }
  }, draw:function(primitive, numInstances) {
    var gl = this.gl;
    var i, j, len;
    var sampler, samplerValue, texture, numTextures;
    var uniform, scopeId, uniformVersion, programVersion;
    var shader = this.shader;
    var samplers = shader.samplers;
    var uniforms = shader.uniforms;
    if (numInstances > 1) {
      this.boundBuffer = null;
      this.attributesInvalidated = true;
    }
    this.setBuffers(numInstances);
    var textureUnit = 0;
    for (i = 0, len = samplers.length; i < len; i++) {
      sampler = samplers[i];
      samplerValue = sampler.scopeId.value;
      if (!samplerValue) {
        continue;
      }
      if (samplerValue instanceof pc.Texture) {
        texture = samplerValue;
        this.setTexture(texture, textureUnit);
        if (sampler.slot !== textureUnit) {
          gl.uniform1i(sampler.locationId, textureUnit);
          sampler.slot = textureUnit;
        }
        textureUnit++;
      } else {
        sampler.array.length = 0;
        numTextures = samplerValue.length;
        for (j = 0; j < numTextures; j++) {
          texture = samplerValue[j];
          this.setTexture(texture, textureUnit);
          sampler.array[j] = textureUnit;
          textureUnit++;
        }
        gl.uniform1iv(sampler.locationId, sampler.array);
      }
    }
    for (i = 0, len = uniforms.length; i < len; i++) {
      uniform = uniforms[i];
      scopeId = uniform.scopeId;
      uniformVersion = uniform.version;
      programVersion = scopeId.versionObject.version;
      if (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {
        uniformVersion.globalId = programVersion.globalId;
        uniformVersion.revision = programVersion.revision;
        if (scopeId.value !== null) {
          this.commitFunction[uniform.dataType](uniform, scopeId.value);
        }
      }
    }
    if (this.webgl2 && this.transformFeedbackBuffer) {
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.bufferId);
      gl.beginTransformFeedback(gl.POINTS);
    }
    var mode = this.glPrimitive[primitive.type];
    var count = primitive.count;
    if (primitive.indexed) {
      var indexBuffer = this.indexBuffer;
      var format = indexBuffer.glFormat;
      var offset = primitive.base * indexBuffer.bytesPerIndex;
      if (numInstances > 1) {
        gl.drawElementsInstanced(mode, count, format, offset, numInstances);
      } else {
        gl.drawElements(mode, count, format, offset);
      }
    } else {
      var first = primitive.base;
      if (numInstances > 1) {
        gl.drawArraysInstanced(mode, first, count, numInstances);
      } else {
        gl.drawArrays(mode, first, count);
      }
    }
    if (this.webgl2 && this.transformFeedbackBuffer) {
      gl.endTransformFeedback();
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
    }
  }, clear:function(options) {
    var defaultOptions = this.defaultClearOptions;
    options = options || defaultOptions;
    var flags = options.flags == undefined ? defaultOptions.flags : options.flags;
    if (flags !== 0) {
      var gl = this.gl;
      if (flags & pc.CLEARFLAG_COLOR) {
        var color = options.color == undefined ? defaultOptions.color : options.color;
        this.setClearColor(color[0], color[1], color[2], color[3]);
      }
      if (flags & pc.CLEARFLAG_DEPTH) {
        var depth = options.depth == undefined ? defaultOptions.depth : options.depth;
        this.setClearDepth(depth);
        if (!this.depthWrite) {
          gl.depthMask(true);
        }
      }
      if (flags & pc.CLEARFLAG_STENCIL) {
        var stencil = options.stencil == undefined ? defaultOptions.stencil : options.stencil;
        this.setClearStencil(stencil);
      }
      gl.clear(this.glClearFlag[flags]);
      if (flags & pc.CLEARFLAG_DEPTH) {
        if (!this.depthWrite) {
          gl.depthMask(false);
        }
      }
    }
  }, readPixels:function(x, y, w, h, pixels) {
    var gl = this.gl;
    gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  }, setClearDepth:function(depth) {
    if (depth !== this.clearDepth) {
      this.gl.clearDepth(depth);
      this.clearDepth = depth;
    }
  }, setClearColor:function(r, g, b, a) {
    if (r !== this.clearRed || g !== this.clearGreen || b !== this.clearBlue || a !== this.clearAlpha) {
      this.gl.clearColor(r, g, b, a);
      this.clearRed = r;
      this.clearGreen = g;
      this.clearBlue = b;
      this.clearAlpha = a;
    }
  }, setClearStencil:function(value) {
    if (value !== this.clearStencil) {
      this.gl.clearStencil(value);
      this.clearStencil = value;
    }
  }, setRenderTarget:function(renderTarget) {
    this.renderTarget = renderTarget;
  }, getRenderTarget:function() {
    return this.renderTarget;
  }, getDepthTest:function() {
    return this.depthTest;
  }, setDepthTest:function(depthTest) {
    if (this.depthTest !== depthTest) {
      var gl = this.gl;
      if (depthTest) {
        gl.enable(gl.DEPTH_TEST);
      } else {
        gl.disable(gl.DEPTH_TEST);
      }
      this.depthTest = depthTest;
    }
  }, setDepthFunc:function(func) {
    if (this.depthFunc === func) {
      return;
    }
    this.gl.depthFunc(this.glComparison[func]);
    this.depthFunc = func;
  }, getDepthWrite:function() {
    return this.depthWrite;
  }, setDepthWrite:function(writeDepth) {
    if (this.depthWrite !== writeDepth) {
      this.gl.depthMask(writeDepth);
      this.depthWrite = writeDepth;
    }
  }, setColorWrite:function(writeRed, writeGreen, writeBlue, writeAlpha) {
    if (this.writeRed !== writeRed || this.writeGreen !== writeGreen || this.writeBlue !== writeBlue || this.writeAlpha !== writeAlpha) {
      this.gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);
      this.writeRed = writeRed;
      this.writeGreen = writeGreen;
      this.writeBlue = writeBlue;
      this.writeAlpha = writeAlpha;
    }
  }, setAlphaToCoverage:function(state) {
    if (!this.webgl2) {
      return;
    }
    if (this.alphaToCoverage === state) {
      return;
    }
    this.alphaToCoverage = state;
    if (state) {
      this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
    } else {
      this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
    }
  }, setTransformFeedbackBuffer:function(tf) {
    if (this.transformFeedbackBuffer === tf) {
      return;
    }
    this.transformFeedbackBuffer = tf;
    if (this.webgl2) {
      var gl = this.gl;
      if (tf) {
        if (!this.feedback) {
          this.feedback = gl.createTransformFeedback();
        }
        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.feedback);
      } else {
        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
      }
    }
  }, setRaster:function(on) {
    if (this.raster === on) {
      return;
    }
    this.raster = on;
    if (this.webgl2) {
      if (on) {
        this.gl.disable(this.gl.RASTERIZER_DISCARD);
      } else {
        this.gl.enable(this.gl.RASTERIZER_DISCARD);
      }
    }
  }, setDepthBias:function(on) {
    if (this.depthBiasEnabled === on) {
      return;
    }
    this.depthBiasEnabled = on;
    if (on) {
      this.gl.enable(this.gl.POLYGON_OFFSET_FILL);
    } else {
      this.gl.disable(this.gl.POLYGON_OFFSET_FILL);
    }
  }, setDepthBiasValues:function(constBias, slopeBias) {
    this.gl.polygonOffset(slopeBias, constBias);
  }, getBlending:function() {
    return this.blending;
  }, setBlending:function(blending) {
    if (this.blending !== blending) {
      var gl = this.gl;
      if (blending) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
      this.blending = blending;
    }
  }, setStencilTest:function(enable) {
    if (this.stencil !== enable) {
      var gl = this.gl;
      if (enable) {
        gl.enable(gl.STENCIL_TEST);
      } else {
        gl.disable(gl.STENCIL_TEST);
      }
      this.stencil = enable;
    }
  }, setStencilFunc:function(func, ref, mask) {
    if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask || this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
      var gl = this.gl;
      gl.stencilFunc(this.glComparison[func], ref, mask);
      this.stencilFuncFront = this.stencilFuncBack = func;
      this.stencilRefFront = this.stencilRefBack = ref;
      this.stencilMaskFront = this.stencilMaskBack = mask;
    }
  }, setStencilFuncFront:function(func, ref, mask) {
    if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {
      var gl = this.gl;
      gl.stencilFuncSeparate(gl.FRONT, this.glComparison[func], ref, mask);
      this.stencilFuncFront = func;
      this.stencilRefFront = ref;
      this.stencilMaskFront = mask;
    }
  }, setStencilFuncBack:function(func, ref, mask) {
    if (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
      var gl = this.gl;
      gl.stencilFuncSeparate(gl.BACK, this.glComparison[func], ref, mask);
      this.stencilFuncBack = func;
      this.stencilRefBack = ref;
      this.stencilMaskBack = mask;
    }
  }, setStencilOperation:function(fail, zfail, zpass, writeMask) {
    if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass || this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
      this.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
      this.stencilFailFront = this.stencilFailBack = fail;
      this.stencilZfailFront = this.stencilZfailBack = zfail;
      this.stencilZpassFront = this.stencilZpassBack = zpass;
    }
    if (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {
      this.gl.stencilMask(writeMask);
      this.stencilWriteMaskFront = writeMask;
      this.stencilWriteMaskBack = writeMask;
    }
  }, setStencilOperationFront:function(fail, zfail, zpass, writeMask) {
    if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {
      this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
      this.stencilFailFront = fail;
      this.stencilZfailFront = zfail;
      this.stencilZpassFront = zpass;
    }
    if (this.stencilWriteMaskFront !== writeMask) {
      this.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);
      this.stencilWriteMaskFront = writeMask;
    }
  }, setStencilOperationBack:function(fail, zfail, zpass, writeMask) {
    if (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
      this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
      this.stencilFailBack = fail;
      this.stencilZfailBack = zfail;
      this.stencilZpassBack = zpass;
    }
    if (this.stencilWriteMaskBack !== writeMask) {
      this.gl.stencilMaskSeparate(this.gl.BACK, writeMask);
      this.stencilWriteMaskBack = writeMask;
    }
  }, setBlendFunction:function(blendSrc, blendDst) {
    if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.separateAlphaBlend) {
      this.gl.blendFunc(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst]);
      this.blendSrc = blendSrc;
      this.blendDst = blendDst;
      this.separateAlphaBlend = false;
    }
  }, setBlendFunctionSeparate:function(blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {
    if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.blendSrcAlpha !== blendSrcAlpha || this.blendDstAlpha !== blendDstAlpha || !this.separateAlphaBlend) {
      this.gl.blendFuncSeparate(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst], this.glBlendFunction[blendSrcAlpha], this.glBlendFunction[blendDstAlpha]);
      this.blendSrc = blendSrc;
      this.blendDst = blendDst;
      this.blendSrcAlpha = blendSrcAlpha;
      this.blendDstAlpha = blendDstAlpha;
      this.separateAlphaBlend = true;
    }
  }, setBlendEquation:function(blendEquation) {
    if (this.blendEquation !== blendEquation || this.separateAlphaEquation) {
      this.gl.blendEquation(this.glBlendEquation[blendEquation]);
      this.blendEquation = blendEquation;
      this.separateAlphaEquation = false;
    }
  }, setBlendEquationSeparate:function(blendEquation, blendAlphaEquation) {
    if (this.blendEquation !== blendEquation || this.blendAlphaEquation !== blendAlphaEquation || !this.separateAlphaEquation) {
      this.gl.blendEquationSeparate(this.glBlendEquation[blendEquation], this.glBlendEquation[blendAlphaEquation]);
      this.blendEquation = blendEquation;
      this.blendAlphaEquation = blendAlphaEquation;
      this.separateAlphaEquation = true;
    }
  }, setCullMode:function(cullMode) {
    if (this.cullMode !== cullMode) {
      if (cullMode === pc.CULLFACE_NONE) {
        this.gl.disable(this.gl.CULL_FACE);
      } else {
        if (this.cullMode === pc.CULLFACE_NONE) {
          this.gl.enable(this.gl.CULL_FACE);
        }
        var mode = this.glCull[cullMode];
        if (this.cullFace !== mode) {
          this.gl.cullFace(mode);
          this.cullFace = mode;
        }
      }
      this.cullMode = cullMode;
    }
  }, getCullMode:function() {
    return this.cullMode;
  }, setIndexBuffer:function(indexBuffer) {
    this.indexBuffer = indexBuffer;
  }, setVertexBuffer:function(vertexBuffer, stream, vbOffset) {
    if (this.vertexBuffers[stream] !== vertexBuffer || this.vbOffsets[stream] !== vbOffset) {
      this.vertexBuffers[stream] = vertexBuffer;
      this.vbOffsets[stream] = vbOffset;
      var vertexFormat = vertexBuffer.getFormat();
      var i = 0;
      var elements = vertexFormat.elements;
      var numElements = elements.length;
      while (i < numElements) {
        var vertexElement = elements[i++];
        vertexElement.stream = stream;
        vertexElement.scopeId.setValue(vertexElement);
      }
      this.attributesInvalidated = true;
    }
  }, compileShaderSource:function(src, isVertexShader) {
    var gl = this.gl;
    var glShader = isVertexShader ? this.vertexShaderCache[src] : this.fragmentShaderCache[src];
    if (!glShader) {
      glShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
      gl.shaderSource(glShader, src);
      gl.compileShader(glShader);
      if (isVertexShader) {
        this.vertexShaderCache[src] = glShader;
      } else {
        this.fragmentShaderCache[src] = glShader;
      }
    }
    return glShader;
  }, compileAndLinkShader:function(shader) {
    var gl = this.gl;
    var definition = shader.definition;
    var glVertexShader = this.compileShaderSource(definition.vshader, true);
    var glFragmentShader = this.compileShaderSource(definition.fshader, false);
    var glProgram = gl.createProgram();
    gl.attachShader(glProgram, glVertexShader);
    gl.attachShader(glProgram, glFragmentShader);
    if (this.webgl2 && definition.useTransformFeedback) {
      var attrs = definition.attributes;
      var outNames = [];
      for (var attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          outNames.push("out_" + attr);
        }
      }
      gl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);
    }
    gl.linkProgram(glProgram);
    shader._glVertexShader = glVertexShader;
    shader._glFragmentShader = glFragmentShader;
    shader._glProgram = glProgram;
  }, createShader:function(shader) {
    this.compileAndLinkShader(shader);
    this.shaders.push(shader);
  }, destroyShader:function(shader) {
    var idx = this.shaders.indexOf(shader);
    if (idx !== -1) {
      this.shaders.splice(idx, 1);
    }
    if (shader._glProgram) {
      this.gl.deleteProgram(shader._glProgram);
      shader._glProgram = null;
      this.removeShaderFromCache(shader);
    }
  }, _addLineNumbers:function(src) {
    var lines = src.split("\n");
    for (var i = 0, len = lines.length; i < len; i++) {
      lines[i] = i + 1 + ":\t" + lines[i];
    }
    return lines.join("\n");
  }, postLink:function(shader) {
    var gl = this.gl;
    var glVertexShader = shader._glVertexShader;
    var glFragmentShader = shader._glFragmentShader;
    var glProgram = shader._glProgram;
    var definition = shader.definition;
    if (!gl.getShaderParameter(glVertexShader, gl.COMPILE_STATUS)) {
      console.error("Failed to compile vertex shader:\n\n" + this._addLineNumbers(definition.vshader) + "\n\n" + gl.getShaderInfoLog(glVertexShader));
      return false;
    }
    if (!gl.getShaderParameter(glFragmentShader, gl.COMPILE_STATUS)) {
      console.error("Failed to compile fragment shader:\n\n" + this._addLineNumbers(definition.fshader) + "\n\n" + gl.getShaderInfoLog(glFragmentShader));
      return false;
    }
    if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
      console.error("Failed to link shader program. Error: " + gl.getProgramInfoLog(glProgram));
      return false;
    }
    var i, info, location, shaderInput;
    i = 0;
    var numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);
    while (i < numAttributes) {
      info = gl.getActiveAttrib(glProgram, i++);
      location = gl.getAttribLocation(glProgram, info.name);
      if (definition.attributes[info.name] === undefined) {
        console.error('Vertex shader attribute "' + info.name + '" is not mapped to a semantic in shader definition.');
      }
      shaderInput = new pc.ShaderInput(this, definition.attributes[info.name], this.pcUniformType[info.type], location);
      shader.attributes.push(shaderInput);
    }
    i = 0;
    var numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);
    while (i < numUniforms) {
      info = gl.getActiveUniform(glProgram, i++);
      location = gl.getUniformLocation(glProgram, info.name);
      shaderInput = new pc.ShaderInput(this, info.name, this.pcUniformType[info.type], location);
      if (info.type === gl.SAMPLER_2D || info.type === gl.SAMPLER_CUBE || this.webgl2 && (info.type === gl.SAMPLER_2D_SHADOW || info.type === gl.SAMPLER_CUBE_SHADOW || info.type === gl.SAMPLER_3D)) {
        shader.samplers.push(shaderInput);
      } else {
        shader.uniforms.push(shaderInput);
      }
    }
    shader.ready = true;
    return true;
  }, setShader:function(shader) {
    if (shader !== this.shader) {
      if (!shader.ready) {
        if (!this.postLink(shader)) {
          return false;
        }
      }
      this.shader = shader;
      this.gl.useProgram(shader._glProgram);
      this.attributesInvalidated = true;
    }
    return true;
  }, getHdrFormat:function() {
    if (this.textureHalfFloatRenderable) {
      return pc.PIXELFORMAT_RGB16F;
    } else {
      if (this.textureFloatRenderable) {
        return pc.PIXELFORMAT_RGB32F;
      }
    }
    return pc.PIXELFORMAT_R8_G8_B8_A8;
  }, getBoneLimit:function() {
    return this.boneLimit;
  }, setBoneLimit:function(maxBones) {
    this.boneLimit = maxBones;
  }, resizeCanvas:function(width, height) {
    this._width = width;
    this._height = height;
    var ratio = Math.min(this._maxPixelRatio, window.devicePixelRatio);
    width *= ratio;
    height *= ratio;
    this.canvas.width = width;
    this.canvas.height = height;
    this.fire(EVENT_RESIZE, width, height);
  }, setResolution:function(width, height) {
    this._width = width;
    this._height = height;
    this.canvas.width = width;
    this.canvas.height = height;
    this.fire(EVENT_RESIZE, width, height);
  }, clearShaderCache:function() {
    var gl = this.gl;
    var shaderSrc;
    for (shaderSrc in this.fragmentShaderCache) {
      gl.deleteShader(this.fragmentShaderCache[shaderSrc]);
      delete this.fragmentShaderCache[shaderSrc];
    }
    for (shaderSrc in this.vertexShaderCache) {
      gl.deleteShader(this.vertexShaderCache[shaderSrc]);
      delete this.vertexShaderCache[shaderSrc];
    }
    this.programLib.clearCache();
  }, removeShaderFromCache:function(shader) {
    this.programLib.removeFromCache(shader);
  }, destroy:function() {
    var gl = this.gl;
    this.grabPassTexture.destroy();
    if (this.webgl2 && this.feedback) {
      gl.deleteTransformFeedback(this.feedback);
    }
    this.clearShaderCache();
    this.canvas.removeEventListener("webglcontextlost", this._contextLostHandler, false);
    this.canvas.removeEventListener("webglcontextrestored", this._contextRestoredHandler, false);
    this._contextLostHandler = null;
    this._contextRestoredHandler = null;
    this.canvas = null;
    this.gl = null;
  }});
  Object.defineProperty(GraphicsDevice.prototype, "width", {get:function() {
    return this.gl.drawingBufferWidth || this.canvas.width;
  }});
  Object.defineProperty(GraphicsDevice.prototype, "height", {get:function() {
    return this.gl.drawingBufferHeight || this.canvas.height;
  }});
  Object.defineProperty(GraphicsDevice.prototype, "fullscreen", {get:function() {
    return !!document.fullscreenElement;
  }, set:function(fullscreen) {
    if (fullscreen) {
      var canvas = this.gl.canvas;
      canvas.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  }});
  Object.defineProperty(GraphicsDevice.prototype, "enableAutoInstancing", {get:function() {
    return this._enableAutoInstancing;
  }, set:function(value) {
    this._enableAutoInstancing = value && this.extInstancing;
  }});
  Object.defineProperty(GraphicsDevice.prototype, "maxPixelRatio", {get:function() {
    return this._maxPixelRatio;
  }, set:function(ratio) {
    this._maxPixelRatio = ratio;
    this.resizeCanvas(this._width, this._height);
  }});
  Object.defineProperty(GraphicsDevice.prototype, "textureFloatHighPrecision", {get:function() {
    if (this._textureFloatHighPrecision === undefined) {
      this._textureFloatHighPrecision = testTextureFloatHighPrecision(this);
    }
    return this._textureFloatHighPrecision;
  }});
  return {GraphicsDevice:GraphicsDevice};
}());
Object.assign(pc, function() {
  var shaderChunks = {};
  var attrib2Semantic = {vertex_position:pc.SEMANTIC_POSITION, vertex_normal:pc.SEMANTIC_NORMAL, vertex_tangent:pc.SEMANTIC_TANGENT, vertex_texCoord0:pc.SEMANTIC_TEXCOORD0, vertex_texCoord1:pc.SEMANTIC_TEXCOORD1, vertex_texCoord2:pc.SEMANTIC_TEXCOORD2, vertex_texCoord3:pc.SEMANTIC_TEXCOORD3, vertex_texCoord4:pc.SEMANTIC_TEXCOORD4, vertex_texCoord5:pc.SEMANTIC_TEXCOORD5, vertex_texCoord6:pc.SEMANTIC_TEXCOORD6, vertex_texCoord7:pc.SEMANTIC_TEXCOORD7, vertex_color:pc.SEMANTIC_COLOR, vertex_boneIndices:pc.SEMANTIC_BLENDINDICES, 
  vertex_boneWeights:pc.SEMANTIC_BLENDWEIGHT};
  shaderChunks.collectAttribs = function(vsCode) {
    var attribs = {};
    var attrs = 0;
    var found = vsCode.indexOf("attribute");
    while (found >= 0) {
      if (found > 0 && vsCode[found - 1] === "/") {
        break;
      }
      var endOfLine = vsCode.indexOf(";", found);
      var startOfAttribName = vsCode.lastIndexOf(" ", endOfLine);
      var attribName = vsCode.substr(startOfAttribName + 1, endOfLine - (startOfAttribName + 1));
      var semantic = attrib2Semantic[attribName];
      if (semantic !== undefined) {
        attribs[attribName] = semantic;
      } else {
        attribs[attribName] = "ATTR" + attrs;
        attrs++;
      }
      found = vsCode.indexOf("attribute", found + 1);
    }
    return attribs;
  };
  shaderChunks.createShader = function(device, vsName, psName, useTransformFeedback) {
    var vsCode = shaderChunks[vsName];
    var psCode = pc.programlib.precisionCode(device) + "\n" + shaderChunks[psName];
    var attribs = this.collectAttribs(vsCode);
    if (device.webgl2) {
      vsCode = pc.programlib.versionCode(device) + this.gles3VS + vsCode;
      psCode = pc.programlib.versionCode(device) + this.gles3PS + psCode;
    }
    return new pc.Shader(device, {attributes:attribs, vshader:vsCode, fshader:psCode, useTransformFeedback:useTransformFeedback});
  };
  shaderChunks.createShaderFromCode = function(device, vsCode, psCode, uName, useTransformFeedback) {
    var shaderCache = device.programLib._cache;
    var cached = shaderCache[uName];
    if (cached !== undefined) {
      return cached;
    }
    psCode = pc.programlib.precisionCode(device) + "\n" + (psCode || pc.programlib.dummyFragmentCode());
    var attribs = this.collectAttribs(vsCode);
    if (device.webgl2) {
      vsCode = pc.programlib.versionCode(device) + this.gles3VS + vsCode;
      psCode = pc.programlib.versionCode(device) + this.gles3PS + psCode;
    }
    shaderCache[uName] = new pc.Shader(device, {attributes:attribs, vshader:vsCode, fshader:psCode, useTransformFeedback:useTransformFeedback});
    return shaderCache[uName];
  };
  return {shaderChunks:shaderChunks};
}());
Object.assign(pc, function() {
  var _postEffectQuadVB = null;
  var _postEffectQuadDraw = {type:pc.PRIMITIVE_TRISTRIP, base:0, count:4, indexed:false};
  function drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend) {
    if (_postEffectQuadVB === null) {
      var vertexFormat = new pc.VertexFormat(device, [{semantic:pc.SEMANTIC_POSITION, components:2, type:pc.TYPE_FLOAT32}]);
      _postEffectQuadVB = new pc.VertexBuffer(device, vertexFormat, 4);
      var iterator = new pc.VertexIterator(_postEffectQuadVB);
      iterator.element[pc.SEMANTIC_POSITION].set(-1.0, -1.0);
      iterator.next();
      iterator.element[pc.SEMANTIC_POSITION].set(1.0, -1.0);
      iterator.next();
      iterator.element[pc.SEMANTIC_POSITION].set(-1.0, 1.0);
      iterator.next();
      iterator.element[pc.SEMANTIC_POSITION].set(1.0, 1.0);
      iterator.end();
    }
    var oldRt = device.renderTarget;
    device.setRenderTarget(target);
    device.updateBegin();
    var x, y, w, h;
    var sx, sy, sw, sh;
    if (!rect) {
      w = target ? target.width : device.width;
      h = target ? target.height : device.height;
      x = 0;
      y = 0;
    } else {
      x = rect.x;
      y = rect.y;
      w = rect.z;
      h = rect.w;
    }
    if (!scissorRect) {
      sx = x;
      sy = y;
      sw = w;
      sh = h;
    } else {
      sx = scissorRect.x;
      sy = scissorRect.y;
      sw = scissorRect.z;
      sh = scissorRect.w;
    }
    var oldVx = device.vx;
    var oldVy = device.vy;
    var oldVw = device.vw;
    var oldVh = device.vh;
    device.setViewport(x, y, w, h);
    var oldSx = device.sx;
    var oldSy = device.sy;
    var oldSw = device.sw;
    var oldSh = device.sh;
    device.setScissor(sx, sy, sw, sh);
    var oldDepthTest = device.getDepthTest();
    var oldDepthWrite = device.getDepthWrite();
    var oldCullMode = device.getCullMode();
    var oldWR = device.writeRed;
    var oldWG = device.writeGreen;
    var oldWB = device.writeBlue;
    var oldWA = device.writeAlpha;
    device.setDepthTest(false);
    device.setDepthWrite(false);
    device.setCullMode(pc.CULLFACE_NONE);
    device.setColorWrite(true, true, true, true);
    if (!useBlend) {
      device.setBlending(false);
    }
    device.setVertexBuffer(_postEffectQuadVB, 0);
    device.setShader(shader);
    device.draw(_postEffectQuadDraw);
    device.setDepthTest(oldDepthTest);
    device.setDepthWrite(oldDepthWrite);
    device.setCullMode(oldCullMode);
    device.setColorWrite(oldWR, oldWG, oldWB, oldWA);
    device.updateEnd();
    device.setRenderTarget(oldRt);
    device.updateBegin();
    device.setViewport(oldVx, oldVy, oldVw, oldVh);
    device.setScissor(oldSx, oldSy, oldSw, oldSh);
  }
  function destroyPostEffectQuad() {
    if (_postEffectQuadVB) {
      _postEffectQuadVB.destroy();
      _postEffectQuadVB = null;
    }
  }
  return {drawQuadWithShader:drawQuadWithShader, destroyPostEffectQuad:destroyPostEffectQuad};
}());
Object.assign(pc, function() {
  function syncToCpu(device, targ, face) {
    var tex = targ._colorBuffer;
    if (tex.format != pc.PIXELFORMAT_R8_G8_B8_A8) {
      return;
    }
    var pixels = new Uint8Array(tex.width * tex.height * 4);
    var gl = device.gl;
    device.setFramebuffer(targ._glFrameBuffer);
    gl.readPixels(0, 0, tex.width, tex.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    if (!tex._levels) {
      tex._levels = [];
    }
    if (!tex._levels[0]) {
      tex._levels[0] = [];
    }
    tex._levels[0][face] = pixels;
  }
  function prefilterCubemap(options) {
    var device = options.device;
    var sourceCubemap = options.sourceCubemap;
    var method = options.method;
    var samples = options.samples;
    var cpuSync = options.cpuSync;
    if (cpuSync && !sourceCubemap._levels[0]) {
      console.error("ERROR: prefilter: cubemap must have _levels");
      return;
    }
    var chunks = pc.shaderChunks;
    var rgbmSource = sourceCubemap.rgbm;
    var shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.rgbmPS + chunks.prefilterCubemapPS.replace(/\$METHOD/g, method === 0 ? "cos" : "phong").replace(/\$NUMSAMPLES/g, samples).replace(/\$textureCube/g, rgbmSource ? "textureCubeRGBM" : "textureCube"), "prefilter" + method + "" + samples + "" + rgbmSource);
    var shader2 = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.outputCubemapPS, "outputCubemap");
    var constantTexSource = device.scope.resolve("source");
    var constantParams = device.scope.resolve("params");
    var params = new pc.Vec4;
    var size = sourceCubemap.width;
    var format = sourceCubemap.format;
    var cmapsList = [[], options.filteredFixed, options.filteredRgbm, options.filteredFixedRgbm];
    var gloss = method === 0 ? [0.9, 0.85, 0.7, 0.4, 0.25] : [512, 128, 32, 8, 2];
    var mipSize = [64, 32, 16, 8, 4];
    var numMips = 5;
    var targ;
    var i, face, pass;
    var rgbFormat = format === pc.PIXELFORMAT_R8_G8_B8;
    var isImg = false;
    var nextCubemap, cubemap;
    if (cpuSync) {
      isImg = sourceCubemap._levels[0][0] instanceof HTMLImageElement;
    }
    if ((rgbFormat || isImg) && cpuSync) {
      format = pc.PIXELFORMAT_R8_G8_B8_A8;
      nextCubemap = new pc.Texture(device, {cubemap:true, rgbm:rgbmSource, format:format, width:size, height:size, mipmaps:false});
      nextCubemap.name = "prefiltered-cube";
      for (face = 0; face < 6; face++) {
        targ = new pc.RenderTarget(device, nextCubemap, {face:face, depth:false});
        params.x = face;
        params.y = 0;
        constantTexSource.setValue(sourceCubemap);
        constantParams.setValue(params.data);
        pc.drawQuadWithShader(device, targ, shader2);
        syncToCpu(device, targ, face);
      }
      sourceCubemap = nextCubemap;
    }
    if (size > 128) {
      var log128 = Math.round(Math.log2(128));
      var logSize = Math.round(Math.log2(size));
      var steps = logSize - log128;
      for (i = 0; i < steps; i++) {
        size = sourceCubemap.width * 0.5;
        var sampleGloss = method === 0 ? 1 : Math.pow(2, Math.round(Math.log2(gloss[0]) + (steps - i) * 2));
        nextCubemap = new pc.Texture(device, {cubemap:true, rgbm:rgbmSource, format:format, width:size, height:size, mipmaps:false});
        nextCubemap.name = "prefiltered-cube";
        for (face = 0; face < 6; face++) {
          targ = new pc.RenderTarget(device, nextCubemap, {face:face, depth:false});
          params.x = face;
          params.y = sampleGloss;
          params.z = size;
          params.w = rgbmSource ? 3 : 0;
          constantTexSource.setValue(sourceCubemap);
          constantParams.setValue(params.data);
          pc.drawQuadWithShader(device, targ, shader2);
          if (i === steps - 1 && cpuSync) {
            syncToCpu(device, targ, face);
          }
        }
        sourceCubemap = nextCubemap;
      }
    }
    options.sourceCubemap = sourceCubemap;
    var sourceCubemapRgbm = null;
    if (!rgbmSource && options.filteredFixedRgbm) {
      nextCubemap = new pc.Texture(device, {cubemap:true, rgbm:true, format:pc.PIXELFORMAT_R8_G8_B8_A8, width:size, height:size, mipmaps:false});
      nextCubemap.name = "prefiltered-cube";
      for (face = 0; face < 6; face++) {
        targ = new pc.RenderTarget(device, nextCubemap, {face:face, depth:false});
        params.x = face;
        params.w = 2;
        constantTexSource.setValue(sourceCubemap);
        constantParams.setValue(params.data);
        pc.drawQuadWithShader(device, targ, shader2);
        syncToCpu(device, targ, face);
      }
      sourceCubemapRgbm = nextCubemap;
    }
    var unblurredGloss = method === 0 ? 1 : 2048;
    var startPass = method === 0 ? 0 : -1;
    cmapsList[startPass] = [];
    for (i = 0; i < numMips; i++) {
      for (pass = startPass; pass < cmapsList.length; pass++) {
        if (cmapsList[pass] != null) {
          cmapsList[pass][i] = new pc.Texture(device, {cubemap:true, rgbm:pass < 2 ? rgbmSource : true, format:pass < 2 ? format : pc.PIXELFORMAT_R8_G8_B8_A8, fixCubemapSeams:pass === 1 || pass === 3, width:mipSize[i], height:mipSize[i], mipmaps:false});
          cmapsList[pass][i].name = "prefiltered-cube";
        }
      }
    }
    for (pass = startPass; pass < cmapsList.length; pass++) {
      if (cmapsList[pass] != null) {
        if (pass > 1 && rgbmSource) {
          cmapsList[pass] = cmapsList[pass - 2];
          continue;
        }
        for (i = 0; i < numMips; i++) {
          for (face = 0; face < 6; face++) {
            targ = new pc.RenderTarget(device, cmapsList[pass][i], {face:face, depth:false});
            params.x = face;
            params.y = pass < 0 ? unblurredGloss : gloss[i];
            params.z = mipSize[i];
            params.w = rgbmSource ? 3 : pass;
            constantTexSource.setValue(i === 0 ? sourceCubemap : method === 0 ? cmapsList[0][i - 1] : cmapsList[-1][i - 1]);
            constantParams.setValue(params.data);
            pc.drawQuadWithShader(device, targ, shader);
            if (cpuSync) {
              syncToCpu(device, targ, face);
            }
          }
        }
      }
    }
    options.filtered = cmapsList[0];
    var mips;
    if (cpuSync && options.singleFilteredFixed) {
      mips = [sourceCubemap, options.filteredFixed[0], options.filteredFixed[1], options.filteredFixed[2], options.filteredFixed[3], options.filteredFixed[4], options.filteredFixed[5]];
      cubemap = new pc.Texture(device, {cubemap:true, rgbm:rgbmSource, fixCubemapSeams:true, format:format, width:128, height:128, addressU:pc.ADDRESS_CLAMP_TO_EDGE, addressV:pc.ADDRESS_CLAMP_TO_EDGE});
      cubemap.name = "prefiltered-cube";
      for (i = 0; i < 6; i++) {
        cubemap._levels[i] = mips[i]._levels[0];
      }
      cubemap.upload();
      cubemap._prefilteredMips = true;
      options.singleFilteredFixed = cubemap;
    }
    if (cpuSync && options.singleFilteredFixedRgbm && options.filteredFixedRgbm) {
      mips = [sourceCubemapRgbm, options.filteredFixedRgbm[0], options.filteredFixedRgbm[1], options.filteredFixedRgbm[2], options.filteredFixedRgbm[3], options.filteredFixedRgbm[4], options.filteredFixedRgbm[5]];
      cubemap = new pc.Texture(device, {cubemap:true, rgbm:true, fixCubemapSeams:true, format:pc.PIXELFORMAT_R8_G8_B8_A8, width:128, height:128, addressU:pc.ADDRESS_CLAMP_TO_EDGE, addressV:pc.ADDRESS_CLAMP_TO_EDGE});
      cubemap.name = "prefiltered-cube";
      for (i = 0; i < 6; i++) {
        cubemap._levels[i] = mips[i]._levels[0];
      }
      cubemap.upload();
      cubemap._prefilteredMips = true;
      options.singleFilteredFixedRgbm = cubemap;
    }
  }
  function areaElement(x, y) {
    return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
  }
  function texelCoordSolidAngle(u, v, size) {
    var _u = 2.0 * (u + 0.5) / size - 1.0;
    var _v = 2.0 * (v + 0.5) / size - 1.0;
    _u *= 1.0 - 1.0 / size;
    _v *= 1.0 - 1.0 / size;
    var invResolution = 1.0 / size;
    var x0 = _u - invResolution;
    var y0 = _v - invResolution;
    var x1 = _u + invResolution;
    var y1 = _v + invResolution;
    var solidAngle = areaElement(x0, y0) - areaElement(x0, y1) - areaElement(x1, y0) + areaElement(x1, y1);
    if (u === 0 && v === 0 || u === size - 1 && v === 0 || u === 0 && v === size - 1 || u === size - 1 && v === size - 1) {
      solidAngle /= 3;
    } else {
      if (u === 0 || v === 0 || u === size - 1 || v === size - 1) {
        solidAngle *= 0.5;
      }
    }
    return solidAngle;
  }
  function shFromCubemap(source, dontFlipX) {
    var face;
    var cubeSize = source.width;
    var x, y;
    if (source.format != pc.PIXELFORMAT_R8_G8_B8_A8) {
      console.error("ERROR: SH: cubemap must be RGBA8");
      return;
    }
    if (!source._levels[0]) {
      console.error("ERROR: SH: cubemap must be synced to CPU");
      return;
    }
    if (!source._levels[0][0].length) {
      if (source._levels[0][0] instanceof HTMLImageElement) {
        var device = pc.Application.getApplication().graphicsDevice;
        var gl = device.gl;
        var chunks = pc.shaderChunks;
        var shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.fullscreenQuadPS, "fsQuadSimple");
        var constantTexSource = device.scope.resolve("source");
        for (face = 0; face < 6; face++) {
          var img = source._levels[0][face];
          var tex = new pc.Texture(device, {cubemap:false, rgbm:false, format:source.format, width:cubeSize, height:cubeSize, mipmaps:false});
          tex.name = "prefiltered-cube";
          tex._levels[0] = img;
          tex.upload();
          var tex2 = new pc.Texture(device, {cubemap:false, rgbm:false, format:source.format, width:cubeSize, height:cubeSize, mipmaps:false});
          tex2.name = "prefiltered-cube";
          var targ = new pc.RenderTarget(device, tex2, {depth:false});
          constantTexSource.setValue(tex);
          pc.drawQuadWithShader(device, targ, shader);
          var pixels = new Uint8Array(cubeSize * cubeSize * 4);
          gl.bindFramebuffer(gl.FRAMEBUFFER, targ._glFrameBuffer);
          gl.readPixels(0, 0, tex.width, tex.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
          source._levels[0][face] = pixels;
        }
      } else {
        console.error("ERROR: SH: cubemap must be composed of arrays or images");
        return;
      }
    }
    var dirs = [];
    for (y = 0; y < cubeSize; y++) {
      for (x = 0; x < cubeSize; x++) {
        var u = x / (cubeSize - 1) * 2 - 1;
        var v = y / (cubeSize - 1) * 2 - 1;
        dirs[y * cubeSize + x] = (new pc.Vec3(u, v, 1.0)).normalize();
      }
    }
    var sh = new Float32Array(9 * 3);
    var coef1 = 0;
    var coef2 = 1 * 3;
    var coef3 = 2 * 3;
    var coef4 = 3 * 3;
    var coef5 = 4 * 3;
    var coef6 = 5 * 3;
    var coef7 = 6 * 3;
    var coef8 = 7 * 3;
    var coef9 = 8 * 3;
    var nx = 0;
    var px = 1;
    var ny = 2;
    var py = 3;
    var nz = 4;
    var pz = 5;
    var addr, c, a, value, weight, dir, dx, dy, dz;
    var weight1, weight2, weight3, weight4, weight5;
    var accum = 0;
    for (face = 0; face < 6; face++) {
      for (y = 0; y < cubeSize; y++) {
        for (x = 0; x < cubeSize; x++) {
          addr = y * cubeSize + x;
          weight = texelCoordSolidAngle(x, y, cubeSize);
          weight1 = weight * 4 / 17;
          weight2 = weight * 8 / 17;
          weight3 = weight * 15 / 17;
          weight4 = weight * 5 / 68;
          weight5 = weight * 15 / 68;
          dir = dirs[addr];
          if (face == nx) {
            dx = dir.z;
            dy = -dir.y;
            dz = -dir.x;
          } else {
            if (face == px) {
              dx = -dir.z;
              dy = -dir.y;
              dz = dir.x;
            } else {
              if (face == ny) {
                dx = dir.x;
                dy = dir.z;
                dz = dir.y;
              } else {
                if (face == py) {
                  dx = dir.x;
                  dy = -dir.z;
                  dz = -dir.y;
                } else {
                  if (face == nz) {
                    dx = dir.x;
                    dy = -dir.y;
                    dz = dir.z;
                  } else {
                    if (face == pz) {
                      dx = -dir.x;
                      dy = -dir.y;
                      dz = -dir.z;
                    }
                  }
                }
              }
            }
          }
          if (!dontFlipX) {
            dx = -dx;
          }
          a = source._levels[0][face][addr * 4 + 3] / 255.0;
          for (c = 0; c < 3; c++) {
            value = source._levels[0][face][addr * 4 + c] / 255.0;
            if (source.rgbm) {
              value *= a * 8.0;
              value *= value;
            } else {
              value = Math.pow(value, 2.2);
            }
            sh[coef1 + c] += value * weight1;
            sh[coef2 + c] += value * weight2 * dx;
            sh[coef3 + c] += value * weight2 * dy;
            sh[coef4 + c] += value * weight2 * dz;
            sh[coef5 + c] += value * weight3 * dx * dz;
            sh[coef6 + c] += value * weight3 * dz * dy;
            sh[coef7 + c] += value * weight3 * dy * dx;
            sh[coef8 + c] += value * weight4 * (3.0 * dz * dz - 1.0);
            sh[coef9 + c] += value * weight5 * (dx * dx - dy * dy);
            accum += weight;
          }
        }
      }
    }
    for (c = 0; c < sh.length; c++) {
      sh[c] *= 4 * Math.PI / accum;
    }
    return sh;
  }
  return {prefilterCubemap:prefilterCubemap, shFromCubemap:shFromCubemap};
}());
Object.assign(pc, function() {
  var dpMult = 2.0;
  function paraboloidFromCubemap(device, sourceCubemap, fixSeamsAmount, dontFlipX) {
    var chunks = pc.shaderChunks;
    var shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, (sourceCubemap.fixCubemapSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS) + chunks.genParaboloidPS, "genParaboloid");
    var constantTexSource = device.scope.resolve("source");
    var constantParams = device.scope.resolve("params");
    var params = new pc.Vec4;
    var size = sourceCubemap.width;
    var rgbmSource = sourceCubemap.rgbm;
    var format = sourceCubemap.format;
    size = Math.max(size, 8) * dpMult;
    var tex = new pc.Texture(device, {rgbm:rgbmSource, format:format, width:size * 2, height:size, mipmaps:false});
    tex.name = "paraboloid";
    var targ = new pc.RenderTarget(device, tex, {depth:false});
    params.x = fixSeamsAmount;
    params.y = dontFlipX ? -1.0 : 1.0;
    constantTexSource.setValue(sourceCubemap);
    constantParams.setValue(params.data);
    pc.drawQuadWithShader(device, targ, shader);
    return tex;
  }
  function getDpAtlasRect(rect, mip) {
    rect.x = pc.math.clamp(mip - 2.0, 0, 1) * 0.5;
    var t = mip - rect.x * 6.0;
    var i = 1.0 - rect.x;
    rect.y = Math.min(t * 0.5, 0.75) * i + rect.x;
    rect.z = (1.0 - pc.math.clamp(t, 0, 1) * 0.5) * i;
    rect.w = rect.z * 0.5;
    return 1.0 / rect.z;
  }
  function generateDpAtlas(device, sixCubemaps, dontFlipX) {
    var dp, rect;
    rect = new pc.Vec4;
    var params = new pc.Vec4;
    var size = sixCubemaps[0].width * 2 * dpMult;
    var chunks = pc.shaderChunks;
    var shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.dpAtlasQuadPS, "dpAtlasQuad");
    var constantTexSource = device.scope.resolve("source");
    var constantParams = device.scope.resolve("params");
    var tex = new pc.Texture(device, {rgbm:sixCubemaps[0].rgbm, format:sixCubemaps[0].format, width:size, height:size, mipmaps:false});
    tex.name = "paraboloid";
    var targ = new pc.RenderTarget(device, tex, {depth:false});
    var borderSize = 2;
    var mip0Width = size;
    var scaleFactor = (mip0Width + borderSize) / mip0Width - 1;
    var scaleAmount;
    for (var i = 0; i < 6; i++) {
      dp = pc.paraboloidFromCubemap(device, sixCubemaps[i], i, dontFlipX);
      constantTexSource.setValue(dp);
      scaleAmount = getDpAtlasRect(rect, i);
      params.x = scaleAmount * scaleFactor;
      params.y = params.x * 2;
      params.x += 1;
      params.y += 1;
      constantParams.setValue(params.data);
      rect.x *= size;
      rect.y *= size;
      rect.z *= size;
      rect.w *= size;
      pc.drawQuadWithShader(device, targ, shader, rect);
    }
    return tex;
  }
  return {paraboloidFromCubemap:paraboloidFromCubemap, generateDpAtlas:generateDpAtlas};
}());
pc.shaderChunks.alphaTestPS = "uniform float alpha_ref;\nvoid alphaTest(float a) {\n    if (a < alpha_ref) discard;\n}\n";
pc.shaderChunks.ambientConstantPS = "\nvoid addAmbient() {\n    dDiffuseLight += light_globalAmbient;\n}\n";
pc.shaderChunks.ambientPrefilteredCubePS = "#ifndef PMREM4\n#define PMREM4\nuniform samplerCube texture_prefilteredCubeMap4;\n#endif\nvoid addAmbient() {\n    vec3 fixedReflDir = fixSeamsStatic(dNormalW, 1.0 - 1.0 / 4.0);\n    fixedReflDir.x *= -1.0;\n    dDiffuseLight += processEnvironment($DECODE(textureCube(texture_prefilteredCubeMap4, fixedReflDir)).rgb);\n}\n";
pc.shaderChunks.ambientPrefilteredCubeLodPS = "#ifndef PMREM4\n#define PMREM4\n#extension GL_EXT_shader_texture_lod : enable\nuniform samplerCube texture_prefilteredCubeMap128;\n#endif\nvoid addAmbient() {\n    vec3 fixedReflDir = fixSeamsStatic(dNormalW, 1.0 - 1.0 / 4.0);\n    fixedReflDir.x *= -1.0;\n    dDiffuseLight += processEnvironment($DECODE( textureCubeLodEXT(texture_prefilteredCubeMap128, fixedReflDir, 5.0) ).rgb);\n}\n";
pc.shaderChunks.ambientSHPS = "uniform vec3 ambientSH[9];\nvoid addAmbient() {\n    vec3 n = dNormalW;\n    vec3 color =\n                        ambientSH[0] +\n                        ambientSH[1] * n.x +\n                        ambientSH[2] * n.y +\n                        ambientSH[3] * n.z +\n                        ambientSH[4] * n.x * n.z +\n                        ambientSH[5] * n.z * n.y +\n                        ambientSH[6] * n.y * n.x +\n                        ambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n                        ambientSH[8] * (n.x * n.x - n.y * n.y);\n    dDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n}\n";
pc.shaderChunks.aoPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_aoMap;\n#endif\nvoid applyAO() {\n    dAo = 1.0;\n    #ifdef MAPTEXTURE\n        dAo *= texture2D(texture_aoMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        dAo *= saturate(vVertexColor.$VC);\n    #endif\n    dDiffuseLight *= dAo;\n}\n";
pc.shaderChunks.aoSpecOccPS = "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n    // approximated specular occlusion from AO\n    float specPow = exp2(dGlossiness * 11.0);\n    // http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx\n    float specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n    specOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n";
pc.shaderChunks.aoSpecOccConstPS = "void occludeSpecular() {\n    // approximated specular occlusion from AO\n    float specPow = exp2(dGlossiness * 11.0);\n    // http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx\n    float specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n";
pc.shaderChunks.aoSpecOccConstSimplePS = "void occludeSpecular() {\n    float specOcc = dAo;\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n";
pc.shaderChunks.aoSpecOccSimplePS = "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n    float specOcc = mix(1.0, dAo, material_occludeSpecularIntensity);\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n";
pc.shaderChunks.bakeDirLmEndPS = "\n    vec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n    if (bakeDir > 0.5) {\n        if (dAtten > 0.00001) {\n            dirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n            dAtten = saturate(dAtten);\n            gl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n            gl_FragColor.a = dirLm.w + dAtten;\n            gl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n        } else {\n            gl_FragColor = dirLm;\n        }\n    } else {\n        gl_FragColor.rgb = dirLm.xyz;\n        gl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n    }\n";
pc.shaderChunks.bakeLmEndPS = "\ngl_FragColor.rgb = dDiffuseLight;\ngl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\ngl_FragColor.rgb /= 8.0;\ngl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\ngl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\ngl_FragColor.rgb /= gl_FragColor.a;\n";
pc.shaderChunks.basePS = "\nuniform vec3 view_position;\nuniform vec3 light_globalAmbient;\nfloat square(float x) {\n    return x*x;\n}\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x) {\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n";
pc.shaderChunks.baseVS = "\nattribute vec3 vertex_position;\nattribute vec3 vertex_normal;\nattribute vec4 vertex_tangent;\nattribute vec2 vertex_texCoord0;\nattribute vec2 vertex_texCoord1;\nattribute vec4 vertex_color;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nvec3 dPositionW;\nmat4 dModelMatrix;\nmat3 dNormalMatrix;\nvec3 dLightPosW;\nvec3 dLightDirNormW;\nvec3 dNormalW;\n";
pc.shaderChunks.baseNineSlicedPS = "#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";
pc.shaderChunks.baseNineSlicedVS = "#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n";
pc.shaderChunks.baseNineSlicedTiledPS = "#define NINESLICED\n#define NINESLICETILED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";
pc.shaderChunks.biasConstPS = "#define SHADOWBIAS\nfloat getShadowBias(float resolution, float maxBias) {\n    return maxBias;\n}\n";
pc.shaderChunks.blurVSMPS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\n#ifdef PACKED\nfloat decodeFloatRG(vec2 rg) {\n    return rg.y*(1.0/255.0) + rg.x;\n}\nvec2 encodeFloatRG( float v ) {\n  vec2 enc = vec2(1.0, 255.0) * v;\n  enc = fract(enc);\n  enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n  return enc;\n}\n#endif\nvoid main(void) {\n    vec3 moments = vec3(0.0);\n    vec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n    for(int i=0; i<SAMPLES; i++) {\n        vec4 c = texture2D(source, uv + pixelOffset * float(i));\n        #ifdef PACKED\n        c.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\n        #endif\n        #ifdef GAUSS\n        moments += c.xyz * weight[i];\n        #else\n        moments += c.xyz;\n        #endif\n    }\n    #ifndef GAUSS\n    moments /= float(SAMPLES);\n    #endif\n    #ifdef PACKED\n    gl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\n    #else\n    gl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n    #endif\n}\n";
pc.shaderChunks.combineDiffusePS = "vec3 combineColor() {\n    return dAlbedo * dDiffuseLight;\n}\n";
pc.shaderChunks.combineDiffuseSpecularPS = "vec3 combineColor() {\n    return mix(dAlbedo * dDiffuseLight, dSpecularLight + dReflection.rgb * dReflection.a, dSpecularity);\n}\n";
pc.shaderChunks.combineDiffuseSpecularNoConservePS = "vec3 combineColor() {\n    return dAlbedo * dDiffuseLight + (dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity;\n}\n";
pc.shaderChunks.combineDiffuseSpecularNoReflPS = "vec3 combineColor() {\n    return dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity;\n}\n";
pc.shaderChunks.combineDiffuseSpecularNoReflSeparateAmbientPS = "uniform vec3 material_ambient;\nvec3 combineColor() {\n    return (dDiffuseLight - light_globalAmbient) * dAlbedo + dSpecularLight * dSpecularity + material_ambient * light_globalAmbient;\n}\n";
pc.shaderChunks.combineDiffuseSpecularOldPS = "vec3 combineColor() {\n    return mix(dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity, dReflection.rgb, dReflection.a);\n}\n";
pc.shaderChunks.cookiePS = "vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n    return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    projPos.xy += cookieOffset;\n    vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n    return mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    projPos.xy += cookieOffset;\n    if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n    vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n    return mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n    return mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n";
pc.shaderChunks.cubeMapProjectBoxPS = "uniform vec3 envBoxMin, envBoxMax;\nvec3 cubeMapProject(vec3 nrdir) {\n    vec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n    vec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n    vec3 rbminmax;\n    rbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n    rbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n    rbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n    float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n    vec3 posonbox = vPositionW + nrdir * fa;\n    vec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n    return posonbox - envBoxPos;\n}\n";
pc.shaderChunks.cubeMapProjectNonePS = "vec3 cubeMapProject(vec3 dir) {\n    return dir;\n}\n";
pc.shaderChunks.diffusePS = "#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseMap;\n#endif\nvoid getAlbedo() {\n    dAlbedo = vec3(1.0);\n    #ifdef MAPCOLOR\n        dAlbedo *= material_diffuse.rgb;\n    #endif\n    #ifdef MAPTEXTURE\n        dAlbedo *= texture2DSRGB(texture_diffuseMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        dAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n    #endif\n}\n";
pc.shaderChunks.dilatePS = "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nvoid main(void) {\n    vec4 c = texture2D(source, vUv0);\n    c = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);\n    gl_FragColor = c;\n}\n";
pc.shaderChunks.dpAtlasQuadPS = "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec4 params;\nvoid main(void) {\n    vec2 uv = vUv0;\n    uv = uv * 2.0 - vec2(1.0);\n    uv *= params.xy;\n    uv = uv * 0.5 + 0.5;\n    gl_FragColor = texture2D(source, uv);\n}\n";
pc.shaderChunks.emissivePS = "#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_emissiveMap;\n#endif\nvec3 getEmission() {\n    vec3 emission = vec3(1.0);\n    #ifdef MAPFLOAT\n        emission *= material_emissiveIntensity;\n    #endif\n    #ifdef MAPCOLOR\n        emission *= material_emissive;\n    #endif\n    #ifdef MAPTEXTURE\n        emission *= $texture2DSAMPLE(texture_emissiveMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        emission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n    #endif\n    return emission;\n}\n";
pc.shaderChunks.endPS = "   gl_FragColor.rgb = combineColor();\n   gl_FragColor.rgb += getEmission();\n   gl_FragColor.rgb = addFog(gl_FragColor.rgb);\n   #ifndef HDR\n    gl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n    gl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n   #endif\n";
pc.shaderChunks.envConstPS = "vec3 processEnvironment(vec3 color) {\n    return color;\n}\n";
pc.shaderChunks.envMultiplyPS = "uniform float skyboxIntensity;\nvec3 processEnvironment(vec3 color) {\n    return color * skyboxIntensity;\n}\n";
pc.shaderChunks.extensionPS = "";
pc.shaderChunks.extensionVS = "\n";
pc.shaderChunks.falloffInvSquaredPS = "float getFalloffInvSquared(float lightRadius) {\n    float sqrDist = dot(dLightDirW, dLightDirW);\n    float falloff = 1.0 / (sqrDist + 1.0);\n    float invRadius = 1.0 / lightRadius;\n    falloff *= 16.0;\n    falloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n    return falloff;\n}\n";
pc.shaderChunks.falloffLinearPS = "float getFalloffLinear(float lightRadius) {\n    float d = length(dLightDirW);\n    return max(((lightRadius - d) / lightRadius), 0.0);\n}\n";
pc.shaderChunks.fixCubemapSeamsNonePS = "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n    return vec;\n}\nvec3 fixSeams(vec3 vec) {\n    return vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n    return vec;\n}\n";
pc.shaderChunks.fixCubemapSeamsStretchPS = "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n    float scale = 1.0 - exp2(mipmapIndex) / 128.0;\n    float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n    if (abs(vec.x) != M) vec.x *= scale;\n    if (abs(vec.y) != M) vec.y *= scale;\n    if (abs(vec.z) != M) vec.z *= scale;\n    return vec;\n}\nvec3 fixSeams(vec3 vec) {\n    float scale = 1.0 - 1.0 / 128.0;\n    float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n    if (abs(vec.x) != M) vec.x *= scale;\n    if (abs(vec.y) != M) vec.y *= scale;\n    if (abs(vec.z) != M) vec.z *= scale;\n    return vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n    float scale = invRecMipSize;\n    float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n    if (abs(vec.x) != M) vec.x *= scale;\n    if (abs(vec.y) != M) vec.y *= scale;\n    if (abs(vec.z) != M) vec.z *= scale;\n    return vec;\n}\n";
pc.shaderChunks.fogExpPS = "uniform vec3 fog_color;\nuniform float fog_density;\nvec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = exp(-depth * fog_density);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(fog_color, color, fogFactor);\n}\n";
pc.shaderChunks.fogExp2PS = "uniform vec3 fog_color;\nuniform float fog_density;\nvec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = exp(-depth * depth * fog_density * fog_density);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(fog_color, color, fogFactor);\n}\n";
pc.shaderChunks.fogLinearPS = "uniform vec3 fog_color;\nuniform float fog_start;\nuniform float fog_end;\nvec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = (fog_end - depth) / (fog_end - fog_start);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    fogFactor = gammaCorrectInput(fogFactor);\n    return mix(fog_color, color, fogFactor);\n}\n";
pc.shaderChunks.fogNonePS = "vec3 addFog(vec3 color) {\n    return color;\n}\n";
pc.shaderChunks.fresnelSchlickPS = "// Schlick's approximation\nuniform float material_fresnelFactor; // unused\nvoid getFresnel() {\n    float fresnel = 1.0 - max(dot(dNormalW, dViewDirW), 0.0);\n    float fresnel2 = fresnel * fresnel;\n    fresnel *= fresnel2 * fresnel2;\n    fresnel *= dGlossiness * dGlossiness;\n    dSpecularity = dSpecularity + (1.0 - dSpecularity) * fresnel;\n}\n";
pc.shaderChunks.fullscreenQuadPS = "varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n    gl_FragColor = texture2D(source, vUv0);\n}\n";
pc.shaderChunks.fullscreenQuadVS = "attribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n    gl_Position = vec4(vertex_position, 0.5, 1.0);\n    vUv0 = vertex_position.xy*0.5+0.5;\n}\n";
pc.shaderChunks.gamma1_0PS = "vec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n    return texture2D(tex, uv);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n    return texture2D(tex, uv, bias);\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n    return textureCube(tex, uvw);\n}\nvec3 gammaCorrectOutput(vec3 color) {\n    return color;\n}\nvec3 gammaCorrectInput(vec3 color) {\n    return color;\n}\nfloat gammaCorrectInput(float color) {\n    return color;\n}\nvec4 gammaCorrectInput(vec4 color) {\n    return color;\n}\n";
pc.shaderChunks.gamma2_2PS = "vec3 gammaCorrectInput(vec3 color) {\n    return pow(color, vec3(2.2));\n}\nfloat gammaCorrectInput(float color) {\n    return pow(color, 2.2);\n}\nvec4 gammaCorrectInput(vec4 color) {\n    return vec4(pow(color.rgb, vec3(2.2)), color.a);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n    vec4 rgba = texture2D(tex, uv);\n    rgba.rgb = gammaCorrectInput(rgba.rgb);\n    return rgba;\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n    vec4 rgba = texture2D(tex, uv, bias);\n    rgba.rgb = gammaCorrectInput(rgba.rgb);\n    return rgba;\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n    vec4 rgba = textureCube(tex, uvw);\n    rgba.rgb = gammaCorrectInput(rgba.rgb);\n    return rgba;\n}\nvec3 gammaCorrectOutput(vec3 color) {\n#ifdef HDR\n    return color;\n#else\n    color += vec3(0.0000001);\n    return pow(color, vec3(0.45));\n#endif\n}\n";
pc.shaderChunks.genParaboloidPS = "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params; // x = mip\nvoid main(void) {\n    vec2 uv = vUv0;\n    float side = uv.x < 0.5? 1.0 : -1.0;\n    vec2 tc;\n    tc.x = fract(uv.x * 2.0) * 2.0 - 1.0;\n    tc.y = uv.y * 2.0 - 1.0;\n    // scale projection a bit to have a little overlap for filtering\n    const float scale = 1.1;\n    tc *= scale;\n    vec3 dir;\n    dir.y = (dot(tc, tc) - 1.0) * side; // from 1.0 center to 0.0 borders quadratically\n    dir.xz = tc * -2.0;\n    dir.x *= -side * params.y; // flip original cubemap x instead of doing it at runtime\n    dir = fixSeams(dir, params.x);\n    vec4 color = textureCube(source, dir, -100.0);\n    gl_FragColor = color;\n}\n";
pc.shaderChunks.gles3PS = "#define varying in\nout highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\n#define GL2\n";
pc.shaderChunks.gles3VS = "#define attribute in\n#define varying out\n#define texture2D texture\n#define GL2\n#define VERTEXSHADER\n";
pc.shaderChunks.glossPS = "#ifdef MAPFLOAT\nuniform float material_shininess;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_glossMap;\n#endif\nvoid getGlossiness() {\n    dGlossiness = 1.0;\n    #ifdef MAPFLOAT\n        dGlossiness *= material_shininess;\n    #endif\n    #ifdef MAPTEXTURE\n        dGlossiness *= texture2D(texture_glossMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        dGlossiness *= saturate(vVertexColor.$VC);\n    #endif\n    dGlossiness += 0.0000001;\n}\n";
pc.shaderChunks.instancingVS = "\nattribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\n";
pc.shaderChunks.lightDiffuseLambertPS = "float getLightDiffuse() {\n    return max(dot(dNormalW, -dLightDirNormW), 0.0);\n}\n";
pc.shaderChunks.lightDirPointPS = "void getLightDirPoint(vec3 lightPosW) {\n    dLightDirW = vPositionW - lightPosW;\n    dLightDirNormW = normalize(dLightDirW);\n    dLightPosW = lightPosW;\n}\n";
pc.shaderChunks.lightmapDirPS = "uniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\nvoid addLightMap() {\n    vec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n    vec4 dir = texture2D(texture_dirLightMap, $UV);\n    if (dot(dir.xyz,vec3(1.0)) < 0.00001) {\n        dDiffuseLight += color;\n        return;\n    }\n    dLightDirNormW = normalize(dir.xyz * 2.0 - vec3(1.0));\n    float vlight = saturate(dot(dLightDirNormW, -dVertexNormalW));\n    float flight = saturate(dot(dLightDirNormW, -dNormalW));\n    float nlight = (flight / max(vlight,0.01)) * 0.5;\n    dDiffuseLight += color * nlight * 2.0;\n}\nvoid addDirLightMap() {\n    vec4 dir = texture2D(texture_dirLightMap, $UV);\n    if (dot(dir.xyz,vec3(1.0)) < 0.00001) return;\n    vec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n    dLightDirNormW = normalize(dir.xyz * 2.0 - vec3(1.0));\n    dSpecularLight += vec3(getLightSpecular()) * color;\n}\n";
pc.shaderChunks.lightmapSinglePS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_lightMap;\n#endif\nvoid addLightMap() {\n    vec3 lm = vec3(1.0);\n    #ifdef MAPTEXTURE\n        lm *= $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        lm *= saturate(vVertexColor.$VC);\n    #endif\n    \n    dDiffuseLight += lm;\n}\n";
pc.shaderChunks.lightmapSingleVertPS = "void addLightMap() {\n    dDiffuseLight += saturate(vVertexColor.$CH);\n}\n";
pc.shaderChunks.lightSpecularBlinnPS = "// Energy-conserving (hopefully) Blinn-Phong\nfloat getLightSpecular() {\n    vec3 h = normalize( -dLightDirNormW + dViewDirW );\n    float nh = max( dot( h, dNormalW ), 0.0 );\n    float specPow = exp2(dGlossiness * 11.0); // glossiness is linear, power is not; 0 - 2048\n    specPow = antiAliasGlossiness(specPow);\n    // Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little\n    specPow = max(specPow, 0.0001);\n    return pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\n";
pc.shaderChunks.lightSpecularPhongPS = "float getLightSpecular() {\n    float specPow = dGlossiness;\n    specPow = antiAliasGlossiness(specPow);\n    // Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little\n    return pow(max(dot(dReflDirW, -dLightDirNormW), 0.0), specPow + 0.0001);\n}\n";
pc.shaderChunks.metalnessPS = "void processMetalness(float metalness) {\n    const float dielectricF0 = 0.04;\n    dSpecularity = mix(vec3(dielectricF0), dAlbedo, metalness);\n    dAlbedo *= 1.0 - metalness;\n}\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_metalnessMap;\n#endif\nvoid getSpecularity() {\n    float metalness = 1.0;\n    #ifdef MAPFLOAT\n        metalness *= material_metalness;\n    #endif\n    #ifdef MAPTEXTURE\n        metalness *= texture2D(texture_metalnessMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        metalness *= saturate(vVertexColor.$VC);\n    #endif\n    processMetalness(metalness);\n}\n";
pc.shaderChunks.msdfPS = "uniform sampler2D texture_msdfMap;\n#ifdef GL_OES_standard_derivatives\n#define USE_FWIDTH\n#endif\n#ifdef GL2\n#define USE_FWIDTH\n#endif\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\nfloat map (float min, float max, float v) {\n    return (v - min) / (max - min);\n}\nuniform float font_sdfIntensity; // intensity is used to boost the value read from the SDF, 0 is no boost, 1.0 is max boost\nuniform float font_pxrange;      // the number of pixels between inside and outside the font in SDF\nuniform float font_textureWidth; // the width of the texture atlas\nuniform vec4 outline_color;\nuniform float outline_thickness;\nuniform vec4 shadow_color;\nuniform vec2 shadow_offset;\nvec4 applyMsdf(vec4 color) {\n    // sample the field\n    vec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n    vec2 uvShdw = vUv0 - shadow_offset;\n    vec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n    // get the signed distance value\n    float sigDist = median(tsample.r, tsample.g, tsample.b);\n    float sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n    #ifdef USE_FWIDTH\n        // smoothing depends on size of texture on screen\n        vec2 w = fwidth(vUv0);\n        float smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, 0.5);\n    #else\n        float font_size = 16.0; // TODO fix this\n        // smoothing gets smaller as the font size gets bigger\n        // don't have fwidth we can approximate from font size, this doesn't account for scaling\n        // so a big font scaled down will be wrong...\n        float smoothing = clamp(font_pxrange / font_size, 0.0, 0.5);\n    #endif\n    float mapMin = 0.05;\n    float mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n    // remap to a smaller range (used on smaller font sizes)\n    float sigDistInner = map(mapMin, mapMax, sigDist);\n    float sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n    sigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n    float center = 0.5;\n    // calculate smoothing and use to generate opacity\n    float inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n    float outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n    float shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n    vec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n    tcolor = mix(tcolor, color, inside);\n    vec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n    tcolor = mix(scolor, tcolor, outline);\n    \n    return tcolor;\n}";
pc.shaderChunks.normalVS = "vec3 getNormal() {\n    #ifdef SKIN\n        dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n    #elif defined(INSTANCING)\n        dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n    #else\n        dNormalMatrix = matrix_normal;\n    #endif\n    return normalize(dNormalMatrix * vertex_normal);\n}\n";
pc.shaderChunks.normalInstancedVS = "vec3 getNormal() {\n    dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n    return normalize(dNormalMatrix * vertex_normal);\n}\n";
pc.shaderChunks.normalMapPS = "uniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\nvoid getNormal() {\n    vec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n    dNormalMap = normalMap;\n    dNormalW = dTBN * normalMap;\n}\n";
pc.shaderChunks.normalMapFloatPS = "uniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\nvoid getNormal() {\n    vec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n    dNormalMap = normalMap;\n    normalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness));\n    dNormalW = dTBN * normalMap;\n}\n";
pc.shaderChunks.normalMapFloatTBNfastPS = "uniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\nvoid getNormal() {\n    vec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n    dNormalMap = normalMap;\n    normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);\n    dNormalW = normalize(dTBN * normalMap);\n}\n";
pc.shaderChunks.normalSkinnedVS = "vec3 getNormal() {\n    dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n    return normalize(dNormalMatrix * vertex_normal);\n}\n";
pc.shaderChunks.normalVertexPS = "void getNormal() {\n    dNormalW = normalize(dVertexNormalW);\n}\n";
pc.shaderChunks.normalXYPS = "vec3 unpackNormal(vec4 nmap) {\n    vec3 normal;\n    normal.xy = nmap.wy * 2.0 - 1.0;\n    normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n    return normal;\n}\n";
pc.shaderChunks.normalXYZPS = "vec3 unpackNormal(vec4 nmap) {\n    return nmap.xyz * 2.0 - 1.0;\n}\n";
pc.shaderChunks.opacityPS = "#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_opacityMap;\n#endif\nvoid getOpacity() {\n    dAlpha = 1.0;\n    #ifdef MAPFLOAT\n        dAlpha *= material_opacity;\n    #endif\n    #ifdef MAPTEXTURE\n        dAlpha *= texture2D(texture_opacityMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        dAlpha *= saturate(vVertexColor.$VC);\n    #endif\n}\n";
pc.shaderChunks.outputAlphaPS = "gl_FragColor.a = dAlpha;\n";
pc.shaderChunks.outputAlphaOpaquePS = "gl_FragColor.a = 1.0;\n";
pc.shaderChunks.outputAlphaPremulPS = "gl_FragColor.rgb *= dAlpha;\ngl_FragColor.a = dAlpha;\n";
pc.shaderChunks.outputCubemapPS = "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params;\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec4 color) { // modified RGBM\n    color.rgb = pow(color.rgb, vec3(0.5));\n    color.rgb *= 1.0 / 8.0;\n    color.a = saturate( max( max( color.r, color.g ), max( color.b, 1.0 / 255.0 ) ) );\n    color.a = ceil(color.a * 255.0) / 255.0;\n    color.rgb /= color.a;\n    return color;\n}\nvoid main(void) {\n    vec2 st = vUv0 * 2.0 - 1.0;\n    float face = params.x;\n    vec3 vec;\n    if (face==0.0) {\n        vec = vec3(1, -st.y, -st.x);\n    } else if (face==1.0) {\n        vec = vec3(-1, -st.y, st.x);\n    } else if (face==2.0) {\n        vec = vec3(st.x, 1, st.y);\n    } else if (face==3.0) {\n        vec = vec3(st.x, -1, -st.y);\n    } else if (face==4.0) {\n        vec = vec3(st.x, -st.y, 1);\n    } else {\n        vec = vec3(-st.x, -st.y, -1);\n    }\n    gl_FragColor = textureCube(source, vec);\n    if (params.w >= 2.0) gl_FragColor = encodeRGBM(gl_FragColor);\n}\n";
pc.shaderChunks.outputTex2DPS = "varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n    gl_FragColor = texture2D(source, vUv0);\n}\n";
pc.shaderChunks.packDepthPS = "// Packing a float in GLSL with multiplication and mod\n// http://blog.gradientstudios.com/2012/08/23/shadow-map-improvement\nvec4 packFloat(float depth) {\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n    const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n    // combination of mod and multiplication and division works better\n    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n    res -= res.xxyz * bit_mask;\n    return res;\n}\n";
pc.shaderChunks.packDepthMaskPS = "vec4 packFloat(float depth) {\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n    const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n    // combination of mod and multiplication and division works better\n    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n    res.x = 0.0;\n    res -= res.xxyz * bit_mask;\n    return res;\n}\n";
pc.shaderChunks.parallaxPS = "uniform sampler2D texture_heightMap;\nuniform float material_heightMapFactor;\nvoid getParallax() {\n    float parallaxScale = material_heightMapFactor;\n    float height = texture2D(texture_heightMap, $UV).$CH;\n    height = height * parallaxScale - parallaxScale*0.5;\n    vec3 viewDirT = dViewDirW * dTBN;\n    viewDirT.z += 0.42;\n    dUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n";
pc.shaderChunks.particlePS = "varying vec4 texCoordsAlphaLife;\nuniform sampler2D colorMap;\nuniform sampler2D internalTex3;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nuniform float softening;\nuniform float colorMult;\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n    const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n    float depth = dot(rgbaDepth, bitShift);\n    return depth;\n}\n#endif\nvoid main(void) {\n    vec4 tex         = texture2DSRGB(colorMap, texCoordsAlphaLife.xy);\n    vec4 ramp     = texture2DSRGB(internalTex3, vec2(texCoordsAlphaLife.w, 0.0));\n    ramp.rgb *= colorMult;\n    ramp.a += texCoordsAlphaLife.z;\n    vec3 rgb =     tex.rgb * ramp.rgb;\n    float a =         tex.a * ramp.a;\n";
pc.shaderChunks.particleVS = "\nvec3 unpack3NFloats(float src) {\n    float r = fract(src);\n    float g = fract(src * 256.0);\n    float b = fract(src * 65536.0);\n    return vec3(r, g, b);\n}\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\nvec4 tex1Dlod_lerp(sampler2D tex, vec2 tc) {\n    return mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\nvec4 tex1Dlod_lerp(sampler2D tex, vec2 tc, out vec3 w) {\n    vec4 a = texture2D(tex,tc);\n    vec4 b = texture2D(tex,tc + graphSampleSize);\n    float c = fract(tc.x*graphNumSamples);\n    vec3 unpackedA = unpack3NFloats(a.w);\n    vec3 unpackedB = unpack3NFloats(b.w);\n    w = mix(unpackedA, unpackedB, c);\n    return mix(a, b, c);\n}\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n    float c = cos(pRotation);\n    float s = sin(pRotation);\n    mat2 m = mat2(c, -s, s, c);\n    rotMatrix = m;\n    return m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n    vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n    return pos;\n}\nvoid main(void) {\n    vec3 meshLocalPos = particle_vertexData.xyz;\n    float id = floor(particle_vertexData.w);\n    float rndFactor = fract(sin(id + 1.0 + seed));\n    vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n    float uv = id / numParticlesPot;\n    readInput(uv);\n    vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used\n    float particleLifetime = lifetime;\n    if (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n    vec2 quadXY = meshLocalPos.xy;\n    float nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n    vec3 paramDiv;\n    vec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n    float scale = params.y;\n    float scaleDiv = paramDiv.x;\n    float alphaDiv = paramDiv.z;\n    scale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n    texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5,    (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0),    nlife);\n    vec3 particlePos = inPos;\n    vec3 particlePosMoved = vec3(0.0);\n    mat2 rotMatrix;\n";
pc.shaderChunks.particleAnimFrameClampVS = "\n    float animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.z), animTexParams.w);\n";
pc.shaderChunks.particleAnimFrameLoopVS = "\n    float animFrame = floor(texCoordsAlphaLife.w * animTexParams.z);\n";
pc.shaderChunks.particleAnimTexVS = "\n    float atlasX = animFrame * animTexParams.x;\n    float atlasY = floor(atlasX) * animTexParams.y;\n    atlasX = fract(atlasX);\n    texCoordsAlphaLife.xy *= animTexParams.xy;\n    texCoordsAlphaLife.xy += vec2(atlasX, atlasY); \n";
pc.shaderChunks.particleInputFloatPS = "void readInput(float uv) {\n    vec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n    vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n    inPos = tex.xyz;\n    inVel = tex2.xyz;\n    inAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n    inShow = tex.w >= 0.0;\n    inLife = tex2.w;\n}\n";
pc.shaderChunks.particleInputRgba8PS = "//RG=X, BA=Y\n//RG=Z, BA=A\n//RGB=V, A=visMode\n//RGBA=life\n#define PI2 6.283185307179586\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\nuniform float maxVel;\nfloat decodeFloatRG(vec2 rg) {\n    return rg.y*(1.0/255.0) + rg.x;\n}\nfloat decodeFloatRGBA( vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\nvoid readInput(float uv) {\n    vec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n    vec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n    vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n    vec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n    inPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n    inPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n    inVel = tex2.xyz;\n    inVel = (inVel - vec3(0.5)) * maxVel;\n    inAngle = decodeFloatRG(tex1.ba) * PI2;\n    inShow = tex2.a > 0.5;\n    inLife = decodeFloatRGBA(tex3);\n    float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n    float maxPosLife = lifetime+1.0;\n    inLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n";
pc.shaderChunks.particleOutputFloatPS = "void writeOutput() {\n    if (gl_FragCoord.y<1.0) {\n        gl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n    } else {\n        gl_FragColor = vec4(outVel, outLife);\n    }\n}\n";
pc.shaderChunks.particleOutputRgba8PS = "uniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\nvec2 encodeFloatRG( float v ) {\n  vec2 enc = vec2(1.0, 255.0) * v;\n  enc = fract(enc);\n  enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n  return enc;\n}\nvec4 encodeFloatRGBA( float v ) {\n  vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n  enc = fract(enc);\n  enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n  return enc;\n}\nvoid writeOutput() {\n    //outPos = (outPos - outBoundsCenter) / outBoundsSize + vec3(0.5);\n    outPos = outPos * outBoundsMul + outBoundsAdd;\n    outAngle = fract(outAngle / PI2);\n    outVel = (outVel / maxVel) + vec3(0.5); // TODO: mul\n    float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n    float maxPosLife = lifetime+1.0;\n    outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n    if (gl_FragCoord.y < 1.0) {\n        gl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n    } else if (gl_FragCoord.y < 2.0) {\n        gl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n    } else if (gl_FragCoord.y < 3.0) {\n        gl_FragColor = vec4(outVel, visMode*0.5+0.5);\n    } else {\n        gl_FragColor = encodeFloatRGBA(outLife);\n    }\n}\n";
pc.shaderChunks.particleUpdaterAABBPS = "uniform mat3 spawnBounds;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n    return emitterPos + spawnBounds * (inBounds - vec3(0.5));\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n    localVelocity -= vec3(0, 0, initialVelocity);\n}\n";
pc.shaderChunks.particleUpdaterEndPS = "\n    writeOutput();\n}\n";
pc.shaderChunks.particleUpdaterInitPS = "varying vec2 vUv0;\nuniform sampler2D particleTexIN;\nuniform sampler2D internalTex0;\nuniform sampler2D internalTex1;\nuniform sampler2D internalTex2;\nuniform mat3 emitterMatrix;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;\nuniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, seed;\nuniform float startAngle, startAngle2;\nuniform float initialVelocity;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n";
pc.shaderChunks.particleUpdaterNoRespawnPS = "    if (outLife >= lifetime) {\n        outLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n        visMode = -1.0;\n    }\n";
pc.shaderChunks.particleUpdaterOnStopPS = "    visMode = outLife < 0.0? -1.0: visMode;\n";
pc.shaderChunks.particleUpdaterRespawnPS = "    if (outLife >= lifetime) {\n        outLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n        visMode = 1.0;\n    }\n    visMode = outLife < 0.0? 1.0: visMode;\n";
pc.shaderChunks.particleUpdaterSpherePS = "uniform float spawnBoundsSphere;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n    float rnd4 = fract(rndFactor * 1000.0);\n    return emitterPos + normalize(inBounds.xyz - vec3(0.5)) * rnd4 * spawnBoundsSphere;\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n    localVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n";
pc.shaderChunks.particleUpdaterStartPS = "float saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\nvec3 unpack3NFloats(float src) {\n    float r = fract(src);\n    float g = fract(src * 256.0);\n    float b = fract(src * 65536.0);\n    return vec3(r, g, b);\n}\nvec3 tex1Dlod_lerp(sampler2D tex, vec2 tc, out vec3 w) {\n    vec4 a = texture2D(tex, tc);\n    vec4 b = texture2D(tex, tc + graphSampleSize);\n    float c = fract(tc.x * graphNumSamples);\n    vec3 unpackedA = unpack3NFloats(a.w);\n    vec3 unpackedB = unpack3NFloats(b.w);\n    w = mix(unpackedA, unpackedB, c);\n    return mix(a.xyz, b.xyz, c);\n}\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n    vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\nvoid main(void)\n{\n    if (gl_FragCoord.x > numParticles) discard;\n    readInput(vUv0.x);\n    visMode = inShow? 1.0 : -1.0;\n    vec4 rndFactor = hash41(gl_FragCoord.x + seed);\n    float particleRate = rate + rateDiv * rndFactor.x;\n    outLife = inLife + delta;\n    float nlife = clamp(outLife / lifetime, 0.0, 1.0);\n    vec3 localVelocityDiv;\n    vec3 velocityDiv;\n    vec3 paramDiv;\n    vec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);\n    vec3 velocity =      tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);\n    vec3 params =        tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n    float rotSpeed = params.x;\n    float rotSpeedDiv = paramDiv.y;\n    localVelocity +=    (localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n    velocity +=         (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n    rotSpeed +=         (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n    addInitialVelocity(localVelocity, rndFactor.xyz);\n    outVel = emitterMatrix * localVelocity.xyz + velocity.xyz * emitterScale;\n    outPos = inPos + outVel * delta;\n    outAngle = inAngle + rotSpeed * delta;\n    bool respawn = outLife <= 0.0 || outLife >= lifetime;\n    outPos = respawn? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : outPos;\n    outAngle = respawn? mix(startAngle, startAngle2, rndFactor.x) : outAngle;\n    outVel = respawn? vec3(0.0) : outVel;\n";
pc.shaderChunks.particle_billboardVS = "\n    quadXY = rotate(quadXY, inAngle, rotMatrix);\n    vec3 localPos = billboard(particlePos, quadXY);\n";
pc.shaderChunks.particle_blendAddPS = "\n    rgb *= saturate(gammaCorrectInput(a));\n    if ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n";
pc.shaderChunks.particle_blendMultiplyPS = "\n    rgb = mix(vec3(1.0), rgb, vec3(a));\n    if (rgb.r + rgb.g + rgb.b > 2.99) discard;\n";
pc.shaderChunks.particle_blendNormalPS = "\n    if (a < 0.01) discard;\n";
pc.shaderChunks.particle_cpuVS = "attribute vec4 particle_vertexData;     // XYZ = world pos, W = life\nattribute vec4 particle_vertexData2;     // X = angle, Y = scale, Z = alpha, W = velocity.x\nattribute vec4 particle_vertexData3;     // XYZ = particle local pos, W = velocity.y\nattribute vec2 particle_vertexData4;     // X = velocity.z, W = particle ID\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\n//uniform float graphSampleSize;\n//uniform float graphNumSamples;\nuniform vec3 wrapBounds, emitterScale;\nuniform sampler2D texLifeAndSourcePosOUT;\nuniform sampler2D internalTex0;\nuniform sampler2D internalTex1;\nuniform sampler2D internalTex2;\nuniform vec3 emitterPos;\nvarying vec4 texCoordsAlphaLife;\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n    float c = cos(pRotation);\n    float s = sin(pRotation);\n    //vec4 rotationMatrix = vec4(c, -s, s, c);\n    mat2 m = mat2(c, -s, s, c);\n    rotMatrix = m;\n    return m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n    vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n    return pos;\n}\nvoid main(void)\n{\n    vec3 particlePos = particle_vertexData.xyz;\n    vec3 inPos = particlePos;\n    vec3 vertPos = particle_vertexData3.xyz;\n    vec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData4.x);\n    vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used\n    vec2 quadXY = vertPos.xy;\n    texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n    mat2 rotMatrix;\n    float inAngle = particle_vertexData2.x;\n    vec3 particlePosMoved = vec3(0.0);\n    vec3 meshLocalPos = particle_vertexData3.xyz;\n";
pc.shaderChunks.particle_cpu_endVS = "\n    localPos *= particle_vertexData2.y * emitterScale;\n    localPos += particlePos;\n    gl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n";
pc.shaderChunks.particle_endPS = "    rgb = addFog(rgb);\n    rgb = toneMap(rgb);\n    rgb = gammaCorrectOutput(rgb);\n    gl_FragColor = vec4(rgb, a);\n}\n";
pc.shaderChunks.particle_endVS = "\n    localPos *= scale * emitterScale;\n    localPos += particlePos;\n    gl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n";
pc.shaderChunks.particle_halflambertPS = "\n    vec3 negNormal = normal*0.5+0.5;\n    vec3 posNormal = -normal*0.5+0.5;\n    negNormal *= negNormal;\n    posNormal *= posNormal;\n";
pc.shaderChunks.particle_initVS = "attribute vec4 particle_vertexData; // XYZ = particle position, W = particle ID + random factor\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform float numParticles, numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale, emitterPos;\nuniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;\nuniform sampler2D particleTexOUT, particleTexIN;\nuniform sampler2D internalTex0;\nuniform sampler2D internalTex1;\nuniform sampler2D internalTex2;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nvarying vec4 texCoordsAlphaLife;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n";
pc.shaderChunks.particle_lambertPS = "\n    vec3 negNormal = max(normal, vec3(0.0));\n    vec3 posNormal = max(-normal, vec3(0.0));\n";
pc.shaderChunks.particle_lightingPS = "\n    vec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n                        negNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n                        negNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n    rgb *= light;\n";
pc.shaderChunks.particle_localShiftVS = "    particlePos += emitterPos;\n";
pc.shaderChunks.particle_meshVS = "\n    vec3 localPos = meshLocalPos;\n    localPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n    localPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n    billboard(particlePos, quadXY);\n";
pc.shaderChunks.particle_normalVS = "\n    Normal = normalize(localPos + matrix_viewInverse[2].xyz);\n";
pc.shaderChunks.particle_normalMapPS = "\n    vec3 normalMap         = normalize( texture2D(normalMap, texCoordsAlphaLife.xy).xyz * 2.0 - 1.0 );\n    vec3 normal = ParticleMat * normalMap;\n";
pc.shaderChunks.particle_pointAlongVS = "    inAngle = atan(velocityV.x, velocityV.y); // not the fastest way, but easier to plug in; TODO: create rot matrix right from vectors\n";
pc.shaderChunks.particle_softPS = "\n    float depth = getLinearScreenDepth();\n    float particleDepth = vDepth;\n    float depthDiff = saturate(abs(particleDepth - depth) * softening);\n    a *= depthDiff;\n";
pc.shaderChunks.particle_softVS = "\n    vDepth = getLinearDepth(localPos);\n";
pc.shaderChunks.particle_stretchVS = "    vec3 moveDir = inVel * stretch;\n    vec3 posPrev = inPos - moveDir;\n    posPrev += particlePosMoved;\n    vec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n    float interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n    particlePos = mix(particlePos, posPrev, interpolation);\n";
pc.shaderChunks.particle_TBNVS = "\n    mat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0,        rotMatrix[1][0], rotMatrix[1][1], 0.0,        0.0, 0.0, 1.0);\n    ParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n";
pc.shaderChunks.particle_wrapVS = "\n    vec3 origParticlePos = particlePos;\n    particlePos -= matrix_model[3].xyz;\n    particlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n    particlePos += matrix_model[3].xyz;\n    particlePosMoved = particlePos - origParticlePos;\n";
pc.shaderChunks.precisionTestPS = "void main(void) {\n    gl_FragColor = vec4(2147483648.0);\n}\n";
pc.shaderChunks.precisionTest2PS = "uniform sampler2D source;\nvec4 packFloat(float depth) {\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n    const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n    res -= res.xxyz * bit_mask;\n    return res;\n}\nvoid main(void) {\n    float c = texture2D(source, vec2(0.0)).r;\n    float diff = abs(c - 2147483648.0) / 2147483648.0;\n    gl_FragColor = packFloat(diff);\n}\n";
pc.shaderChunks.prefilterCubemapPS = "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params;\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\nfloat rnd(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233) * 2.0)) * 43758.5453);\n}\nconst float PI = 3.14159265358979;\nvec3 hemisphereSample_cos(vec2 uv, mat3 vecSpace, vec3 cubeDir, float gloss) { // cos + lerped cone size (better than just lerped)\n    float phi = uv.y * 2.0 * PI;\n    float cosTheta = sqrt(1.0 - uv.x);\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    vec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n    return normalize(mix(vecSpace * sampleDir, cubeDir, params.y));\n}\nvec3 hemisphereSample_phong(vec2 uv, mat3 vecSpace, vec3 cubeDir, float specPow) {\n    float phi = uv.y * 2.0 * PI;\n    float cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    vec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n    return vecSpace * sampleDir;\n}\nmat3 matrixFromVector(vec3 n) { // frisvad\n    float a = 1.0 / (1.0 + n.z);\n    float b = -n.x * n.y * a;\n    vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n    vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n    return mat3(b1, b2, n);\n}\nvec4 encodeRGBM(vec3 color) { // modified RGBM\n    vec4 encoded;\n    encoded.rgb = pow(color.rgb, vec3(0.5));\n    encoded.rgb *= 1.0 / 8.0;\n    encoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n    encoded.a = ceil(encoded.a * 255.0) / 255.0;\n    encoded.rgb /= encoded.a;\n    return encoded;\n}\nvoid main(void) {\n    vec2 st = vUv0 * 2.0 - 1.0;\n    if (params.w==1.0 || params.w==3.0) {\n        st = 2.0 * floor(gl_FragCoord.xy) / (params.z - 1.0) - 1.0;\n    }\n    float face = params.x;\n    vec3 vec;\n    if (face==0.0) {\n        vec = vec3(1, -st.y, -st.x);\n    } else if (face==1.0) {\n        vec = vec3(-1, -st.y, st.x);\n    } else if (face==2.0) {\n        vec = vec3(st.x, 1, st.y);\n    } else if (face==3.0) {\n        vec = vec3(st.x, -1, -st.y);\n    } else if (face==4.0) {\n        vec = vec3(st.x, -st.y, 1);\n    } else {\n        vec = vec3(-st.x, -st.y, -1);\n    }\n    mat3 vecSpace = matrixFromVector(normalize(vec));\n    vec3 color = vec3(0.0);\n    const int samples = $NUMSAMPLES;\n    vec3 vect;\n    for(int i=0; i<samples; i++) {\n        float sini = sin(float(i));\n        float cosi = cos(float(i));\n        float rand = rnd(vec2(sini, cosi));\n        vect = hemisphereSample_$METHOD(vec2(float(i) / float(samples), rand), vecSpace, vec, params.y);\n        color += $textureCube(source, vect).rgb;\n    }\n    color /= float(samples);\n    gl_FragColor = params.w < 2.0? vec4(color, 1.0) : encodeRGBM(color);\n}\n";
pc.shaderChunks.reflDirPS = "void getReflDir() {\n    dReflDirW = normalize(-reflect(dViewDirW, dNormalW));\n}\n";
pc.shaderChunks.reflectionCubePS = "uniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvoid addReflection() {\n    vec3 lookupVec = fixSeams(cubeMapProject(dReflDirW));\n    lookupVec.x *= -1.0;\n    dReflection += vec4($textureCubeSAMPLE(texture_cubeMap, lookupVec).rgb, material_reflectivity);\n}\n";
pc.shaderChunks.reflectionDpAtlasPS = "uniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec2 getDpAtlasUv(vec2 uv, float mip) {\n    vec4 rect;\n    float sx = saturate(mip - 2.0);\n    rect.x = sx * 0.5;\n    float t = mip - rect.x * 6.0;\n    float i = 1.0 - rect.x;\n    rect.y = min(t * 0.5, 0.75) * i + rect.x;\n    float st = saturate(t);\n    rect.z = (1.0 - st * 0.5) * i;\n    rect.w = rect.z * 0.5;\n    float rcRectZ = 1.0 / rect.z;\n    float scaleFactor = 0.00390625 * rcRectZ; // 0.0078125 = (256 + 2) / 256 - 1, 0.00390625 same for 512\n    vec2 scale = vec2(scaleFactor, scaleFactor * 2.0);\n    uv = uv * (vec2(1.0) - scale) + scale * 0.5;\n    uv = uv * rect.zw + rect.xy;\n    return uv;\n}\nvoid addReflection() {\n    vec3 reflDir = normalize(cubeMapProject(dReflDirW));\n    // Convert vector to DP coords\n    bool up = reflDir.y > 0.0;\n    float scale = 0.90909090909090909090909090909091;// 1.0 / 1.1;\n    vec3 reflDirWarp = reflDir.xzx * vec3(-0.25, 0.5, 0.25);\n    float reflDirVer = abs(reflDir.y) + 1.0;\n    reflDirWarp /= reflDirVer;\n    reflDirWarp *= scale;\n    reflDirWarp = vec3(0.75, 0.5, 0.25) - reflDirWarp;\n    vec2 tc = up? reflDirWarp.xy : reflDirWarp.zy;\n    float bias = saturate(1.0 - dGlossiness) * 5.0; // multiply by max mip level\n    float mip = floor(bias);\n    vec3 tex1 = $texture2DSAMPLE(texture_sphereMap, getDpAtlasUv(tc, mip)).rgb;\n    mip = min(mip + 1.0, 5.0);\n    vec3 tex2 = $texture2DSAMPLE(texture_sphereMap, getDpAtlasUv(tc, mip)).rgb;\n    tex1 = mix(tex1, tex2, fract(bias));\n    tex1 = processEnvironment(tex1);\n    dReflection += vec4(tex1, material_reflectivity);\n}\n";
pc.shaderChunks.reflectionPrefilteredCubePS = "uniform samplerCube texture_prefilteredCubeMap128;\nuniform samplerCube texture_prefilteredCubeMap64;\nuniform samplerCube texture_prefilteredCubeMap32;\nuniform samplerCube texture_prefilteredCubeMap16;\nuniform samplerCube texture_prefilteredCubeMap8;\n#ifndef PMREM4\n#define PMREM4\nuniform samplerCube texture_prefilteredCubeMap4;\n#endif\nuniform float material_reflectivity;\nvoid addReflection() {\n    // Unfortunately, WebGL doesn't allow us using textureCubeLod. Therefore bunch of nasty workarounds is required.\n    // We fix mip0 to 128x128, so code is rather static.\n    // Mips smaller than 4x4 aren't great even for diffuse. Don't forget that we don't have bilinear filtering between different faces.\n    float bias = saturate(1.0 - dGlossiness) * 5.0; // multiply by max mip level\n    int index1 = int(bias);\n    int index2 = int(min(bias + 1.0, 7.0));\n    vec3 fixedReflDir = fixSeams(cubeMapProject(dReflDirW), bias);\n    fixedReflDir.x *= -1.0;\n    vec4 cubes[6];\n    cubes[0] = textureCube(texture_prefilteredCubeMap128, fixedReflDir);\n    cubes[1] = textureCube(texture_prefilteredCubeMap64, fixedReflDir);\n    cubes[2] = textureCube(texture_prefilteredCubeMap32, fixedReflDir);\n    cubes[3] = textureCube(texture_prefilteredCubeMap16, fixedReflDir);\n    cubes[4] = textureCube(texture_prefilteredCubeMap8, fixedReflDir);\n    cubes[5] = textureCube(texture_prefilteredCubeMap4, fixedReflDir);\n    // Also we don't have dynamic indexing in PS, so...\n    vec4 cube[2];\n    for(int i = 0; i < 6; i++) {\n        if (i == index1) {\n            cube[0] = cubes[i];\n        }\n        if (i == index2) {\n            cube[1] = cubes[i];\n        }\n    }\n    // another variant\n    /*if (index1==0){ cube[0]=cubes[0];\n    }else if (index1==1){ cube[0]=cubes[1];\n    }else if (index1==2){ cube[0]=cubes[2];\n    }else if (index1==3){ cube[0]=cubes[3];\n    }else if (index1==4){ cube[0]=cubes[4];\n    }else if (index1==5){ cube[0]=cubes[5];}\n    if (index2==0){ cube[1]=cubes[0];\n    }else if (index2==1){ cube[1]=cubes[1];\n    }else if (index2==2){ cube[1]=cubes[2];\n    }else if (index2==3){ cube[1]=cubes[3];\n    }else if (index2==4){ cube[1]=cubes[4];\n    }else if (index2==5){ cube[1]=cubes[5];}*/\n    vec4 cubeFinal = mix(cube[0], cube[1], fract(bias));\n    vec3 refl = processEnvironment($DECODE(cubeFinal).rgb);\n    dReflection += vec4(refl, material_reflectivity);\n}\n";
pc.shaderChunks.reflectionPrefilteredCubeLodPS = "\n#ifndef PMREM4\n#define PMREM4\n#extension GL_EXT_shader_texture_lod : enable\nuniform samplerCube texture_prefilteredCubeMap128;\n#endif\nuniform float material_reflectivity;\nvoid addReflection() {\n    float bias = saturate(1.0 - dGlossiness) * 5.0; // multiply by max mip level\n    vec3 fixedReflDir = fixSeams(cubeMapProject(dReflDirW), bias);\n    fixedReflDir.x *= -1.0;\n    vec3 refl = processEnvironment($DECODE( textureCubeLodEXT(texture_prefilteredCubeMap128, fixedReflDir, bias) ).rgb);\n    dReflection += vec4(refl, material_reflectivity);\n}\n";
pc.shaderChunks.reflectionSpherePS = "#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvoid addReflection() {\n    vec3 reflDirV = (mat3(matrix_view) * dReflDirW).xyz;\n    float m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n    vec2 sphereMapUv = reflDirV.xy / m + 0.5;\n    dReflection += vec4($texture2DSAMPLE(texture_sphereMap, sphereMapUv).rgb, material_reflectivity);\n}\n";
pc.shaderChunks.reflectionSphereLowPS = "uniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvoid addReflection() {\n    vec3 reflDirV = vNormalV;\n    vec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;\n    dReflection += vec4($texture2DSAMPLE(texture_sphereMap, sphereMapUv).rgb, material_reflectivity);\n}\n";
pc.shaderChunks.refractionPS = "uniform float material_refraction, material_refractionIndex;\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\n    float vn = dot(viewVec, Normal);\n    float k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n    vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\n    return refrVec;\n}\nvoid addRefraction() {\n    // use same reflection code with refraction vector\n    vec3 tmp = dReflDirW;\n    vec4 tmp2 = dReflection;\n    dReflection = vec4(0.0);\n    dReflDirW = refract2(-dViewDirW, dNormalW, material_refractionIndex);\n    addReflection();\n    dDiffuseLight = mix(dDiffuseLight, dReflection.rgb * dAlbedo, material_refraction);\n    dReflDirW = tmp;\n    dReflection = tmp2;\n}\n";
pc.shaderChunks.rgbmPS = "vec3 decodeRGBM(vec4 rgbm) {\n    vec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n    return color * color;\n}\nvec3 texture2DRGBM(sampler2D tex, vec2 uv) {\n    return decodeRGBM(texture2D(tex, uv));\n}\nvec3 textureCubeRGBM(samplerCube tex, vec3 uvw) {\n    return decodeRGBM(textureCube(tex, uvw));\n}\n";
pc.shaderChunks.screenDepthPS = "uniform sampler2D uDepthMap;\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params; // 1 / camera_far,      camera_far,     (1 - f / n) / 2,        (1 + f / n) / 2\n#endif\n#ifdef GL2\n    float linearizeDepth(float z) {\n        z = z * 2.0 - 1.0;\n        return 1.0 / (camera_params.z * z + camera_params.w);\n    }\n#else\n    #ifndef UNPACKFLOAT\n    #define UNPACKFLOAT\n    float unpackFloat(vec4 rgbaDepth) {\n        const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n        return dot(rgbaDepth, bitShift);\n    }\n    #endif\n#endif\n// Retrieves rendered linear camera depth by UV\nfloat getLinearScreenDepth(vec2 uv) {\n    #ifdef GL2\n        return linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y;\n    #else\n        return unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y;\n    #endif\n}\n#ifndef VERTEXSHADER\n// Retrieves rendered linear camera depth under the current pixel\nfloat getLinearScreenDepth() {\n    vec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n    return getLinearScreenDepth(uv);\n}\n#endif\n// Generates linear camera depth for the given world position\nfloat getLinearDepth(vec3 pos) {\n    return -(matrix_view * vec4(pos, 1.0)).z;\n}\n";
pc.shaderChunks.shadowCommonPS = "void normalOffsetPointShadow(vec4 shadowParams) {\n    float distScale = length(dLightDirW);\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale; //0.02\n    vec3 dir = wPos - dLightPosW;\n    dLightDirW = dir;\n}\n";
pc.shaderChunks.shadowCoordPS = "void _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n    dShadowCoord = (shadowMatrix * vec4(wPos, 1.0)).xyz;\n    dShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n    #ifdef SHADOWBIAS\n        dShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n    #endif\n}\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    projPos.xy /= projPos.w;\n    dShadowCoord.xy = projPos.xy;\n    dShadowCoord.z = length(dLightDirW) * shadowParams.w;\n    #ifdef SHADOWBIAS\n        dShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n    #endif\n}\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams) {\n    _getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n    float distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW)); // fov?\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n    _getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0); //0.08\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n";
pc.shaderChunks.shadowCoordVS = "void getLightDirPoint(vec3 lightPosW) {\n    vec3 lightDirW = vPositionW - lightPosW;\n    dLightDirNormW = normalize(lightDirW);\n    dLightPosW = lightPosW;\n}\nvoid _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    vMainShadowUv = projPos;\n}\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    vMainShadowUv = projPos;\n}\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec3 shadowParams) {\n    _getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n    float distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW)); // fov?\n    vec3 wPos = vPositionW + dNormalW * shadowParams.y * clamp(1.0 - dot(dNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n    _getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n    vec3 wPos = vPositionW + dNormalW * shadowParams.y * clamp(1.0 - dot(dNormalW, -dLightDirNormW), 0.0, 1.0); //0.08\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n";
pc.shaderChunks.shadowCoordPerspZbufferPS = "void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    projPos.xyz /= projPos.w;\n    dShadowCoord = projPos.xyz;\n    // depth bias is already applied on render\n}\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n    float distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW)); // fov?\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n    _getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams) {\n    _getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, vPositionW);\n}\n";
pc.shaderChunks.shadowEVSMPS = "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n    vec3 moments = texture2D(tex, texCoords).xyz;\n    return calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";
pc.shaderChunks.shadowEVSMnPS = "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n    float pixelSize = 1.0 / resolution;\n    texCoords -= vec2(pixelSize);\n    vec3 s00 = texture2D(tex, texCoords).xyz;\n    vec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n    vec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n    vec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n    vec2 fr = fract(texCoords * resolution);\n    vec3 h0 = mix(s00, s10, fr.x);\n    vec3 h1 = mix(s01, s11, fr.x);\n    vec3 moments = mix(h0, h1, fr.y);\n    return calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";
pc.shaderChunks.shadowStandardPS = "vec3 lessThan2(vec3 a, vec3 b) {\n    return clamp((b - a)*1000.0, 0.0, 1.0); // softer version\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n    const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n    return dot(rgbaDepth, bitShift);\n}\n#endif\n// ----- Direct/Spot Sampling -----\n#ifdef GL2\n    float _getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n        float z = dShadowCoord.z;\n        vec2 uv = dShadowCoord.xy * shadowParams.x; // 1 unit - 1 texel\n        float shadowMapSizeInv = 1.0 / shadowParams.x;\n        vec2 base_uv = floor(uv + 0.5);\n        float s = (uv.x + 0.5 - base_uv.x);\n        float t = (uv.y + 0.5 - base_uv.y);\n        base_uv -= vec2(0.5);\n        base_uv *= shadowMapSizeInv;\n        float sum = 0.0;\n        float uw0 = (3.0 - 2.0 * s);\n        float uw1 = (1.0 + 2.0 * s);\n        float u0 = (2.0 - s) / uw0 - 1.0;\n        float u1 = s / uw1 + 1.0;\n        float vw0 = (3.0 - 2.0 * t);\n        float vw1 = (1.0 + 2.0 * t);\n        float v0 = (2.0 - t) / vw0 - 1.0;\n        float v1 = t / vw1 + 1.0;\n        u0 = u0 * shadowMapSizeInv + base_uv.x;\n        v0 = v0 * shadowMapSizeInv + base_uv.y;\n        u1 = u1 * shadowMapSizeInv + base_uv.x;\n        v1 = v1 * shadowMapSizeInv + base_uv.y;\n        sum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n        sum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n        sum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n        sum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n        sum *= 1.0f / 16.0;\n        return sum;\n    }\n    float getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n        return _getShadowPCF3x3(shadowMap, shadowParams);\n    }\n    float getShadowSpotPCF3x3(sampler2DShadow shadowMap, vec4 shadowParams) {\n        return _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n    }\n#else\n    float _xgetShadowPCF3x3(mat3 depthKernel, sampler2D shadowMap, vec3 shadowParams) {\n        mat3 shadowKernel;\n        vec3 shadowCoord = dShadowCoord;\n        vec3 shadowZ = vec3(shadowCoord.z);\n        shadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\n        shadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\n        shadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\n        vec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\n        shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n        shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n        vec4 shadowValues;\n        shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n        shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n        shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n        shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n        return dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n    }\n    float _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n        vec3 shadowCoord = dShadowCoord;\n        float xoffset = 1.0 / shadowParams.x; // 1/shadow map width\n        float dx0 = -xoffset;\n        float dx1 = xoffset;\n        mat3 depthKernel;\n        depthKernel[0][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\n        depthKernel[0][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\n        depthKernel[0][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\n        depthKernel[1][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\n        depthKernel[1][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy));\n        depthKernel[1][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\n        depthKernel[2][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\n        depthKernel[2][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\n        depthKernel[2][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\n        return _xgetShadowPCF3x3(depthKernel, shadowMap, shadowParams);\n    }\n    float getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n        return _getShadowPCF3x3(shadowMap, shadowParams);\n    }\n    float getShadowSpotPCF3x3(sampler2D shadowMap, vec4 shadowParams) {\n        return _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n    }\n#endif\n// ----- Point Sampling -----\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\n    vec3 tc = normalize(dir);\n    vec3 tcAbs = abs(tc);\n    vec4 dirX = vec4(1,0,0, tc.x);\n    vec4 dirY = vec4(0,1,0, tc.y);\n    float majorAxisLength = tc.z;\n    if ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\n        dirX = vec4(0,0,1, tc.z);\n        dirY = vec4(0,1,0, tc.y);\n        majorAxisLength = tc.x;\n    } else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\n        dirX = vec4(1,0,0, tc.x);\n        dirY = vec4(0,0,1, tc.z);\n        majorAxisLength = tc.y;\n    }\n    float shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\n    vec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\n    vec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\n    vec3 dx0 = -xoffset;\n    vec3 dy0 = -yoffset;\n    vec3 dx1 = xoffset;\n    vec3 dy1 = yoffset;\n    mat3 shadowKernel;\n    mat3 depthKernel;\n    depthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\n    depthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\n    depthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\n    depthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\n    depthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\n    depthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\n    depthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\n    depthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\n    depthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\n    vec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\n    shadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\n    shadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\n    shadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\n    vec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\n    vec2 fractionalCoord = fract( uv * shadowParams.x );\n    shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n    shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n    vec4 shadowValues;\n    shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n    shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n    shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n    shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n    return 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec4 shadowParams) {\n    return _getShadowPoint(shadowMap, shadowParams, dLightDirW);\n}\n";
pc.shaderChunks.shadowStandardGL2PS = "float _getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n    // http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/\n    float z = dShadowCoord.z;\n    vec2 uv = dShadowCoord.xy * shadowParams.x; // 1 unit - 1 texel\n    float shadowMapSizeInv = 1.0 / shadowParams.x;\n    vec2 base_uv = floor(uv + 0.5);\n    float s = (uv.x + 0.5 - base_uv.x);\n    float t = (uv.y + 0.5 - base_uv.y);\n    base_uv -= vec2(0.5);\n    base_uv *= shadowMapSizeInv;\n    float uw0 = (4.0 - 3.0 * s);\n    float uw1 = 7.0;\n    float uw2 = (1.0 + 3.0 * s);\n    float u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n    float u1 = (3.0 + s) / uw1;\n    float u2 = s / uw2 + 2.0;\n    float vw0 = (4.0 - 3.0 * t);\n    float vw1 = 7.0;\n    float vw2 = (1.0 + 3.0 * t);\n    float v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n    float v1 = (3.0 + t) / vw1;\n    float v2 = t / vw2 + 2.0;\n    float sum = 0.0;\n    u0 = u0 * shadowMapSizeInv + base_uv.x;\n    v0 = v0 * shadowMapSizeInv + base_uv.y;\n    u1 = u1 * shadowMapSizeInv + base_uv.x;\n    v1 = v1 * shadowMapSizeInv + base_uv.y;\n    u2 = u2 * shadowMapSizeInv + base_uv.x;\n    v2 = v2 * shadowMapSizeInv + base_uv.y;\n    sum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n    sum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n    sum += uw2 * vw0 * texture(shadowMap, vec3(u2, v0, z));\n    sum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n    sum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n    sum += uw2 * vw1 * texture(shadowMap, vec3(u2, v1, z));\n    sum += uw0 * vw2 * texture(shadowMap, vec3(u0, v2, z));\n    sum += uw1 * vw2 * texture(shadowMap, vec3(u1, v2, z));\n    sum += uw2 * vw2 * texture(shadowMap, vec3(u2, v2, z));\n    sum *= 1.0f / 144.0;\n    sum = gammaCorrectInput(sum); // gives softer gradient\n    sum = saturate(sum);\n    return sum;\n}\nfloat getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n    return _getShadowPCF5x5(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF5x5(sampler2DShadow shadowMap, vec4 shadowParams) {\n    return _getShadowPCF5x5(shadowMap, shadowParams.xyz);\n}\n";
pc.shaderChunks.shadowStandardGL2VSPS = "float getShadowPCF5x5VS(sampler2DShadow shadowMap, vec3 shadowParams) {\n    dShadowCoord = vMainShadowUv.xyz;\n    dShadowCoord.z = saturate(dShadowCoord.z) - 0.0001; // prevent going to dark after the far plane\n    return _getShadowPCF5x5(shadowMap, shadowParams);\n}\n";
pc.shaderChunks.shadowStandardVSPS = "#ifdef GL2\n#define SHADOW_SAMPLERVS sampler2DShadow\n#else\n#define SHADOW_SAMPLERVS sampler2D\n#endif\nfloat getShadowPCF3x3VS(SHADOW_SAMPLERVS shadowMap, vec3 shadowParams) {\n    dShadowCoord = vMainShadowUv.xyz;\n    dShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n    #ifdef SHADOWBIAS\n        dShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n    #endif\n    return _getShadowPCF3x3(shadowMap, shadowParams);\n}\n";
pc.shaderChunks.shadowVSM8PS = "float calculateVSM8(vec3 moments, float Z, float vsmBias) {\n    float VSMBias = vsmBias;//0.01 * 0.25;\n    float depthScale = VSMBias * Z;\n    float minVariance1 = depthScale * depthScale;\n    return chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\n}\nfloat decodeFloatRG(vec2 rg) {\n    return rg.y*(1.0/255.0) + rg.x;\n}\nfloat VSM8(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n    vec4 c = texture2D(tex, texCoords);\n    vec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\n    return calculateVSM8(moments, Z, vsmBias);\n}\nfloat getShadowVSM8(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    return VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, 0.0);\n}\nfloat getShadowSpotVSM8(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n    return VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\n}\n";
pc.shaderChunks.shadowVSMVSPS = "float getShadowVSM$VS(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    dShadowCoord = vMainShadowUv.xyz;\n    dShadowCoord.z += shadowParams.z;\n    dShadowCoord.xyz /= vMainShadowUv.w;\n    dShadowCoord.z = min(dShadowCoord.z, 1.0);\n    return $VSM(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\n";
pc.shaderChunks.shadowVSM_commonPS = "float linstep(float a, float b, float v) {\n    return saturate((v - a) / (b - a));\n}\nfloat reduceLightBleeding(float pMax, float amount) {\n  // Remove the [0, amount] tail and linearly rescale (amount, 1].\n   return linstep(amount, 1.0, pMax);\n}\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n    // Compute variance\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, minVariance);\n    // Compute probabilistic upper bound\n    float d = mean - moments.x;\n    float pMax = variance / (variance + (d * d));\n    pMax = reduceLightBleeding(pMax, lightBleedingReduction);\n    // One-tailed Chebyshev\n    return (mean <= moments.x ? 1.0 : pMax);\n}\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n    Z = 2.0 * Z - 1.0;\n    float warpedDepth = exp(exponent * Z);\n    moments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n    float VSMBias = vsmBias;//0.01 * 0.25;\n    float depthScale = VSMBias * exponent * warpedDepth;\n    float minVariance1 = depthScale * depthScale;\n    return chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\n";
pc.shaderChunks.skinBatchConstVS = "attribute float vertex_boneIndices;\nuniform mat4 matrix_pose[BONE_LIMIT];\nmat4 getBoneMatrix(const in float i) {\n    mat4 bone = matrix_pose[int(i)];\n    return bone;\n}\n";
pc.shaderChunks.skinBatchTexVS = "attribute float vertex_boneIndices;\nuniform sampler2D texture_poseMap;\nuniform vec2 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i) {\n    float j = i * 4.0;\n    float x = mod(j, float(texture_poseMapSize.x));\n    float y = floor(j / float(texture_poseMapSize.x));\n    float dx = 1.0 / float(texture_poseMapSize.x);\n    float dy = 1.0 / float(texture_poseMapSize.y);\n    y = dy * (y + 0.5);\n    vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n    vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n    vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n    vec4 v4 = texture2D(texture_poseMap, vec2(dx * (x + 3.5), y));\n    mat4 bone = mat4(v1, v2, v3, v4);\n    return bone;\n}\n";
pc.shaderChunks.skinConstVS = "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform mat4 matrix_pose[BONE_LIMIT];\nmat4 getBoneMatrix(const in float i)\n{\n    mat4 bone = matrix_pose[int(i)];\n    return bone;\n}\n";
pc.shaderChunks.skinTexVS = "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform sampler2D texture_poseMap;\nuniform vec2 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i)\n{\n    float j = i * 4.0;\n    float x = mod(j, float(texture_poseMapSize.x));\n    float y = floor(j / float(texture_poseMapSize.x));\n    float dx = 1.0 / float(texture_poseMapSize.x);\n    float dy = 1.0 / float(texture_poseMapSize.y);\n    y = dy * (y + 0.5);\n    vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n    vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n    vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n    vec4 v4 = texture2D(texture_poseMap, vec2(dx * (x + 3.5), y));\n    mat4 bone = mat4(v1, v2, v3, v4);\n    return bone;\n}\n";
pc.shaderChunks.skyboxPS = "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvoid main(void) {\n    gl_FragColor = textureCube(texture_cubeMap, fixSeams(vViewDir));\n}\n";
pc.shaderChunks.skyboxVS = "attribute vec3 aPosition;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat4 matrix_projection;\nvarying vec3 vViewDir;\nvoid main(void)\n{\n    mat4 view = matrix_view;\n    view[3][0] = view[3][1] = view[3][2] = 0.0;\n    gl_Position = matrix_projection * view * vec4(aPosition, 1.0);\n    // Force skybox to far Z, regardless of the clip planes on the camera\n    // Subtract a tiny fudge factor to ensure floating point errors don't\n    // still push pixels beyond far Z. See:\n    // http://www.opengl.org/discussion_boards/showthread.php/171867-skybox-problem\n    gl_Position.z = gl_Position.w - 0.00001;\n    vViewDir = aPosition;\n    vViewDir.x *= -1.0;\n}\n";
pc.shaderChunks.skyboxHDRPS = "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvoid main(void) {\n    vec3 color = processEnvironment($textureCubeSAMPLE(texture_cubeMap, fixSeamsStatic(vViewDir, $FIXCONST)).rgb);\n    color = toneMap(color);\n    color = gammaCorrectOutput(color);\n    gl_FragColor = vec4(color, 1.0);\n}\n";
pc.shaderChunks.skyboxPrefilteredCubePS = "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvec3 fixSeamsStretch(vec3 vec, float mipmapIndex, float cubemapSize) {\n    float scale = 1.0 - exp2(mipmapIndex) / cubemapSize;\n    float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n    if (abs(vec.x) != M) vec.x *= scale;\n    if (abs(vec.y) != M) vec.y *= scale;\n    if (abs(vec.z) != M) vec.z *= scale;\n    return vec;\n}\nvoid main(void) {\n    vec3 color = textureCubeRGBM(texture_cubeMap, fixSeamsStretch(vViewDir, 0.0, 128.0));\n    color = toneMap(color);\n    color = gammaCorrectOutput(color);\n    gl_FragColor = vec4(color, 1.0);\n}\n";
pc.shaderChunks.specularPS = "#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_specularMap;\n#endif\nvoid getSpecularity() {\n    dSpecularity = vec3(1.0);\n    #ifdef MAPCOLOR\n        dSpecularity *= material_specular;\n    #endif\n    #ifdef MAPTEXTURE\n        dSpecularity *= texture2D(texture_specularMap, $UV).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        dSpecularity *= saturate(vVertexColor.$VC);\n    #endif\n}\n";
pc.shaderChunks.specularAaNonePS = "float antiAliasGlossiness(float power) {\n    return power;\n}\n";
pc.shaderChunks.specularAaToksvigPS = "float antiAliasGlossiness(float power) {\n    float rlen = 1.0 / saturate(length(dNormalMap));\n    float toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n    return power * toksvig;\n}\n";
pc.shaderChunks.specularAaToksvigFloatPS = "float antiAliasGlossiness(float power) {\n    float rlen = 1.0 / saturate(length(dNormalMap));\n    float toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n    return power * mix(1.0, toksvig, material_bumpiness);\n}\n";
pc.shaderChunks.spotPS = "float getSpotEffect(vec3 lightSpotDirW, float lightInnerConeAngle, float lightOuterConeAngle) {\n    float cosAngle = dot(dLightDirNormW, lightSpotDirW);\n    return smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n";
pc.shaderChunks.startPS = "\nvoid main(void) {\n    dDiffuseLight = vec3(0);\n    dSpecularLight = vec3(0);\n    dReflection = vec4(0);\n    dSpecularity = vec3(0);\n";
pc.shaderChunks.startVS = "\nvoid main(void) {\n    gl_Position = getPosition();\n";
pc.shaderChunks.startNineSlicedPS = "    nineSlicedUv = vUv0;\n";
pc.shaderChunks.startNineSlicedTiledPS = "\n    vec2 tileMask = step(vMask, vec2(0.99999));\n    vec2 clampedUv = mix(innerOffset.xy*0.5, vec2(1.0) - innerOffset.zw*0.5, fract(vTiledUv));\n    clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n    nineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n";
pc.shaderChunks.storeEVSMPS = "float exponent = VSM_EXPONENT;\ndepth = 2.0 * depth - 1.0;\ndepth =  exp(exponent * depth);\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n";
pc.shaderChunks.tangentBinormalVS = "\nvec3 getTangent() {\n    return normalize(dNormalMatrix * vertex_tangent.xyz);\n}\nvec3 getBinormal() {\n    return cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\n";
pc.shaderChunks.TBNPS = "void getTBN() {\n    dTBN = mat3(normalize(dTangentW), normalize(dBinormalW), normalize(dVertexNormalW));\n}\n";
pc.shaderChunks.TBNderivativePS = "// http://www.thetenthplanet.de/archives/1180\nvoid getTBN() {\n    vec2 uv = $UV;\n    // get edge vectors of the pixel triangle\n    vec3 dp1 = dFdx( vPositionW );\n    vec3 dp2 = dFdy( vPositionW );\n    vec2 duv1 = dFdx( uv );\n    vec2 duv2 = dFdy( uv );\n    // solve the linear system\n    vec3 dp2perp = cross( dp2, dVertexNormalW );\n    vec3 dp1perp = cross( dVertexNormalW, dp1 );\n    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n    // construct a scale-invariant frame\n    float invmax = 1.0 / sqrt( max( dot(T,T), dot(B,B) ) );\n    dTBN = mat3( T * invmax, B * invmax, dVertexNormalW );\n}\n";
pc.shaderChunks.TBNfastPS = "void getTBN() {\n    dTBN = mat3(dTangentW, dBinormalW, dVertexNormalW);\n}\n";
pc.shaderChunks.tonemappingAcesPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n    float tA = 2.51;\n    float tB = 0.03;\n    float tC = 2.43;\n    float tD = 0.59;\n    float tE = 0.14;\n    vec3 x = color * exposure;\n    return (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n";
pc.shaderChunks.tonemappingAces2PS = "uniform float exposure;\n// ACES approximation by Stephen Hill\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v) {\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\nvec3 toneMap(vec3 color) {\n    color *= exposure;\n    color = color * ACESInputMat;\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n    return color;\n}\n";
pc.shaderChunks.tonemappingFilmicPS = "const float A =  0.15;\nconst float B =  0.50;\nconst float C =  0.10;\nconst float D =  0.20;\nconst float E =  0.02;\nconst float F =  0.30;\nconst float W =  11.2;\nuniform float exposure;\nvec3 uncharted2Tonemap(vec3 x) {\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nvec3 toneMap(vec3 color) {\n    color = uncharted2Tonemap(color * exposure);\n    vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n    color = color * whiteScale;\n    return color;\n}\n";
pc.shaderChunks.tonemappingHejlPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n    color *= exposure;\n    const float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n    const float Scl = 1.25;\n    vec3 h = max( vec3(0.0), color - vec3(0.004) );\n    return (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n";
pc.shaderChunks.tonemappingLinearPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n    return color * exposure;\n}\n";
pc.shaderChunks.tonemappingNonePS = "vec3 toneMap(vec3 color) {\n    return color;\n}\n";
pc.shaderChunks.transformVS = "#ifdef PIXELSNAP\n    uniform vec4 uScreenSize;\n#endif\nmat4 getModelMatrix() {\n    #ifdef DYNAMICBATCH\n        return getBoneMatrix(vertex_boneIndices);\n    #elif defined(SKIN)\n        return matrix_model * (getBoneMatrix(vertex_boneIndices.x) * vertex_boneWeights.x +\n               getBoneMatrix(vertex_boneIndices.y) * vertex_boneWeights.y +\n               getBoneMatrix(vertex_boneIndices.z) * vertex_boneWeights.z +\n               getBoneMatrix(vertex_boneIndices.w) * vertex_boneWeights.w);\n    #elif defined(INSTANCING)\n        return mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n    #else\n        return matrix_model;\n    #endif\n}\nvec4 getPosition() {\n    dModelMatrix = getModelMatrix();\n    vec3 localPos = vertex_position;\n    #ifdef NINESLICED\n        // outer and inner vertices are at the same position, scale both\n        localPos.xz *= outerScale;\n        // offset inner vertices inside\n        // (original vertices must be in [-1;1] range)\n        vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n        vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n        localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n        vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0; // uv = local pos - inner corner\n        localPos.xz *= -0.5; // move from -1;1 to -0.5;0.5\n        localPos = localPos.xzy;\n    #endif\n    vec4 posW = dModelMatrix * vec4(localPos, 1.0);\n    #ifdef SCREENSPACE\n        posW.zw = vec2(0.0, 1.0);\n    #endif\n    dPositionW = posW.xyz;\n    vec4 screenPos;\n    #ifdef UV1LAYOUT\n        screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n    #else\n        #ifdef SCREENSPACE\n            screenPos = posW;\n        #else\n            screenPos = matrix_viewProjection * posW;\n        #endif\n        #ifdef PIXELSNAP\n            // snap vertex to a pixel boundary\n            screenPos.xy = (screenPos.xy * 0.5) + 0.5;\n            screenPos.xy *= uScreenSize.xy;\n            screenPos.xy = floor(screenPos.xy);\n            screenPos.xy *= uScreenSize.zw;\n            screenPos.xy = (screenPos.xy * 2.0) - 1.0;\n        #endif\n    #endif\n    return screenPos;\n}\nvec3 getWorldPosition() {\n    return dPositionW;\n}\n";
pc.shaderChunks.transformDeclVS = "attribute vec3 vertex_position;\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\nvec3 dPositionW;\nmat4 dModelMatrix;\n";
pc.shaderChunks.uv0VS = "#ifdef NINESLICED\nvec2 getUv0() {\n    vec2 uv = vertex_position.xz;\n    // offset inner vertices inside\n    // (original vertices must be in [-1;1] range)\n    vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n    vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n    uv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n    uv = uv * -0.5 + 0.5;\n    uv = uv * atlasRect.zw + atlasRect.xy;\n    vMask = vertex_texCoord0.xy;\n    return uv;\n}\n#else\nvec2 getUv0() {\n    return vertex_texCoord0;\n}\n#endif\n";
pc.shaderChunks.uv1VS = "\nvec2 getUv1() {\n    return vertex_texCoord1;\n}\n";
pc.shaderChunks.viewDirPS = "void getViewDir() {\n    dViewDirW = normalize(view_position - vPositionW);\n}\n";
pc.shaderChunks.viewNormalVS = "\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nvec3 getViewNormal() {\n    return mat3(matrix_view) * vNormalW;\n}\n";
pc.programlib = {gammaCode:function(value) {
  if (value === pc.GAMMA_SRGB || value === pc.GAMMA_SRGBFAST) {
    return pc.shaderChunks.gamma2_2PS;
  } else {
    if (value === pc.GAMMA_SRGBHDR) {
      return "#define HDR\n" + pc.shaderChunks.gamma2_2PS;
    }
  }
  return pc.shaderChunks.gamma1_0PS;
}, tonemapCode:function(value) {
  if (value === pc.TONEMAP_FILMIC) {
    return pc.shaderChunks.tonemappingFilmicPS;
  } else {
    if (value === pc.TONEMAP_LINEAR) {
      return pc.shaderChunks.tonemappingLinearPS;
    } else {
      if (value === pc.TONEMAP_HEJL) {
        return pc.shaderChunks.tonemappingHejlPS;
      } else {
        if (value === pc.TONEMAP_ACES) {
          return pc.shaderChunks.tonemappingAcesPS;
        } else {
          if (value === pc.TONEMAP_ACES2) {
            return pc.shaderChunks.tonemappingAces2PS;
          }
        }
      }
    }
  }
  return pc.shaderChunks.tonemappingNonePS;
}, fogCode:function(value) {
  if (value === "linear") {
    return pc.shaderChunks.fogLinearPS;
  } else {
    if (value === "exp") {
      return pc.shaderChunks.fogExpPS;
    } else {
      if (value === "exp2") {
        return pc.shaderChunks.fogExp2PS;
      }
    }
  }
  return pc.shaderChunks.fogNonePS;
}, skinCode:function(device, chunks) {
  if (!chunks) {
    chunks = pc.shaderChunks;
  }
  if (device.supportsBoneTextures) {
    return chunks.skinTexVS;
  }
  return "#define BONE_LIMIT " + device.getBoneLimit() + "\n" + chunks.skinConstVS;
}, precisionCode:function(device) {
  var pcode = "precision " + device.precision + " float;\n";
  if (device.webgl2) {
    pcode += "#ifdef GL2\nprecision " + device.precision + " sampler2DShadow;\n#endif\n";
  }
  return pcode;
}, versionCode:function(device) {
  return device.webgl2 ? "#version 300 es\n" : "";
}, dummyFragmentCode:function() {
  return "void main(void) {gl_FragColor = vec4(0.0);}";
}, begin:function() {
  return "void main(void)\n{\n";
}, end:function() {
  return "}\n";
}};
pc.programlib.basic = {generateKey:function(options) {
  var key = "basic";
  if (options.fog) {
    key += "_fog";
  }
  if (options.alphaTest) {
    key += "_atst";
  }
  if (options.vertexColors) {
    key += "_vcol";
  }
  if (options.diffuseMap) {
    key += "_diff";
  }
  key += "_" + options.pass;
  return key;
}, createShaderDefinition:function(device, options) {
  var attributes = {vertex_position:pc.SEMANTIC_POSITION};
  if (options.skin) {
    attributes.vertex_boneWeights = pc.SEMANTIC_BLENDWEIGHT;
    attributes.vertex_boneIndices = pc.SEMANTIC_BLENDINDICES;
  }
  if (options.vertexColors) {
    attributes.vertex_color = pc.SEMANTIC_COLOR;
  }
  if (options.diffuseMap) {
    attributes.vertex_texCoord0 = pc.SEMANTIC_TEXCOORD0;
  }
  var chunks = pc.shaderChunks;
  var code = "";
  code += chunks.transformDeclVS;
  if (options.skin) {
    code += pc.programlib.skinCode(device);
    code += chunks.transformSkinnedVS;
  } else {
    code += chunks.transformVS;
  }
  if (options.vertexColors) {
    code += "attribute vec4 vertex_color;\n";
    code += "varying vec4 vColor;\n";
  }
  if (options.diffuseMap) {
    code += "attribute vec2 vertex_texCoord0;\n";
    code += "varying vec2 vUv0;\n";
  }
  if (options.pass === pc.SHADER_DEPTH) {
    code += "varying float vDepth;\n";
    code += "#ifndef VIEWMATRIX\n";
    code += "#define VIEWMATRIX\n";
    code += "uniform mat4 matrix_view;\n";
    code += "#endif\n";
    code += "#ifndef CAMERAPLANES\n";
    code += "#define CAMERAPLANES\n";
    code += "uniform vec4 camera_params;\n\n";
    code += "#endif\n";
  }
  code += pc.programlib.begin();
  code += "   gl_Position = getPosition();\n";
  if (options.pass === pc.SHADER_DEPTH) {
    code += "    vDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\n";
  }
  if (options.vertexColors) {
    code += "    vColor = vertex_color;\n";
  }
  if (options.diffuseMap) {
    code += "    vUv0 = vertex_texCoord0;\n";
  }
  code += pc.programlib.end();
  var vshader = code;
  code = pc.programlib.precisionCode(device);
  if (options.vertexColors) {
    code += "varying vec4 vColor;\n";
  } else {
    code += "uniform vec4 uColor;\n";
  }
  if (options.diffuseMap) {
    code += "varying vec2 vUv0;\n";
    code += "uniform sampler2D texture_diffuseMap;\n";
  }
  if (options.fog) {
    code += pc.programlib.fogCode(options.fog);
  }
  if (options.alphatest) {
    code += chunks.alphaTestPS;
  }
  if (options.pass === pc.SHADER_DEPTH) {
    code += "varying float vDepth;\n";
    code += chunks.packDepthPS;
  }
  code += pc.programlib.begin();
  if (options.vertexColors) {
    code += "    gl_FragColor = vColor;\n";
  } else {
    code += "    gl_FragColor = uColor;\n";
  }
  if (options.diffuseMap) {
    code += "    gl_FragColor *= texture2D(texture_diffuseMap, vUv0);\n";
  }
  if (options.alphatest) {
    code += "   alphaTest(gl_FragColor.a);\n";
  }
  if (options.pass === pc.SHADER_PICK) {
  } else {
    if (options.pass === pc.SHADER_DEPTH) {
      code += "    gl_FragColor = packFloat(vDepth);\n";
    } else {
      if (options.fog) {
        code += "   glFragColor.rgb = addFog(gl_FragColor.rgb);\n";
      }
    }
  }
  code += pc.programlib.end();
  var fshader = code;
  return {attributes:attributes, vshader:vshader, fshader:fshader};
}};
pc.programlib.particle = {generateKey:function(options) {
  var key = "particle";
  for (var prop in options) {
    if (options.hasOwnProperty(prop)) {
      key += options[prop];
    }
  }
  return key;
}, _animTex:function(options, chunk) {
  var vshader = "";
  vshader += options.animTexLoop ? chunk.particleAnimFrameLoopVS : chunk.particleAnimFrameClampVS;
  vshader += chunk.particleAnimTexVS;
  return vshader;
}, createShaderDefinition:function(device, options) {
  var chunk = pc.shaderChunks;
  var vshader = "";
  var fshader = pc.programlib.precisionCode(device) + "\n";
  if (device.webgl2) {
    vshader += "#define GL2\n";
    fshader += "#define GL2\n";
  }
  vshader += "#define VERTEXSHADER\n";
  if (options.animTex) {
    vshader += "\nuniform vec4 animTexParams;\n";
  }
  if (options.normal == 2) {
    vshader += "\nvarying mat3 ParticleMat;\n";
  }
  if (options.normal == 1) {
    vshader += "\nvarying vec3 Normal;\n";
  }
  if (options.soft) {
    vshader += "\nvarying float vDepth;\n";
  }
  if (!options.useCpu) {
    vshader += chunk.particle_initVS;
    vshader += options.pack8 ? chunk.particleInputRgba8PS : chunk.particleInputFloatPS;
    if (options.soft > 0) {
      vshader += chunk.screenDepthPS;
    }
    vshader += chunk.particleVS;
    if (options.localSpace) {
      vshader += chunk.particle_localShiftVS;
    }
    if (options.animTex) {
      vshader += this._animTex(options, chunk);
    }
    if (options.wrap) {
      vshader += chunk.particle_wrapVS;
    }
    if (options.alignToMotion) {
      vshader += chunk.particle_pointAlongVS;
    }
    vshader += options.mesh ? chunk.particle_meshVS : chunk.particle_billboardVS;
    if (options.normal == 1) {
      vshader += chunk.particle_normalVS;
    }
    if (options.normal == 2) {
      vshader += chunk.particle_TBNVS;
    }
    if (options.stretch > 0.0) {
      vshader += chunk.particle_stretchVS;
    }
    vshader += chunk.particle_endVS;
    if (options.soft > 0) {
      vshader += chunk.particle_softVS;
    }
  } else {
    if (options.soft > 0) {
      vshader += chunk.screenDepthPS;
    }
    vshader += chunk.particle_cpuVS;
    if (options.localSpace) {
      vshader += chunk.particle_localShiftVS;
    }
    if (options.animTex) {
      vshader += this._animTex(options, chunk);
    }
    if (options.alignToMotion) {
      vshader += chunk.particle_pointAlongVS;
    }
    vshader += options.mesh ? chunk.particle_meshVS : chunk.particle_billboardVS;
    if (options.normal == 1) {
      vshader += chunk.particle_normalVS;
    }
    if (options.normal == 2) {
      vshader += chunk.particle_TBNVS;
    }
    if (options.stretch > 0.0) {
      vshader += chunk.particle_stretchVS;
    }
    vshader += chunk.particle_cpu_endVS;
    if (options.soft > 0) {
      vshader += chunk.particle_softVS;
    }
  }
  vshader += "}\n";
  if (options.normal > 0) {
    if (options.normal == 1) {
      fshader += "\nvarying vec3 Normal;\n";
    } else {
      if (options.normal == 2) {
        fshader += "\nvarying mat3 ParticleMat;\n";
      }
    }
    fshader += "\nuniform vec3 lightCube[6];\n";
  }
  if (options.soft) {
    fshader += "\nvarying float vDepth;\n";
  }
  if (options.normal === 0 && options.fog === "none") {
    options.srgb = false;
  }
  fshader += pc.programlib.gammaCode(options.gamma);
  fshader += pc.programlib.tonemapCode(options.toneMap);
  if (options.fog === "linear") {
    fshader += chunk.fogLinearPS;
  } else {
    if (options.fog === "exp") {
      fshader += chunk.fogExpPS;
    } else {
      if (options.fog === "exp2") {
        fshader += chunk.fogExp2PS;
      } else {
        fshader += chunk.fogNonePS;
      }
    }
  }
  if (options.normal == 2) {
    fshader += "\nuniform sampler2D normalMap;\n";
  }
  if (options.soft > 0) {
    fshader += chunk.screenDepthPS;
  }
  fshader += chunk.particlePS;
  if (options.soft > 0) {
    fshader += chunk.particle_softPS;
  }
  if (options.normal == 1) {
    fshader += "\nvec3 normal = Normal;\n";
  }
  if (options.normal == 2) {
    fshader += chunk.particle_normalMapPS;
  }
  if (options.normal > 0) {
    fshader += options.halflambert ? chunk.particle_halflambertPS : chunk.particle_lambertPS;
  }
  if (options.normal > 0) {
    fshader += chunk.particle_lightingPS;
  }
  if (options.blend == pc.BLEND_NORMAL) {
    fshader += chunk.particle_blendNormalPS;
  } else {
    if (options.blend == pc.BLEND_ADDITIVE) {
      fshader += chunk.particle_blendAddPS;
    } else {
      if (options.blend == pc.BLEND_MULTIPLICATIVE) {
        fshader += chunk.particle_blendMultiplyPS;
      }
    }
  }
  fshader += chunk.particle_endPS;
  var attributes = pc.shaderChunks.collectAttribs(vshader);
  return {attributes:attributes, vshader:vshader, fshader:fshader};
}};
var _oldChunkWarn = function(oldName, newName) {
};
var _oldChunkFloat = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef MAPFLOAT\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkColor = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef MAPCOLOR\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTex = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef MAPTEXTURE\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTexColor = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "#undef MAPTEXTURECOLOR\n#ifdef MAPTEXTURE\n#ifdef MAPCOLOR\n#define MAPTEXTURECOLOR\n#endif\n#endif\n" + "#ifdef MAPTEXTURECOLOR\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTexFloat = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "#undef MAPTEXTUREFLOAT\n#ifdef MAPTEXTURE\n#ifdef MAPFLOAT\n#define MAPTEXTUREFLOAT\n#endif\n#endif\n" + "#ifdef MAPTEXTUREFLOAT\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkVert = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef MAPVERTEX\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkVertColor = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "#undef MAPVERTEXCOLOR\n#ifdef MAPVERTEX\n#ifdef MAPCOLOR\n#define MAPVERTEXCOLOR\n#endif\n#endif\n" + "#ifdef MAPVERTEXCOLOR\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkVertFloat = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "#undef MAPVERTEXFLOAT\n#ifdef MAPVERTEX\n#ifdef MAPFLOAT\n#define MAPVERTEXFLOAT\n#endif\n#endif\n" + "#ifdef MAPVERTEXFLOAT\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTransformSkin = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef SKIN\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTransformDynbatch = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef DYNAMICBATCH\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTransformInstanced = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef INSTANCING\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTransformPixelSnap = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef PIXELSNAP\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTransformScreenSpace = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef SCREENSPACE\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTransformScreenSpaceBatch = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "#undef SCREENSPACEBATCH\n#ifdef SCREENSPACE\n#ifdef BATCH\n#define SCREENSPACEBATCH\n#endif\n#endif\n" + "#ifdef SCREENSPACEBATCH\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
var _oldChunkTransformUv1 = function(s, o, p) {
  _oldChunkWarn(p, o);
  return "\n#ifdef UV1LAYOUT\n" + s + "\n#else\n" + pc.shaderChunks[o] + "\n#endif\n";
};
pc.programlib.standard = {_oldChunkToNew:{aoTexPS:{n:"aoPS", f:_oldChunkTex}, aoVertPS:{n:"aoPS", f:_oldChunkVert}, diffuseConstPS:{n:"diffusePS", f:_oldChunkColor}, diffuseTexPS:{n:"diffusePS", f:_oldChunkTex}, diffuseTexConstPS:{n:"diffusePS", f:_oldChunkTexColor}, diffuseVertPS:{n:"diffusePS", f:_oldChunkVert}, diffuseVertConstPS:{n:"diffusePS", f:_oldChunkVertColor}, emissiveConstPS:{n:"emissivePS", f:_oldChunkColor}, emissiveTexPS:{n:"emissivePS", f:_oldChunkTex}, emissiveTexConstPS:{n:"emissivePS", 
f:_oldChunkTexColor}, emissiveTexConstFloatPS:{n:"emissivePS", f:_oldChunkTexFloat}, emissiveVertPS:{n:"emissivePS", f:_oldChunkVert}, emissiveVertConstPS:{n:"emissivePS", f:_oldChunkVertColor}, emissiveVertConstFloatPS:{n:"emissivePS", f:_oldChunkVertFloat}, glossConstPS:{n:"glossPS", f:_oldChunkFloat}, glossTexPS:{n:"glossPS", f:_oldChunkTex}, glossTexConstPS:{n:"glossPS", f:_oldChunkTexFloat}, glossVertPS:{n:"glossPS", f:_oldChunkVert}, glossVertConstPS:{n:"glossPS", f:_oldChunkVertFloat}, metalnessConstPS:{n:"metalnessPS", 
f:_oldChunkFloat}, metalnessTexPS:{n:"metalnessPS", f:_oldChunkTex}, metalnessTexConstPS:{n:"metalnessPS", f:_oldChunkTexFloat}, metalnessVertPS:{n:"metalnessPS", f:_oldChunkVert}, metalnessVertConstPS:{n:"metalnessPS", f:_oldChunkVertFloat}, opacityConstPS:{n:"opacityPS", f:_oldChunkFloat}, opacityTexPS:{n:"opacityPS", f:_oldChunkTex}, opacityTexConstPS:{n:"opacityPS", f:_oldChunkTexFloat}, opacityVertPS:{n:"opacityPS", f:_oldChunkVert}, opacityVertConstPS:{n:"opacityPS", f:_oldChunkVertFloat}, 
specularConstPS:{n:"specularPS", f:_oldChunkColor}, specularTexPS:{n:"specularPS", f:_oldChunkTex}, specularTexConstPS:{n:"specularPS", f:_oldChunkTexColor}, specularVertPS:{n:"specularPS", f:_oldChunkVert}, specularVertConstPS:{n:"specularPS", f:_oldChunkVertColor}, transformBatchSkinnedVS:{n:"transformVS", f:_oldChunkTransformDynbatch}, transformInstancedVS:{n:"transformVS", f:_oldChunkTransformInstanced}, transformPixelSnapVS:{n:"transformVS", f:_oldChunkTransformPixelSnap}, transformScreenSpaceVS:{n:"transformVS", 
f:_oldChunkTransformScreenSpace}, transformScreenSpaceBatchSkinned:{n:"transformVS", f:_oldChunkTransformScreenSpaceBatch}, transformSkinned:{n:"transformVS", f:_oldChunkTransformSkin}, transformUv1:{n:"transformVS", f:_oldChunkTransformUv1}}, optionsContext:{}, optionsContextMin:{}, generateKey:function(options) {
  var buildPropertiesList = function(options) {
    var props = [];
    for (var prop in options) {
      if (options.hasOwnProperty(prop) && prop !== "chunks" && prop !== "lights") {
        props.push(prop);
      }
    }
    return props.sort();
  };
  var props;
  if (options === this.optionsContextMin) {
    if (!this.propsMin) {
      this.propsMin = buildPropertiesList(options);
    }
    props = this.propsMin;
  } else {
    if (options === this.optionsContext) {
      if (!this.props) {
        this.props = buildPropertiesList(options);
      }
      props = this.props;
    } else {
      props = buildPropertiesList(options);
    }
  }
  var key = "standard";
  var i;
  for (i = 0; i < props.length; i++) {
    if (options[props[i]]) {
      key += props[i] + options[props[i]];
    }
  }
  if (options.chunks) {
    var chunks = [];
    for (var p in options.chunks) {
      if (options.chunks.hasOwnProperty(p)) {
        chunks.push(p + options.chunks[p]);
      }
    }
    chunks.sort();
    key += chunks;
  }
  if (options.lights) {
    for (i = 0; i < options.lights.length; i++) {
      key += options.lights[i].key;
    }
  }
  return pc.hashCode(key);
}, _correctChannel:function(p, chan) {
  if (pc._matTex2D[p] > 0) {
    if (pc._matTex2D[p] < chan.length) {
      return chan.substring(0, pc._matTex2D[p]);
    } else {
      if (pc._matTex2D[p] > chan.length) {
        var str = chan;
        var chr = str.charAt(str.length - 1);
        var addLen = pc._matTex2D[p] - str.length;
        for (var i = 0; i < addLen; i++) {
          str += chr;
        }
        return str;
      }
    }
    return chan;
  }
}, _setMapTransform:function(codes, name, id, uv) {
  codes[0] += "uniform vec4 texture_" + name + "MapTransform;\n";
  var checkId = id + uv * 100;
  if (!codes[3][checkId]) {
    codes[1] += "varying vec2 vUV" + uv + "_" + id + ";\n";
    codes[2] += "   vUV" + uv + "_" + id + " = uv" + uv + " * texture_" + name + "MapTransform.xy + texture_" + name + "MapTransform.zw;\n";
    codes[3][checkId] = true;
  }
  return codes;
}, _getUvSourceExpression:function(transformPropName, uVPropName, options) {
  var transformId = options[transformPropName];
  var uvChannel = options[uVPropName];
  var expression;
  if (options.nineSlicedMode === pc.SPRITE_RENDERMODE_SLICED) {
    expression = "nineSlicedUv";
  } else {
    if (options.nineSlicedMode === pc.SPRITE_RENDERMODE_TILED) {
      expression = "nineSlicedUv, -1000.0";
    } else {
      if (transformId === 0) {
        expression = "vUv" + uvChannel;
      } else {
        expression = "vUV" + uvChannel + "_" + transformId;
      }
      if (options.heightMap && transformPropName !== "heightMapTransform") {
        expression += " + dUvOffset";
      }
    }
  }
  return expression;
}, _addMapDef:function(name, enabled) {
  var s = "\n#undef " + name + "\n";
  if (enabled) {
    s += " #define " + name + "\n";
  }
  return s;
}, _addMapDefs:function(float, color, vertex, map) {
  var s = "";
  s += this._addMapDef("MAPFLOAT", float);
  s += this._addMapDef("MAPCOLOR", color);
  s += this._addMapDef("MAPVERTEX", vertex);
  s += this._addMapDef("MAPTEXTURE", map);
  return s;
}, _addMap:function(propName, chunkName, options, chunks, samplerFormat) {
  var mapPropName = propName + "Map";
  var uVPropName = mapPropName + "Uv";
  var transformPropName = mapPropName + "Transform";
  var channelPropName = mapPropName + "Channel";
  var vertexColorChannelPropName = propName + "VertexColorChannel";
  var tintPropName = propName + "Tint";
  var vertexColorPropName = propName + "VertexColor";
  var tintOption = options[tintPropName];
  var vertexColorOption = options[vertexColorPropName];
  var textureOption = options[mapPropName];
  var subCode = chunks[chunkName];
  if (textureOption) {
    var uv = this._getUvSourceExpression(transformPropName, uVPropName, options);
    subCode = subCode.replace(/\$UV/g, uv).replace(/\$CH/g, options[channelPropName]);
    if (samplerFormat !== undefined) {
      var fmt = samplerFormat === 0 ? "texture2DSRGB" : samplerFormat === 1 ? "texture2DRGBM" : "texture2D";
      subCode = subCode.replace(/\$texture2DSAMPLE/g, fmt);
    }
  }
  if (vertexColorOption) {
    subCode = subCode.replace(/\$VC/g, options[vertexColorChannelPropName]);
  }
  var isFloatTint = tintOption === 1;
  var isVecTint = tintOption === 3;
  subCode = this._addMapDefs(isFloatTint, isVecTint, vertexColorOption, textureOption) + subCode;
  return subCode.replace(/\$/g, "");
}, _nonPointShadowMapProjection:function(device, light, shadowCoordArgs) {
  if (!light._normalOffsetBias || light._isVsm) {
    if (light._type === pc.LIGHTTYPE_SPOT) {
      if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
        return "       getShadowCoordPerspZbuffer" + shadowCoordArgs;
      }
      return "       getShadowCoordPersp" + shadowCoordArgs;
    }
    return "       getShadowCoordOrtho" + shadowCoordArgs;
  }
  if (light._type === pc.LIGHTTYPE_SPOT) {
    if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
      return "       getShadowCoordPerspZbufferNormalOffset" + shadowCoordArgs;
    }
    return "       getShadowCoordPerspNormalOffset" + shadowCoordArgs;
  }
  return "       getShadowCoordOrthoNormalOffset" + shadowCoordArgs;
}, _addVaryingIfNeeded:function(code, type, name) {
  return code.indexOf(name) >= 0 ? "varying " + type + " " + name + ";\n" : "";
}, _vsAddTransformCode:function(code, device, chunks, options) {
  code += chunks.transformVS;
  return code;
}, _vsAddBaseCode:function(code, device, chunks, options) {
  code += chunks.baseVS;
  if (options.nineSlicedMode === pc.SPRITE_RENDERMODE_SLICED || options.nineSlicedMode === pc.SPRITE_RENDERMODE_TILED) {
    code += chunks.baseNineSlicedVS;
  }
  return code;
}, _fsAddBaseCode:function(code, device, chunks, options) {
  code += chunks.basePS;
  if (options.nineSlicedMode === pc.SPRITE_RENDERMODE_SLICED) {
    code += chunks.baseNineSlicedPS;
  } else {
    if (options.nineSlicedMode === pc.SPRITE_RENDERMODE_TILED) {
      code += chunks.baseNineSlicedTiledPS;
    }
  }
  return code;
}, _fsAddStartCode:function(code, device, chunks, options) {
  code += chunks.startPS;
  if (options.nineSlicedMode === pc.SPRITE_RENDERMODE_SLICED) {
    code += chunks.startNineSlicedPS;
  } else {
    if (options.nineSlicedMode === pc.SPRITE_RENDERMODE_TILED) {
      code += chunks.startNineSlicedTiledPS;
    }
  }
  return code;
}, createShaderDefinition:function(device, options) {
  var i, p;
  var lighting = options.lights.length > 0;
  if (options.dirLightMap) {
    lighting = true;
    options.useSpecular = true;
  }
  if (options.shadingModel === pc.SPECULAR_PHONG) {
    options.fresnelModel = 0;
    options.specularAntialias = false;
    options.prefilteredCubemap = false;
    options.dpAtlas = false;
    options.ambientSH = false;
  } else {
    options.fresnelModel = options.fresnelModel === 0 ? pc.FRESNEL_SCHLICK : options.fresnelModel;
  }
  var cubemapReflection = (options.cubeMap || options.prefilteredCubemap && options.useSpecular) && !options.sphereMap && !options.dpAtlas;
  var reflections = options.sphereMap || cubemapReflection || options.dpAtlas;
  var useTexCubeLod = options.useTexCubeLod;
  if (options.cubeMap) {
    options.sphereMap = null;
  }
  if (options.dpAtlas) {
    options.prefilteredCubemap = null;
  }
  if (!options.useSpecular) {
    options.specularMap = options.glossMap = null;
  }
  var needsNormal = lighting || reflections || options.ambientSH || options.prefilteredCubemap || options.heightMap;
  var shadowPass = options.pass >= pc.SHADER_SHADOW && options.pass <= 17;
  this.options = options;
  var code = "";
  var codeBody = "";
  var varyings = "";
  var chunks = pc.shaderChunks;
  var lightType;
  var shadowCoordArgs;
  var chunk;
  var attributes = {vertex_position:pc.SEMANTIC_POSITION};
  if (options.chunks) {
    var customChunks = {};
    var newP;
    for (p in chunks) {
      if (chunks.hasOwnProperty(p)) {
        if (!options.chunks[p]) {
          customChunks[p] = chunks[p];
        } else {
          chunk = options.chunks[p];
          if (chunk.indexOf("vertex_normal") >= 0) {
            attributes.vertex_normal = pc.SEMANTIC_NORMAL;
          }
          if (chunk.indexOf("vertex_tangent") >= 0) {
            attributes.vertex_tangent = pc.SEMANTIC_TANGENT;
          }
          if (chunk.indexOf("vertex_texCoord0") >= 0) {
            attributes.vertex_texCoord0 = pc.SEMANTIC_TEXCOORD0;
          }
          if (chunk.indexOf("vertex_texCoord1") >= 0) {
            attributes.vertex_texCoord1 = pc.SEMANTIC_TEXCOORD1;
          }
          if (chunk.indexOf("vertex_color") >= 0) {
            attributes.vertex_color = pc.SEMANTIC_COLOR;
          }
          if (chunk.indexOf("vertex_boneWeights") >= 0) {
            attributes.vertex_boneWeights = pc.SEMANTIC_BLENDWEIGHT;
          }
          if (chunk.indexOf("vertex_boneIndices") >= 0) {
            attributes.vertex_boneIndices = pc.SEMANTIC_BLENDINDICES;
          }
          customChunks[p] = chunk;
        }
      }
    }
    for (p in options.chunks) {
      newP = this._oldChunkToNew[p];
      if (newP) {
        customChunks[newP.n] = newP.f(options.chunks[p], newP.n, p);
      }
    }
    chunks = customChunks;
  }
  code = this._vsAddBaseCode(code, device, chunks, options);
  var mainShadowLight = -1;
  if (!options.noShadow && !options.twoSidedLighting) {
    for (i = 0; i < options.lights.length; i++) {
      lightType = options.lights[i]._type;
      if (options.lights[i].castShadows) {
        if (lightType === pc.LIGHTTYPE_DIRECTIONAL) {
          code += "uniform mat4 light" + i + "_shadowMatrixVS;\n";
          code += "uniform vec3 light" + i + "_shadowParamsVS;\n";
          code += "uniform vec3 light" + i + (lightType === pc.LIGHTTYPE_DIRECTIONAL ? "_directionVS" : "_positionVS") + ";\n";
          mainShadowLight = i;
          break;
        }
      }
    }
    if (mainShadowLight >= 0) {
      code += chunks.shadowCoordVS;
    }
  }
  codeBody += "   vPositionW    = getWorldPosition();\n";
  if (options.pass === pc.SHADER_DEPTH) {
    code += "varying float vDepth;\n";
    code += "#ifndef VIEWMATRIX\n";
    code += "#define VIEWMATRIX\n";
    code += "uniform mat4 matrix_view;\n";
    code += "#endif\n";
    code += "#ifndef CAMERAPLANES\n";
    code += "#define CAMERAPLANES\n";
    code += "uniform vec4 camera_params;\n\n";
    code += "#endif\n";
    codeBody += "    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n";
  }
  if (options.useInstancing) {
    attributes.instance_line1 = pc.SEMANTIC_TEXCOORD2;
    attributes.instance_line2 = pc.SEMANTIC_TEXCOORD3;
    attributes.instance_line3 = pc.SEMANTIC_TEXCOORD4;
    attributes.instance_line4 = pc.SEMANTIC_TEXCOORD5;
    code += chunks.instancingVS;
  }
  if (needsNormal) {
    attributes.vertex_normal = pc.SEMANTIC_NORMAL;
    codeBody += "   vNormalW    = dNormalW = getNormal();\n";
    if (options.sphereMap && device.fragmentUniformsCount <= 16) {
      code += chunks.viewNormalVS;
      codeBody += "   vNormalV    = getViewNormal();\n";
    }
    if ((options.heightMap || options.normalMap) && options.hasTangents) {
      attributes.vertex_tangent = pc.SEMANTIC_TANGENT;
      code += chunks.tangentBinormalVS;
      codeBody += "   vTangentW   = getTangent();\n";
      codeBody += "   vBinormalW  = getBinormal();\n";
    }
    if (mainShadowLight >= 0) {
      lightType = options.lights[mainShadowLight]._type;
      if (lightType === pc.LIGHTTYPE_DIRECTIONAL) {
        codeBody += "   dLightDirNormW = light" + mainShadowLight + "_directionVS;\n";
      } else {
        codeBody += "   getLightDirPoint(light" + mainShadowLight + "_positionVS);\n";
      }
      shadowCoordArgs = "(light" + mainShadowLight + "_shadowMatrixVS, light" + mainShadowLight + "_shadowParamsVS);\n";
      codeBody += this._nonPointShadowMapProjection(device, options.lights[mainShadowLight], shadowCoordArgs);
    }
  }
  var useUv = [];
  var useUnmodifiedUv = [];
  var maxUvSets = 2;
  var cname, mname, tname, uname;
  for (p in pc._matTex2D) {
    mname = p + "Map";
    if (options[p + "VertexColor"]) {
      cname = p + "VertexColorChannel";
      options[cname] = this._correctChannel(p, options[cname]);
    }
    if (options[mname]) {
      cname = mname + "Channel";
      tname = mname + "Transform";
      uname = mname + "Uv";
      options[uname] = Math.min(options[uname], maxUvSets - 1);
      options[cname] = this._correctChannel(p, options[cname]);
      var uvSet = options[uname];
      useUv[uvSet] = true;
      useUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || options[mname] && !options[tname];
    }
  }
  if (options.forceUv1) {
    useUv[1] = true;
  }
  for (i = 0; i < maxUvSets; i++) {
    if (useUv[i]) {
      attributes["vertex_texCoord" + i] = pc["SEMANTIC_TEXCOORD" + i];
      code += chunks["uv" + i + "VS"];
      codeBody += "   vec2 uv" + i + " = getUv" + i + "();\n";
    }
    if (useUnmodifiedUv[i]) {
      codeBody += "   vUv" + i + " = uv" + i + ";\n";
    }
  }
  var codes = [code, varyings, codeBody, []];
  for (p in pc._matTex2D) {
    mname = p + "Map";
    if (options[mname]) {
      tname = mname + "Transform";
      if (options[tname]) {
        uname = mname + "Uv";
        this._setMapTransform(codes, p, options[tname], options[uname]);
      }
    }
  }
  code = codes[0];
  varyings = codes[1];
  codeBody = codes[2];
  if (options.vertexColors) {
    attributes.vertex_color = pc.SEMANTIC_COLOR;
    codeBody += "   vVertexColor = vertex_color;\n";
  }
  if (options.skin) {
    attributes.vertex_boneWeights = pc.SEMANTIC_BLENDWEIGHT;
    attributes.vertex_boneIndices = pc.SEMANTIC_BLENDINDICES;
    code += pc.programlib.skinCode(device, chunks);
    code += "#define SKIN\n";
  } else {
    if (options.useInstancing) {
      code += "#define INSTANCING\n";
    }
  }
  if (options.screenSpace) {
    code += "#define SCREENSPACE\n";
  }
  if (options.pixelSnap) {
    code += "#define PIXELSNAP\n";
  }
  code = this._vsAddTransformCode(code, device, chunks, options);
  if (needsNormal) {
    code += chunks.normalVS;
  }
  code += "\n";
  code += chunks.startVS;
  code += codeBody;
  code += "}";
  var vshader = code;
  var oldVars = varyings;
  varyings = "";
  varyings += this._addVaryingIfNeeded(code, "vec4", "vMainShadowUv");
  varyings += this._addVaryingIfNeeded(code, "vec4", "vVertexColor");
  varyings += this._addVaryingIfNeeded(code, "vec3", "vPositionW");
  varyings += this._addVaryingIfNeeded(code, "vec3", "vNormalV");
  varyings += this._addVaryingIfNeeded(code, "vec3", "vNormalW");
  varyings += this._addVaryingIfNeeded(code, "vec3", "vTangentW");
  varyings += this._addVaryingIfNeeded(code, "vec3", "vBinormalW");
  varyings += this._addVaryingIfNeeded(code, "vec2", "vUv0");
  varyings += this._addVaryingIfNeeded(code, "vec2", "vUv1");
  varyings += oldVars;
  vshader = varyings + vshader;
  var startCode = "";
  if (device.webgl2) {
    startCode = pc.programlib.versionCode(device);
    if (chunks.extensionVS) {
      startCode += chunks.extensionVS + "\n";
    }
    vshader = startCode + chunks.gles3VS + vshader;
  } else {
    if (chunks.extensionVS) {
      startCode = chunks.extensionVS + "\n";
    }
    vshader = startCode + vshader;
  }
  if (options.forceFragmentPrecision && options.forceFragmentPrecision != "highp" && options.forceFragmentPrecision !== "mediump" && options.forceFragmentPrecision !== "lowp") {
    options.forceFragmentPrecision = null;
  }
  if (options.forceFragmentPrecision) {
    if (options.forceFragmentPrecision === "highp" && device.maxPrecision !== "highp") {
      options.forceFragmentPrecision = "mediump";
    }
    if (options.forceFragmentPrecision === "mediump" && device.maxPrecision === "lowp") {
      options.forceFragmentPrecision = "lowp";
    }
  }
  var fshader;
  code = "";
  if (device.webgl2) {
    code += pc.programlib.versionCode(device);
  }
  if (device.extStandardDerivatives && !device.webgl2) {
    code += "#extension GL_OES_standard_derivatives : enable\n\n";
  }
  if (chunks.extensionPS) {
    code += chunks.extensionPS + "\n";
  }
  if (device.webgl2) {
    code += chunks.gles3PS;
  }
  code += options.forceFragmentPrecision ? "precision " + options.forceFragmentPrecision + " float;\n\n" : pc.programlib.precisionCode(device);
  if (options.pass === pc.SHADER_PICK) {
    code += "uniform vec4 uColor;";
    code += varyings;
    if (options.alphaTest) {
      code += "float dAlpha;\n";
      code += this._addMap("opacity", "opacityPS", options, chunks);
      code += chunks.alphaTestPS;
    }
    code += pc.programlib.begin();
    if (options.alphaTest) {
      code += "   getOpacity();\n";
      code += "   alphaTest(dAlpha);\n";
    }
    code += "    gl_FragColor = uColor;\n";
    code += pc.programlib.end();
    return {attributes:attributes, vshader:vshader, fshader:code};
  } else {
    if (options.pass === pc.SHADER_DEPTH) {
      code += "varying float vDepth;\n";
      code += varyings;
      code += chunks.packDepthPS;
      if (options.alphaTest) {
        code += "float dAlpha;\n";
        code += this._addMap("opacity", "opacityPS", options, chunks);
        code += chunks.alphaTestPS;
      }
      code += pc.programlib.begin();
      if (options.alphaTest) {
        code += "   getOpacity();\n";
        code += "   alphaTest(dAlpha);\n";
      }
      code += "    gl_FragColor = packFloat(vDepth);\n";
      code += pc.programlib.end();
      return {attributes:attributes, vshader:vshader, fshader:code};
    } else {
      if (shadowPass) {
        var smode = options.pass - pc.SHADER_SHADOW;
        var numShadowModes = 5;
        lightType = Math.floor(smode / numShadowModes);
        var shadowType = smode - lightType * numShadowModes;
        if (device.extStandardDerivatives && !device.webgl2) {
          code += "uniform vec2 polygonOffset;\n";
        }
        if (shadowType === pc.SHADOW_VSM32) {
          if (device.textureFloatHighPrecision) {
            code += "#define VSM_EXPONENT 15.0\n\n";
          } else {
            code += "#define VSM_EXPONENT 5.54\n\n";
          }
        } else {
          if (shadowType === pc.SHADOW_VSM16) {
            code += "#define VSM_EXPONENT 5.54\n\n";
          }
        }
        if (lightType !== pc.LIGHTTYPE_DIRECTIONAL) {
          code += "uniform vec3 view_position;\n";
          code += "uniform float light_radius;\n";
        }
        code += varyings;
        if (options.alphaTest) {
          code += "float dAlpha;\n";
          code += this._addMap("opacity", "opacityPS", options, chunks);
          code += chunks.alphaTestPS;
        }
        if (shadowType === pc.SHADOW_PCF3 && (!device.webgl2 || lightType === pc.LIGHTTYPE_POINT)) {
          code += chunks.packDepthPS;
        } else {
          if (shadowType === pc.SHADOW_VSM8) {
            code += "vec2 encodeFloatRG( float v ) {\n";
            code += "    vec2 enc = vec2(1.0, 255.0) * v;\n";
            code += "    enc = fract(enc);\n";
            code += "    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n";
            code += "    return enc;\n";
            code += "}\n\n";
          }
        }
        code += pc.programlib.begin();
        if (options.alphaTest) {
          code += "   getOpacity();\n";
          code += "   alphaTest(dAlpha);\n";
        }
        var isVsm = shadowType === pc.SHADOW_VSM8 || shadowType === pc.SHADOW_VSM16 || shadowType === pc.SHADOW_VSM32;
        if (lightType === pc.LIGHTTYPE_POINT || isVsm && lightType !== pc.LIGHTTYPE_DIRECTIONAL) {
          code += "   float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n";
        } else {
          code += "   float depth = gl_FragCoord.z;\n";
        }
        if (shadowType === pc.SHADOW_PCF3 && (!device.webgl2 || lightType === pc.LIGHTTYPE_POINT)) {
          if (device.extStandardDerivatives && !device.webgl2) {
            code += "   float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n";
            code += "   depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n";
            code += "   gl_FragColor = packFloat(depth);\n";
          } else {
            code += "   gl_FragColor = packFloat(depth);\n";
          }
        } else {
          if (shadowType === pc.SHADOW_PCF3 || shadowType === pc.SHADOW_PCF5) {
            code += "   gl_FragColor = vec4(1.0);\n";
          } else {
            if (shadowType === pc.SHADOW_VSM8) {
              code += "   gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n";
            } else {
              code += chunks.storeEVSMPS;
            }
          }
        }
        code += pc.programlib.end();
        return {attributes:attributes, vshader:vshader, fshader:code};
      }
    }
  }
  if (options.customFragmentShader) {
    fshader = code + options.customFragmentShader;
    return {attributes:attributes, vshader:vshader, fshader:fshader, tag:pc.SHADERTAG_MATERIAL};
  }
  code += varyings;
  code = this._fsAddBaseCode(code, device, chunks, options);
  var codeBegin = code;
  code = "";
  var numShadowLights = 0;
  var shadowTypeUsed = [];
  var useVsm = false;
  var usePerspZbufferShadow = false;
  var light;
  for (i = 0; i < options.lights.length; i++) {
    light = options.lights[i];
    lightType = light._type;
    code += "uniform vec3 light" + i + "_color;\n";
    if (lightType === pc.LIGHTTYPE_DIRECTIONAL) {
      code += "uniform vec3 light" + i + "_direction;\n";
    } else {
      code += "uniform vec3 light" + i + "_position;\n";
      code += "uniform float light" + i + "_radius;\n";
      if (lightType === pc.LIGHTTYPE_SPOT) {
        code += "uniform vec3 light" + i + "_direction;\n";
        code += "uniform float light" + i + "_innerConeAngle;\n";
        code += "uniform float light" + i + "_outerConeAngle;\n";
      }
    }
    if (light.castShadows && !options.noShadow) {
      code += "uniform mat4 light" + i + "_shadowMatrix;\n";
      if (lightType !== pc.LIGHTTYPE_DIRECTIONAL) {
        code += "uniform vec4 light" + i + "_shadowParams;\n";
      } else {
        code += "uniform vec3 light" + i + "_shadowParams;\n";
      }
      if (lightType === pc.LIGHTTYPE_POINT) {
        code += "uniform samplerCube light" + i + "_shadowMap;\n";
      } else {
        if (light._isPcf && device.webgl2) {
          code += "uniform sampler2DShadow light" + i + "_shadowMap;\n";
        } else {
          code += "uniform sampler2D light" + i + "_shadowMap;\n";
        }
      }
      numShadowLights++;
      shadowTypeUsed[light._shadowType] = true;
      if (light._isVsm) {
        useVsm = true;
      }
      if (light._isPcf && (device.webgl2 || device.extStandardDerivatives) && lightType === pc.LIGHTTYPE_SPOT) {
        usePerspZbufferShadow = true;
      }
    }
    if (light._cookie) {
      if (light._cookie._cubemap) {
        if (lightType === pc.LIGHTTYPE_POINT) {
          code += "uniform samplerCube light" + i + "_cookie;\n";
          code += "uniform float light" + i + "_cookieIntensity;\n";
          if (!light.castShadows || options.noShadow) {
            code += "uniform mat4 light" + i + "_shadowMatrix;\n";
          }
        }
      } else {
        if (lightType === pc.LIGHTTYPE_SPOT) {
          code += "uniform sampler2D light" + i + "_cookie;\n";
          code += "uniform float light" + i + "_cookieIntensity;\n";
          if (!light.castShadows || options.noShadow) {
            code += "uniform mat4 light" + i + "_shadowMatrix;\n";
          }
          if (light._cookieTransform) {
            code += "uniform vec4 light" + i + "_cookieMatrix;\n";
            code += "uniform vec2 light" + i + "_cookieOffset;\n";
          }
        }
      }
    }
  }
  code += "\n";
  var tbn;
  if (!options.hasTangents) {
    tbn = chunks.TBNderivativePS;
  } else {
    if (options.fastTbn) {
      tbn = chunks.TBNfastPS;
    } else {
      tbn = chunks.TBNPS;
    }
  }
  if (needsNormal) {
    if (options.normalMap) {
      code += options.packedNormal ? chunks.normalXYPS : chunks.normalXYZPS;
      var transformedNormalMapUv = this._getUvSourceExpression("normalMapTransform", "normalMapUv", options);
      if (options.needsNormalFloat) {
        code += (options.fastTbn ? chunks.normalMapFloatTBNfastPS : chunks.normalMapFloatPS).replace(/\$UV/g, transformedNormalMapUv);
      } else {
        code += chunks.normalMapPS.replace(/\$UV/g, transformedNormalMapUv);
      }
      if (!options.hasTangents) {
        tbn = tbn.replace(/\$UV/g, transformedNormalMapUv);
      }
      code += tbn;
    } else {
      code += chunks.normalVertexPS;
    }
  }
  code += pc.programlib.gammaCode(options.gamma);
  code += pc.programlib.tonemapCode(options.toneMap);
  code += pc.programlib.fogCode(options.fog);
  if (options.useRgbm) {
    code += chunks.rgbmPS;
  }
  if (cubemapReflection || options.prefilteredCubemap) {
    code += options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS;
  }
  if (needsNormal) {
    code += options.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS;
    code += options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS;
  }
  code += this._addMap("diffuse", "diffusePS", options, chunks);
  if (options.blendType !== pc.BLEND_NONE || options.alphaTest || options.alphaToCoverage) {
    code += this._addMap("opacity", "opacityPS", options, chunks);
  }
  code += this._addMap("emissive", "emissivePS", options, chunks, options.emissiveFormat);
  if (options.useSpecular && (lighting || reflections)) {
    if (options.specularAntialias && options.normalMap) {
      if (options.needsNormalFloat && needsNormal) {
        code += chunks.specularAaToksvigFloatPS;
      } else {
        code += chunks.specularAaToksvigPS;
      }
    } else {
      code += chunks.specularAaNonePS;
    }
    var specularPropName = options.useMetalness ? "metalness" : "specular";
    code += this._addMap(specularPropName, specularPropName + "PS", options, chunks);
    code += this._addMap("gloss", "glossPS", options, chunks);
    if (options.fresnelModel > 0) {
      if (options.fresnelModel === pc.FRESNEL_SIMPLE) {
        code += chunks.fresnelSimplePS;
      } else {
        if (options.fresnelModel === pc.FRESNEL_SCHLICK) {
          code += chunks.fresnelSchlickPS;
        } else {
          if (options.fresnelModel === pc.FRESNEL_COMPLEX) {
            code += chunks.fresnelComplexPS;
          }
        }
      }
    }
  }
  if (options.heightMap) {
    if (!options.normalMap) {
      var transformedHeightMapUv = this._getUvSourceExpression("heightMapTransform", "heightMapUv", options);
      if (!options.hasTangents) {
        tbn = tbn.replace(/\$UV/g, transformedHeightMapUv);
      }
      code += tbn;
    }
    code += this._addMap("height", "parallaxPS", options, chunks);
  }
  var useAo = options.aoMap || options.aoVertexColor;
  if (useAo) {
    code += this._addMap("ao", "aoPS", options, chunks);
    if (options.occludeSpecular) {
      if (options.occludeSpecular === pc.SPECOCC_AO) {
        code += options.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS;
      } else {
        code += options.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS;
      }
    }
  }
  var reflectionDecode = options.rgbmReflection ? "decodeRGBM" : options.hdrReflection ? "" : "gammaCorrectInput";
  if (options.sphereMap) {
    var scode = device.fragmentUniformsCount > 16 ? chunks.reflectionSpherePS : chunks.reflectionSphereLowPS;
    scode = scode.replace(/\$texture2DSAMPLE/g, options.rgbmReflection ? "texture2DRGBM" : options.hdrReflection ? "texture2D" : "texture2DSRGB");
    code += scode;
  } else {
    if (cubemapReflection) {
      if (options.prefilteredCubemap) {
        if (useTexCubeLod) {
          code += chunks.reflectionPrefilteredCubeLodPS.replace(/\$DECODE/g, reflectionDecode);
        } else {
          code += chunks.reflectionPrefilteredCubePS.replace(/\$DECODE/g, reflectionDecode);
        }
      } else {
        code += chunks.reflectionCubePS.replace(/\$textureCubeSAMPLE/g, options.rgbmReflection ? "textureCubeRGBM" : options.hdrReflection ? "textureCube" : "textureCubeSRGB");
      }
    } else {
      if (options.dpAtlas) {
        code += chunks.reflectionDpAtlasPS.replace(/\$texture2DSAMPLE/g, options.rgbmReflection ? "texture2DRGBM" : options.hdrReflection ? "texture2D" : "texture2DSRGB");
      }
    }
  }
  if ((cubemapReflection || options.sphereMap || options.dpAtlas) && options.refraction) {
    code += chunks.refractionPS;
  }
  if (numShadowLights > 0) {
    if (shadowTypeUsed[pc.SHADOW_PCF3]) {
      code += chunks.shadowStandardPS;
    }
    if (shadowTypeUsed[pc.SHADOW_PCF5]) {
      code += chunks.shadowStandardGL2PS;
    }
    if (useVsm) {
      code += chunks.shadowVSM_commonPS;
      if (shadowTypeUsed[pc.SHADOW_VSM8]) {
        code += chunks.shadowVSM8PS;
      }
      if (shadowTypeUsed[pc.SHADOW_VSM16]) {
        code += device.extTextureHalfFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "16") : chunks.shadowEVSMnPS.replace(/\$/g, "16");
      }
      if (shadowTypeUsed[pc.SHADOW_VSM32]) {
        code += device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "32") : chunks.shadowEVSMnPS.replace(/\$/g, "32");
      }
    }
    if (device.webgl2 || device.extStandardDerivatives) {
    } else {
      code += chunks.biasConstPS;
    }
    code += chunks.shadowCoordPS + chunks.shadowCommonPS;
    if (usePerspZbufferShadow) {
      code += chunks.shadowCoordPerspZbufferPS;
    }
    if (mainShadowLight >= 0) {
      if (shadowTypeUsed[pc.SHADOW_PCF3]) {
        code += chunks.shadowStandardVSPS;
      }
      if (shadowTypeUsed[pc.SHADOW_PCF5]) {
        code += chunks.shadowStandardGL2VSPS;
      }
      if (useVsm) {
        if (shadowTypeUsed[pc.SHADOW_VSM8]) {
          code += chunks.shadowVSMVSPS.replace(/\$VSM/g, "VSM8").replace(/\$/g, "8");
        }
        if (shadowTypeUsed[pc.SHADOW_VSM16]) {
          code += chunks.shadowVSMVSPS.replace(/\$VSM/g, "VSM16").replace(/\$/g, "16");
        }
        if (shadowTypeUsed[pc.SHADOW_VSM32]) {
          code += chunks.shadowVSMVSPS.replace(/\$VSM/g, "VSM32").replace(/\$/g, "32");
        }
      }
    }
  }
  if (lighting) {
    code += chunks.lightDiffuseLambertPS;
  }
  var useOldAmbient = false;
  if (options.useSpecular) {
    if (lighting) {
      code += options.shadingModel === pc.SPECULAR_PHONG ? chunks.lightSpecularPhongPS : chunks.lightSpecularBlinnPS;
    }
    if (options.sphereMap || cubemapReflection || options.dpAtlas || options.fresnelModel > 0) {
      if (options.fresnelModel > 0) {
        if (options.conserveEnergy) {
          code += chunks.combineDiffuseSpecularPS;
        } else {
          code += chunks.combineDiffuseSpecularNoConservePS;
        }
      } else {
        code += chunks.combineDiffuseSpecularOldPS;
      }
    } else {
      if (options.diffuseMap) {
        code += chunks.combineDiffuseSpecularNoReflPS;
      } else {
        code += chunks.combineDiffuseSpecularNoReflSeparateAmbientPS;
        useOldAmbient = true;
      }
    }
  } else {
    code += chunks.combineDiffusePS;
  }
  var addAmbient = true;
  if (options.lightMap || options.lightVertexColor) {
    var lightmapChunkPropName = options.dirLightMap ? "lightmapDirPS" : "lightmapSinglePS";
    code += this._addMap("light", lightmapChunkPropName, options, chunks, options.lightMapFormat);
    addAmbient = options.lightMapWithoutAmbient;
  }
  if (addAmbient) {
    var ambientDecode = options.rgbmAmbient ? "decodeRGBM" : options.hdrAmbient ? "" : "gammaCorrectInput";
    if (options.ambientSH) {
      code += chunks.ambientSHPS;
    } else {
      if (options.prefilteredCubemap) {
        if (useTexCubeLod) {
          code += chunks.ambientPrefilteredCubeLodPS.replace(/\$DECODE/g, ambientDecode);
        } else {
          code += chunks.ambientPrefilteredCubePS.replace(/\$DECODE/g, ambientDecode);
        }
      } else {
        code += chunks.ambientConstantPS;
      }
    }
  }
  if (options.ambientTint && !useOldAmbient) {
    code += "uniform vec3 material_ambient;\n";
  }
  if (options.alphaTest) {
    code += chunks.alphaTestPS;
  }
  if (options.msdf) {
    code += chunks.msdfPS;
  }
  if (needsNormal) {
    code += chunks.viewDirPS;
    if (options.useSpecular) {
      code += chunks.reflDirPS;
    }
  }
  var hasPointLights = false;
  var usesLinearFalloff = false;
  var usesInvSquaredFalloff = false;
  var usesSpot = false;
  var usesCookie = false;
  var usesCookieNow;
  code = this._fsAddStartCode(code, device, chunks, options);
  if (needsNormal) {
    if (options.twoSidedLighting) {
      code += "   dVertexNormalW = gl_FrontFacing ? vNormalW : -vNormalW;\n";
    } else {
      code += "   dVertexNormalW = vNormalW;\n";
    }
    if ((options.heightMap || options.normalMap) && options.hasTangents) {
      if (options.twoSidedLighting) {
        code += "   dTangentW = gl_FrontFacing ? vTangentW : -vTangentW;\n";
        code += "   dBinormalW = gl_FrontFacing ? vBinormalW : -vBinormalW;\n";
      } else {
        code += "   dTangentW = vTangentW;\n";
        code += "   dBinormalW = vBinormalW;\n";
      }
    }
  }
  var opacityParallax = false;
  if (options.blendType === pc.BLEND_NONE && !options.alphaTest && !options.alphaToCoverage) {
    code += "   dAlpha = 1.0;\n";
  } else {
    if (options.heightMap && options.opacityMap) {
      opacityParallax = true;
    } else {
      code += "   getOpacity();\n";
      if (options.alphaTest) {
        code += "   alphaTest(dAlpha);\n";
      }
    }
  }
  if (needsNormal) {
    code += "   getViewDir();\n";
    if (options.heightMap || options.normalMap) {
      code += "   getTBN();\n";
    }
    if (options.heightMap) {
      code += "   getParallax();\n";
    }
    if (opacityParallax) {
      code += "   getOpacity();\n";
      if (options.alphaTest) {
        code += "   alphaTest(dAlpha);\n";
      }
    }
    code += "   getNormal();\n";
    if (options.useSpecular) {
      code += "   getReflDir();\n";
    }
  }
  code += "   getAlbedo();\n";
  if (lighting && options.useSpecular || reflections) {
    code += "   getSpecularity();\n";
    code += "   getGlossiness();\n";
    if (options.fresnelModel > 0) {
      code += "   getFresnel();\n";
    }
  }
  if (addAmbient) {
    code += "   addAmbient();\n";
  }
  if (options.ambientTint && !useOldAmbient) {
    code += "   dDiffuseLight *= material_ambient;\n";
  }
  if (useAo && !options.occludeDirect) {
    code += "    applyAO();\n";
  }
  if (options.lightMap || options.lightVertexColor) {
    code += "   addLightMap();\n";
  }
  if (lighting || reflections) {
    if (cubemapReflection || options.sphereMap || options.dpAtlas) {
      code += "   addReflection();\n";
    }
    if (options.dirLightMap) {
      code += "   addDirLightMap();\n";
    }
    for (i = 0; i < options.lights.length; i++) {
      light = options.lights[i];
      lightType = light._type;
      usesCookieNow = false;
      if (lightType === pc.LIGHTTYPE_DIRECTIONAL) {
        code += "   dLightDirNormW = light" + i + "_direction;\n";
        code += "   dAtten = 1.0;\n";
      } else {
        if (light._cookie) {
          if (lightType === pc.LIGHTTYPE_SPOT && !light._cookie._cubemap) {
            usesCookie = true;
            usesCookieNow = true;
          } else {
            if (lightType === pc.LIGHTTYPE_POINT && light._cookie._cubemap) {
              usesCookie = true;
              usesCookieNow = true;
            }
          }
        }
        code += "   getLightDirPoint(light" + i + "_position);\n";
        hasPointLights = true;
        if (usesCookieNow) {
          if (lightType === pc.LIGHTTYPE_SPOT) {
            code += "   dAtten3 = getCookie2D" + (light._cookieFalloff ? "" : "Clip") + (light._cookieTransform ? "Xform" : "") + "(light" + i + "_cookie, light" + i + "_shadowMatrix, light" + i + "_cookieIntensity" + (light._cookieTransform ? ", light" + i + "_cookieMatrix, light" + i + "_cookieOffset" : "") + ")." + light._cookieChannel + ";\n";
          } else {
            code += "   dAtten3 = getCookieCube(light" + i + "_cookie, light" + i + "_shadowMatrix, light" + i + "_cookieIntensity)." + light._cookieChannel + ";\n";
          }
        }
        if (light._falloffMode === pc.LIGHTFALLOFF_LINEAR) {
          code += "   dAtten = getFalloffLinear(light" + i + "_radius);\n";
          usesLinearFalloff = true;
        } else {
          code += "   dAtten = getFalloffInvSquared(light" + i + "_radius);\n";
          usesInvSquaredFalloff = true;
        }
        code += "   if (dAtten > 0.00001) {\n";
        if (lightType === pc.LIGHTTYPE_SPOT) {
          if (!(usesCookieNow && !light._cookieFalloff)) {
            code += "       dAtten *= getSpotEffect(light" + i + "_direction, light" + i + "_innerConeAngle, light" + i + "_outerConeAngle);\n";
            usesSpot = true;
          }
        }
      }
      code += "       dAtten *= getLightDiffuse();\n";
      if (light.castShadows && !options.noShadow) {
        var shadowReadMode = null;
        var evsmExp;
        if (light._shadowType === pc.SHADOW_VSM8) {
          shadowReadMode = "VSM8";
          evsmExp = "0.0";
        } else {
          if (light._shadowType === pc.SHADOW_VSM16) {
            shadowReadMode = "VSM16";
            evsmExp = "5.54";
          } else {
            if (light._shadowType === pc.SHADOW_VSM32) {
              shadowReadMode = "VSM32";
              if (device.textureFloatHighPrecision) {
                evsmExp = "15.0";
              } else {
                evsmExp = "5.54";
              }
            } else {
              if (light._shadowType === pc.SHADOW_PCF5) {
                shadowReadMode = "PCF5x5";
              } else {
                shadowReadMode = "PCF3x3";
              }
            }
          }
        }
        if (shadowReadMode !== null) {
          if (lightType === pc.LIGHTTYPE_POINT) {
            shadowCoordArgs = "(light" + i + "_shadowMap, light" + i + "_shadowParams);\n";
            if (light._normalOffsetBias) {
              code += "       normalOffsetPointShadow(light" + i + "_shadowParams);\n";
            }
            code += "       dAtten *= getShadowPoint" + shadowReadMode + shadowCoordArgs;
          } else {
            if (mainShadowLight === i) {
              shadowReadMode += "VS";
            } else {
              shadowCoordArgs = "(light" + i + "_shadowMatrix, light" + i + "_shadowParams);\n";
              code += this._nonPointShadowMapProjection(device, options.lights[i], shadowCoordArgs);
            }
            if (lightType === pc.LIGHTTYPE_SPOT) {
              shadowReadMode = "Spot" + shadowReadMode;
            }
            code += "       dAtten *= getShadow" + shadowReadMode + "(light" + i + "_shadowMap, light" + i + "_shadowParams" + (light._isVsm ? ", " + evsmExp : "") + ");\n";
          }
        }
      }
      code += "       dDiffuseLight += dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
      if (options.useSpecular) {
        code += "       dAtten *= getLightSpecular();\n";
        code += "       dSpecularLight += dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
      }
      if (lightType !== pc.LIGHTTYPE_DIRECTIONAL) {
        code += "   }\n";
      }
      code += "\n";
    }
    if ((cubemapReflection || options.sphereMap || options.dpAtlas) && options.refraction) {
      code += "   addRefraction();\n";
    }
  }
  code += "\n";
  if (useAo) {
    if (options.occludeDirect) {
      code += "    applyAO();\n";
    }
    if (options.occludeSpecular) {
      code += "    occludeSpecular();\n";
    }
  }
  code += chunks.endPS;
  if (options.blendType === pc.BLEND_NORMAL || options.blendType === pc.BLEND_ADDITIVEALPHA || options.alphaToCoverage) {
    code += chunks.outputAlphaPS;
  } else {
    if (options.blendType === pc.BLEND_PREMULTIPLIED) {
      code += chunks.outputAlphaPremulPS;
    } else {
      code += chunks.outputAlphaOpaquePS;
    }
  }
  if (options.msdf) {
    code += "   gl_FragColor = applyMsdf(gl_FragColor);\n";
  }
  code += "\n";
  code += pc.programlib.end();
  if (hasPointLights) {
    code = chunks.lightDirPointPS + code;
  }
  if (usesLinearFalloff) {
    code = chunks.falloffLinearPS + code;
  }
  if (usesInvSquaredFalloff) {
    code = chunks.falloffInvSquaredPS + code;
  }
  if (usesSpot) {
    code = chunks.spotPS + code;
  }
  if (usesCookie) {
    code = chunks.cookiePS + code;
  }
  var structCode = "";
  if (code.includes("dReflection")) {
    structCode += "vec4 dReflection;\n";
  }
  if (code.includes("dTBN")) {
    structCode += "mat3 dTBN;\n";
  }
  if (code.includes("dAlbedo")) {
    structCode += "vec3 dAlbedo;\n";
  }
  if (code.includes("dEmission")) {
    structCode += "vec3 dEmission;\n";
  }
  if (code.includes("dNormalW")) {
    structCode += "vec3 dNormalW;\n";
  }
  if (code.includes("dVertexNormalW")) {
    structCode += "vec3 dVertexNormalW;\n";
  }
  if (code.includes("dTangentW")) {
    structCode += "vec3 dTangentW;\n";
  }
  if (code.includes("dBinormalW")) {
    structCode += "vec3 dBinormalW;\n";
  }
  if (code.includes("dViewDirW")) {
    structCode += "vec3 dViewDirW;\n";
  }
  if (code.includes("dReflDirW")) {
    structCode += "vec3 dReflDirW;\n";
  }
  if (code.includes("dDiffuseLight")) {
    structCode += "vec3 dDiffuseLight;\n";
  }
  if (code.includes("dSpecularLight")) {
    structCode += "vec3 dSpecularLight;\n";
  }
  if (code.includes("dLightDirNormW")) {
    structCode += "vec3 dLightDirNormW;\n";
  }
  if (code.includes("dLightDirW")) {
    structCode += "vec3 dLightDirW;\n";
  }
  if (code.includes("dLightPosW")) {
    structCode += "vec3 dLightPosW;\n";
  }
  if (code.includes("dShadowCoord")) {
    structCode += "vec3 dShadowCoord;\n";
  }
  if (code.includes("dNormalMap")) {
    structCode += "vec3 dNormalMap;\n";
  }
  if (code.includes("dSpecularity")) {
    structCode += "vec3 dSpecularity;\n";
  }
  if (code.includes("dUvOffset")) {
    structCode += "vec2 dUvOffset;\n";
  }
  if (code.includes("dGlossiness")) {
    structCode += "float dGlossiness;\n";
  }
  if (code.includes("dAlpha")) {
    structCode += "float dAlpha;\n";
  }
  if (code.includes("dAtten")) {
    structCode += "float dAtten;\n";
  }
  if (code.includes("dAtten3")) {
    structCode += "vec3 dAtten3;\n";
  }
  if (code.includes("dAo")) {
    structCode += "float dAo;\n";
  }
  if (code.includes("dMsdf")) {
    structCode += "vec4 dMsdf;\n";
  }
  code = codeBegin + structCode + code;
  fshader = code;
  return {attributes:attributes, vshader:vshader, fshader:fshader, tag:pc.SHADERTAG_MATERIAL};
}};
pc.programlib.skybox = {generateKey:function(options) {
  var key = "skybox" + options.rgbm + " " + options.hdr + " " + options.fixSeams + "" + options.toneMapping + "" + options.gamma + "" + options.useIntensity + "" + options.mip;
  return key;
}, createShaderDefinition:function(device, options) {
  var chunks = pc.shaderChunks;
  var mip2size = [128, 64, 16, 8, 4, 2];
  return {attributes:{aPosition:pc.SEMANTIC_POSITION}, vshader:chunks.skyboxVS, fshader:pc.programlib.precisionCode(device) + (options.mip ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS) + (options.useIntensity ? chunks.envMultiplyPS : chunks.envConstPS) + pc.programlib.gammaCode(options.gamma) + pc.programlib.tonemapCode(options.toneMapping) + chunks.rgbmPS + chunks.skyboxHDRPS.replace(/\$textureCubeSAMPLE/g, options.rgbm ? "textureCubeRGBM" : options.hdr ? "textureCube" : "textureCubeSRGB").replace(/\$FIXCONST/g, 
  1.0 - 1.0 / mip2size[options.mip] + "")};
}};
Object.assign(pc, function() {
  var primitive = {type:pc.PRIMITIVE_TRISTRIP, base:0, count:4, indexed:false};
  var PostEffect = function(graphicsDevice) {
    this.device = graphicsDevice;
    this.shader = null;
    this.depthMap = null;
    this.vertexBuffer = pc.createFullscreenQuad(graphicsDevice);
    this.needsDepthBuffer = false;
  };
  Object.assign(PostEffect.prototype, {render:function(inputTarget, outputTarget, rect) {
  }});
  function createFullscreenQuad(device) {
    var vertexFormat = new pc.VertexFormat(device, [{semantic:pc.SEMANTIC_POSITION, components:2, type:pc.TYPE_FLOAT32}]);
    var vertexBuffer = new pc.VertexBuffer(device, vertexFormat, 4);
    var iterator = new pc.VertexIterator(vertexBuffer);
    iterator.element[pc.SEMANTIC_POSITION].set(-1.0, -1.0);
    iterator.next();
    iterator.element[pc.SEMANTIC_POSITION].set(1.0, -1.0);
    iterator.next();
    iterator.element[pc.SEMANTIC_POSITION].set(-1.0, 1.0);
    iterator.next();
    iterator.element[pc.SEMANTIC_POSITION].set(1.0, 1.0);
    iterator.end();
    return vertexBuffer;
  }
  function drawFullscreenQuad(device, target, vertexBuffer, shader, rect) {
    var oldRt = device.getRenderTarget();
    device.setRenderTarget(target);
    device.updateBegin();
    var w = target !== null ? target.width : device.width;
    var h = target !== null ? target.height : device.height;
    var x = 0;
    var y = 0;
    if (rect) {
      x = rect.x * w;
      y = rect.y * h;
      w *= rect.z;
      h *= rect.w;
    }
    var oldVx = device.vx;
    var oldVy = device.vy;
    var oldVw = device.vw;
    var oldVh = device.vh;
    device.setViewport(x, y, w, h);
    var oldSx = device.sx;
    var oldSy = device.sy;
    var oldSw = device.sw;
    var oldSh = device.sh;
    device.setScissor(x, y, w, h);
    var oldBlending = device.getBlending();
    var oldDepthTest = device.getDepthTest();
    var oldDepthWrite = device.getDepthWrite();
    var oldCullMode = device.getCullMode();
    var oldWR = device.writeRed;
    var oldWG = device.writeGreen;
    var oldWB = device.writeBlue;
    var oldWA = device.writeAlpha;
    device.setBlending(false);
    device.setDepthTest(false);
    device.setDepthWrite(false);
    device.setCullMode(pc.CULLFACE_NONE);
    device.setColorWrite(true, true, true, true);
    device.setVertexBuffer(vertexBuffer, 0);
    device.setShader(shader);
    device.draw(primitive);
    device.setBlending(oldBlending);
    device.setDepthTest(oldDepthTest);
    device.setDepthWrite(oldDepthWrite);
    device.setCullMode(oldCullMode);
    device.setColorWrite(oldWR, oldWG, oldWB, oldWA);
    device.updateEnd();
    device.setRenderTarget(oldRt);
    device.updateBegin();
    device.setViewport(oldVx, oldVy, oldVw, oldVh);
    device.setScissor(oldSx, oldSy, oldSw, oldSh);
  }
  return {PostEffect:PostEffect, createFullscreenQuad:createFullscreenQuad, drawFullscreenQuad:drawFullscreenQuad};
}());
(function() {
  var enums = {BLEND_SUBTRACTIVE:0, BLEND_ADDITIVE:1, BLEND_NORMAL:2, BLEND_NONE:3, BLEND_PREMULTIPLIED:4, BLEND_MULTIPLICATIVE:5, BLEND_ADDITIVEALPHA:6, BLEND_MULTIPLICATIVE2X:7, BLEND_SCREEN:8, BLEND_MIN:9, BLEND_MAX:10, FOG_NONE:"none", FOG_LINEAR:"linear", FOG_EXP:"exp", FOG_EXP2:"exp2", FRESNEL_NONE:0, FRESNEL_SCHLICK:2, LAYER_HUD:0, LAYER_GIZMO:1, LAYER_FX:2, LAYER_WORLD:15, LAYERID_WORLD:0, LAYERID_DEPTH:1, LAYERID_SKYBOX:2, LAYERID_IMMEDIATE:3, LAYERID_UI:4, LIGHTTYPE_DIRECTIONAL:0, LIGHTTYPE_POINT:1, 
  LIGHTTYPE_SPOT:2, LIGHTFALLOFF_LINEAR:0, LIGHTFALLOFF_INVERSESQUARED:1, SHADOW_PCF3:0, SHADOW_DEPTH:0, SHADOW_VSM8:1, SHADOW_VSM16:2, SHADOW_VSM32:3, SHADOW_PCF5:4, BLUR_BOX:0, BLUR_GAUSSIAN:1, PARTICLESORT_NONE:0, PARTICLESORT_DISTANCE:1, PARTICLESORT_NEWER_FIRST:2, PARTICLESORT_OLDER_FIRST:3, PARTICLEMODE_GPU:0, PARTICLEMODE_CPU:1, EMITTERSHAPE_BOX:0, EMITTERSHAPE_SPHERE:1, PROJECTION_PERSPECTIVE:0, PROJECTION_ORTHOGRAPHIC:1, RENDERSTYLE_SOLID:0, RENDERSTYLE_WIREFRAME:1, RENDERSTYLE_POINTS:2, 
  CUBEPROJ_NONE:0, CUBEPROJ_BOX:1, SPECULAR_PHONG:0, SPECULAR_BLINN:1, GAMMA_NONE:0, GAMMA_SRGB:1, GAMMA_SRGBFAST:2, GAMMA_SRGBHDR:3, TONEMAP_LINEAR:0, TONEMAP_FILMIC:1, TONEMAP_HEJL:2, TONEMAP_ACES:3, TONEMAP_ACES2:4, SPECOCC_NONE:0, SPECOCC_AO:1, SPECOCC_GLOSSDEPENDENT:2, SHADERDEF_NOSHADOW:1, SHADERDEF_SKIN:2, SHADERDEF_UV0:4, SHADERDEF_UV1:8, SHADERDEF_VCOLOR:16, SHADERDEF_INSTANCING:32, SHADERDEF_LM:64, SHADERDEF_DIRLM:128, SHADERDEF_SCREENSPACE:256, SHADERDEF_TANGENTS:512, LINEBATCH_WORLD:0, 
  LINEBATCH_OVERLAY:1, LINEBATCH_GIZMO:2, SHADOWUPDATE_NONE:0, SHADOWUPDATE_THISFRAME:1, SHADOWUPDATE_REALTIME:2, SORTKEY_FORWARD:0, SORTKEY_DEPTH:1, MASK_DYNAMIC:1, MASK_BAKED:2, MASK_LIGHTMAP:4, SHADER_FORWARD:0, SHADER_FORWARDHDR:1, SHADER_DEPTH:2, SHADER_SHADOW:3, SHADER_PICK:18, BAKE_COLOR:0, BAKE_COLORDIR:1, VIEW_CENTER:0, VIEW_LEFT:1, VIEW_RIGHT:2, SORTMODE_NONE:0, SORTMODE_MANUAL:1, SORTMODE_MATERIALMESH:2, SORTMODE_BACK2FRONT:3, SORTMODE_FRONT2BACK:4, SORTMODE_CUSTOM:5, COMPUPDATED_INSTANCES:1, 
  COMPUPDATED_LIGHTS:2, COMPUPDATED_CAMERAS:4, COMPUPDATED_BLEND:8, ASPECT_AUTO:0, ASPECT_MANUAL:1, ORIENTATION_HORIZONTAL:0, ORIENTATION_VERTICAL:1};
  Object.assign(pc, enums);
  pc.scene = {};
  Object.assign(pc.scene, enums);
})();
Object.assign(pc, function() {
  var Scene = function Scene() {
    this.root = null;
    this._gravity = new pc.Vec3(0, -9.8, 0);
    this._layers = null;
    this._fog = pc.FOG_NONE;
    this.fogColor = new pc.Color(0, 0, 0);
    this.fogStart = 1;
    this.fogEnd = 1000;
    this.fogDensity = 0;
    this.ambientLight = new pc.Color(0, 0, 0);
    this._gammaCorrection = pc.GAMMA_NONE;
    this._toneMapping = 0;
    this.exposure = 1.0;
    this._skyboxPrefiltered = [null, null, null, null, null, null];
    this._skyboxCubeMap = null;
    this.skyboxModel = null;
    this._skyboxIntensity = 1;
    this._skyboxMip = 0;
    this.lightmapSizeMultiplier = 1;
    this.lightmapMaxResolution = 2048;
    this.lightmapMode = pc.BAKE_COLORDIR;
    this._stats = {meshInstances:0, lights:0, dynamicLights:0, bakedLights:0, lastStaticPrepareFullTime:0, lastStaticPrepareSearchTime:0, lastStaticPrepareWriteTime:0, lastStaticPrepareTriAabbTime:0, lastStaticPrepareCombineTime:0, updateShadersTime:0};
    this.updateShaders = true;
    this.updateSkybox = true;
    this._shaderVersion = 0;
    this._statsUpdated = false;
    this._models = [];
    this.defaultMaterial = new pc.StandardMaterial;
    this.defaultMaterial.name = "Default Material";
    this.defaultMaterial.shadingModel = pc.SPECULAR_BLINN;
    pc.events.attach(this);
  };
  Scene.prototype.destroy = function() {
    this.root = null;
    this.defaultMaterial.destroy();
    this.defaultMaterial = null;
    this.off();
  };
  Object.defineProperty(Scene.prototype, "fog", {get:function() {
    return this._fog;
  }, set:function(type) {
    if (type !== this._fog) {
      this._fog = type;
      this.updateShaders = true;
    }
  }});
  Object.defineProperty(Scene.prototype, "gammaCorrection", {get:function() {
    return this._gammaCorrection;
  }, set:function(value) {
    if (value !== this._gammaCorrection) {
      this._gammaCorrection = value;
      this.updateShaders = true;
    }
  }});
  Object.defineProperty(Scene.prototype, "toneMapping", {get:function() {
    return this._toneMapping;
  }, set:function(value) {
    if (value !== this._toneMapping) {
      this._toneMapping = value;
      this.updateShaders = true;
    }
  }});
  Object.defineProperty(Scene.prototype, "skybox", {get:function() {
    return this._skyboxCubeMap;
  }, set:function(value) {
    this._skyboxCubeMap = value;
    this._resetSkyboxModel();
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxIntensity", {get:function() {
    return this._skyboxIntensity;
  }, set:function(value) {
    this._skyboxIntensity = value;
    this._resetSkyboxModel();
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxMip", {get:function() {
    return this._skyboxMip;
  }, set:function(value) {
    this._skyboxMip = value;
    this._resetSkyboxModel();
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxPrefiltered128", {get:function() {
    return this._skyboxPrefiltered[0];
  }, set:function(value) {
    if (this._skyboxPrefiltered[0] === value) {
      return;
    }
    this._skyboxPrefiltered[0] = value;
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxPrefiltered64", {get:function() {
    return this._skyboxPrefiltered[1];
  }, set:function(value) {
    if (this._skyboxPrefiltered[1] === value) {
      return;
    }
    this._skyboxPrefiltered[1] = value;
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxPrefiltered32", {get:function() {
    return this._skyboxPrefiltered[2];
  }, set:function(value) {
    if (this._skyboxPrefiltered[2] === value) {
      return;
    }
    this._skyboxPrefiltered[2] = value;
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxPrefiltered16", {get:function() {
    return this._skyboxPrefiltered[3];
  }, set:function(value) {
    if (this._skyboxPrefiltered[3] === value) {
      return;
    }
    this._skyboxPrefiltered[3] = value;
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxPrefiltered8", {get:function() {
    return this._skyboxPrefiltered[4];
  }, set:function(value) {
    if (this._skyboxPrefiltered[4] === value) {
      return;
    }
    this._skyboxPrefiltered[4] = value;
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "skyboxPrefiltered4", {get:function() {
    return this._skyboxPrefiltered[5];
  }, set:function(value) {
    if (this._skyboxPrefiltered[5] === value) {
      return;
    }
    this._skyboxPrefiltered[5] = value;
    this.updateShaders = true;
  }});
  Object.defineProperty(Scene.prototype, "drawCalls", {get:function() {
    var drawCalls = this.layers._meshInstances;
    if (!drawCalls.length) {
      this.layers._update();
      drawCalls = this.layers._meshInstances;
    }
    return drawCalls;
  }, set:function(value) {
  }});
  Object.defineProperty(Scene.prototype, "layers", {get:function() {
    return this._layers;
  }, set:function(layers) {
    var prev = this._layers;
    this._layers = layers;
    this.fire("set:layers", prev, layers);
  }});
  Scene.prototype.applySettings = function(settings) {
    this._gravity.set(settings.physics.gravity[0], settings.physics.gravity[1], settings.physics.gravity[2]);
    this.ambientLight.set(settings.render.global_ambient[0], settings.render.global_ambient[1], settings.render.global_ambient[2]);
    this._fog = settings.render.fog;
    this.fogColor.set(settings.render.fog_color[0], settings.render.fog_color[1], settings.render.fog_color[2]);
    this.fogStart = settings.render.fog_start;
    this.fogEnd = settings.render.fog_end;
    this.fogDensity = settings.render.fog_density;
    this._gammaCorrection = settings.render.gamma_correction;
    this._toneMapping = settings.render.tonemapping;
    this.lightmapSizeMultiplier = settings.render.lightmapSizeMultiplier;
    this.lightmapMaxResolution = settings.render.lightmapMaxResolution;
    this.lightmapMode = settings.render.lightmapMode;
    this.exposure = settings.render.exposure;
    this._skyboxIntensity = settings.render.skyboxIntensity === undefined ? 1 : settings.render.skyboxIntensity;
    this._skyboxMip = settings.render.skyboxMip === undefined ? 0 : settings.render.skyboxMip;
    this._resetSkyboxModel();
    this.updateShaders = true;
  };
  Scene.prototype._updateSkybox = function(device) {
    if (this._skyboxCubeMap && !this.skyboxModel) {
      var material = new pc.Material;
      var scene = this;
      material.updateShader = function(dev, sc, defs, staticLightList, pass) {
        var library = device.getProgramLibrary();
        var shader = library.getProgram("skybox", {rgbm:scene._skyboxCubeMap.rgbm, hdr:scene._skyboxCubeMap.rgbm || scene._skyboxCubeMap.format === pc.PIXELFORMAT_RGBA32F, useIntensity:scene.skyboxIntensity !== 1, mip:scene._skyboxCubeMap.fixCubemapSeams ? scene.skyboxMip : 0, fixSeams:scene._skyboxCubeMap.fixCubemapSeams, gamma:pass === pc.SHADER_FORWARDHDR ? scene.gammaCorrection ? pc.GAMMA_SRGBHDR : pc.GAMMA_NONE : scene.gammaCorrection, toneMapping:pass === pc.SHADER_FORWARDHDR ? pc.TONEMAP_LINEAR : 
        scene.toneMapping});
        this.shader = shader;
      };
      material.updateShader();
      var usedTex;
      if (!this._skyboxCubeMap.fixCubemapSeams || !scene._skyboxMip) {
        usedTex = this._skyboxCubeMap;
      } else {
        var mip2tex = [null, "64", "16", "8", "4"];
        var mipTex = this["skyboxPrefiltered" + mip2tex[scene._skyboxMip]];
        if (mipTex) {
          usedTex = mipTex;
        }
      }
      material.setParameter("texture_cubeMap", usedTex);
      material.cull = pc.CULLFACE_NONE;
      var skyLayer = this.layers.getLayerById(pc.LAYERID_SKYBOX);
      if (skyLayer) {
        var node = new pc.GraphNode;
        var mesh = pc.createBox(device);
        var meshInstance = new pc.MeshInstance(node, mesh, material);
        meshInstance.cull = false;
        meshInstance._noDepthDrawGl1 = true;
        var model = new pc.Model;
        model.graph = node;
        model.meshInstances = [meshInstance];
        this.skyboxModel = model;
        skyLayer.addMeshInstances(model.meshInstances);
        skyLayer.enabled = true;
        this.skyLayer = skyLayer;
        this.fire("set:skybox", usedTex);
      }
    }
  };
  Scene.prototype._resetSkyboxModel = function() {
    if (this.skyboxModel) {
      this.skyLayer.removeMeshInstances(this.skyboxModel.meshInstances);
      this.skyLayer.enabled = false;
    }
    this.skyboxModel = null;
    this.updateSkybox = true;
  };
  Scene.prototype.setSkybox = function(cubemaps) {
    var i;
    if (!cubemaps) {
      cubemaps = [null, null, null, null, null, null, null];
    }
    var different = false;
    if (this._skyboxCubeMap !== cubemaps[0]) {
      different = true;
    }
    if (!different) {
      for (i = 0; i < 6 && !different; i++) {
        if (this._skyboxPrefiltered[i] !== cubemaps[i + 1]) {
          different = true;
        }
      }
    }
    if (!different) {
      return;
    }
    for (i = 0; i < 6; i++) {
      this._skyboxPrefiltered[i] = cubemaps[i + 1];
    }
    this.skybox = cubemaps[0];
  };
  Scene.prototype.destroy = function() {
    this.skybox = null;
  };
  Scene.prototype.addModel = function(model) {
    if (this.containsModel(model)) {
      return;
    }
    var layer = this.layers.getLayerById(pc.LAYERID_WORLD);
    if (!layer) {
      return;
    }
    layer.addMeshInstances(model.meshInstances);
    this._models.push(model);
  };
  Scene.prototype.addShadowCaster = function(model) {
    var layer = this.layers.getLayerById(pc.LAYERID_WORLD);
    if (!layer) {
      return;
    }
    layer.addShadowCasters(model.meshInstances);
  };
  Scene.prototype.removeModel = function(model) {
    var index = this._models.indexOf(model);
    if (index !== -1) {
      var layer = this.layers.getLayerById(pc.LAYERID_WORLD);
      if (!layer) {
        return;
      }
      layer.removeMeshInstances(model.meshInstances);
      this._models.splice(index, 1);
    }
  };
  Scene.prototype.removeShadowCasters = function(model) {
    var layer = this.layers.getLayerById(pc.LAYERID_WORLD);
    if (!layer) {
      return;
    }
    layer.removeShadowCasters(model.meshInstances);
  };
  Scene.prototype.containsModel = function(model) {
    return this._models.indexOf(model) >= 0;
  };
  Scene.prototype.getModels = function(model) {
    return this._models;
  };
  return {Scene:Scene};
}());
Object.assign(pc, function() {
  var scaleShift = (new pc.Mat4).mul2((new pc.Mat4).setTranslate(0.5, 0.5, 0.5), (new pc.Mat4).setScale(0.5, 0.5, 0.5));
  var opChanId = {r:1, g:2, b:3, a:4};
  var pointLightRotations = [(new pc.Quat).setFromEulerAngles(0, 90, 180), (new pc.Quat).setFromEulerAngles(0, -90, 180), (new pc.Quat).setFromEulerAngles(90, 0, 0), (new pc.Quat).setFromEulerAngles(-90, 0, 0), (new pc.Quat).setFromEulerAngles(0, 180, 180), (new pc.Quat).setFromEulerAngles(0, 0, 180)];
  var numShadowModes = 5;
  var shadowMapCache = [{}, {}, {}, {}, {}];
  var directionalShadowEpsilon = 0.01;
  var pixelOffset = new Float32Array(2);
  var blurScissorRect = {x:1, y:1, z:0, w:0};
  var shadowCamView = new pc.Mat4;
  var shadowCamViewProj = new pc.Mat4;
  var c2sc = new pc.Mat4;
  var viewInvMat = new pc.Mat4;
  var viewMat = new pc.Mat4;
  var viewMat3 = new pc.Mat3;
  var viewProjMat = new pc.Mat4;
  var projMat;
  var viewInvL = new pc.Mat4;
  var viewInvR = new pc.Mat4;
  var viewL = new pc.Mat4;
  var viewR = new pc.Mat4;
  var viewPosL = new pc.Vec3;
  var viewPosR = new pc.Vec3;
  var projL, projR;
  var viewMat3L = new pc.Mat4;
  var viewMat3R = new pc.Mat4;
  var viewProjMatL = new pc.Mat4;
  var viewProjMatR = new pc.Mat4;
  var frustumDiagonal = new pc.Vec3;
  var tempSphere = {center:null, radius:0};
  var meshPos;
  var visibleSceneAabb = new pc.BoundingBox;
  var boneTextureSize = [0, 0];
  var boneTexture, instancingData, modelMatrix, normalMatrix;
  var shadowMapCubeCache = {};
  var maxBlurSize = 25;
  var keyA, keyB;
  var frustumPoints = [];
  for (var fp = 0; fp < 8; fp++) {
    frustumPoints.push(new pc.Vec3);
  }
  function _getFrustumPoints(camera, farClip, points) {
    var nearClip = camera._nearClip;
    var fov = camera._fov * Math.PI / 180.0;
    var aspect = camera._aspect;
    var projection = camera._projection;
    var x, y;
    if (projection === pc.PROJECTION_PERSPECTIVE) {
      y = Math.tan(fov / 2.0) * nearClip;
    } else {
      y = camera._orthoHeight;
    }
    x = y * aspect;
    points[0].x = x;
    points[0].y = -y;
    points[0].z = -nearClip;
    points[1].x = x;
    points[1].y = y;
    points[1].z = -nearClip;
    points[2].x = -x;
    points[2].y = y;
    points[2].z = -nearClip;
    points[3].x = -x;
    points[3].y = -y;
    points[3].z = -nearClip;
    if (projection === pc.PROJECTION_PERSPECTIVE) {
      y = Math.tan(fov / 2.0) * farClip;
      x = y * aspect;
    }
    points[4].x = x;
    points[4].y = -y;
    points[4].z = -farClip;
    points[5].x = x;
    points[5].y = y;
    points[5].z = -farClip;
    points[6].x = -x;
    points[6].y = y;
    points[6].z = -farClip;
    points[7].x = -x;
    points[7].y = -y;
    points[7].z = -farClip;
    return points;
  }
  var _sceneAABB_LS = [new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3];
  function _getZFromAABBSimple(w2sc, aabbMin, aabbMax, lcamMinX, lcamMaxX, lcamMinY, lcamMaxY) {
    _sceneAABB_LS[0].x = _sceneAABB_LS[1].x = _sceneAABB_LS[2].x = _sceneAABB_LS[3].x = aabbMin.x;
    _sceneAABB_LS[1].y = _sceneAABB_LS[3].y = _sceneAABB_LS[7].y = _sceneAABB_LS[5].y = aabbMin.y;
    _sceneAABB_LS[2].z = _sceneAABB_LS[3].z = _sceneAABB_LS[6].z = _sceneAABB_LS[7].z = aabbMin.z;
    _sceneAABB_LS[4].x = _sceneAABB_LS[5].x = _sceneAABB_LS[6].x = _sceneAABB_LS[7].x = aabbMax.x;
    _sceneAABB_LS[0].y = _sceneAABB_LS[2].y = _sceneAABB_LS[4].y = _sceneAABB_LS[6].y = aabbMax.y;
    _sceneAABB_LS[0].z = _sceneAABB_LS[1].z = _sceneAABB_LS[4].z = _sceneAABB_LS[5].z = aabbMax.z;
    var minz = 9999999999;
    var maxz = -9999999999;
    var z;
    for (var i = 0; i < 8; ++i) {
      w2sc.transformPoint(_sceneAABB_LS[i], _sceneAABB_LS[i]);
      z = _sceneAABB_LS[i].z;
      if (z < minz) {
        minz = z;
      }
      if (z > maxz) {
        maxz = z;
      }
    }
    return {min:minz, max:maxz};
  }
  function getShadowFormat(device, shadowType) {
    if (shadowType === pc.SHADOW_VSM32) {
      return pc.PIXELFORMAT_RGBA32F;
    } else {
      if (shadowType === pc.SHADOW_VSM16) {
        return pc.PIXELFORMAT_RGBA16F;
      } else {
        if (shadowType === pc.SHADOW_PCF5) {
          return pc.PIXELFORMAT_DEPTH;
        } else {
          if (shadowType === pc.SHADOW_PCF3 && device.webgl2) {
            return pc.PIXELFORMAT_DEPTH;
          }
        }
      }
    }
    return pc.PIXELFORMAT_R8_G8_B8_A8;
  }
  function getShadowFiltering(device, shadowType) {
    if (shadowType === pc.SHADOW_PCF3 && !device.webgl2) {
      return pc.FILTER_NEAREST;
    } else {
      if (shadowType === pc.SHADOW_VSM32) {
        return device.extTextureFloatLinear ? pc.FILTER_LINEAR : pc.FILTER_NEAREST;
      } else {
        if (shadowType === pc.SHADOW_VSM16) {
          return device.extTextureHalfFloatLinear ? pc.FILTER_LINEAR : pc.FILTER_NEAREST;
        }
      }
    }
    return pc.FILTER_LINEAR;
  }
  function createShadowMap(device, width, height, shadowType) {
    var format = getShadowFormat(device, shadowType);
    var filter = getShadowFiltering(device, shadowType);
    var shadowMap = new pc.Texture(device, {format:format, width:width, height:height, mipmaps:false, minFilter:filter, magFilter:filter, addressU:pc.ADDRESS_CLAMP_TO_EDGE, addressV:pc.ADDRESS_CLAMP_TO_EDGE});
    shadowMap.name = "shadowmap";
    if (shadowType === pc.SHADOW_PCF5 || shadowType === pc.SHADOW_PCF3 && device.webgl2) {
      shadowMap.compareOnRead = true;
      shadowMap.compareFunc = pc.FUNC_LESS;
      return new pc.RenderTarget({depthBuffer:shadowMap});
    }
    return new pc.RenderTarget({colorBuffer:shadowMap, depth:true});
  }
  function createShadowCubeMap(device, size) {
    var cubemap = new pc.Texture(device, {format:pc.PIXELFORMAT_R8_G8_B8_A8, width:size, height:size, cubemap:true, mipmaps:false, minFilter:pc.FILTER_NEAREST, magFilter:pc.FILTER_NEAREST, addressU:pc.ADDRESS_CLAMP_TO_EDGE, addressV:pc.ADDRESS_CLAMP_TO_EDGE});
    cubemap.name = "shadowcube";
    var targets = [];
    var target;
    for (var i = 0; i < 6; i++) {
      target = new pc.RenderTarget({colorBuffer:cubemap, face:i, depth:true});
      targets.push(target);
    }
    return targets;
  }
  function gauss(x, sigma) {
    return Math.exp(-(x * x) / (2.0 * sigma * sigma));
  }
  function gaussWeights(kernelSize) {
    if (kernelSize > maxBlurSize) {
      kernelSize = maxBlurSize;
    }
    var sigma = (kernelSize - 1) / (2 * 3);
    var i, values, sum, halfWidth;
    halfWidth = (kernelSize - 1) * 0.5;
    values = new Array(kernelSize);
    sum = 0.0;
    for (i = 0; i < kernelSize; ++i) {
      values[i] = gauss(i - halfWidth, sigma);
      sum += values[i];
    }
    for (i = 0; i < kernelSize; ++i) {
      values[i] /= sum;
    }
    return values;
  }
  function createShadowCamera(device, shadowType, type) {
    var flags = pc.CLEARFLAG_DEPTH;
    var hwPcf = shadowType === pc.SHADOW_PCF5 || shadowType === pc.SHADOW_PCF3 && device.webgl2;
    if (type === pc.LIGHTTYPE_POINT) {
      hwPcf = false;
    }
    if (!hwPcf) {
      flags |= pc.CLEARFLAG_COLOR;
    }
    var shadowCam = new pc.Camera;
    if (shadowType >= pc.SHADOW_VSM8 && shadowType <= pc.SHADOW_VSM32) {
      shadowCam.clearColor[0] = 0;
      shadowCam.clearColor[1] = 0;
      shadowCam.clearColor[2] = 0;
      shadowCam.clearColor[3] = 0;
    } else {
      shadowCam.clearColor[0] = 1;
      shadowCam.clearColor[1] = 1;
      shadowCam.clearColor[2] = 1;
      shadowCam.clearColor[3] = 1;
    }
    shadowCam.clearDepth = 1;
    shadowCam.clearFlags = flags;
    shadowCam.clearStencil = null;
    shadowCam._node = new pc.GraphNode;
    return shadowCam;
  }
  function getShadowMapFromCache(device, res, mode, layer) {
    if (!layer) {
      layer = 0;
    }
    var id = layer * 10000 + res;
    var shadowBuffer = shadowMapCache[mode][id];
    if (!shadowBuffer) {
      shadowBuffer = createShadowMap(device, res, res, mode ? mode : pc.SHADOW_PCF3);
      shadowMapCache[mode][id] = shadowBuffer;
    }
    return shadowBuffer;
  }
  function createShadowBuffer(device, light) {
    var shadowBuffer;
    if (light._type === pc.LIGHTTYPE_POINT) {
      if (light._shadowType > pc.SHADOW_PCF3) {
        light._shadowType = pc.SHADOW_PCF3;
      }
      if (light._cacheShadowMap) {
        shadowBuffer = shadowMapCubeCache[light._shadowResolution];
        if (!shadowBuffer) {
          shadowBuffer = createShadowCubeMap(device, light._shadowResolution);
          shadowMapCubeCache[light._shadowResolution] = shadowBuffer;
        }
      } else {
        shadowBuffer = createShadowCubeMap(device, light._shadowResolution);
      }
      light._shadowCamera.renderTarget = shadowBuffer[0];
      light._shadowCubeMap = shadowBuffer;
    } else {
      if (light._cacheShadowMap) {
        shadowBuffer = getShadowMapFromCache(device, light._shadowResolution, light._shadowType);
      } else {
        shadowBuffer = createShadowMap(device, light._shadowResolution, light._shadowResolution, light._shadowType);
      }
      light._shadowCamera.renderTarget = shadowBuffer;
    }
    light._isCachedShadowMap = light._cacheShadowMap;
  }
  function getDepthKey(meshInstance) {
    var material = meshInstance.material;
    var x = meshInstance.skinInstance ? 10 : 0;
    var y = 0;
    if (material.opacityMap) {
      var opChan = material.opacityMapChannel;
      if (opChan) {
        y = opChanId[opChan];
      }
    }
    return x + y;
  }
  function ForwardRenderer(graphicsDevice) {
    this.device = graphicsDevice;
    var device = this.device;
    this._shadowDrawCalls = 0;
    this._forwardDrawCalls = 0;
    this._skinDrawCalls = 0;
    this._camerasRendered = 0;
    this._materialSwitches = 0;
    this._shadowMapUpdates = 0;
    this._shadowMapTime = 0;
    this._depthMapTime = 0;
    this._forwardTime = 0;
    this._cullTime = 0;
    this._sortTime = 0;
    this._skinTime = 0;
    this._morphTime = 0;
    this._instancingTime = 0;
    var library = device.getProgramLibrary();
    this.library = library;
    var scope = device.scope;
    this.projId = scope.resolve("matrix_projection");
    this.viewId = scope.resolve("matrix_view");
    this.viewId3 = scope.resolve("matrix_view3");
    this.viewInvId = scope.resolve("matrix_viewInverse");
    this.viewProjId = scope.resolve("matrix_viewProjection");
    this.viewPos = new Float32Array(3);
    this.viewPosId = scope.resolve("view_position");
    this.nearClipId = scope.resolve("camera_near");
    this.farClipId = scope.resolve("camera_far");
    this.cameraParamsId = scope.resolve("camera_params");
    this.shadowMapLightRadiusId = scope.resolve("light_radius");
    this.fogColorId = scope.resolve("fog_color");
    this.fogStartId = scope.resolve("fog_start");
    this.fogEndId = scope.resolve("fog_end");
    this.fogDensityId = scope.resolve("fog_density");
    this.modelMatrixId = scope.resolve("matrix_model");
    this.normalMatrixId = scope.resolve("matrix_normal");
    this.poseMatrixId = scope.resolve("matrix_pose[0]");
    this.boneTextureId = scope.resolve("texture_poseMap");
    this.boneTextureSizeId = scope.resolve("texture_poseMapSize");
    this.alphaTestId = scope.resolve("alpha_ref");
    this.opacityMapId = scope.resolve("texture_opacityMap");
    this.ambientId = scope.resolve("light_globalAmbient");
    this.exposureId = scope.resolve("exposure");
    this.skyboxIntensityId = scope.resolve("skyboxIntensity");
    this.lightColorId = [];
    this.lightDir = [];
    this.lightDirId = [];
    this.lightShadowMapId = [];
    this.lightShadowMatrixId = [];
    this.lightShadowParamsId = [];
    this.lightShadowMatrixVsId = [];
    this.lightShadowParamsVsId = [];
    this.lightDirVs = [];
    this.lightDirVsId = [];
    this.lightRadiusId = [];
    this.lightPos = [];
    this.lightPosId = [];
    this.lightInAngleId = [];
    this.lightOutAngleId = [];
    this.lightPosVsId = [];
    this.lightCookieId = [];
    this.lightCookieIntId = [];
    this.lightCookieMatrixId = [];
    this.lightCookieOffsetId = [];
    this.depthMapId = scope.resolve("uDepthMap");
    this.screenSizeId = scope.resolve("uScreenSize");
    this._screenSize = new Float32Array(4);
    this.sourceId = scope.resolve("source");
    this.pixelOffsetId = scope.resolve("pixelOffset");
    this.weightId = scope.resolve("weight[0]");
    var chunks = pc.shaderChunks;
    this.blurVsmShaderCode = [chunks.blurVSMPS, "#define GAUSS\n" + chunks.blurVSMPS];
    var packed = "#define PACKED\n";
    this.blurPackedVsmShaderCode = [packed + this.blurVsmShaderCode[0], packed + this.blurVsmShaderCode[1]];
    this.blurVsmShader = [{}, {}];
    this.blurPackedVsmShader = [{}, {}];
    this.blurVsmWeights = {};
    this.polygonOffsetId = scope.resolve("polygonOffset");
    this.polygonOffset = new Float32Array(2);
    this.fogColor = new Float32Array(3);
    this.ambientColor = new Float32Array(3);
  }
  function mat3FromMat4(m3, m4) {
    m3.data[0] = m4.data[0];
    m3.data[1] = m4.data[1];
    m3.data[2] = m4.data[2];
    m3.data[3] = m4.data[4];
    m3.data[4] = m4.data[5];
    m3.data[5] = m4.data[6];
    m3.data[6] = m4.data[8];
    m3.data[7] = m4.data[9];
    m3.data[8] = m4.data[10];
  }
  Object.assign(ForwardRenderer.prototype, {sortCompare:function(drawCallA, drawCallB) {
    if (drawCallA.layer === drawCallB.layer) {
      if (drawCallA.drawOrder && drawCallB.drawOrder) {
        return drawCallA.drawOrder - drawCallB.drawOrder;
      } else {
        if (drawCallA.zdist && drawCallB.zdist) {
          return drawCallB.zdist - drawCallA.zdist;
        } else {
          if (drawCallA.zdist2 && drawCallB.zdist2) {
            return drawCallA.zdist2 - drawCallB.zdist2;
          }
        }
      }
    }
    return drawCallB._key[pc.SORTKEY_FORWARD] - drawCallA._key[pc.SORTKEY_FORWARD];
  }, sortCompareMesh:function(drawCallA, drawCallB) {
    if (drawCallA.layer === drawCallB.layer) {
      if (drawCallA.drawOrder && drawCallB.drawOrder) {
        return drawCallA.drawOrder - drawCallB.drawOrder;
      } else {
        if (drawCallA.zdist && drawCallB.zdist) {
          return drawCallB.zdist - drawCallA.zdist;
        }
      }
    }
    keyA = drawCallA._key[pc.SORTKEY_FORWARD];
    keyB = drawCallB._key[pc.SORTKEY_FORWARD];
    if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
      return drawCallB.mesh.id - drawCallA.mesh.id;
    }
    return keyB - keyA;
  }, depthSortCompare:function(drawCallA, drawCallB) {
    keyA = drawCallA._key[pc.SORTKEY_DEPTH];
    keyB = drawCallB._key[pc.SORTKEY_DEPTH];
    if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
      return drawCallB.mesh.id - drawCallA.mesh.id;
    }
    return keyB - keyA;
  }, lightCompare:function(lightA, lightB) {
    return lightA.key - lightB.key;
  }, _isVisible:function(camera, meshInstance) {
    if (!meshInstance.visible) {
      return false;
    }
    if (meshInstance.isVisibleFunc) {
      return meshInstance.isVisibleFunc(camera);
    }
    meshPos = meshInstance.aabb.center;
    if (meshInstance._aabb._radiusVer !== meshInstance._aabbVer) {
      meshInstance._aabb._radius = meshInstance._aabb.halfExtents.length();
      meshInstance._aabb._radiusVer = meshInstance._aabbVer;
    }
    tempSphere.radius = meshInstance._aabb._radius;
    tempSphere.center = meshPos;
    return camera.frustum.containsSphere(tempSphere);
  }, getShadowCamera:function(device, light) {
    var shadowCam = light._shadowCamera;
    var shadowBuffer;
    if (shadowCam === null) {
      shadowCam = light._shadowCamera = createShadowCamera(device, light._shadowType, light._type);
      createShadowBuffer(device, light);
    } else {
      shadowBuffer = shadowCam.renderTarget;
      if (shadowBuffer.width !== light._shadowResolution || shadowBuffer.height !== light._shadowResolution) {
        createShadowBuffer(device, light);
      }
    }
    return shadowCam;
  }, updateCameraFrustum:function(camera) {
    if (camera.vrDisplay && camera.vrDisplay.presenting) {
      projMat = camera.vrDisplay.combinedProj;
      var parent = camera._node.getParent();
      if (parent) {
        viewMat.copy(parent.getWorldTransform()).mul(camera.vrDisplay.combinedViewInv).invert();
      } else {
        viewMat.copy(camera.vrDisplay.combinedView);
      }
      viewInvMat.copy(viewMat).invert();
      this.viewInvId.setValue(viewInvMat.data);
      camera.frustum.update(projMat, viewMat);
      return;
    }
    projMat = camera.getProjectionMatrix();
    if (camera.overrideCalculateProjection) {
      camera.calculateProjection(projMat, pc.VIEW_CENTER);
    }
    if (camera.overrideCalculateTransform) {
      camera.calculateTransform(viewInvMat, pc.VIEW_CENTER);
    } else {
      var pos = camera._node.getPosition();
      var rot = camera._node.getRotation();
      viewInvMat.setTRS(pos, rot, pc.Vec3.ONE);
      this.viewInvId.setValue(viewInvMat.data);
    }
    viewMat.copy(viewInvMat).invert();
    camera.frustum.update(projMat, viewMat);
  }, setCamera:function(camera, target, clear, cullBorder) {
    var vrDisplay = camera.vrDisplay;
    if (!vrDisplay || !vrDisplay.presenting) {
      projMat = camera.getProjectionMatrix();
      if (camera.overrideCalculateProjection) {
        camera.calculateProjection(projMat, pc.VIEW_CENTER);
      }
      this.projId.setValue(projMat.data);
      if (camera.overrideCalculateTransform) {
        camera.calculateTransform(viewInvMat, pc.VIEW_CENTER);
      } else {
        var pos = camera._node.getPosition();
        var rot = camera._node.getRotation();
        viewInvMat.setTRS(pos, rot, pc.Vec3.ONE);
      }
      this.viewInvId.setValue(viewInvMat.data);
      viewMat.copy(viewInvMat).invert();
      this.viewId.setValue(viewMat.data);
      mat3FromMat4(viewMat3, viewMat);
      this.viewId3.setValue(viewMat3.data);
      viewProjMat.mul2(projMat, viewMat);
      this.viewProjId.setValue(viewProjMat.data);
      var cameraPos = camera._node.getPosition();
      this.viewPos[0] = cameraPos.x;
      this.viewPos[1] = cameraPos.y;
      this.viewPos[2] = cameraPos.z;
      this.viewPosId.setValue(this.viewPos);
      camera.frustum.update(projMat, viewMat);
    } else {
      projL = vrDisplay.leftProj;
      projR = vrDisplay.rightProj;
      projMat = vrDisplay.combinedProj;
      if (camera.overrideCalculateProjection) {
        camera.calculateProjection(projL, pc.VIEW_LEFT);
        camera.calculateProjection(projR, pc.VIEW_RIGHT);
        camera.calculateProjection(projMat, pc.VIEW_CENTER);
      }
      if (camera.overrideCalculateTransform) {
        camera.calculateTransform(viewInvL, pc.VIEW_LEFT);
        camera.calculateTransform(viewInvR, pc.VIEW_RIGHT);
        camera.calculateTransform(viewInvMat, pc.VIEW_CENTER);
        viewL.copy(viewInvL).invert();
        viewR.copy(viewInvR).invert();
        viewMat.copy(viewInvMat).invert();
      } else {
        var parent = camera._node.getParent();
        if (parent) {
          var transform = parent.getWorldTransform();
          viewInvL.mul2(transform, vrDisplay.leftViewInv);
          viewInvR.mul2(transform, vrDisplay.rightViewInv);
          viewL.copy(viewInvL).invert();
          viewR.copy(viewInvR).invert();
          viewMat.copy(parent.getWorldTransform()).mul(vrDisplay.combinedViewInv).invert();
        } else {
          viewInvL.copy(vrDisplay.leftViewInv);
          viewInvR.copy(vrDisplay.rightViewInv);
          viewL.copy(vrDisplay.leftView);
          viewR.copy(vrDisplay.rightView);
          viewMat.copy(vrDisplay.combinedView);
        }
      }
      mat3FromMat4(viewMat3L, viewL);
      mat3FromMat4(viewMat3R, viewR);
      viewProjMatL.mul2(projL, viewL);
      viewProjMatR.mul2(projR, viewR);
      viewPosL.x = viewInvL.data[12];
      viewPosL.y = viewInvL.data[13];
      viewPosL.z = viewInvL.data[14];
      viewPosR.x = viewInvR.data[12];
      viewPosR.y = viewInvR.data[13];
      viewPosR.z = viewInvR.data[14];
      camera.frustum.update(projMat, viewMat);
    }
    this.nearClipId.setValue(camera._nearClip);
    this.farClipId.setValue(camera._farClip);
    this.cameraParamsId.setValue(camera._shaderParams);
    var device = this.device;
    device.setRenderTarget(target);
    device.updateBegin();
    var rect = camera.getRect();
    var pixelWidth = target ? target.width : device.width;
    var pixelHeight = target ? target.height : device.height;
    var x = Math.floor(rect.x * pixelWidth);
    var y = Math.floor(rect.y * pixelHeight);
    var w = Math.floor(rect.width * pixelWidth);
    var h = Math.floor(rect.height * pixelHeight);
    device.setViewport(x, y, w, h);
    device.setScissor(x, y, w, h);
    if (clear) {
      device.clear(camera._clearOptions);
    }
    rect = camera._scissorRect;
    x = Math.floor(rect.x * pixelWidth);
    y = Math.floor(rect.y * pixelHeight);
    w = Math.floor(rect.width * pixelWidth);
    h = Math.floor(rect.height * pixelHeight);
    device.setScissor(x, y, w, h);
    if (cullBorder) {
      device.setScissor(1, 1, pixelWidth - 2, pixelHeight - 2);
    }
  }, dispatchGlobalLights:function(scene) {
    var i;
    this.mainLight = -1;
    this.ambientColor[0] = scene.ambientLight.r;
    this.ambientColor[1] = scene.ambientLight.g;
    this.ambientColor[2] = scene.ambientLight.b;
    if (scene.gammaCorrection) {
      for (i = 0; i < 3; i++) {
        this.ambientColor[i] = Math.pow(this.ambientColor[i], 2.2);
      }
    }
    this.ambientId.setValue(this.ambientColor);
    this.exposureId.setValue(scene.exposure);
    if (scene.skyboxModel) {
      this.skyboxIntensityId.setValue(scene.skyboxIntensity);
    }
  }, _resolveLight:function(scope, i) {
    var light = "light" + i;
    this.lightColorId[i] = scope.resolve(light + "_color");
    this.lightDir[i] = new Float32Array(3);
    this.lightDirId[i] = scope.resolve(light + "_direction");
    this.lightShadowMapId[i] = scope.resolve(light + "_shadowMap");
    this.lightShadowMatrixId[i] = scope.resolve(light + "_shadowMatrix");
    this.lightShadowParamsId[i] = scope.resolve(light + "_shadowParams");
    this.lightShadowMatrixVsId[i] = scope.resolve(light + "_shadowMatrixVS");
    this.lightShadowParamsVsId[i] = scope.resolve(light + "_shadowParamsVS");
    this.lightDirVs[i] = new Float32Array(3);
    this.lightDirVsId[i] = scope.resolve(light + "_directionVS");
    this.lightRadiusId[i] = scope.resolve(light + "_radius");
    this.lightPos[i] = new Float32Array(3);
    this.lightPosId[i] = scope.resolve(light + "_position");
    this.lightInAngleId[i] = scope.resolve(light + "_innerConeAngle");
    this.lightOutAngleId[i] = scope.resolve(light + "_outerConeAngle");
    this.lightPosVsId[i] = scope.resolve(light + "_positionVS");
    this.lightCookieId[i] = scope.resolve(light + "_cookie");
    this.lightCookieIntId[i] = scope.resolve(light + "_cookieIntensity");
    this.lightCookieMatrixId[i] = scope.resolve(light + "_cookieMatrix");
    this.lightCookieOffsetId[i] = scope.resolve(light + "_cookieOffset");
  }, dispatchDirectLights:function(dirs, scene, mask) {
    var numDirs = dirs.length;
    var i;
    var directional, wtm;
    var cnt = 0;
    this.mainLight = -1;
    var scope = this.device.scope;
    for (i = 0; i < numDirs; i++) {
      if (!(dirs[i]._mask & mask)) {
        continue;
      }
      directional = dirs[i];
      wtm = directional._node.getWorldTransform();
      if (!this.lightColorId[cnt]) {
        this._resolveLight(scope, cnt);
      }
      this.lightColorId[cnt].setValue(scene.gammaCorrection ? directional._linearFinalColor : directional._finalColor);
      wtm.getY(directional._direction).scale(-1);
      directional._direction.normalize();
      this.lightDir[cnt][0] = directional._direction.x;
      this.lightDir[cnt][1] = directional._direction.y;
      this.lightDir[cnt][2] = directional._direction.z;
      this.lightDirId[cnt].setValue(this.lightDir[cnt]);
      if (directional.castShadows) {
        var shadowMap = directional._isPcf && this.device.webgl2 ? directional._shadowCamera.renderTarget.depthBuffer : directional._shadowCamera.renderTarget.colorBuffer;
        var bias;
        if (directional._isVsm) {
          bias = -0.00001 * 20;
        } else {
          bias = directional.shadowBias / directional._shadowCamera._farClip * 100;
          if (!this.device.webgl2 && this.device.extStandardDerivatives) {
            bias *= -100;
          }
        }
        var normalBias = directional._isVsm ? directional.vsmBias / (directional._shadowCamera._farClip / 7.0) : directional._normalOffsetBias;
        this.lightShadowMapId[cnt].setValue(shadowMap);
        this.lightShadowMatrixId[cnt].setValue(directional._shadowMatrix.data);
        var params = directional._rendererParams;
        if (params.length !== 3) {
          params.length = 3;
        }
        params[0] = directional._shadowResolution;
        params[1] = normalBias;
        params[2] = bias;
        this.lightShadowParamsId[cnt].setValue(params);
        if (this.mainLight < 0) {
          this.lightShadowMatrixVsId[cnt].setValue(directional._shadowMatrix.data);
          this.lightShadowParamsVsId[cnt].setValue(params);
          directional._direction.normalize();
          this.lightDirVs[cnt][0] = directional._direction.x;
          this.lightDirVs[cnt][1] = directional._direction.y;
          this.lightDirVs[cnt][2] = directional._direction.z;
          this.lightDirVsId[cnt].setValue(this.lightDirVs[cnt]);
          this.mainLight = i;
        }
      }
      cnt++;
    }
    return cnt;
  }, dispatchPointLight:function(scene, scope, point, cnt) {
    var wtm = point._node.getWorldTransform();
    if (!this.lightColorId[cnt]) {
      this._resolveLight(scope, cnt);
    }
    this.lightRadiusId[cnt].setValue(point.attenuationEnd);
    this.lightColorId[cnt].setValue(scene.gammaCorrection ? point._linearFinalColor : point._finalColor);
    wtm.getTranslation(point._position);
    this.lightPos[cnt][0] = point._position.x;
    this.lightPos[cnt][1] = point._position.y;
    this.lightPos[cnt][2] = point._position.z;
    this.lightPosId[cnt].setValue(this.lightPos[cnt]);
    if (point.castShadows) {
      var shadowMap = point._shadowCamera.renderTarget.colorBuffer;
      this.lightShadowMapId[cnt].setValue(shadowMap);
      var params = point._rendererParams;
      if (params.length !== 4) {
        params.length = 4;
      }
      params[0] = point._shadowResolution;
      params[1] = point._normalOffsetBias;
      params[2] = point.shadowBias;
      params[3] = 1.0 / point.attenuationEnd;
      this.lightShadowParamsId[cnt].setValue(params);
    }
    if (point._cookie) {
      this.lightCookieId[cnt].setValue(point._cookie);
      this.lightShadowMatrixId[cnt].setValue(wtm.data);
      this.lightCookieIntId[cnt].setValue(point.cookieIntensity);
    }
  }, dispatchSpotLight:function(scene, scope, spot, cnt) {
    var wtm = spot._node.getWorldTransform();
    if (!this.lightColorId[cnt]) {
      this._resolveLight(scope, cnt);
    }
    this.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);
    this.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);
    this.lightRadiusId[cnt].setValue(spot.attenuationEnd);
    this.lightColorId[cnt].setValue(scene.gammaCorrection ? spot._linearFinalColor : spot._finalColor);
    wtm.getTranslation(spot._position);
    this.lightPos[cnt][0] = spot._position.x;
    this.lightPos[cnt][1] = spot._position.y;
    this.lightPos[cnt][2] = spot._position.z;
    this.lightPosId[cnt].setValue(this.lightPos[cnt]);
    wtm.getY(spot._direction).scale(-1);
    spot._direction.normalize();
    this.lightDir[cnt][0] = spot._direction.x;
    this.lightDir[cnt][1] = spot._direction.y;
    this.lightDir[cnt][2] = spot._direction.z;
    this.lightDirId[cnt].setValue(this.lightDir[cnt]);
    if (spot.castShadows) {
      var bias;
      if (spot._isVsm) {
        bias = -0.00001 * 20;
      } else {
        bias = spot.shadowBias * 20;
        if (!this.device.webgl2 && this.device.extStandardDerivatives) {
          bias *= -100;
        }
      }
      var normalBias = spot._isVsm ? spot.vsmBias / (spot.attenuationEnd / 7.0) : spot._normalOffsetBias;
      var shadowMap = spot._isPcf && this.device.webgl2 ? spot._shadowCamera.renderTarget.depthBuffer : spot._shadowCamera.renderTarget.colorBuffer;
      this.lightShadowMapId[cnt].setValue(shadowMap);
      this.lightShadowMatrixId[cnt].setValue(spot._shadowMatrix.data);
      var params = spot._rendererParams;
      if (params.length !== 4) {
        params.length = 4;
      }
      params[0] = spot._shadowResolution;
      params[1] = normalBias;
      params[2] = bias;
      params[3] = 1.0 / spot.attenuationEnd;
      this.lightShadowParamsId[cnt].setValue(params);
    }
    if (spot._cookie) {
      this.lightCookieId[cnt].setValue(spot._cookie);
      if (!spot.castShadows) {
        var shadowCam = this.getShadowCamera(this.device, spot);
        var shadowCamNode = shadowCam._node;
        shadowCamNode.setPosition(spot._node.getPosition());
        shadowCamNode.setRotation(spot._node.getRotation());
        shadowCamNode.rotateLocal(-90, 0, 0);
        shadowCam.projection = pc.PROJECTION_PERSPECTIVE;
        shadowCam.aspectRatio = 1;
        shadowCam.fov = spot._outerConeAngle * 2;
        shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), pc.Vec3.ONE).invert();
        shadowCamViewProj.mul2(shadowCam.getProjectionMatrix(), shadowCamView);
        spot._shadowMatrix.mul2(scaleShift, shadowCamViewProj);
      }
      this.lightShadowMatrixId[cnt].setValue(spot._shadowMatrix.data);
      this.lightCookieIntId[cnt].setValue(spot.cookieIntensity);
      if (spot._cookieTransform) {
        spot._cookieTransformUniform[0] = spot._cookieTransform.x;
        spot._cookieTransformUniform[1] = spot._cookieTransform.y;
        spot._cookieTransformUniform[2] = spot._cookieTransform.z;
        spot._cookieTransformUniform[3] = spot._cookieTransform.w;
        this.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);
        spot._cookieOffsetUniform[0] = spot._cookieOffset.x;
        spot._cookieOffsetUniform[1] = spot._cookieOffset.y;
        this.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);
      }
    }
  }, dispatchLocalLights:function(sortedLights, scene, mask, usedDirLights, staticLightList) {
    var i;
    var point, spot;
    var pnts = sortedLights[pc.LIGHTTYPE_POINT];
    var spts = sortedLights[pc.LIGHTTYPE_SPOT];
    var numDirs = usedDirLights;
    var numPnts = pnts.length;
    var numSpts = spts.length;
    var cnt = numDirs;
    var scope = this.device.scope;
    for (i = 0; i < numPnts; i++) {
      point = pnts[i];
      if (!(point._mask & mask)) {
        continue;
      }
      if (point.isStatic) {
        continue;
      }
      this.dispatchPointLight(scene, scope, point, cnt);
      cnt++;
    }
    var staticId = 0;
    if (staticLightList) {
      point = staticLightList[staticId];
      while (point && point._type === pc.LIGHTTYPE_POINT) {
        this.dispatchPointLight(scene, scope, point, cnt);
        cnt++;
        staticId++;
        point = staticLightList[staticId];
      }
    }
    for (i = 0; i < numSpts; i++) {
      spot = spts[i];
      if (!(spot._mask & mask)) {
        continue;
      }
      if (spot.isStatic) {
        continue;
      }
      this.dispatchSpotLight(scene, scope, spot, cnt);
      cnt++;
    }
    if (staticLightList) {
      spot = staticLightList[staticId];
      while (spot && spot._type === pc.LIGHTTYPE_SPOT) {
        this.dispatchSpotLight(scene, scope, spot, cnt);
        cnt++;
        staticId++;
        spot = staticLightList[staticId];
      }
    }
  }, cull:function(camera, drawCalls, visibleList) {
    var visibleLength = 0;
    var i, drawCall, visible;
    var drawCallsCount = drawCalls.length;
    var cullingMask = camera.cullingMask || 4294967295;
    if (!camera.frustumCulling) {
      for (i = 0; i < drawCallsCount; i++) {
        drawCall = drawCalls[i];
        if (!drawCall.visible && !drawCall.command) {
          continue;
        }
        if (drawCall.mask && (drawCall.mask & cullingMask) === 0) {
          continue;
        }
        visibleList[visibleLength] = drawCall;
        visibleLength++;
        drawCall.visibleThisFrame = true;
      }
      return visibleLength;
    }
    for (i = 0; i < drawCallsCount; i++) {
      drawCall = drawCalls[i];
      if (!drawCall.command) {
        if (!drawCall.visible) {
          continue;
        }
        visible = true;
        if (drawCall.mask && (drawCall.mask & cullingMask) === 0) {
          continue;
        }
        if (drawCall.cull) {
          visible = this._isVisible(camera, drawCall);
        }
        if (visible) {
          visibleList[visibleLength] = drawCall;
          visibleLength++;
          drawCall.visibleThisFrame = true;
        }
      } else {
        visibleList[visibleLength] = drawCall;
        visibleLength++;
        drawCall.visibleThisFrame = true;
      }
    }
    return visibleLength;
  }, cullLights:function(camera, lights) {
    var i, light, type;
    for (i = 0; i < lights.length; i++) {
      light = lights[i];
      type = light._type;
      if (light.castShadows && light._enabled && light.shadowUpdateMode !== pc.SHADOWUPDATE_NONE) {
        if (type !== pc.LIGHTTYPE_DIRECTIONAL) {
          light.getBoundingSphere(tempSphere);
          if (!camera.frustum.containsSphere(tempSphere)) {
            continue;
          }
          light.visibleThisFrame = true;
        }
      }
    }
  }, updateCpuSkinMatrices:function(drawCalls) {
    var drawCallsCount = drawCalls.length;
    if (drawCallsCount === 0) {
      return;
    }
    var i, skin;
    for (i = 0; i < drawCallsCount; i++) {
      skin = drawCalls[i].skinInstance;
      if (skin) {
        skin.updateMatrices(drawCalls[i].node);
        skin._dirty = true;
      }
    }
  }, updateGpuSkinMatrices:function(drawCalls) {
    var i, skin;
    var drawCallsCount = drawCalls.length;
    for (i = 0; i < drawCallsCount; i++) {
      if (!drawCalls[i].visibleThisFrame) {
        continue;
      }
      skin = drawCalls[i].skinInstance;
      if (skin) {
        if (skin._dirty) {
          skin.updateMatrixPalette();
          skin._dirty = false;
        }
      }
    }
  }, updateMorphedBounds:function(drawCalls) {
    var i, morph;
    var drawCallsCount = drawCalls.length;
    for (i = 0; i < drawCallsCount; i++) {
      morph = drawCalls[i].morphInstance;
      if (morph && morph._dirty) {
        morph.updateBounds(drawCalls[i].mesh);
      }
    }
  }, updateMorphing:function(drawCalls) {
    var i, morph;
    var drawCallsCount = drawCalls.length;
    for (i = 0; i < drawCallsCount; i++) {
      if (!drawCalls[i].visibleThisFrame) {
        continue;
      }
      morph = drawCalls[i].morphInstance;
      if (morph && morph._dirty) {
        morph.update(drawCalls[i].mesh);
        morph._dirty = false;
      }
    }
  }, setBaseConstants:function(device, material) {
    device.setCullMode(material.cull);
    if (material.opacityMap) {
      this.opacityMapId.setValue(material.opacityMap);
      this.alphaTestId.setValue(material.alphaTest);
    }
  }, setSkinning:function(device, meshInstance, material) {
    if (meshInstance.skinInstance) {
      this._skinDrawCalls++;
      if (device.supportsBoneTextures) {
        boneTexture = meshInstance.skinInstance.boneTexture;
        this.boneTextureId.setValue(boneTexture);
        boneTextureSize[0] = boneTexture.width;
        boneTextureSize[1] = boneTexture.height;
        this.boneTextureSizeId.setValue(boneTextureSize);
      } else {
        this.poseMatrixId.setValue(meshInstance.skinInstance.matrixPalette);
      }
    }
  }, drawInstance:function(device, meshInstance, mesh, style, normal) {
    instancingData = meshInstance.instancingData;
    if (instancingData) {
      this._instancedDrawCalls++;
      this._removedByInstancing += instancingData.count;
      device.setVertexBuffer(instancingData._buffer, 1, instancingData.offset);
      device.draw(mesh.primitive[style], instancingData.count);
      if (instancingData._buffer === pc._autoInstanceBuffer) {
        meshInstance.instancingData = null;
        return instancingData.count - 1;
      }
    } else {
      modelMatrix = meshInstance.node.worldTransform;
      this.modelMatrixId.setValue(modelMatrix.data);
      if (normal) {
        normalMatrix = meshInstance.node.normalMatrix;
        if (meshInstance.node._dirtyNormal) {
          modelMatrix.invertTo3x3(normalMatrix);
          normalMatrix.transpose();
          meshInstance.node._dirtyNormal = false;
        }
        this.normalMatrixId.setValue(normalMatrix.data);
      }
      device.draw(mesh.primitive[style]);
      return 0;
    }
  }, drawInstance2:function(device, meshInstance, mesh, style) {
    instancingData = meshInstance.instancingData;
    if (instancingData) {
      this._instancedDrawCalls++;
      this._removedByInstancing += instancingData.count;
      device.setVertexBuffer(instancingData._buffer, 1, instancingData.offset);
      device.draw(mesh.primitive[style], instancingData.count);
      if (instancingData._buffer === pc._autoInstanceBuffer) {
        meshInstance.instancingData = null;
        return instancingData.count - 1;
      }
    } else {
      device.draw(mesh.primitive[style]);
      return 0;
    }
  }, renderShadows:function(lights, cameraPass) {
    var device = this.device;
    var i, j, light, shadowShader, type, shadowCam, shadowCamNode, pass, passes, shadowType, smode;
    var numInstances;
    var meshInstance, mesh, material;
    var style;
    var settings;
    var visibleList, visibleLength;
    var passFlag = 1 << pc.SHADER_SHADOW;
    var paramName, parameter, parameters;
    for (i = 0; i < lights.length; i++) {
      light = lights[i];
      type = light._type;
      if (!light.castShadows || !light._enabled) {
        continue;
      }
      if (!light._shadowCamera) {
        this.getShadowCamera(device, light);
      }
      if (light.shadowUpdateMode !== pc.SHADOWUPDATE_NONE && light.visibleThisFrame) {
        var cameraPos;
        shadowCam = this.getShadowCamera(device, light);
        shadowCamNode = shadowCam._node;
        pass = 0;
        passes = 1;
        if (type === pc.LIGHTTYPE_DIRECTIONAL) {
          if (light._visibleLength[cameraPass] < 0) {
            continue;
          }
          settings = light._visibleCameraSettings[cameraPass];
          shadowCamNode.setPosition(settings.x, settings.y, settings.z);
          shadowCam.orthoHeight = settings.orthoHeight;
          shadowCam.farClip = settings.farClip;
          pass = cameraPass;
        } else {
          if (type === pc.LIGHTTYPE_SPOT) {
            cameraPos = shadowCamNode.getPosition();
            this.viewPos[0] = cameraPos.x;
            this.viewPos[1] = cameraPos.y;
            this.viewPos[2] = cameraPos.z;
            this.viewPosId.setValue(this.viewPos);
            this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
          } else {
            if (type === pc.LIGHTTYPE_POINT) {
              cameraPos = shadowCamNode.getPosition();
              this.viewPos[0] = cameraPos.x;
              this.viewPos[1] = cameraPos.y;
              this.viewPos[2] = cameraPos.z;
              this.viewPosId.setValue(this.viewPos);
              this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
              passes = 6;
            }
          }
        }
        if (type !== pc.LIGHTTYPE_POINT) {
          shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), pc.Vec3.ONE).invert();
          shadowCamViewProj.mul2(shadowCam.getProjectionMatrix(), shadowCamView);
          light._shadowMatrix.mul2(scaleShift, shadowCamViewProj);
        }
        if (device.webgl2) {
          if (type === pc.LIGHTTYPE_POINT) {
            device.setDepthBias(false);
          } else {
            device.setDepthBias(true);
            device.setDepthBiasValues(light.shadowBias * -1000.0, light.shadowBias * -1000.0);
          }
        } else {
          if (device.extStandardDerivatives) {
            if (type === pc.LIGHTTYPE_POINT) {
              this.polygonOffset[0] = 0;
              this.polygonOffset[1] = 0;
              this.polygonOffsetId.setValue(this.polygonOffset);
            } else {
              this.polygonOffset[0] = light.shadowBias * -1000.0;
              this.polygonOffset[1] = light.shadowBias * -1000.0;
              this.polygonOffsetId.setValue(this.polygonOffset);
            }
          }
        }
        if (light.shadowUpdateMode === pc.SHADOWUPDATE_THISFRAME) {
          light.shadowUpdateMode = pc.SHADOWUPDATE_NONE;
        }
        this._shadowMapUpdates += passes;
        device.setBlending(false);
        device.setDepthWrite(true);
        device.setDepthTest(true);
        if (light._isPcf && device.webgl2 && type !== pc.LIGHTTYPE_POINT) {
          device.setColorWrite(false, false, false, false);
        } else {
          device.setColorWrite(true, true, true, true);
        }
        if (pass) {
          passes = pass + 1;
        } else {
          pass = 0;
        }
        while (pass < passes) {
          if (type === pc.LIGHTTYPE_POINT) {
            shadowCamNode.setRotation(pointLightRotations[pass]);
            shadowCam.renderTarget = light._shadowCubeMap[pass];
          }
          this.setCamera(shadowCam, shadowCam.renderTarget, true, type !== pc.LIGHTTYPE_POINT);
          visibleList = light._visibleList[pass];
          visibleLength = light._visibleLength[pass];
          shadowType = light._shadowType;
          smode = shadowType + type * numShadowModes;
          for (j = 0, numInstances = visibleLength; j < numInstances; j++) {
            meshInstance = visibleList[j];
            mesh = meshInstance.mesh;
            material = meshInstance.material;
            this.setBaseConstants(device, material);
            this.setSkinning(device, meshInstance, material);
            if (material.dirty) {
              material.updateUniforms();
              material.dirty = false;
            }
            if (material.chunks) {
              parameters = material.parameters;
              for (paramName in parameters) {
                parameter = parameters[paramName];
                if (parameter.passFlags & passFlag) {
                  if (!parameter.scopeId) {
                    parameter.scopeId = device.scope.resolve(paramName);
                  }
                  parameter.scopeId.setValue(parameter.data);
                }
              }
              parameters = meshInstance.parameters;
              for (paramName in parameters) {
                parameter = parameters[paramName];
                if (parameter.passFlags & passFlag) {
                  if (!parameter.scopeId) {
                    parameter.scopeId = device.scope.resolve(paramName);
                  }
                  parameter.scopeId.setValue(parameter.data);
                }
              }
            }
            shadowShader = meshInstance._shader[pc.SHADER_SHADOW + smode];
            if (!shadowShader) {
              this.updateShader(meshInstance, meshInstance._shaderDefs, null, pc.SHADER_SHADOW + smode);
              shadowShader = meshInstance._shader[pc.SHADER_SHADOW + smode];
              meshInstance._key[pc.SORTKEY_DEPTH] = getDepthKey(meshInstance);
            }
            device.setShader(shadowShader);
            style = meshInstance.renderStyle;
            device.setVertexBuffer(meshInstance.morphInstance && meshInstance.morphInstance._vertexBuffer ? meshInstance.morphInstance._vertexBuffer : mesh.vertexBuffer, 0);
            device.setIndexBuffer(mesh.indexBuffer[style]);
            j += this.drawInstance(device, meshInstance, mesh, style);
            this._shadowDrawCalls++;
          }
          pass++;
          if (type === pc.LIGHTTYPE_DIRECTIONAL) {
            light._visibleLength[cameraPass] = -1;
          }
        }
        if (light._isVsm) {
          var filterSize = light._vsmBlurSize;
          if (filterSize > 1) {
            var origShadowMap = shadowCam.renderTarget;
            var tempRt = getShadowMapFromCache(device, light._shadowResolution, light._shadowType, 1);
            var isVsm8 = light._shadowType === pc.SHADOW_VSM8;
            var blurMode = light.vsmBlurMode;
            var blurShader = (isVsm8 ? this.blurPackedVsmShader : this.blurVsmShader)[blurMode][filterSize];
            if (!blurShader) {
              this.blurVsmWeights[filterSize] = gaussWeights(filterSize);
              var blurVS = pc.shaderChunks.fullscreenQuadVS;
              var blurFS = "#define SAMPLES " + filterSize + "\n";
              if (isVsm8) {
                blurFS += this.blurPackedVsmShaderCode[blurMode];
              } else {
                blurFS += this.blurVsmShaderCode[blurMode];
              }
              var blurShaderName = "blurVsm" + blurMode + "" + filterSize + "" + isVsm8;
              blurShader = pc.shaderChunks.createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);
              if (isVsm8) {
                this.blurPackedVsmShader[blurMode][filterSize] = blurShader;
              } else {
                this.blurVsmShader[blurMode][filterSize] = blurShader;
              }
            }
            blurScissorRect.z = light._shadowResolution - 2;
            blurScissorRect.w = blurScissorRect.z;
            this.sourceId.setValue(origShadowMap.colorBuffer);
            pixelOffset[0] = 1 / light._shadowResolution;
            pixelOffset[1] = 0;
            this.pixelOffsetId.setValue(pixelOffset);
            if (blurMode === pc.BLUR_GAUSSIAN) {
              this.weightId.setValue(this.blurVsmWeights[filterSize]);
            }
            pc.drawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);
            this.sourceId.setValue(tempRt.colorBuffer);
            pixelOffset[1] = pixelOffset[0];
            pixelOffset[0] = 0;
            this.pixelOffsetId.setValue(pixelOffset);
            pc.drawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);
          }
        }
      }
    }
    if (device.webgl2) {
      device.setDepthBias(false);
    } else {
      if (device.extStandardDerivatives) {
        this.polygonOffset[0] = 0;
        this.polygonOffset[1] = 0;
        this.polygonOffsetId.setValue(this.polygonOffset);
      }
    }
  }, updateShader:function(meshInstance, objDefs, staticLightList, pass, sortedLights) {
    meshInstance.material._scene = this.scene;
    meshInstance.material.updateShader(this.device, this.scene, objDefs, staticLightList, pass, sortedLights);
    meshInstance._shader[pass] = meshInstance.material.shader;
  }, renderForward:function(camera, drawCalls, drawCallsCount, sortedLights, pass, cullingMask, drawCallback, layer) {
    var device = this.device;
    var scene = this.scene;
    var vrDisplay = camera.vrDisplay;
    var passFlag = 1 << pass;
    var lightHash = layer ? layer._lightHash : 0;
    var i, drawCall, mesh, material, objDefs, variantKey, lightMask, style, usedDirLights;
    var prevMaterial = null, prevObjDefs, prevLightMask, prevStatic;
    var paramName, parameter, parameters;
    var stencilFront, stencilBack;
    var halfWidth = device.width * 0.5;
    for (i = 0; i < drawCallsCount; i++) {
      drawCall = drawCalls[i];
      if (cullingMask && drawCall.mask && !(cullingMask & drawCall.mask)) {
        continue;
      }
      if (drawCall.command) {
        drawCall.command();
      } else {
        mesh = drawCall.mesh;
        material = drawCall.material;
        objDefs = drawCall._shaderDefs;
        lightMask = drawCall.mask;
        this.setSkinning(device, drawCall, material);
        if (material && material === prevMaterial && objDefs !== prevObjDefs) {
          prevMaterial = null;
        }
        if (drawCall.isStatic || prevStatic) {
          prevMaterial = null;
        }
        if (material !== prevMaterial) {
          this._materialSwitches++;
          if (material.dirty) {
            material.updateUniforms();
            material.dirty = false;
          }
          if (!drawCall._shader[pass] || drawCall._shaderDefs !== objDefs || drawCall._lightHash !== lightHash) {
            if (!drawCall.isStatic) {
              variantKey = pass + "_" + objDefs + "_" + lightHash;
              drawCall._shader[pass] = material.variants[variantKey];
              if (!drawCall._shader[pass]) {
                this.updateShader(drawCall, objDefs, null, pass, sortedLights);
                material.variants[variantKey] = drawCall._shader[pass];
              }
            } else {
              this.updateShader(drawCall, objDefs, drawCall._staticLightList, pass, sortedLights);
            }
            drawCall._shaderDefs = objDefs;
            drawCall._lightHash = lightHash;
          }
          device.setShader(drawCall._shader[pass]);
          parameters = material.parameters;
          for (paramName in parameters) {
            parameter = parameters[paramName];
            if (parameter.passFlags & passFlag) {
              if (!parameter.scopeId) {
                parameter.scopeId = device.scope.resolve(paramName);
              }
              parameter.scopeId.setValue(parameter.data);
            }
          }
          if (!prevMaterial || lightMask !== prevLightMask) {
            usedDirLights = this.dispatchDirectLights(sortedLights[pc.LIGHTTYPE_DIRECTIONAL], scene, lightMask);
            this.dispatchLocalLights(sortedLights, scene, lightMask, usedDirLights, drawCall._staticLightList);
          }
          this.alphaTestId.setValue(material.alphaTest);
          device.setBlending(material.blend);
          if (material.blend) {
            if (material.separateAlphaBlend) {
              device.setBlendFunctionSeparate(material.blendSrc, material.blendDst, material.blendSrcAlpha, material.blendDstAlpha);
              device.setBlendEquationSeparate(material.blendEquation, material.blendAlphaEquation);
            } else {
              device.setBlendFunction(material.blendSrc, material.blendDst);
              device.setBlendEquation(material.blendEquation);
            }
          }
          device.setColorWrite(material.redWrite, material.greenWrite, material.blueWrite, material.alphaWrite);
          if (camera._cullFaces) {
            if (camera._flipFaces) {
              device.setCullMode(material.cull > 0 ? material.cull === pc.CULLFACE_FRONT ? pc.CULLFACE_BACK : pc.CULLFACE_FRONT : 0);
            } else {
              device.setCullMode(material.cull);
            }
          } else {
            device.setCullMode(pc.CULLFACE_NONE);
          }
          device.setDepthWrite(material.depthWrite);
          device.setDepthTest(material.depthTest);
          device.setAlphaToCoverage(material.alphaToCoverage);
          if (material.depthBias || material.slopeDepthBias) {
            device.setDepthBias(true);
            device.setDepthBiasValues(material.depthBias, material.slopeDepthBias);
          } else {
            device.setDepthBias(false);
          }
        }
        stencilFront = drawCall.stencilFront || material.stencilFront;
        stencilBack = drawCall.stencilBack || material.stencilBack;
        if (stencilFront || stencilBack) {
          device.setStencilTest(true);
          if (stencilFront === stencilBack) {
            device.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);
            device.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
          } else {
            if (stencilFront) {
              device.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);
              device.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
            } else {
              device.setStencilFuncFront(pc.FUNC_ALWAYS, 0, 255);
              device.setStencilOperationFront(pc.STENCILOP_KEEP, pc.STENCILOP_KEEP, pc.STENCILOP_KEEPP, 255);
            }
            if (stencilBack) {
              device.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);
              device.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);
            } else {
              device.setStencilFuncBack(pc.FUNC_ALWAYS, 0, 255);
              device.setStencilOperationBack(pc.STENCILOP_KEEP, pc.STENCILOP_KEEP, pc.STENCILOP_KEEP, 255);
            }
          }
        } else {
          device.setStencilTest(false);
        }
        parameters = drawCall.parameters;
        for (paramName in parameters) {
          parameter = parameters[paramName];
          if (parameter.passFlags & passFlag) {
            if (!parameter.scopeId) {
              parameter.scopeId = device.scope.resolve(paramName);
            }
            parameter.scopeId.setValue(parameter.data);
          }
        }
        device.setVertexBuffer(drawCall.morphInstance && drawCall.morphInstance._vertexBuffer ? drawCall.morphInstance._vertexBuffer : mesh.vertexBuffer, 0);
        style = drawCall.renderStyle;
        device.setIndexBuffer(mesh.indexBuffer[style]);
        if (drawCallback) {
          drawCallback(drawCall, i);
        }
        if (vrDisplay && vrDisplay.presenting) {
          device.setViewport(0, 0, halfWidth, device.height);
          this.projId.setValue(projL.data);
          this.viewInvId.setValue(viewInvL.data);
          this.viewId.setValue(viewL.data);
          this.viewId3.setValue(viewMat3L.data);
          this.viewProjId.setValue(viewProjMatL.data);
          this.viewPos[0] = viewPosL.x;
          this.viewPos[1] = viewPosL.y;
          this.viewPos[2] = viewPosL.z;
          this.viewPosId.setValue(this.viewPos);
          i += this.drawInstance(device, drawCall, mesh, style, true);
          this._forwardDrawCalls++;
          device.setViewport(halfWidth, 0, halfWidth, device.height);
          this.projId.setValue(projR.data);
          this.viewInvId.setValue(viewInvR.data);
          this.viewId.setValue(viewR.data);
          this.viewId3.setValue(viewMat3R.data);
          this.viewProjId.setValue(viewProjMatR.data);
          this.viewPos[0] = viewPosR.x;
          this.viewPos[1] = viewPosR.y;
          this.viewPos[2] = viewPosR.z;
          this.viewPosId.setValue(this.viewPos);
          i += this.drawInstance2(device, drawCall, mesh, style);
          this._forwardDrawCalls++;
        } else {
          i += this.drawInstance(device, drawCall, mesh, style, true);
          this._forwardDrawCalls++;
        }
        if (i < drawCallsCount - 1 && drawCalls[i + 1].material === material) {
          for (paramName in parameters) {
            parameter = material.parameters[paramName];
            if (parameter) {
              if (!parameter.scopeId) {
                parameter.scopeId = device.scope.resolve(paramName);
              }
              parameter.scopeId.setValue(parameter.data);
            }
          }
        }
        prevMaterial = material;
        prevObjDefs = objDefs;
        prevLightMask = lightMask;
        prevStatic = drawCall.isStatic;
      }
    }
    device.updateEnd();
  }, setupInstancing:function(device) {
    if (!pc._instanceVertexFormat) {
      var formatDesc = [{semantic:pc.SEMANTIC_TEXCOORD2, components:4, type:pc.TYPE_FLOAT32}, {semantic:pc.SEMANTIC_TEXCOORD3, components:4, type:pc.TYPE_FLOAT32}, {semantic:pc.SEMANTIC_TEXCOORD4, components:4, type:pc.TYPE_FLOAT32}, {semantic:pc.SEMANTIC_TEXCOORD5, components:4, type:pc.TYPE_FLOAT32}];
      pc._instanceVertexFormat = new pc.VertexFormat(device, formatDesc);
    }
    if (device.enableAutoInstancing) {
      if (!pc._autoInstanceBuffer) {
        pc._autoInstanceBuffer = new pc.VertexBuffer(device, pc._instanceVertexFormat, device.autoInstancingMaxObjects, pc.BUFFER_DYNAMIC);
        pc._autoInstanceBufferData = new Float32Array(pc._autoInstanceBuffer.lock());
      }
    }
  }, revertStaticMeshes:function(meshInstances) {
    var i;
    var drawCalls = meshInstances;
    var drawCallsCount = drawCalls.length;
    var drawCall;
    var newDrawCalls = [];
    var prevStaticSource;
    for (i = 0; i < drawCallsCount; i++) {
      drawCall = drawCalls[i];
      if (drawCall._staticSource) {
        if (drawCall._staticSource !== prevStaticSource) {
          newDrawCalls.push(drawCall._staticSource);
          prevStaticSource = drawCall._staticSource;
        }
      } else {
        newDrawCalls.push(drawCall);
      }
    }
    meshInstances.length = newDrawCalls.length;
    for (i = 0; i < newDrawCalls.length; i++) {
      meshInstances[i] = newDrawCalls[i];
    }
  }, prepareStaticMeshes:function(meshInstances, lights) {
    var i, j, k, v, s, index;
    var device = this.device;
    var scene = this.scene;
    var drawCalls = meshInstances;
    var drawCallsCount = drawCalls.length;
    var drawCall, light;
    var newDrawCalls = [];
    var mesh;
    var indices, verts, numTris, elems, vertSize, offsetP, baseIndex;
    var _x, _y, _z;
    var minx, miny, minz, maxx, maxy, maxz;
    var minv, maxv;
    var minVec = new pc.Vec3;
    var maxVec = new pc.Vec3;
    var localLightBounds = new pc.BoundingBox;
    var invMatrix = new pc.Mat4;
    var triLightComb = [];
    var triLightCombUsed;
    var indexBuffer, vertexBuffer;
    var combIndices, combIbName, combIb;
    var lightTypePass;
    var lightAabb = [];
    var aabb;
    var triBounds = [];
    var staticLights = [];
    var bit;
    var lht;
    for (i = 0; i < drawCallsCount; i++) {
      drawCall = drawCalls[i];
      if (!drawCall.isStatic) {
        newDrawCalls.push(drawCall);
      } else {
        aabb = drawCall.aabb;
        staticLights.length = 0;
        for (lightTypePass = pc.LIGHTTYPE_POINT; lightTypePass <= pc.LIGHTTYPE_SPOT; lightTypePass++) {
          for (j = 0; j < lights.length; j++) {
            light = lights[j];
            if (light._type !== lightTypePass) {
              continue;
            }
            if (light._enabled) {
              if (light._mask & drawCall.mask) {
                if (light.isStatic) {
                  if (!lightAabb[j]) {
                    lightAabb[j] = new pc.BoundingBox;
                    light._node.getWorldTransform();
                    light.getBoundingSphere(tempSphere);
                    lightAabb[j].center.copy(tempSphere.center);
                    lightAabb[j].halfExtents.x = tempSphere.radius;
                    lightAabb[j].halfExtents.y = tempSphere.radius;
                    lightAabb[j].halfExtents.z = tempSphere.radius;
                  }
                  if (!lightAabb[j].intersects(aabb)) {
                    continue;
                  }
                  staticLights.push(j);
                }
              }
            }
          }
        }
        if (staticLights.length === 0) {
          newDrawCalls.push(drawCall);
          continue;
        }
        mesh = drawCall.mesh;
        vertexBuffer = mesh.vertexBuffer;
        indexBuffer = mesh.indexBuffer[drawCall.renderStyle];
        indices = indexBuffer.bytesPerIndex === 2 ? new Uint16Array(indexBuffer.lock()) : new Uint32Array(indexBuffer.lock());
        numTris = mesh.primitive[drawCall.renderStyle].count / 3;
        baseIndex = mesh.primitive[drawCall.renderStyle].base;
        elems = vertexBuffer.format.elements;
        vertSize = vertexBuffer.format.size / 4;
        verts = new Float32Array(vertexBuffer.storage);
        for (k = 0; k < elems.length; k++) {
          if (elems[k].name === pc.SEMANTIC_POSITION) {
            offsetP = elems[k].offset / 4;
          }
        }
        triLightComb.length = numTris;
        for (k = 0; k < numTris; k++) {
          triLightComb[k] = 0;
        }
        triLightCombUsed = false;
        triBounds.length = numTris * 6;
        for (k = 0; k < numTris; k++) {
          minx = Number.MAX_VALUE;
          miny = Number.MAX_VALUE;
          minz = Number.MAX_VALUE;
          maxx = -Number.MAX_VALUE;
          maxy = -Number.MAX_VALUE;
          maxz = -Number.MAX_VALUE;
          for (v = 0; v < 3; v++) {
            index = indices[k * 3 + v + baseIndex];
            index = index * vertSize + offsetP;
            _x = verts[index];
            _y = verts[index + 1];
            _z = verts[index + 2];
            if (_x < minx) {
              minx = _x;
            }
            if (_y < miny) {
              miny = _y;
            }
            if (_z < minz) {
              minz = _z;
            }
            if (_x > maxx) {
              maxx = _x;
            }
            if (_y > maxy) {
              maxy = _y;
            }
            if (_z > maxz) {
              maxz = _z;
            }
          }
          index = k * 6;
          triBounds[index] = minx;
          triBounds[index + 1] = miny;
          triBounds[index + 2] = minz;
          triBounds[index + 3] = maxx;
          triBounds[index + 4] = maxy;
          triBounds[index + 5] = maxz;
        }
        for (s = 0; s < staticLights.length; s++) {
          j = staticLights[s];
          light = lights[j];
          invMatrix.copy(drawCall.node.worldTransform).invert();
          localLightBounds.setFromTransformedAabb(lightAabb[j], invMatrix);
          minv = localLightBounds.getMin();
          maxv = localLightBounds.getMax();
          bit = 1 << s;
          for (k = 0; k < numTris; k++) {
            index = k * 6;
            if (triBounds[index] <= maxv.x && triBounds[index + 3] >= minv.x && triBounds[index + 1] <= maxv.y && triBounds[index + 4] >= minv.y && triBounds[index + 2] <= maxv.z && triBounds[index + 5] >= minv.z) {
              triLightComb[k] |= bit;
              triLightCombUsed = true;
            }
          }
        }
        if (triLightCombUsed) {
          combIndices = {};
          for (k = 0; k < numTris; k++) {
            j = k * 3 + baseIndex;
            combIbName = triLightComb[k];
            if (!combIndices[combIbName]) {
              combIndices[combIbName] = [];
            }
            combIb = combIndices[combIbName];
            combIb.push(indices[j]);
            combIb.push(indices[j + 1]);
            combIb.push(indices[j + 2]);
          }
          for (combIbName in combIndices) {
            combIb = combIndices[combIbName];
            var ib = new pc.IndexBuffer(device, indexBuffer.format, combIb.length, indexBuffer.usage);
            var ib2 = ib.bytesPerIndex === 2 ? new Uint16Array(ib.lock()) : new Uint32Array(ib.lock());
            ib2.set(combIb);
            ib.unlock();
            minx = Number.MAX_VALUE;
            miny = Number.MAX_VALUE;
            minz = Number.MAX_VALUE;
            maxx = -Number.MAX_VALUE;
            maxy = -Number.MAX_VALUE;
            maxz = -Number.MAX_VALUE;
            for (k = 0; k < combIb.length; k++) {
              index = combIb[k];
              _x = verts[index * vertSize + offsetP];
              _y = verts[index * vertSize + offsetP + 1];
              _z = verts[index * vertSize + offsetP + 2];
              if (_x < minx) {
                minx = _x;
              }
              if (_y < miny) {
                miny = _y;
              }
              if (_z < minz) {
                minz = _z;
              }
              if (_x > maxx) {
                maxx = _x;
              }
              if (_y > maxy) {
                maxy = _y;
              }
              if (_z > maxz) {
                maxz = _z;
              }
            }
            minVec.set(minx, miny, minz);
            maxVec.set(maxx, maxy, maxz);
            var chunkAabb = new pc.BoundingBox;
            chunkAabb.setMinMax(minVec, maxVec);
            var mesh2 = new pc.Mesh;
            mesh2.vertexBuffer = vertexBuffer;
            mesh2.indexBuffer[0] = ib;
            mesh2.primitive[0].type = pc.PRIMITIVE_TRIANGLES;
            mesh2.primitive[0].base = 0;
            mesh2.primitive[0].count = combIb.length;
            mesh2.primitive[0].indexed = true;
            mesh2.aabb = chunkAabb;
            var instance = new pc.MeshInstance(drawCall.node, mesh2, drawCall.material);
            instance.isStatic = drawCall.isStatic;
            instance.visible = drawCall.visible;
            instance.layer = drawCall.layer;
            instance.castShadow = drawCall.castShadow;
            instance._receiveShadow = drawCall._receiveShadow;
            instance.cull = drawCall.cull;
            instance.pick = drawCall.pick;
            instance.mask = drawCall.mask;
            instance.parameters = drawCall.parameters;
            instance._shaderDefs = drawCall._shaderDefs;
            instance._staticSource = drawCall;
            if (drawCall._staticLightList) {
              instance._staticLightList = drawCall._staticLightList;
            } else {
              instance._staticLightList = [];
            }
            for (k = 0; k < staticLights.length; k++) {
              bit = 1 << k;
              if (combIbName & bit) {
                lht = lights[staticLights[k]];
                if (instance._staticLightList.indexOf(lht) < 0) {
                  instance._staticLightList.push(lht);
                }
              }
            }
            instance._staticLightList.sort(this.lightCompare);
            newDrawCalls.push(instance);
          }
        } else {
          newDrawCalls.push(drawCall);
        }
      }
    }
    meshInstances.length = newDrawCalls.length;
    for (i = 0; i < newDrawCalls.length; i++) {
      meshInstances[i] = newDrawCalls[i];
    }
  }, updateShaders:function(drawCalls) {
    var i;
    var materials = [];
    for (i = 0; i < drawCalls.length; i++) {
      var drawCall = drawCalls[i];
      if (drawCall.material !== undefined) {
        if (materials.indexOf(drawCall.material) === -1) {
          materials.push(drawCall.material);
        }
      }
    }
    for (i = 0; i < materials.length; i++) {
      var mat = materials[i];
      if (mat.updateShader !== pc.Material.prototype.updateShader) {
        mat.clearVariants();
        mat.shader = null;
      }
    }
  }, updateLitShaders:function(drawCalls) {
    for (var i = 0; i < drawCalls.length; i++) {
      var drawCall = drawCalls[i];
      if (drawCall.material !== undefined) {
        var mat = drawCall.material;
        if (mat.updateShader !== pc.Material.prototype.updateShader) {
          if (mat.useLighting === false || mat.emitter && !mat.emitter.lighting) {
            continue;
          }
          mat.clearVariants();
          mat.shader = null;
        }
      }
    }
  }, beginFrame:function(comp) {
    var device = this.device;
    var scene = this.scene;
    var meshInstances = comp._meshInstances;
    var lights = comp._lights;
    if (scene.updateSkybox) {
      scene._updateSkybox(device);
      scene.updateSkybox = false;
    }
    if (scene.updateShaders) {
      this.updateShaders(meshInstances);
      scene.updateShaders = false;
      scene.updateLitShaders = false;
      scene._shaderVersion++;
    } else {
      if (scene.updateLitShaders) {
        this.updateLitShaders(meshInstances);
        scene.updateLitShaders = false;
        scene._shaderVersion++;
      }
    }
    this.updateCpuSkinMatrices(meshInstances);
    this.updateMorphedBounds(meshInstances);
    var i;
    var len = meshInstances.length;
    for (i = 0; i < len; i++) {
      meshInstances[i].visibleThisFrame = false;
    }
    len = lights.length;
    for (i = 0; i < len; i++) {
      lights[i].visibleThisFrame = lights[i]._type === pc.LIGHTTYPE_DIRECTIONAL;
    }
  }, beginLayers:function(comp) {
    var scene = this.scene;
    var len = comp.layerList.length;
    var layer;
    var i, j;
    var shaderVersion = this.scene._shaderVersion;
    for (i = 0; i < len; i++) {
      comp.layerList[i]._postRenderCounter = 0;
    }
    var transparent;
    for (i = 0; i < len; i++) {
      layer = comp.layerList[i];
      layer._shaderVersion = shaderVersion;
      layer._preRenderCalledForCameras = 0;
      layer._postRenderCalledForCameras = 0;
      transparent = comp.subLayerList[i];
      if (transparent) {
        layer._postRenderCounter |= 2;
      } else {
        layer._postRenderCounter |= 1;
      }
      layer._postRenderCounterMax = layer._postRenderCounter;
      for (j = 0; j < layer.cameras.length; j++) {
        if (!layer.instances.visibleOpaque[j]) {
          layer.instances.visibleOpaque[j] = new pc.VisibleInstanceList;
        }
        if (!layer.instances.visibleTransparent[j]) {
          layer.instances.visibleTransparent[j] = new pc.VisibleInstanceList;
        }
        layer.instances.visibleOpaque[j].done = false;
        layer.instances.visibleTransparent[j].done = false;
      }
      if (layer.cameras.length < layer.instances.visibleOpaque.length) {
        layer.instances.visibleOpaque.splice(layer.cameras.length, 1);
      }
      if (layer.cameras.length < layer.instances.visibleTransparent.length) {
        layer.instances.visibleTransparent.splice(layer.cameras.length, 1);
      }
      if (layer._needsStaticPrepare && layer._staticLightHash) {
        if (layer._staticPrepareDone) {
          this.revertStaticMeshes(layer.opaqueMeshInstances);
          this.revertStaticMeshes(layer.transparentMeshInstances);
        }
        this.prepareStaticMeshes(layer.opaqueMeshInstances, layer._lights);
        this.prepareStaticMeshes(layer.transparentMeshInstances, layer._lights);
        comp._dirty = true;
        scene.updateShaders = true;
        layer._needsStaticPrepare = false;
        layer._staticPrepareDone = true;
      }
    }
  }, cullLocalShadowmap:function(light, drawCalls) {
    var i, type, shadowCam, shadowCamNode, passes, pass, numInstances, meshInstance, visibleList, vlen, visible;
    var lightNode;
    type = light._type;
    if (type === pc.LIGHTTYPE_DIRECTIONAL) {
      return;
    }
    light.visibleThisFrame = true;
    shadowCam = this.getShadowCamera(this.device, light);
    shadowCam.projection = pc.PROJECTION_PERSPECTIVE;
    shadowCam.nearClip = light.attenuationEnd / 1000;
    shadowCam.farClip = light.attenuationEnd;
    shadowCam.aspectRatio = 1;
    if (type === pc.LIGHTTYPE_SPOT) {
      shadowCam.fov = light._outerConeAngle * 2;
      passes = 1;
    } else {
      shadowCam.fov = 90;
      passes = 6;
    }
    shadowCamNode = shadowCam._node;
    lightNode = light._node;
    shadowCamNode.setPosition(lightNode.getPosition());
    if (type === pc.LIGHTTYPE_SPOT) {
      shadowCamNode.setRotation(lightNode.getRotation());
      shadowCamNode.rotateLocal(-90, 0, 0);
    }
    for (pass = 0; pass < passes; pass++) {
      if (type === pc.LIGHTTYPE_POINT) {
        shadowCamNode.setRotation(pointLightRotations[pass]);
        shadowCam.renderTarget = light._shadowCubeMap[pass];
      }
      this.updateCameraFrustum(shadowCam);
      visibleList = light._visibleList[pass];
      if (!visibleList) {
        visibleList = light._visibleList[pass] = [];
      }
      light._visibleLength[pass] = 0;
      vlen = 0;
      for (i = 0, numInstances = drawCalls.length; i < numInstances; i++) {
        meshInstance = drawCalls[i];
        visible = true;
        if (meshInstance.cull) {
          visible = this._isVisible(shadowCam, meshInstance);
        }
        if (visible) {
          visibleList[vlen] = meshInstance;
          vlen++;
          meshInstance.visibleThisFrame = true;
        }
      }
      light._visibleLength[pass] = vlen;
      if (visibleList.length !== vlen) {
        visibleList.length = vlen;
      }
      visibleList.sort(this.depthSortCompare);
    }
  }, cullDirectionalShadowmap:function(light, drawCalls, camera, pass) {
    var i, shadowCam, shadowCamNode, lightNode, frustumSize, vlen, visibleList;
    var unitPerTexel, delta, p;
    var minx, miny, minz, maxx, maxy, maxz, centerx, centery;
    var visible, numInstances;
    var meshInstance;
    var emptyAabb;
    var drawCallAabb;
    var device = this.device;
    light.visibleThisFrame = true;
    shadowCam = this.getShadowCamera(device, light);
    shadowCamNode = shadowCam._node;
    lightNode = light._node;
    shadowCamNode.setPosition(lightNode.getPosition());
    shadowCamNode.setRotation(lightNode.getRotation());
    shadowCamNode.rotateLocal(-90, 0, 0);
    _getFrustumPoints(camera, light.shadowDistance || camera._farClip, frustumPoints);
    frustumSize = frustumDiagonal.sub2(frustumPoints[0], frustumPoints[6]).length();
    frustumSize = Math.max(frustumSize, frustumDiagonal.sub2(frustumPoints[4], frustumPoints[6]).length());
    shadowCamView.copy(shadowCamNode.getWorldTransform()).invert();
    c2sc.copy(shadowCamView).mul(camera._node.worldTransform);
    for (i = 0; i < 8; i++) {
      c2sc.transformPoint(frustumPoints[i], frustumPoints[i]);
    }
    minx = miny = minz = 1000000;
    maxx = maxy = maxz = -1000000;
    for (i = 0; i < 8; i++) {
      p = frustumPoints[i];
      if (p.x < minx) {
        minx = p.x;
      }
      if (p.x > maxx) {
        maxx = p.x;
      }
      if (p.y < miny) {
        miny = p.y;
      }
      if (p.y > maxy) {
        maxy = p.y;
      }
      if (p.z < minz) {
        minz = p.z;
      }
      if (p.z > maxz) {
        maxz = p.z;
      }
    }
    unitPerTexel = frustumSize / light._shadowResolution;
    delta = (frustumSize - (maxx - minx)) * 0.5;
    minx = Math.floor((minx - delta) / unitPerTexel) * unitPerTexel;
    delta = (frustumSize - (maxy - miny)) * 0.5;
    miny = Math.floor((miny - delta) / unitPerTexel) * unitPerTexel;
    maxx = minx + frustumSize;
    maxy = miny + frustumSize;
    centerx = (maxx + minx) * 0.5;
    centery = (maxy + miny) * 0.5;
    shadowCamNode.translateLocal(centerx, centery, 100000);
    shadowCam.projection = pc.PROJECTION_ORTHOGRAPHIC;
    shadowCam.nearClip = 0;
    shadowCam.farClip = 200000;
    shadowCam.aspectRatio = 1;
    shadowCam.orthoHeight = frustumSize * 0.5;
    this.updateCameraFrustum(shadowCam);
    emptyAabb = true;
    visibleList = light._visibleList[pass];
    if (!visibleList) {
      visibleList = light._visibleList[pass] = [];
    }
    vlen = light._visibleLength[pass] = 0;
    for (i = 0, numInstances = drawCalls.length; i < numInstances; i++) {
      meshInstance = drawCalls[i];
      visible = true;
      if (meshInstance.cull) {
        visible = this._isVisible(shadowCam, meshInstance);
      }
      if (visible) {
        visibleList[vlen] = meshInstance;
        vlen++;
        meshInstance.visibleThisFrame = true;
        drawCallAabb = meshInstance.aabb;
        if (emptyAabb) {
          visibleSceneAabb.copy(drawCallAabb);
          emptyAabb = false;
        } else {
          visibleSceneAabb.add(drawCallAabb);
        }
      }
    }
    light._visibleLength[pass] = vlen;
    if (visibleList.length !== vlen) {
      visibleList.length = vlen;
    }
    visibleList.sort(this.depthSortCompare);
    var z = _getZFromAABBSimple(shadowCamView, visibleSceneAabb.getMin(), visibleSceneAabb.getMax(), minx, maxx, miny, maxy);
    maxz = z.max;
    if (z.min > minz) {
      minz = z.min;
    }
    shadowCamNode.setPosition(lightNode.getPosition());
    shadowCamNode.translateLocal(centerx, centery, maxz + directionalShadowEpsilon);
    shadowCam.farClip = maxz - minz;
    var settings = light._visibleCameraSettings[pass];
    if (!settings) {
      settings = light._visibleCameraSettings[pass] = {};
    }
    var lpos = shadowCamNode.getPosition();
    settings.x = lpos.x;
    settings.y = lpos.y;
    settings.z = lpos.z;
    settings.orthoHeight = shadowCam.orthoHeight;
    settings.farClip = shadowCam.farClip;
  }, gpuUpdate:function(drawCalls) {
    this.updateGpuSkinMatrices(drawCalls);
    this.updateMorphing(drawCalls);
  }, clearView:function(camera, target, options) {
    camera = camera.camera;
    var device = this.device;
    device.setRenderTarget(target);
    device.updateBegin();
    device.setColorWrite(true, true, true, true);
    device.setDepthWrite(true);
    var rect = camera.getRect();
    var pixelWidth = target ? target.width : device.width;
    var pixelHeight = target ? target.height : device.height;
    var x = Math.floor(rect.x * pixelWidth);
    var y = Math.floor(rect.y * pixelHeight);
    var w = Math.floor(rect.width * pixelWidth);
    var h = Math.floor(rect.height * pixelHeight);
    device.setViewport(x, y, w, h);
    device.setScissor(x, y, w, h);
    device.clear(options ? options : camera._clearOptions);
  }, setSceneConstants:function() {
    var i;
    var device = this.device;
    var scene = this.scene;
    this.dispatchGlobalLights(scene);
    if (scene.fog !== pc.FOG_NONE) {
      this.fogColor[0] = scene.fogColor.r;
      this.fogColor[1] = scene.fogColor.g;
      this.fogColor[2] = scene.fogColor.b;
      if (scene.gammaCorrection) {
        for (i = 0; i < 3; i++) {
          this.fogColor[i] = Math.pow(this.fogColor[i], 2.2);
        }
      }
      this.fogColorId.setValue(this.fogColor);
      if (scene.fog === pc.FOG_LINEAR) {
        this.fogStartId.setValue(scene.fogStart);
        this.fogEndId.setValue(scene.fogEnd);
      } else {
        this.fogDensityId.setValue(scene.fogDensity);
      }
    }
    this._screenSize[0] = device.width;
    this._screenSize[1] = device.height;
    this._screenSize[2] = 1 / device.width;
    this._screenSize[3] = 1 / device.height;
    this.screenSizeId.setValue(this._screenSize);
  }, renderComposition:function(comp) {
    var device = this.device;
    var camera;
    var renderedRt = comp._renderedRt;
    var renderedByCam = comp._renderedByCam;
    var renderedLayer = comp._renderedLayer;
    var i, layer, transparent, cameras, j, rt, k, processedThisCamera, processedThisCameraAndLayer, processedThisCameraAndRt;
    this.beginLayers(comp);
    var updated = comp._update();
    if (updated & pc.COMPUPDATED_LIGHTS) {
      this.scene.updateLitShaders = true;
    }
    this.beginFrame(comp);
    this.setSceneConstants();
    var renderedLength = 0;
    var objects, drawCalls, visible;
    for (i = 0; i < comp.layerList.length; i++) {
      layer = comp.layerList[i];
      if (!layer.enabled || !comp.subLayerEnabled[i]) {
        continue;
      }
      transparent = comp.subLayerList[i];
      objects = layer.instances;
      cameras = layer.cameras;
      for (j = 0; j < cameras.length; j++) {
        camera = cameras[j];
        if (!camera) {
          continue;
        }
        camera.frameBegin(layer.renderTarget);
        drawCalls = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;
        processedThisCamera = false;
        processedThisCameraAndLayer = false;
        for (k = 0; k < renderedLength; k++) {
          if (renderedByCam[k] === camera) {
            processedThisCamera = true;
            if (renderedLayer[k] === layer) {
              processedThisCameraAndLayer = true;
              break;
            }
          }
        }
        if (!processedThisCamera) {
          this.updateCameraFrustum(camera.camera);
          this._camerasRendered++;
        }
        if (!processedThisCameraAndLayer) {
          this.cullLights(camera.camera, layer._lights);
        }
        if (!processedThisCamera || !processedThisCameraAndLayer) {
          renderedByCam[renderedLength] = camera;
          renderedLayer[renderedLength] = layer;
          renderedLength++;
        }
        visible = transparent ? objects.visibleTransparent[j] : objects.visibleOpaque[j];
        if (!visible.done) {
          if (layer.onPreCull) {
            layer.onPreCull(j);
          }
          visible.length = this.cull(camera.camera, drawCalls, visible.list);
          visible.done = true;
          if (layer.onPostCull) {
            layer.onPostCull(j);
          }
        }
        camera.frameEnd();
      }
    }
    var light, casters;
    for (i = 0; i < comp._lights.length; i++) {
      light = comp._lights[i];
      if (!light.visibleThisFrame) {
        continue;
      }
      if (light._type === pc.LIGHTTYPE_DIRECTIONAL) {
        continue;
      }
      if (!light.castShadows || !light._enabled || light.shadowUpdateMode === pc.SHADOWUPDATE_NONE) {
        continue;
      }
      casters = comp._lightShadowCasters[i];
      this.cullLocalShadowmap(light, casters);
    }
    renderedLength = 0;
    var globalLightCounter = -1;
    for (i = 0; i < comp._lights.length; i++) {
      light = comp._lights[i];
      if (light._type !== pc.LIGHTTYPE_DIRECTIONAL) {
        continue;
      }
      globalLightCounter++;
      if (!light.castShadows || !light._enabled || light.shadowUpdateMode === pc.SHADOWUPDATE_NONE) {
        continue;
      }
      casters = comp._lightShadowCasters[i];
      cameras = comp._globalLightCameras[globalLightCounter];
      for (j = 0; j < cameras.length; j++) {
        this.cullDirectionalShadowmap(light, casters, cameras[j].camera, comp._globalLightCameraIds[globalLightCounter][j]);
      }
    }
    this.gpuUpdate(comp._meshInstances);
    this.renderShadows(comp._sortedLights[pc.LIGHTTYPE_SPOT]);
    this.renderShadows(comp._sortedLights[pc.LIGHTTYPE_POINT]);
    renderedLength = 0;
    var cameraPass;
    var sortTime, draws, drawTime;
    for (i = 0; i < comp._renderList.length; i++) {
      layer = comp.layerList[comp._renderList[i]];
      if (!layer.enabled || !comp.subLayerEnabled[comp._renderList[i]]) {
        continue;
      }
      objects = layer.instances;
      transparent = comp.subLayerList[comp._renderList[i]];
      cameraPass = comp._renderListCamera[i];
      camera = layer.cameras[cameraPass];
      if (camera) {
        camera.frameBegin(layer.renderTarget);
      }
      if (!transparent && layer.onPreRenderOpaque) {
        layer.onPreRenderOpaque(cameraPass);
      } else {
        if (transparent && layer.onPreRenderTransparent) {
          layer.onPreRenderTransparent(cameraPass);
        }
      }
      if (!(layer._preRenderCalledForCameras & 1 << cameraPass)) {
        if (layer.onPreRender) {
          layer.onPreRender(cameraPass);
        }
        layer._preRenderCalledForCameras |= 1 << cameraPass;
        if (layer.overrideClear) {
          this.clearView(camera, layer.renderTarget, layer._clearOptions);
        }
      }
      if (camera) {
        rt = layer.renderTarget;
        processedThisCameraAndRt = false;
        for (k = 0; k < renderedLength; k++) {
          if (renderedRt[k] === rt && renderedByCam[k] === camera) {
            processedThisCameraAndRt = true;
            break;
          }
        }
        if (!processedThisCameraAndRt) {
          if (!layer.overrideClear) {
            this.clearView(camera, layer.renderTarget);
          }
          renderedRt[renderedLength] = rt;
          renderedByCam[renderedLength] = camera;
          renderedLength++;
        }
        this.renderShadows(layer._sortedLights[pc.LIGHTTYPE_DIRECTIONAL], cameraPass);
        layer._sortVisible(transparent, camera.node, cameraPass);
        visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];
        this.scene._activeCamera = camera.camera;
        this.setCamera(camera.camera, layer.renderTarget);
        this.renderForward(camera.camera, visible.list, visible.length, layer._sortedLights, layer.shaderPass, layer.cullingMask, layer.onDrawCall, layer);
        device.setColorWrite(true, true, true, true);
        device.setStencilTest(false);
        device.setAlphaToCoverage(false);
        device.setDepthBias(false);
        camera.frameEnd();
      }
      if (!transparent && layer.onPostRenderOpaque) {
        layer.onPostRenderOpaque(cameraPass);
      } else {
        if (transparent && layer.onPostRenderTransparent) {
          layer.onPostRenderTransparent(cameraPass);
        }
      }
      if (layer.onPostRender && !(layer._postRenderCalledForCameras & 1 << cameraPass)) {
        layer._postRenderCounter &= ~(transparent ? 2 : 1);
        if (layer._postRenderCounter === 0) {
          layer.onPostRender(cameraPass);
          layer._postRenderCalledForCameras |= 1 << cameraPass;
          layer._postRenderCounter = layer._postRenderCounterMax;
        }
      }
    }
  }});
  return {ForwardRenderer:ForwardRenderer, gaussWeights:gaussWeights};
}());
Object.assign(pc, function() {
  var scaleCompensatePosTransform = new pc.Mat4;
  var scaleCompensatePos = new pc.Vec3;
  var scaleCompensateRot = new pc.Quat;
  var scaleCompensateRot2 = new pc.Quat;
  var scaleCompensateScale = new pc.Vec3;
  var scaleCompensateScaleForParent = new pc.Vec3;
  var GraphNode = function GraphNode(name) {
    this.name = typeof name === "string" ? name : "Untitled";
    this.tags = new pc.Tags(this);
    this._labels = {};
    this.localPosition = new pc.Vec3(0, 0, 0);
    this.localRotation = new pc.Quat(0, 0, 0, 1);
    this.localScale = new pc.Vec3(1, 1, 1);
    this.localEulerAngles = new pc.Vec3(0, 0, 0);
    this.position = new pc.Vec3(0, 0, 0);
    this.rotation = new pc.Quat(0, 0, 0, 1);
    this.eulerAngles = new pc.Vec3(0, 0, 0);
    this.localTransform = new pc.Mat4;
    this._dirtyLocal = false;
    this._aabbVer = 0;
    this.worldTransform = new pc.Mat4;
    this._dirtyWorld = false;
    this.normalMatrix = new pc.Mat3;
    this._dirtyNormal = true;
    this._right = null;
    this._up = null;
    this._forward = null;
    this._parent = null;
    this._children = [];
    this._graphDepth = 0;
    this._enabled = true;
    this._enabledInHierarchy = false;
    this.scaleCompensation = false;
  };
  Object.defineProperty(GraphNode.prototype, "right", {get:function() {
    if (!this._right) {
      this._right = new pc.Vec3;
    }
    return this.getWorldTransform().getX(this._right).normalize();
  }});
  Object.defineProperty(GraphNode.prototype, "up", {get:function() {
    if (!this._up) {
      this._up = new pc.Vec3;
    }
    return this.getWorldTransform().getY(this._up).normalize();
  }});
  Object.defineProperty(GraphNode.prototype, "forward", {get:function() {
    if (!this._forward) {
      this._forward = new pc.Vec3;
    }
    return this.getWorldTransform().getZ(this._forward).normalize().scale(-1);
  }});
  Object.defineProperty(GraphNode.prototype, "enabled", {get:function() {
    return this._enabled && this._enabledInHierarchy;
  }, set:function(enabled) {
    if (this._enabled !== enabled) {
      this._enabled = enabled;
      if (!this._parent || this._parent.enabled) {
        this._notifyHierarchyStateChanged(this, enabled);
      }
    }
  }});
  Object.defineProperty(GraphNode.prototype, "parent", {get:function() {
    return this._parent;
  }});
  Object.defineProperty(GraphNode.prototype, "root", {get:function() {
    var parent = this._parent;
    if (!parent) {
      return this;
    }
    while (parent._parent) {
      parent = parent._parent;
    }
    return parent;
  }});
  Object.defineProperty(GraphNode.prototype, "children", {get:function() {
    return this._children;
  }});
  Object.defineProperty(GraphNode.prototype, "graphDepth", {get:function() {
    return this._graphDepth;
  }});
  Object.assign(GraphNode.prototype, {_notifyHierarchyStateChanged:function(node, enabled) {
    node._onHierarchyStateChanged(enabled);
    var c = node._children;
    for (var i = 0, len = c.length; i < len; i++) {
      if (c[i]._enabled) {
        this._notifyHierarchyStateChanged(c[i], enabled);
      }
    }
  }, _onHierarchyStateChanged:function(enabled) {
    this._enabledInHierarchy = enabled;
  }, _cloneInternal:function(clone) {
    clone.name = this.name;
    var tags = this.tags._list;
    for (var i = 0; i < tags.length; i++) {
      clone.tags.add(tags[i]);
    }
    clone._labels = Object.assign({}, this._labels);
    clone.localPosition.copy(this.localPosition);
    clone.localRotation.copy(this.localRotation);
    clone.localScale.copy(this.localScale);
    clone.localEulerAngles.copy(this.localEulerAngles);
    clone.position.copy(this.position);
    clone.rotation.copy(this.rotation);
    clone.eulerAngles.copy(this.eulerAngles);
    clone.localTransform.copy(this.localTransform);
    clone._dirtyLocal = this._dirtyLocal;
    clone.worldTransform.copy(this.worldTransform);
    clone._dirtyWorld = this._dirtyWorld;
    clone._dirtyNormal = this._dirtyNormal;
    clone._aabbVer = this._aabbVer + 1;
    clone._enabled = this._enabled;
    clone.scaleCompensation = this.scaleCompensation;
    clone._enabledInHierarchy = false;
  }, clone:function() {
    var clone = new pc.GraphNode;
    this._cloneInternal(clone);
    return clone;
  }, find:function(attr, value) {
    var results = [];
    var len = this._children.length;
    var i, descendants;
    if (attr instanceof Function) {
      var fn = attr;
      for (i = 0; i < len; i++) {
        if (fn(this._children[i])) {
          results.push(this._children[i]);
        }
        descendants = this._children[i].find(fn);
        if (descendants.length) {
          results = results.concat(descendants);
        }
      }
    } else {
      var testValue;
      if (this[attr]) {
        if (this[attr] instanceof Function) {
          testValue = this[attr]();
        } else {
          testValue = this[attr];
        }
        if (testValue === value) {
          results.push(this);
        }
      }
      for (i = 0; i < len; ++i) {
        descendants = this._children[i].find(attr, value);
        if (descendants.length) {
          results = results.concat(descendants);
        }
      }
    }
    return results;
  }, findOne:function(attr, value) {
    var i;
    var len = this._children.length;
    var result = null;
    if (attr instanceof Function) {
      var fn = attr;
      result = fn(this);
      if (result) {
        return this;
      }
      for (i = 0; i < len; i++) {
        result = this._children[i].findOne(fn);
        if (result) {
          return this._children[i];
        }
      }
    } else {
      var testValue;
      if (this[attr]) {
        if (this[attr] instanceof Function) {
          testValue = this[attr]();
        } else {
          testValue = this[attr];
        }
        if (testValue === value) {
          return this;
        }
      }
      for (i = 0; i < len; i++) {
        result = this._children[i].findOne(attr, value);
        if (result !== null) {
          return result;
        }
      }
    }
    return null;
  }, findByTag:function() {
    var tags = this.tags._processArguments(arguments);
    return this._findByTag(tags);
  }, _findByTag:function(tags) {
    var result = [];
    var i, len = this._children.length;
    var descendants;
    for (i = 0; i < len; i++) {
      if (this._children[i].tags._has(tags)) {
        result.push(this._children[i]);
      }
      descendants = this._children[i]._findByTag(tags);
      if (descendants.length) {
        result = result.concat(descendants);
      }
    }
    return result;
  }, findByName:function(name) {
    if (this.name === name) {
      return this;
    }
    for (var i = 0; i < this._children.length; i++) {
      var found = this._children[i].findByName(name);
      if (found !== null) {
        return found;
      }
    }
    return null;
  }, findByPath:function(path) {
    var parts = path.split("/");
    var currentParent = this;
    var result = null;
    for (var i = 0, imax = parts.length; i < imax && currentParent; i++) {
      var part = parts[i];
      result = null;
      var children = currentParent._children;
      for (var j = 0, jmax = children.length; j < jmax; j++) {
        if (children[j].name == part) {
          result = children[j];
          break;
        }
      }
      currentParent = result;
    }
    return result;
  }, getPath:function() {
    var parent = this._parent;
    if (parent) {
      var path = this.name;
      var format = "{0}/{1}";
      while (parent && parent._parent) {
        path = pc.string.format(format, parent.name, path);
        parent = parent._parent;
      }
      return path;
    }
    return "";
  }, getRoot:function() {
    var parent = this._parent;
    if (!parent) {
      return this;
    }
    while (parent._parent) {
      parent = parent._parent;
    }
    return parent;
  }, getParent:function() {
    return this._parent;
  }, isDescendantOf:function(node) {
    var parent = this._parent;
    while (parent) {
      if (parent === node) {
        return true;
      }
      parent = parent._parent;
    }
    return false;
  }, isAncestorOf:function(node) {
    return node.isDescendantOf(this);
  }, getChildren:function() {
    return this._children;
  }, getEulerAngles:function() {
    this.getWorldTransform().getEulerAngles(this.eulerAngles);
    return this.eulerAngles;
  }, getLocalEulerAngles:function() {
    this.localRotation.getEulerAngles(this.localEulerAngles);
    return this.localEulerAngles;
  }, getLocalPosition:function() {
    return this.localPosition;
  }, getLocalRotation:function() {
    return this.localRotation;
  }, getLocalScale:function() {
    return this.localScale;
  }, getLocalTransform:function() {
    if (this._dirtyLocal) {
      this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
      this._dirtyLocal = false;
    }
    return this.localTransform;
  }, getName:function() {
    return this.name;
  }, getPosition:function() {
    this.getWorldTransform().getTranslation(this.position);
    return this.position;
  }, getRotation:function() {
    this.rotation.setFromMat4(this.getWorldTransform());
    return this.rotation;
  }, getWorldTransform:function() {
    if (!this._dirtyLocal && !this._dirtyWorld) {
      return this.worldTransform;
    }
    if (this._parent) {
      this._parent.getWorldTransform();
    }
    this._sync();
    return this.worldTransform;
  }, reparent:function(parent, index) {
    var current = this._parent;
    if (current) {
      current.removeChild(this);
    }
    if (parent) {
      if (index >= 0) {
        parent.insertChild(this, index);
      } else {
        parent.addChild(this);
      }
    }
  }, setLocalEulerAngles:function(x, y, z) {
    if (x instanceof pc.Vec3) {
      this.localRotation.setFromEulerAngles(x.x, x.y, x.z);
    } else {
      this.localRotation.setFromEulerAngles(x, y, z);
    }
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }, setLocalPosition:function(x, y, z) {
    if (x instanceof pc.Vec3) {
      this.localPosition.copy(x);
    } else {
      this.localPosition.set(x, y, z);
    }
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }, setLocalRotation:function(x, y, z, w) {
    if (x instanceof pc.Quat) {
      this.localRotation.copy(x);
    } else {
      this.localRotation.set(x, y, z, w);
    }
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }, setLocalScale:function(x, y, z) {
    if (x instanceof pc.Vec3) {
      this.localScale.copy(x);
    } else {
      this.localScale.set(x, y, z);
    }
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }, setName:function(name) {
    this.name = name;
  }, _dirtifyLocal:function() {
    if (!this._dirtyLocal) {
      this._dirtyLocal = true;
      if (!this._dirtyWorld) {
        this._dirtifyWorld();
      }
    }
  }, _dirtifyWorld:function() {
    if (!this._dirtyWorld) {
      this._dirtyWorld = true;
      for (var i = 0; i < this._children.length; i++) {
        if (!this._children[i]._dirtyWorld) {
          this._children[i]._dirtifyWorld();
        }
      }
    }
    this._dirtyNormal = true;
    this._aabbVer++;
  }, setPosition:function() {
    var position = new pc.Vec3;
    var invParentWtm = new pc.Mat4;
    return function(x, y, z) {
      if (x instanceof pc.Vec3) {
        position.copy(x);
      } else {
        position.set(x, y, z);
      }
      if (this._parent === null) {
        this.localPosition.copy(position);
      } else {
        invParentWtm.copy(this._parent.getWorldTransform()).invert();
        invParentWtm.transformPoint(position, this.localPosition);
      }
      if (!this._dirtyLocal) {
        this._dirtifyLocal();
      }
    };
  }(), setRotation:function() {
    var rotation = new pc.Quat;
    var invParentRot = new pc.Quat;
    return function(x, y, z, w) {
      if (x instanceof pc.Quat) {
        rotation.copy(x);
      } else {
        rotation.set(x, y, z, w);
      }
      if (this._parent === null) {
        this.localRotation.copy(rotation);
      } else {
        var parentRot = this._parent.getRotation();
        invParentRot.copy(parentRot).invert();
        this.localRotation.copy(invParentRot).mul(rotation);
      }
      if (!this._dirtyLocal) {
        this._dirtifyLocal();
      }
    };
  }(), setEulerAngles:function() {
    var invParentRot = new pc.Quat;
    return function(x, y, z) {
      if (x instanceof pc.Vec3) {
        this.localRotation.setFromEulerAngles(x.x, x.y, x.z);
      } else {
        this.localRotation.setFromEulerAngles(x, y, z);
      }
      if (this._parent !== null) {
        var parentRot = this._parent.getRotation();
        invParentRot.copy(parentRot).invert();
        this.localRotation.mul2(invParentRot, this.localRotation);
      }
      if (!this._dirtyLocal) {
        this._dirtifyLocal();
      }
    };
  }(), addChild:function(node) {
    if (node._parent !== null) {
      throw new Error("GraphNode is already parented");
    }
    this._children.push(node);
    this._onInsertChild(node);
  }, addChildAndSaveTransform:function(node) {
    var wPos = node.getPosition();
    var wRot = node.getRotation();
    var current = node._parent;
    if (current) {
      current.removeChild(node);
    }
    if (this.tmpMat4 === undefined) {
      this.tmpMat4 = new pc.Mat4;
      this.tmpQuat = new pc.Quat;
    }
    node.setPosition(this.tmpMat4.copy(this.worldTransform).invert().transformPoint(wPos));
    node.setRotation(this.tmpQuat.copy(this.getRotation()).invert().mul(wRot));
    this._children.push(node);
    this._onInsertChild(node);
  }, insertChild:function(node, index) {
    if (node._parent !== null) {
      throw new Error("GraphNode is already parented");
    }
    this._children.splice(index, 0, node);
    this._onInsertChild(node);
  }, _onInsertChild:function(node) {
    node._parent = this;
    var enabledInHierarchy = node._enabled && this.enabled;
    if (node._enabledInHierarchy !== enabledInHierarchy) {
      node._enabledInHierarchy = enabledInHierarchy;
      node._notifyHierarchyStateChanged(node, enabledInHierarchy);
    }
    node._updateGraphDepth();
    node._dirtifyWorld();
    if (node.fire) {
      node.fire("insert", this);
    }
    if (this.fire) {
      this.fire("childinsert", node);
    }
  }, _updateGraphDepth:function() {
    if (this._parent) {
      this._graphDepth = this._parent._graphDepth + 1;
    } else {
      this._graphDepth = 0;
    }
    for (var i = 0, len = this._children.length; i < len; i++) {
      this._children[i]._updateGraphDepth();
    }
  }, removeChild:function(child) {
    var i;
    var length = this._children.length;
    for (i = 0; i < length; ++i) {
      if (this._children[i] === child) {
        this._children.splice(i, 1);
        child._parent = null;
        if (this.fire) {
          this.fire("childremove", child);
        }
        return;
      }
    }
  }, addLabel:function(label) {
    this._labels[label] = true;
  }, getLabels:function() {
    return Object.keys(this._labels);
  }, hasLabel:function(label) {
    return !!this._labels[label];
  }, removeLabel:function(label) {
    delete this._labels[label];
  }, findByLabel:function(label, results) {
    var i, length = this._children.length;
    results = results || [];
    if (this.hasLabel(label)) {
      results.push(this);
    }
    for (i = 0; i < length; ++i) {
      results = this._children[i].findByLabel(label, results);
    }
    return results;
  }, _sync:function() {
    if (this._dirtyLocal) {
      this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
      this._dirtyLocal = false;
    }
    if (this._dirtyWorld) {
      if (this._parent === null) {
        this.worldTransform.copy(this.localTransform);
      } else {
        if (this.scaleCompensation) {
          var parentWorldScale;
          var parent = this._parent;
          var scale = this.localScale;
          var parentToUseScaleFrom = parent;
          if (parentToUseScaleFrom) {
            while (parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation) {
              parentToUseScaleFrom = parentToUseScaleFrom._parent;
            }
            if (parentToUseScaleFrom) {
              parentToUseScaleFrom = parentToUseScaleFrom._parent;
              if (parentToUseScaleFrom) {
                parentWorldScale = parentToUseScaleFrom.worldTransform.getScale();
                scaleCompensateScale.mul2(parentWorldScale, this.localScale);
                scale = scaleCompensateScale;
              }
            }
          }
          scaleCompensateRot2.setFromMat4(parent.worldTransform);
          scaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);
          var tmatrix = parent.worldTransform;
          if (parent.scaleCompensation) {
            scaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());
            scaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos), scaleCompensateRot2, scaleCompensateScaleForParent);
            tmatrix = scaleCompensatePosTransform;
          }
          tmatrix.transformPoint(this.localPosition, scaleCompensatePos);
          this.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);
        } else {
          this.worldTransform.mul2(this._parent.worldTransform, this.localTransform);
        }
      }
      this._dirtyWorld = false;
    }
  }, syncHierarchy:function() {
    if (!this._enabled) {
      return;
    }
    if (this._dirtyLocal || this._dirtyWorld) {
      this._sync();
    }
    var children = this._children;
    for (var i = 0, len = children.length; i < len; i++) {
      children[i].syncHierarchy();
    }
  }, lookAt:function() {
    var matrix = new pc.Mat4;
    var target = new pc.Vec3;
    var up = new pc.Vec3;
    var rotation = new pc.Quat;
    return function(tx, ty, tz, ux, uy, uz) {
      if (tx instanceof pc.Vec3) {
        target.copy(tx);
        if (ty instanceof pc.Vec3) {
          up.copy(ty);
        } else {
          up.copy(pc.Vec3.UP);
        }
      } else {
        if (tz === undefined) {
          return;
        } else {
          target.set(tx, ty, tz);
          if (ux !== undefined) {
            up.set(ux, uy, uz);
          } else {
            up.copy(pc.Vec3.UP);
          }
        }
      }
      matrix.setLookAt(this.getPosition(), target, up);
      rotation.setFromMat4(matrix);
      this.setRotation(rotation);
    };
  }(), translate:function() {
    var translation = new pc.Vec3;
    return function(x, y, z) {
      if (x instanceof pc.Vec3) {
        translation.copy(x);
      } else {
        translation.set(x, y, z);
      }
      translation.add(this.getPosition());
      this.setPosition(translation);
    };
  }(), translateLocal:function() {
    var translation = new pc.Vec3;
    return function(x, y, z) {
      if (x instanceof pc.Vec3) {
        translation.copy(x);
      } else {
        translation.set(x, y, z);
      }
      this.localRotation.transformVector(translation, translation);
      this.localPosition.add(translation);
      if (!this._dirtyLocal) {
        this._dirtifyLocal();
      }
    };
  }(), rotate:function() {
    var quaternion = new pc.Quat;
    var invParentRot = new pc.Quat;
    return function(x, y, z) {
      if (x instanceof pc.Vec3) {
        quaternion.setFromEulerAngles(x.x, x.y, x.z);
      } else {
        quaternion.setFromEulerAngles(x, y, z);
      }
      if (this._parent === null) {
        this.localRotation.mul2(quaternion, this.localRotation);
      } else {
        var rot = this.getRotation();
        var parentRot = this._parent.getRotation();
        invParentRot.copy(parentRot).invert();
        quaternion.mul2(invParentRot, quaternion);
        this.localRotation.mul2(quaternion, rot);
      }
      if (!this._dirtyLocal) {
        this._dirtifyLocal();
      }
    };
  }(), rotateLocal:function() {
    var quaternion = new pc.Quat;
    return function(x, y, z) {
      if (x instanceof pc.Vec3) {
        quaternion.setFromEulerAngles(x.x, x.y, x.z);
      } else {
        quaternion.setFromEulerAngles(x, y, z);
      }
      this.localRotation.mul(quaternion);
      if (!this._dirtyLocal) {
        this._dirtifyLocal();
      }
    };
  }()});
  return {GraphNode:GraphNode};
}());
Object.assign(pc, function() {
  var _deviceCoord = new pc.Vec3;
  var _far = new pc.Vec3;
  var _farW = new pc.Vec3;
  var _invViewProjMat = new pc.Mat4;
  var Camera = function() {
    this._projection = pc.PROJECTION_PERSPECTIVE;
    this._nearClip = 0.1;
    this._farClip = 10000;
    this._shaderParams = new Float32Array(4);
    this._fov = 45;
    this._orthoHeight = 10;
    this._aspect = 16 / 9;
    this._aspectRatioMode = pc.ASPECT_AUTO;
    this._horizontalFov = false;
    this.frustumCulling = false;
    this.cullingMask = 4294967295;
    this._renderDepthRequests = 0;
    this._projMatDirty = true;
    this._projMat = new pc.Mat4;
    this._viewMatDirty = true;
    this._viewMat = new pc.Mat4;
    this._viewProjMatDirty = true;
    this._viewProjMat = new pc.Mat4;
    this.vrDisplay = null;
    this._rect = {x:0, y:0, width:1, height:1};
    this._scissorRect = {x:0, y:0, width:1, height:1};
    this.frustum = new pc.Frustum(this._projMat, this._viewMat);
    this.renderTarget = null;
    this._depthTarget = null;
    this._clearOptions = {color:[0.5, 0.5, 0.5, 1.0], depth:1.0, stencil:0, flags:pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH | pc.CLEARFLAG_STENCIL};
    this._node = null;
    this.calculateTransform = null;
    this.overrideCalculateTransform = false;
    this.calculateProjection = null;
    this.overrideCalculateProjection = false;
    this._cullFaces = true;
    this._flipFaces = false;
    this._component = null;
  };
  Object.assign(Camera.prototype, {clone:function() {
    var clone = new pc.Camera;
    clone.projection = this._projection;
    clone.nearClip = this._nearClip;
    clone.farClip = this._farClip;
    clone._shaderParams = this._shaderParams.slice();
    clone.fov = this._fov;
    clone.aspectRatio = this._aspect;
    clone._aspectRatioMode = this._aspectRatioMode;
    clone.renderTarget = this.renderTarget;
    clone.setClearOptions(this.getClearOptions());
    clone.frustumCulling = this.frustumCulling;
    clone.cullingMask = this.cullingMask;
    return clone;
  }, worldToScreen:function(worldCoord, cw, ch, screenCoord) {
    if (screenCoord === undefined) {
      screenCoord = new pc.Vec3;
    }
    if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {
      var projMat = this.getProjectionMatrix();
      var viewMat = this.getViewMatrix();
      this._viewProjMat.mul2(projMat, viewMat);
      this._viewProjMatDirty = false;
    }
    this._viewProjMat.transformPoint(worldCoord, screenCoord);
    var vpm = this._viewProjMat.data;
    var w = worldCoord.x * vpm[3] + worldCoord.y * vpm[7] + worldCoord.z * vpm[11] + 1 * vpm[15];
    screenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;
    screenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;
    return screenCoord;
  }, screenToWorld:function(x, y, z, cw, ch, worldCoord) {
    if (worldCoord === undefined) {
      worldCoord = new pc.Vec3;
    }
    if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {
      var projMat = this.getProjectionMatrix();
      var viewMat = this.getViewMatrix();
      this._viewProjMat.mul2(projMat, viewMat);
      this._viewProjMatDirty = false;
    }
    _invViewProjMat.copy(this._viewProjMat).invert();
    if (this._projection === pc.PROJECTION_PERSPECTIVE) {
      _far.set(x / cw * 2 - 1, (ch - y) / ch * 2 - 1, 1);
      _invViewProjMat.transformPoint(_far, _farW);
      var w = _far.x * _invViewProjMat.data[3] + _far.y * _invViewProjMat.data[7] + _far.z * _invViewProjMat.data[11] + _invViewProjMat.data[15];
      _farW.scale(1 / w);
      var alpha = z / this._farClip;
      worldCoord.lerp(this._node.getPosition(), _farW, alpha);
    } else {
      var range = this._farClip - this._nearClip;
      _deviceCoord.set(x / cw, (ch - y) / ch, z / range);
      _deviceCoord.scale(2);
      _deviceCoord.sub(pc.Vec3.ONE);
      _invViewProjMat.transformPoint(_deviceCoord, worldCoord);
    }
    return worldCoord;
  }, getClearOptions:function() {
    return this._clearOptions;
  }, getProjectionMatrix:function() {
    if (this._projMatDirty) {
      if (this._projection === pc.PROJECTION_PERSPECTIVE) {
        this._projMat.setPerspective(this._fov, this._aspect, this._nearClip, this._farClip, this._horizontalFov);
      } else {
        var y = this._orthoHeight;
        var x = y * this._aspect;
        this._projMat.setOrtho(-x, x, -y, y, this._nearClip, this._farClip);
      }
      var n = this._nearClip;
      var f = this._farClip;
      this._shaderParams[0] = 1 / f;
      this._shaderParams[1] = f;
      this._shaderParams[2] = (1 - f / n) / 2;
      this._shaderParams[3] = (1 + f / n) / 2;
      this._projMatDirty = false;
    }
    return this._projMat;
  }, getViewMatrix:function() {
    if (this._viewMatDirty) {
      var wtm = this._node.getWorldTransform();
      this._viewMat.copy(wtm).invert();
      this._viewMatDirty = false;
    }
    return this._viewMat;
  }, getRect:function() {
    return this._rect;
  }, setClearOptions:function(options) {
    this._clearOptions.color[0] = options.color[0];
    this._clearOptions.color[1] = options.color[1];
    this._clearOptions.color[2] = options.color[2];
    this._clearOptions.color[3] = options.color[3];
    this._clearOptions.depth = options.depth;
    this._clearOptions.stencil = options.stencil;
    this._clearOptions.flags = options.flags;
  }, setRect:function(x, y, width, height) {
    this._rect.x = x;
    this._rect.y = y;
    this._rect.width = width;
    this._rect.height = height;
  }, setScissorRect:function(x, y, width, height) {
    this._scissorRect.x = x;
    this._scissorRect.y = y;
    this._scissorRect.width = width;
    this._scissorRect.height = height;
  }, requestDepthMap:function() {
    this._renderDepthRequests++;
  }, releaseDepthMap:function() {
    this._renderDepthRequests--;
  }});
  Object.defineProperty(Camera.prototype, "aspectRatio", {get:function() {
    return this._aspect;
  }, set:function(v) {
    if (this._aspect !== v) {
      this._aspect = v;
      this._projMatDirty = true;
    }
  }});
  Object.defineProperty(Camera.prototype, "projection", {get:function() {
    return this._projection;
  }, set:function(v) {
    if (this._projection !== v) {
      this._projection = v;
      this._projMatDirty = true;
    }
  }});
  Object.defineProperty(Camera.prototype, "nearClip", {get:function() {
    return this._nearClip;
  }, set:function(v) {
    if (this._nearClip !== v) {
      this._nearClip = v;
      this._projMatDirty = true;
    }
  }});
  Object.defineProperty(Camera.prototype, "farClip", {get:function() {
    return this._farClip;
  }, set:function(v) {
    if (this._farClip !== v) {
      this._farClip = v;
      this._projMatDirty = true;
    }
  }});
  Object.defineProperty(Camera.prototype, "fov", {get:function() {
    return this._fov;
  }, set:function(v) {
    if (this._fov !== v) {
      this._fov = v;
      this._projMatDirty = true;
    }
  }});
  Object.defineProperty(Camera.prototype, "horizontalFov", {get:function() {
    return this._horizontalFov;
  }, set:function(v) {
    if (this._horizontalFov !== v) {
      this._horizontalFov = v;
      this._projMatDirty = true;
    }
  }});
  Object.defineProperty(Camera.prototype, "orthoHeight", {get:function() {
    return this._orthoHeight;
  }, set:function(v) {
    if (this._orthoHeight !== v) {
      this._orthoHeight = v;
      this._projMatDirty = true;
    }
  }});
  Object.defineProperty(Camera.prototype, "clearColor", {get:function() {
    return this._clearOptions.color;
  }, set:function(v) {
    this._clearOptions.color[0] = v[0];
    this._clearOptions.color[1] = v[1];
    this._clearOptions.color[2] = v[2];
    this._clearOptions.color[3] = v[3];
  }});
  Object.defineProperty(Camera.prototype, "clearDepth", {get:function() {
    return this._clearOptions.depth;
  }, set:function(v) {
    this._clearOptions.depth = v;
  }});
  Object.defineProperty(Camera.prototype, "clearStencil", {get:function() {
    return this._clearOptions.stencil;
  }, set:function(v) {
    this._clearOptions.stencil = v;
  }});
  Object.defineProperty(Camera.prototype, "clearFlags", {get:function() {
    return this._clearOptions.flags;
  }, set:function(v) {
    this._clearOptions.flags = v;
  }});
  return {Camera:Camera};
}());
Object.assign(pc, function() {
  var spotCenter = new pc.Vec3;
  var spotEndPoint = new pc.Vec3;
  var tmpVec = new pc.Vec3;
  var chanId = {r:0, g:1, b:2, a:3};
  var Light = function Light() {
    this._type = pc.LIGHTTYPE_DIRECTIONAL;
    this._color = new pc.Color(0.8, 0.8, 0.8);
    this._intensity = 1;
    this._castShadows = false;
    this._enabled = false;
    this._mask = 1;
    this.isStatic = false;
    this.key = 0;
    this.bakeDir = true;
    this.attenuationStart = 10;
    this.attenuationEnd = 10;
    this._falloffMode = 0;
    this._shadowType = pc.SHADOW_PCF3;
    this._vsmBlurSize = 11;
    this.vsmBlurMode = pc.BLUR_GAUSSIAN;
    this.vsmBias = 0.01 * 0.25;
    this._cookie = null;
    this.cookieIntensity = 1;
    this._cookieFalloff = true;
    this._cookieChannel = "rgb";
    this._cookieTransform = null;
    this._cookieTransformUniform = new Float32Array(4);
    this._cookieOffset = null;
    this._cookieOffsetUniform = new Float32Array(2);
    this._cookieTransformSet = false;
    this._cookieOffsetSet = false;
    this._innerConeAngle = 40;
    this._outerConeAngle = 45;
    this._finalColor = new Float32Array([0.8, 0.8, 0.8]);
    var c = Math.pow(this._finalColor[0], 2.2);
    this._linearFinalColor = new Float32Array([c, c, c]);
    this._position = new pc.Vec3(0, 0, 0);
    this._direction = new pc.Vec3(0, 0, 0);
    this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
    this._outerConeAngleCos = Math.cos(this._outerConeAngle * Math.PI / 180);
    this._shadowCamera = null;
    this._shadowMatrix = new pc.Mat4;
    this.shadowDistance = 40;
    this._shadowResolution = 1024;
    this.shadowBias = -0.0005;
    this._normalOffsetBias = 0.0;
    this.shadowUpdateMode = pc.SHADOWUPDATE_REALTIME;
    this._scene = null;
    this._node = null;
    this._rendererParams = [];
    this._isVsm = false;
    this._isPcf = true;
    this._cacheShadowMap = false;
    this._isCachedShadowMap = false;
    this._visibleLength = [0];
    this._visibleList = [[]];
    this._visibleCameraSettings = [];
  };
  Object.assign(Light.prototype, {destroy:function() {
    this._destroyShadowMap();
  }, clone:function() {
    var clone = new pc.Light;
    clone.type = this._type;
    clone.setColor(this._color);
    clone.intensity = this._intensity;
    clone.castShadows = this.castShadows;
    clone.enabled = this._enabled;
    clone.attenuationStart = this.attenuationStart;
    clone.attenuationEnd = this.attenuationEnd;
    clone.falloffMode = this._falloffMode;
    clone.shadowType = this._shadowType;
    clone.vsmBlurSize = this._vsmBlurSize;
    clone.vsmBlurMode = this.vsmBlurMode;
    clone.vsmBias = this.vsmBias;
    clone.shadowUpdateMode = this.shadowUpdateMode;
    clone.mask = this._mask;
    clone.innerConeAngle = this._innerConeAngle;
    clone.outerConeAngle = this._outerConeAngle;
    clone.shadowBias = this.shadowBias;
    clone.normalOffsetBias = this._normalOffsetBias;
    clone.shadowResolution = this._shadowResolution;
    clone.shadowDistance = this.shadowDistance;
    return clone;
  }, getColor:function() {
    return this._color;
  }, getBoundingSphere:function(sphere) {
    if (this._type === pc.LIGHTTYPE_SPOT) {
      var range = this.attenuationEnd;
      var angle = this._outerConeAngle;
      var f = Math.cos(angle * pc.math.DEG_TO_RAD);
      var node = this._node;
      spotCenter.copy(node.up);
      spotCenter.scale(-range * 0.5 * f);
      spotCenter.add(node.getPosition());
      sphere.center = spotCenter;
      spotEndPoint.copy(node.up);
      spotEndPoint.scale(-range);
      tmpVec.copy(node.right);
      tmpVec.scale(Math.sin(angle * pc.math.DEG_TO_RAD) * range);
      spotEndPoint.add(tmpVec);
      sphere.radius = spotEndPoint.length() * 0.5;
    } else {
      if (this._type === pc.LIGHTTYPE_POINT) {
        sphere.center = this._node.getPosition();
        sphere.radius = this.attenuationEnd;
      }
    }
  }, getBoundingBox:function(box) {
    if (this._type === pc.LIGHTTYPE_SPOT) {
      var range = this.attenuationEnd;
      var angle = this._outerConeAngle;
      var node = this._node;
      var scl = Math.abs(Math.sin(angle * pc.math.DEG_TO_RAD) * range);
      box.center.set(0, -range * 0.5, 0);
      box.halfExtents.set(scl, range * 0.5, scl);
      box.setFromTransformedAabb(box, node.getWorldTransform());
    } else {
      if (this._type === pc.LIGHTTYPE_POINT) {
        box.center.copy(this._node.getPosition());
        box.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);
      }
    }
  }, _updateFinalColor:function() {
    var color = this._color;
    var r = color.r;
    var g = color.g;
    var b = color.b;
    var i = this._intensity;
    var finalColor = this._finalColor;
    var linearFinalColor = this._linearFinalColor;
    finalColor[0] = r * i;
    finalColor[1] = g * i;
    finalColor[2] = b * i;
    if (i >= 1) {
      linearFinalColor[0] = Math.pow(r, 2.2) * i;
      linearFinalColor[1] = Math.pow(g, 2.2) * i;
      linearFinalColor[2] = Math.pow(b, 2.2) * i;
    } else {
      linearFinalColor[0] = Math.pow(finalColor[0], 2.2);
      linearFinalColor[1] = Math.pow(finalColor[1], 2.2);
      linearFinalColor[2] = Math.pow(finalColor[2], 2.2);
    }
  }, setColor:function() {
    var r, g, b;
    if (arguments.length === 1) {
      r = arguments[0].r;
      g = arguments[0].g;
      b = arguments[0].b;
    } else {
      if (arguments.length === 3) {
        r = arguments[0];
        g = arguments[1];
        b = arguments[2];
      }
    }
    this._color.set(r, g, b);
    this._updateFinalColor();
  }, _destroyShadowMap:function() {
    if (this._shadowCamera) {
      if (!this._isCachedShadowMap) {
        var rt = this._shadowCamera.renderTarget;
        var i;
        if (rt) {
          if (rt.length) {
            for (i = 0; i < rt.length; i++) {
              if (rt[i].colorBuffer) {
                rt[i].colorBuffer.destroy();
              }
              rt[i].destroy();
            }
          } else {
            if (rt.colorBuffer) {
              rt.colorBuffer.destroy();
            }
            if (rt.depthBuffer) {
              rt.depthBuffer.destroy();
            }
            rt.destroy();
          }
        }
      }
      this._shadowCamera.renderTarget = null;
      this._shadowCamera = null;
      this._shadowCubeMap = null;
      if (this.shadowUpdateMode === pc.SHADOWUPDATE_NONE) {
        this.shadowUpdateMode = pc.SHADOWUPDATE_THISFRAME;
      }
    }
  }, updateShadow:function() {
    if (this.shadowUpdateMode !== pc.SHADOWUPDATE_REALTIME) {
      this.shadowUpdateMode = pc.SHADOWUPDATE_THISFRAME;
    }
  }, updateKey:function() {
    var key = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0.0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | chanId[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12;
    if (this._cookieChannel.length === 3) {
      key |= chanId[this._cookieChannel.charAt(1)] << 16;
      key |= chanId[this._cookieChannel.charAt(2)] << 14;
    }
    if (key !== this.key && this._scene !== null) {
      this._scene.layers._dirtyLights = true;
    }
    this.key = key;
  }});
  Object.defineProperty(Light.prototype, "enabled", {get:function() {
    return this._type;
  }, set:function(value) {
    if (this._type === value) {
      return;
    }
    this._enabled = value;
  }});
  Object.defineProperty(Light.prototype, "type", {get:function() {
    return this._type;
  }, set:function(value) {
    if (this._type === value) {
      return;
    }
    this._type = value;
    this._destroyShadowMap();
    this.updateKey();
    var stype = this._shadowType;
    this._shadowType = null;
    this.shadowType = stype;
  }});
  Object.defineProperty(Light.prototype, "mask", {get:function() {
    return this._mask;
  }, set:function(value) {
    if (this._mask === value) {
      return;
    }
    this._mask = value;
  }});
  Object.defineProperty(Light.prototype, "shadowType", {get:function() {
    return this._shadowType;
  }, set:function(value) {
    if (this._shadowType === value) {
      return;
    }
    var device = pc.Application.getApplication().graphicsDevice;
    if (this._type === pc.LIGHTTYPE_POINT) {
      value = pc.SHADOW_PCF3;
    }
    if (value === pc.SHADOW_PCF5 && !device.webgl2) {
      value = pc.SHADOW_PCF3;
    }
    if (value === pc.SHADOW_VSM32 && !device.textureFloatRenderable) {
      value = pc.SHADOW_VSM16;
    }
    if (value === pc.SHADOW_VSM16 && !device.textureHalfFloatRenderable) {
      value = pc.SHADOW_VSM8;
    }
    this._isVsm = value >= pc.SHADOW_VSM8 && value <= pc.SHADOW_VSM32;
    this._isPcf = value === pc.SHADOW_PCF5 || value === pc.SHADOW_PCF3;
    this._shadowType = value;
    this._destroyShadowMap();
    this.updateKey();
  }});
  Object.defineProperty(Light.prototype, "castShadows", {get:function() {
    return this._castShadows && this._mask !== pc.MASK_LIGHTMAP && this._mask !== 0;
  }, set:function(value) {
    if (this._castShadows === value) {
      return;
    }
    this._castShadows = value;
    this.updateKey();
  }});
  Object.defineProperty(Light.prototype, "shadowResolution", {get:function() {
    return this._shadowResolution;
  }, set:function(value) {
    if (this._shadowResolution === value) {
      return;
    }
    var device = pc.Application.getApplication().graphicsDevice;
    if (this._type === pc.LIGHTTYPE_POINT) {
      value = Math.min(value, device.maxCubeMapSize);
    } else {
      value = Math.min(value, device.maxTextureSize);
    }
    this._shadowResolution = value;
  }});
  Object.defineProperty(Light.prototype, "vsmBlurSize", {get:function() {
    return this._vsmBlurSize;
  }, set:function(value) {
    if (this._vsmBlurSize === value) {
      return;
    }
    if (value % 2 === 0) {
      value++;
    }
    this._vsmBlurSize = value;
  }});
  Object.defineProperty(Light.prototype, "normalOffsetBias", {get:function() {
    return this._normalOffsetBias;
  }, set:function(value) {
    if (this._normalOffsetBias === value) {
      return;
    }
    if (!this._normalOffsetBias && value || this._normalOffsetBias && !value) {
      this.updateKey();
    }
    this._normalOffsetBias = value;
  }});
  Object.defineProperty(Light.prototype, "falloffMode", {get:function() {
    return this._falloffMode;
  }, set:function(value) {
    if (this._falloffMode === value) {
      return;
    }
    this._falloffMode = value;
    this.updateKey();
  }});
  Object.defineProperty(Light.prototype, "innerConeAngle", {get:function() {
    return this._innerConeAngle;
  }, set:function(value) {
    if (this._innerConeAngle === value) {
      return;
    }
    this._innerConeAngle = value;
    this._innerConeAngleCos = Math.cos(value * Math.PI / 180);
  }});
  Object.defineProperty(Light.prototype, "outerConeAngle", {get:function() {
    return this._outerConeAngle;
  }, set:function(value) {
    if (this._outerConeAngle === value) {
      return;
    }
    this._outerConeAngle = value;
    this._outerConeAngleCos = Math.cos(value * Math.PI / 180);
  }});
  Object.defineProperty(Light.prototype, "intensity", {get:function() {
    return this._intensity;
  }, set:function(value) {
    if (this._intensity !== value) {
      this._intensity = value;
      this._updateFinalColor();
    }
  }});
  Object.defineProperty(Light.prototype, "cookie", {get:function() {
    return this._cookie;
  }, set:function(value) {
    if (this._cookie === value) {
      return;
    }
    this._cookie = value;
    this.updateKey();
  }});
  Object.defineProperty(Light.prototype, "cookieFalloff", {get:function() {
    return this._cookieFalloff;
  }, set:function(value) {
    if (this._cookieFalloff === value) {
      return;
    }
    this._cookieFalloff = value;
    this.updateKey();
  }});
  Object.defineProperty(Light.prototype, "cookieChannel", {get:function() {
    return this._cookieChannel;
  }, set:function(value) {
    if (this._cookieChannel === value) {
      return;
    }
    if (value.length < 3) {
      var chr = value.charAt(value.length - 1);
      var addLen = 3 - value.length;
      for (var i = 0; i < addLen; i++) {
        value += chr;
      }
    }
    this._cookieChannel = value;
    this.updateKey();
  }});
  Object.defineProperty(Light.prototype, "cookieTransform", {get:function() {
    return this._cookieTransform;
  }, set:function(value) {
    if (this._cookieTransform === value) {
      return;
    }
    this._cookieTransform = value;
    this._cookieTransformSet = !!value;
    if (value && !this._cookieOffset) {
      this.cookieOffset = new pc.Vec2;
      this._cookieOffsetSet = false;
    }
    this.updateKey();
  }});
  Object.defineProperty(Light.prototype, "cookieOffset", {get:function() {
    return this._cookieOffset;
  }, set:function(value) {
    if (this._cookieOffset === value) {
      return;
    }
    var xformNew = !!(this._cookieTransformSet || value);
    if (xformNew && !value && this._cookieOffset) {
      this._cookieOffset.set(0, 0);
    } else {
      this._cookieOffset = value;
    }
    this._cookieOffsetSet = !!value;
    if (value && !this._cookieTransform) {
      this.cookieTransform = new pc.Vec4(1, 1, 0, 0);
      this._cookieTransformSet = false;
    }
    this.updateKey();
  }});
  return {Light:Light};
}());
Object.assign(pc, function() {
  var id = 0;
  var Material = function Material() {
    this.name = "Untitled";
    this.id = id++;
    this._shader = null;
    this.variants = {};
    this.parameters = {};
    this.alphaTest = 0;
    this.alphaToCoverage = false;
    this.blend = false;
    this.blendSrc = pc.BLENDMODE_ONE;
    this.blendDst = pc.BLENDMODE_ZERO;
    this.blendEquation = pc.BLENDEQUATION_ADD;
    this.separateAlphaBlend = false;
    this.blendSrcAlpha = pc.BLENDMODE_ONE;
    this.blendDstAlpha = pc.BLENDMODE_ZERO;
    this.blendAlphaEquation = pc.BLENDEQUATION_ADD;
    this.cull = pc.CULLFACE_BACK;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilFront = null;
    this.stencilBack = null;
    this.depthBias = 0;
    this.slopeDepthBias = 0;
    this.redWrite = true;
    this.greenWrite = true;
    this.blueWrite = true;
    this.alphaWrite = true;
    this.meshInstances = [];
    this._shaderVersion = 0;
    this._scene = null;
    this._dirtyBlend = false;
    this.dirty = true;
  };
  Object.defineProperty(Material.prototype, "shader", {get:function() {
    return this._shader;
  }, set:function(shader) {
    this._shader = shader;
  }});
  Object.defineProperty(Material.prototype, "blendType", {get:function() {
    if (!this.blend && this.blendSrc === pc.BLENDMODE_ONE && this.blendDst === pc.BLENDMODE_ZERO && this.blendEquation === pc.BLENDEQUATION_ADD) {
      return pc.BLEND_NONE;
    } else {
      if (this.blend && this.blendSrc === pc.BLENDMODE_SRC_ALPHA && this.blendDst === pc.BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === pc.BLENDEQUATION_ADD) {
        return pc.BLEND_NORMAL;
      } else {
        if (this.blend && this.blendSrc === pc.BLENDMODE_ONE && this.blendDst === pc.BLENDMODE_ONE && this.blendEquation === pc.BLENDEQUATION_ADD) {
          return pc.BLEND_ADDITIVE;
        } else {
          if (this.blend && this.blendSrc === pc.BLENDMODE_SRC_ALPHA && this.blendDst === pc.BLENDMODE_ONE && this.blendEquation === pc.BLENDEQUATION_ADD) {
            return pc.BLEND_ADDITIVEALPHA;
          } else {
            if (this.blend && this.blendSrc === pc.BLENDMODE_DST_COLOR && this.blendDst === pc.BLENDMODE_SRC_COLOR && this.blendEquation === pc.BLENDEQUATION_ADD) {
              return pc.BLEND_MULTIPLICATIVE2X;
            } else {
              if (this.blend && this.blendSrc === pc.BLENDMODE_ONE_MINUS_DST_COLOR && this.blendDst === pc.BLENDMODE_ONE && this.blendEquation === pc.BLENDEQUATION_ADD) {
                return pc.BLEND_SCREEN;
              } else {
                if (this.blend && this.blendSrc === pc.BLENDMODE_ONE && this.blendDst === pc.BLENDMODE_ONE && this.blendEquation === pc.BLENDEQUATION_MIN) {
                  return pc.BLEND_MIN;
                } else {
                  if (this.blend && this.blendSrc === pc.BLENDMODE_ONE && this.blendDst === pc.BLENDMODE_ONE && this.blendEquation === pc.BLENDEQUATION_MAX) {
                    return pc.BLEND_MAX;
                  } else {
                    if (this.blend && this.blendSrc === pc.BLENDMODE_DST_COLOR && this.blendDst === pc.BLENDMODE_ZERO && this.blendEquation === pc.BLENDEQUATION_ADD) {
                      return pc.BLEND_MULTIPLICATIVE;
                    } else {
                      if (this.blend && this.blendSrc === pc.BLENDMODE_ONE && this.blendDst === pc.BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === pc.BLENDEQUATION_ADD) {
                        return pc.BLEND_PREMULTIPLIED;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return pc.BLEND_NORMAL;
  }, set:function(type) {
    var prevBlend = this.blend !== pc.BLEND_NONE;
    switch(type) {
      case pc.BLEND_NONE:
        this.blend = false;
        this.blendSrc = pc.BLENDMODE_ONE;
        this.blendDst = pc.BLENDMODE_ZERO;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_NORMAL:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_SRC_ALPHA;
        this.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_PREMULTIPLIED:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_ONE;
        this.blendDst = pc.BLENDMODE_ONE_MINUS_SRC_ALPHA;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_ADDITIVE:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_ONE;
        this.blendDst = pc.BLENDMODE_ONE;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_ADDITIVEALPHA:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_SRC_ALPHA;
        this.blendDst = pc.BLENDMODE_ONE;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_MULTIPLICATIVE2X:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_DST_COLOR;
        this.blendDst = pc.BLENDMODE_SRC_COLOR;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_SCREEN:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_ONE_MINUS_DST_COLOR;
        this.blendDst = pc.BLENDMODE_ONE;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_MULTIPLICATIVE:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_DST_COLOR;
        this.blendDst = pc.BLENDMODE_ZERO;
        this.blendEquation = pc.BLENDEQUATION_ADD;
        break;
      case pc.BLEND_MIN:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_ONE;
        this.blendDst = pc.BLENDMODE_ONE;
        this.blendEquation = pc.BLENDEQUATION_MIN;
        break;
      case pc.BLEND_MAX:
        this.blend = true;
        this.blendSrc = pc.BLENDMODE_ONE;
        this.blendDst = pc.BLENDMODE_ONE;
        this.blendEquation = pc.BLENDEQUATION_MAX;
        break;
    }
    if (prevBlend !== (this.blend !== pc.BLEND_NONE)) {
      if (this._scene) {
        this._scene.layers._dirtyBlend = true;
      } else {
        this._dirtyBlend = true;
      }
    }
    this._updateMeshInstanceKeys();
  }});
  Material.prototype._cloneInternal = function(clone) {
    clone.name = this.name;
    clone.shader = this.shader;
    clone.alphaTest = this.alphaTest;
    clone.alphaToCoverage = this.alphaToCoverage;
    clone.blend = this.blend;
    clone.blendSrc = this.blendSrc;
    clone.blendDst = this.blendDst;
    clone.blendEquation = this.blendEquation;
    clone.separateAlphaBlend = this.separateAlphaBlend;
    clone.blendSrcAlpha = this.blendSrcAlpha;
    clone.blendDstAlpha = this.blendDstAlpha;
    clone.blendAlphaEquation = this.blendAlphaEquation;
    clone.cull = this.cull;
    clone.depthTest = this.depthTest;
    clone.depthWrite = this.depthWrite;
    clone.depthBias = this.depthBias;
    clone.slopeDepthBias = this.slopeDepthBias;
    if (this.stencilFront) {
      clone.stencilFront = this.stencilFront.clone();
    }
    if (this.stencilBack) {
      if (this.stencilFront === this.stencilBack) {
        clone.stencilBack = clone.stencilFront;
      } else {
        clone.stencilBack = this.stencilBack.clone();
      }
    }
    clone.redWrite = this.redWrite;
    clone.greenWrite = this.greenWrite;
    clone.blueWrite = this.blueWrite;
    clone.alphaWrite = this.alphaWrite;
  };
  Material.prototype.clone = function() {
    var clone = new pc.Material;
    this._cloneInternal(clone);
    return clone;
  };
  Material.prototype._updateMeshInstanceKeys = function() {
    var i, meshInstances = this.meshInstances;
    for (i = 0; i < meshInstances.length; i++) {
      meshInstances[i].updateKey();
    }
  };
  Material.prototype.updateUniforms = function() {
  };
  Material.prototype.updateShader = function(device, scene, objDefs) {
  };
  Material.prototype.update = function() {
    this.dirty = true;
  };
  Material.prototype.clearParameters = function() {
    this.parameters = {};
  };
  Material.prototype.getParameters = function() {
    return this.parameters;
  };
  Material.prototype.clearVariants = function() {
    var meshInstance;
    this.variants = {};
    var j;
    for (var i = 0; i < this.meshInstances.length; i++) {
      meshInstance = this.meshInstances[i];
      for (j = 0; j < meshInstance._shader.length; j++) {
        meshInstance._shader[j] = null;
      }
    }
  };
  Material.prototype.getParameter = function(name) {
    return this.parameters[name];
  };
  Material.prototype.setParameter = function(name, data, passFlags) {
    if (passFlags === undefined) {
      passFlags = -524285;
    }
    if (data === undefined && typeof name === "object") {
      var uniformObject = name;
      if (uniformObject.length) {
        for (var i = 0; i < uniformObject.length; i++) {
          this.setParameter(uniformObject[i]);
        }
        return;
      }
      name = uniformObject.name;
      data = uniformObject.value;
    }
    var param = this.parameters[name];
    if (param) {
      param.data = data;
      param.passFlags = passFlags;
    } else {
      this.parameters[name] = {scopeId:null, data:data, passFlags:passFlags};
    }
  };
  Material.prototype.deleteParameter = function(name) {
    if (this.parameters[name]) {
      delete this.parameters[name];
    }
  };
  Material.prototype.setParameters = function() {
    for (var paramName in this.parameters) {
      var parameter = this.parameters[paramName];
      parameter.scopeId.setValue(parameter.data);
    }
  };
  Material.prototype.destroy = function() {
    this.variants = {};
    this.shader = null;
    var meshInstance, j;
    for (var i = 0; i < this.meshInstances.length; i++) {
      meshInstance = this.meshInstances[i];
      for (j = 0; j < meshInstance._shader.length; j++) {
        meshInstance._shader[j] = null;
      }
      meshInstance._material = null;
      var defaultMaterial = pc.getDefaultMaterial();
      if (this !== defaultMaterial) {
        meshInstance.material = defaultMaterial;
      }
    }
  };
  return {Material:Material};
}());
Object.assign(pc, function() {
  var BasicMaterial = function() {
    pc.Material.call(this);
    this.color = new pc.Color(1, 1, 1, 1);
    this.colorUniform = new Float32Array(4);
    this.colorMap = null;
    this.vertexColors = false;
  };
  BasicMaterial.prototype = Object.create(pc.Material.prototype);
  BasicMaterial.prototype.constructor = BasicMaterial;
  Object.assign(BasicMaterial.prototype, {clone:function() {
    var clone = new pc.BasicMaterial;
    pc.Material.prototype._cloneInternal.call(this, clone);
    clone.color.copy(this.color);
    clone.colorMap = this.colorMap;
    clone.vertexColors = this.vertexColors;
    return clone;
  }, updateUniforms:function() {
    this.clearParameters();
    this.colorUniform[0] = this.color.r;
    this.colorUniform[1] = this.color.g;
    this.colorUniform[2] = this.color.b;
    this.colorUniform[3] = this.color.a;
    this.setParameter("uColor", this.colorUniform);
    if (this.colorMap) {
      this.setParameter("texture_diffuseMap", this.colorMap);
    }
  }, updateShader:function(device, scene, objDefs, staticLightList, pass, sortedLights) {
    var options = {skin:!!this.meshInstances[0].skinInstance, vertexColors:this.vertexColors, diffuseMap:this.colorMap, pass:pass};
    var library = device.getProgramLibrary();
    this.shader = library.getProgram("basic", options);
  }});
  return {BasicMaterial:BasicMaterial};
}());
Object.assign(pc, function() {
  var DepthMaterial = function() {
    pc.Material.call(this);
  };
  DepthMaterial.prototype = Object.create(pc.Material.prototype);
  DepthMaterial.prototype.constructor = DepthMaterial;
  Object.assign(DepthMaterial.prototype, {clone:function() {
    var clone = new pc.DepthMaterial;
    pc.Material.prototype._cloneInternal.call(this, clone);
    return clone;
  }, updateShader:function(device) {
    var options = {skin:!!this.meshInstances[0].skinInstance};
    var library = device.getProgramLibrary();
    this.shader = library.getProgram("depth", options);
  }});
  return {DepthMaterial:DepthMaterial};
}());
Object.assign(pc, function() {
  var StandardMaterial = function() {
    pc.Material.call(this);
    this._assetReferences = {};
    this._validator = null;
    this.shaderOptBuilder = new pc.StandardMaterialOptionsBuilder;
    this.reset();
  };
  StandardMaterial.prototype = Object.create(pc.Material.prototype);
  StandardMaterial.prototype.constructor = StandardMaterial;
  var _propsSerial = [];
  var _propsSerialDefaultVal = [];
  var _propsInternalNull = [];
  var _propsInternalVec3 = [];
  var _prop2Uniform = {};
  var _defineTex2D = function(obj, name, uv, channels, defChannel) {
    var privMap = "_" + name + "Map";
    var privMapTiling = privMap + "Tiling";
    var privMapOffset = privMap + "Offset";
    var mapTransform = privMap.substring(1) + "Transform";
    var mapTransformUniform = mapTransform + "Uniform";
    var privMapUv = privMap + "Uv";
    var privMapChannel = privMap + "Channel";
    var privMapVertexColor = "_" + name + "VertexColor";
    var privMapVertexColorChannel = "_" + name + "VertexColorChannel";
    obj[privMap] = null;
    obj[privMapTiling] = new pc.Vec2(1, 1);
    obj[privMapOffset] = new pc.Vec2(0, 0);
    obj[mapTransform] = null;
    obj[mapTransformUniform] = null;
    obj[privMapUv] = uv;
    if (channels > 0) {
      var channel = defChannel ? defChannel : channels > 1 ? "rgb" : "g";
      obj[privMapChannel] = channel;
      obj[privMapVertexColorChannel] = channel;
    }
    obj[privMapVertexColor] = false;
    if (!pc._matTex2D) {
      pc._matTex2D = [];
    }
    pc._matTex2D[name] = channels;
    Object.defineProperty(StandardMaterial.prototype, privMap.substring(1), {get:function() {
      return this[privMap];
    }, set:function(value) {
      var oldVal = this[privMap];
      if (!!oldVal ^ !!value) {
        this.dirtyShader = true;
      }
      if (oldVal && value) {
        if (oldVal.rgbm !== value.rgbm || oldVal.fixCubemapSeams !== value.fixCubemapSeams || oldVal.format !== value.format) {
          this.dirtyShader = true;
        }
      }
      this[privMap] = value;
    }});
    var mapTiling = privMapTiling.substring(1);
    var mapOffset = privMapOffset.substring(1);
    Object.defineProperty(StandardMaterial.prototype, mapTiling, {get:function() {
      return this[privMapTiling];
    }, set:function(value) {
      this.dirtyShader = true;
      this[privMapTiling] = value;
    }});
    _prop2Uniform[mapTiling] = function(mat, val, changeMat) {
      var tform = mat._updateMapTransform(changeMat ? mat[mapTransform] : null, val, mat[privMapOffset]);
      return {name:"texture_" + mapTransform, value:tform.data};
    };
    Object.defineProperty(StandardMaterial.prototype, mapOffset, {get:function() {
      return this[privMapOffset];
    }, set:function(value) {
      this.dirtyShader = true;
      this[privMapOffset] = value;
    }});
    _prop2Uniform[mapOffset] = function(mat, val, changeMat) {
      var tform = mat._updateMapTransform(changeMat ? mat[mapTransform] : null, mat[privMapTiling], val);
      return {name:"texture_" + mapTransform, value:tform.data};
    };
    Object.defineProperty(StandardMaterial.prototype, privMapUv.substring(1), {get:function() {
      return this[privMapUv];
    }, set:function(value) {
      if (this[privMapUv] !== value) {
        this.dirtyShader = true;
      }
      this[privMapUv] = value;
    }});
    Object.defineProperty(StandardMaterial.prototype, privMapChannel.substring(1), {get:function() {
      return this[privMapChannel];
    }, set:function(value) {
      if (this[privMapChannel] !== value) {
        this.dirtyShader = true;
      }
      this[privMapChannel] = value;
    }});
    Object.defineProperty(StandardMaterial.prototype, privMapVertexColor.substring(1), {get:function() {
      return this[privMapVertexColor];
    }, set:function(value) {
      this.dirtyShader = true;
      this[privMapVertexColor] = value;
    }});
    Object.defineProperty(StandardMaterial.prototype, privMapVertexColorChannel.substring(1), {get:function() {
      return this[privMapVertexColorChannel];
    }, set:function(value) {
      if (this[privMapVertexColorChannel] !== value) {
        this.dirtyShader = true;
      }
      this[privMapVertexColorChannel] = value;
    }});
    _propsSerial.push(privMap.substring(1));
    _propsSerial.push(privMapTiling.substring(1));
    _propsSerial.push(privMapOffset.substring(1));
    _propsSerial.push(privMapUv.substring(1));
    _propsSerial.push(privMapChannel.substring(1));
    _propsSerial.push(privMapVertexColor.substring(1));
    _propsSerial.push(privMapVertexColorChannel.substring(1));
    _propsInternalNull.push(mapTransform);
  };
  var _propsColor = [];
  var _defineColor = function(obj, name, defaultValue, hasMultiplier) {
    var priv = "_" + name;
    var uform = name + "Uniform";
    var mult = name + "Intensity";
    var pmult = "_" + mult;
    obj[priv] = defaultValue;
    obj[uform] = new Float32Array(3);
    Object.defineProperty(StandardMaterial.prototype, name, {get:function() {
      this.dirtyColor = true;
      this.dirtyShader = true;
      return this[priv];
    }, set:function(newValue) {
      var oldValue = this[priv];
      var wasRound = oldValue.r === 0 && oldValue.g === 0 && oldValue.b === 0 || oldValue.r === 1 && oldValue.g === 1 && oldValue.b === 1;
      var isRound = newValue.r === 0 && newValue.g === 0 && newValue.b === 0 || newValue.r === 1 && newValue.g === 1 && newValue.b === 1;
      if (wasRound ^ isRound) {
        this.dirtyShader = true;
      }
      this.dirtyColor = true;
      this[priv] = newValue;
    }});
    _propsSerial.push(name);
    _propsInternalVec3.push(uform);
    _propsColor.push(name);
    _prop2Uniform[name] = function(mat, val, changeMat) {
      var arr = changeMat ? mat[uform] : new Float32Array(3);
      var gammaCorrection = false;
      if (mat.useGammaTonemap) {
        var scene = mat._scene || pc.Application.getApplication().scene;
        gammaCorrection = scene.gammaCorrection;
      }
      for (var c = 0; c < 3; c++) {
        if (gammaCorrection) {
          arr[c] = Math.pow(val.data[c], 2.2);
        } else {
          arr[c] = val.data[c];
        }
        if (hasMultiplier) {
          arr[c] *= mat[pmult];
        }
      }
      return {name:"material_" + name, value:arr};
    };
    if (hasMultiplier) {
      obj[pmult] = 1;
      Object.defineProperty(StandardMaterial.prototype, mult, {get:function() {
        return this[pmult];
      }, set:function(newValue) {
        var oldValue = this[pmult];
        var wasRound = oldValue === 0 || oldValue === 1;
        var isRound = newValue === 0 || newValue === 1;
        if (wasRound ^ isRound) {
          this.dirtyShader = true;
        }
        this.dirtyColor = true;
        this[pmult] = newValue;
      }});
      _propsSerial.push(mult);
      _prop2Uniform[mult] = function(mat, val, changeMat) {
        var arr = changeMat ? mat[uform] : new Float32Array(3);
        var gammaCorrection = false;
        if (mat.useGammaTonemap) {
          var scene = mat._scene || pc.Application.getApplication().scene;
          gammaCorrection = scene.gammaCorrection;
        }
        for (var c = 0; c < 3; c++) {
          if (gammaCorrection) {
            arr[c] = Math.pow(mat[priv].data[c], 2.2);
          } else {
            arr[c] = mat[priv].data[c];
          }
          arr[c] *= mat[pmult];
        }
        return {name:"material_" + name, value:arr};
      };
    }
  };
  var _defineFloat = function(obj, name, defaultValue, func) {
    var priv = "_" + name;
    obj[priv] = defaultValue;
    Object.defineProperty(StandardMaterial.prototype, name, {get:function() {
      return this[priv];
    }, set:function(newValue) {
      var oldValue = this[priv];
      if (oldValue === newValue) {
        return;
      }
      this[priv] = newValue;
      var wasRound = oldValue === 0 || oldValue === 1;
      var isRound = newValue === 0 || newValue === 1;
      if (wasRound || isRound) {
        this.dirtyShader = true;
      }
    }});
    _propsSerial.push(name);
    _prop2Uniform[name] = func !== undefined ? func : function(mat, val, changeMat) {
      return {name:"material_" + name, value:val};
    };
  };
  var _defineObject = function(obj, name, func) {
    var priv = "_" + name;
    obj[priv] = null;
    Object.defineProperty(StandardMaterial.prototype, name, {get:function() {
      return this[priv];
    }, set:function(value) {
      var oldVal = this[priv];
      if (!!oldVal ^ !!value) {
        this.dirtyShader = true;
      }
      this[priv] = value;
    }});
    _propsSerial.push(name);
    _prop2Uniform[name] = func;
  };
  var _defineAlias = function(obj, newName, oldName) {
    Object.defineProperty(StandardMaterial.prototype, oldName, {get:function() {
      return this[newName];
    }, set:function(value) {
      this[newName] = value;
    }});
  };
  var _defineChunks = function(obj) {
    Object.defineProperty(StandardMaterial.prototype, "chunks", {get:function() {
      this.dirtyShader = true;
      return this._chunks;
    }, set:function(value) {
      this.dirtyShader = true;
      this._chunks = value;
    }});
    _propsSerial.push("chunks");
  };
  var _defineFlag = function(obj, name, defaultValue) {
    var priv = "_" + name;
    obj[priv] = defaultValue;
    Object.defineProperty(StandardMaterial.prototype, name, {get:function() {
      return this[priv];
    }, set:function(value) {
      if (this[priv] !== value) {
        this.dirtyShader = true;
      }
      this[priv] = value;
    }});
    _propsSerial.push(name);
  };
  var Chunks = function() {
  };
  Chunks.prototype.copy = function(from) {
    for (var p in from) {
      if (from.hasOwnProperty(p) && p !== "copy") {
        this[p] = from[p];
      }
    }
  };
  Object.assign(StandardMaterial.prototype, {reset:function() {
    var i;
    for (i = 0; i < _propsSerial.length; i++) {
      var defVal = _propsSerialDefaultVal[i];
      this[_propsSerial[i]] = defVal ? defVal.clone ? defVal.clone() : defVal : defVal;
    }
    for (i = 0; i < _propsInternalNull.length; i++) {
      this[_propsInternalNull[i]] = null;
    }
    for (i = 0; i < _propsInternalVec3.length; i++) {
      this[_propsInternalVec3[i]] = new Float32Array(3);
    }
    this._chunks = new Chunks;
    this.cubeMapMinUniform = new Float32Array(3);
    this.cubeMapMaxUniform = new Float32Array(3);
  }, clone:function() {
    var clone = new pc.StandardMaterial;
    pc.Material.prototype._cloneInternal.call(this, clone);
    var pname;
    for (var i = 0; i < _propsSerial.length; i++) {
      pname = _propsSerial[i];
      if (this[pname] !== undefined) {
        if (this[pname] && this[pname].copy) {
          if (clone[pname]) {
            clone[pname].copy(this[pname]);
          } else {
            clone[pname] = this[pname].clone();
          }
        } else {
          clone[pname] = this[pname];
        }
      }
    }
    return clone;
  }, _updateMapTransform:function(transform, tiling, offset) {
    transform = transform || new pc.Vec4;
    transform.set(tiling.x, tiling.y, offset.x, offset.y);
    if (transform.x === 1 && transform.y === 1 && transform.z === 0 && transform.w === 0) {
      return null;
    }
    return transform;
  }, _setParameter:function(name, value) {
    if (!this.parameters[name]) {
      this._propsSet.push(name);
    }
    this.setParameter(name, value);
  }, _clearParameters:function() {
    var props = this._propsSet;
    for (var i = 0; i < props.length; i++) {
      delete this.parameters[props[i]];
    }
    this._propsSet = [];
  }, _updateMap:function(p) {
    var mname = p + "Map";
    if (this[mname]) {
      this._setParameter("texture_" + mname, this[mname]);
      var tname = mname + "Transform";
      var uname = mname + "TransformUniform";
      if (!this[tname]) {
        this[uname] = new Float32Array(4);
      }
      this[tname] = this._updateMapTransform(this[tname], this[mname + "Tiling"], this[mname + "Offset"]);
      if (this[tname]) {
        this[uname][0] = this[tname].x;
        this[uname][1] = this[tname].y;
        this[uname][2] = this[tname].z;
        this[uname][3] = this[tname].w;
        this._setParameter("texture_" + tname, this[uname]);
      }
    }
  }, getUniform:function(varName, value, changeMat) {
    var func = _prop2Uniform[varName];
    if (func) {
      return func(this, value, changeMat);
    }
    return null;
  }, updateUniforms:function() {
    var uniform;
    this._clearParameters();
    this._setParameter("material_ambient", this.ambientUniform);
    if (!this.diffuseMap || this.diffuseTint) {
      this._setParameter("material_diffuse", this.diffuseUniform);
    }
    if (!this.useMetalness) {
      if (!this.specularMap || this.specularTint) {
        this._setParameter("material_specular", this.specularUniform);
      }
    } else {
      if (!this.metalnessMap || this.metalness < 1) {
        this._setParameter("material_metalness", this.metalness);
      }
    }
    uniform = this.getUniform("shininess", this.shininess, true);
    this._setParameter(uniform.name, uniform.value);
    if (!this.emissiveMap || this.emissiveTint) {
      this._setParameter("material_emissive", this.emissiveUniform);
    }
    if (this.emissiveMap) {
      this._setParameter("material_emissiveIntensity", this.emissiveIntensity);
    }
    if (this.refraction > 0) {
      this._setParameter("material_refraction", this.refraction);
      this._setParameter("material_refractionIndex", this.refractionIndex);
    }
    this._setParameter("material_opacity", this.opacity);
    if (this.occludeSpecular) {
      this._setParameter("material_occludeSpecularIntensity", this.occludeSpecularIntensity);
    }
    if (this.cubeMapProjection === pc.CUBEPROJ_BOX) {
      this._setParameter(this.getUniform("cubeMapProjectionBox", this.cubeMapProjectionBox, true));
    }
    for (var p in pc._matTex2D) {
      this._updateMap(p);
    }
    if (this.ambientSH) {
      this._setParameter("ambientSH[0]", this.ambientSH);
    }
    if (this.normalMap) {
      this._setParameter("material_bumpiness", this.bumpiness);
    }
    if (this.heightMap) {
      uniform = this.getUniform("heightMapFactor", this.heightMapFactor, true);
      this._setParameter(uniform.name, uniform.value);
    }
    if (this.cubeMap) {
      this._setParameter("texture_cubeMap", this.cubeMap);
    }
    if (this.prefilteredCubeMap128) {
      this._setParameter("texture_prefilteredCubeMap128", this.prefilteredCubeMap128);
    } else {
      if (this._scene && this._scene._skyboxPrefiltered[0]) {
        this._setParameter("texture_prefilteredCubeMap128", this._scene._skyboxPrefiltered[0]);
      }
    }
    if (this.prefilteredCubeMap64) {
      this._setParameter("texture_prefilteredCubeMap64", this.prefilteredCubeMap64);
    } else {
      if (this._scene && this._scene._skyboxPrefiltered[1]) {
        this._setParameter("texture_prefilteredCubeMap64", this._scene._skyboxPrefiltered[1]);
      }
    }
    if (this.prefilteredCubeMap32) {
      this._setParameter("texture_prefilteredCubeMap32", this.prefilteredCubeMap32);
    } else {
      if (this._scene && this._scene._skyboxPrefiltered[2]) {
        this._setParameter("texture_prefilteredCubeMap32", this._scene._skyboxPrefiltered[2]);
      }
    }
    if (this.prefilteredCubeMap16) {
      this._setParameter("texture_prefilteredCubeMap16", this.prefilteredCubeMap16);
    } else {
      if (this._scene && this._scene._skyboxPrefiltered[3]) {
        this._setParameter("texture_prefilteredCubeMap16", this._scene._skyboxPrefiltered[3]);
      }
    }
    if (this.prefilteredCubeMap8) {
      this._setParameter("texture_prefilteredCubeMap8", this.prefilteredCubeMap8);
    } else {
      if (this._scene && this._scene._skyboxPrefiltered[4]) {
        this._setParameter("texture_prefilteredCubeMap8", this._scene._skyboxPrefiltered[4]);
      }
    }
    if (this.prefilteredCubeMap4) {
      this._setParameter("texture_prefilteredCubeMap4", this.prefilteredCubeMap4);
    } else {
      if (this._scene && this._scene._skyboxPrefiltered[5]) {
        this._setParameter("texture_prefilteredCubeMap4", this._scene._skyboxPrefiltered[5]);
      }
    }
    if (this.sphereMap) {
      this._setParameter("texture_sphereMap", this.sphereMap);
    }
    if (this.dpAtlas) {
      this._setParameter("texture_sphereMap", this.dpAtlas);
    }
    this._setParameter("material_reflectivity", this.reflectivity);
    if (this.dirtyShader || !this._scene) {
      this.shader = null;
      this.clearVariants();
    }
    this._processColor();
  }, _processColor:function() {
    var c, i;
    if (!this.dirtyColor) {
      return;
    }
    if (!this._scene && this.useGammaTonemap) {
      return;
    }
    var gammaCorrection = false;
    if (this.useGammaTonemap) {
      gammaCorrection = this._scene.gammaCorrection;
    }
    for (i = 0; i < _propsColor.length; i++) {
      var clr = this["_" + _propsColor[i]];
      var arr = this[_propsColor[i] + "Uniform"];
      if (gammaCorrection) {
        arr[0] = Math.pow(clr.r, 2.2);
        arr[1] = Math.pow(clr.g, 2.2);
        arr[2] = Math.pow(clr.b, 2.2);
      } else {
        arr[0] = clr.r;
        arr[1] = clr.g;
        arr[2] = clr.b;
      }
    }
    for (c = 0; c < 3; c++) {
      this.emissiveUniform[c] *= this.emissiveIntensity;
    }
    this.dirtyColor = false;
  }, updateShader:function(device, scene, objDefs, staticLightList, pass, sortedLights) {
    if (!this._colorProcessed && this._scene) {
      this._colorProcessed = true;
      this._processColor();
    }
    var useTexCubeLod = device.useTexCubeLod;
    var useDp = !device.extTextureLod;
    var globalSky128, globalSky64, globalSky32, globalSky16, globalSky8, globalSky4;
    if (this.useSkybox) {
      globalSky128 = scene._skyboxPrefiltered[0];
      globalSky64 = scene._skyboxPrefiltered[1];
      globalSky32 = scene._skyboxPrefiltered[2];
      globalSky16 = scene._skyboxPrefiltered[3];
      globalSky8 = scene._skyboxPrefiltered[4];
      globalSky4 = scene._skyboxPrefiltered[5];
    }
    var prefilteredCubeMap128 = this.prefilteredCubeMap128 || globalSky128;
    var prefilteredCubeMap64 = this.prefilteredCubeMap64 || globalSky64;
    var prefilteredCubeMap32 = this.prefilteredCubeMap32 || globalSky32;
    var prefilteredCubeMap16 = this.prefilteredCubeMap16 || globalSky16;
    var prefilteredCubeMap8 = this.prefilteredCubeMap8 || globalSky8;
    var prefilteredCubeMap4 = this.prefilteredCubeMap4 || globalSky4;
    if (prefilteredCubeMap128) {
      var allMips = prefilteredCubeMap128 && prefilteredCubeMap64 && prefilteredCubeMap32 && prefilteredCubeMap16 && prefilteredCubeMap8 && prefilteredCubeMap4;
      if (useDp && allMips) {
        if (!prefilteredCubeMap128.dpAtlas) {
          var atlas = [prefilteredCubeMap128, prefilteredCubeMap64, prefilteredCubeMap32, prefilteredCubeMap16, prefilteredCubeMap8, prefilteredCubeMap4];
          prefilteredCubeMap128.dpAtlas = pc.generateDpAtlas(device, atlas);
          prefilteredCubeMap128.sh = pc.shFromCubemap(prefilteredCubeMap16);
        }
        this.dpAtlas = prefilteredCubeMap128.dpAtlas;
        this.ambientSH = prefilteredCubeMap128.sh;
        this._setParameter("ambientSH[0]", this.ambientSH);
        this._setParameter("texture_sphereMap", this.dpAtlas);
      } else {
        if (useTexCubeLod) {
          if (prefilteredCubeMap128._levels.length < 6) {
            if (allMips) {
              this._setParameter("texture_prefilteredCubeMap128", prefilteredCubeMap128);
            } else {
              console.log("Can't use prefiltered cubemap: " + allMips + ", " + useTexCubeLod + ", " + prefilteredCubeMap128._levels);
            }
          } else {
            this._setParameter("texture_prefilteredCubeMap128", prefilteredCubeMap128);
          }
        } else {
          if (allMips) {
            this._setParameter("texture_prefilteredCubeMap128", prefilteredCubeMap128);
            this._setParameter("texture_prefilteredCubeMap64", prefilteredCubeMap64);
            this._setParameter("texture_prefilteredCubeMap32", prefilteredCubeMap32);
            this._setParameter("texture_prefilteredCubeMap16", prefilteredCubeMap16);
            this._setParameter("texture_prefilteredCubeMap8", prefilteredCubeMap8);
            this._setParameter("texture_prefilteredCubeMap4", prefilteredCubeMap4);
          } else {
            console.log("Can't use prefiltered cubemap: " + allMips + ", " + useTexCubeLod + ", " + prefilteredCubeMap128._levels);
          }
        }
      }
    }
    var generator = pc.programlib.standard;
    var minimalOptions = pass > pc.SHADER_FORWARDHDR && pass <= pc.SHADER_PICK;
    var options = minimalOptions ? generator.optionsContextMin : generator.optionsContext;
    if (minimalOptions) {
      this.shaderOptBuilder.updateMinRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights, prefilteredCubeMap128);
    } else {
      this.shaderOptBuilder.updateRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights, prefilteredCubeMap128);
    }
    if (this.onUpdateShader) {
      options = this.onUpdateShader(options);
    }
    var library = device.getProgramLibrary();
    this.shader = library.getProgram("standard", options);
    if (!objDefs) {
      this.clearVariants();
      this.variants[0] = this.shader;
    }
    this.dirtyShader = false;
  }});
  var _defineMaterialProps = function(obj) {
    obj.dirtyShader = true;
    obj.dirtyColor = true;
    obj._scene = null;
    obj._colorProcessed = false;
    _defineColor(obj, "ambient", new pc.Color(0.7, 0.7, 0.7));
    _defineColor(obj, "diffuse", new pc.Color(1, 1, 1));
    _defineColor(obj, "specular", new pc.Color(0, 0, 0));
    _defineColor(obj, "emissive", new pc.Color(0, 0, 0), true);
    _defineFloat(obj, "shininess", 25, function(mat, shininess) {
      var value;
      if (mat.shadingModel === pc.SPECULAR_PHONG) {
        value = Math.pow(2, shininess * 0.01 * 11);
      } else {
        value = shininess * 0.01;
      }
      return {name:"material_shininess", value:value};
    });
    _defineFloat(obj, "heightMapFactor", 1, function(mat, height) {
      return {name:"material_heightMapFactor", value:height * 0.025};
    });
    _defineFloat(obj, "opacity", 1);
    _defineFloat(obj, "alphaTest", 0);
    _defineFloat(obj, "bumpiness", 1);
    _defineFloat(obj, "reflectivity", 1);
    _defineFloat(obj, "occludeSpecularIntensity", 1);
    _defineFloat(obj, "refraction", 0);
    _defineFloat(obj, "refractionIndex", 1.0 / 1.5);
    _defineFloat(obj, "metalness", 1);
    _defineFloat(obj, "aoUvSet", 0, null);
    _defineObject(obj, "ambientSH", function(mat, val, changeMat) {
      return {name:"ambientSH[0]", value:val};
    });
    _defineObject(obj, "cubeMapProjectionBox", function(mat, val, changeMat) {
      var bmin = changeMat ? mat.cubeMapMinUniform : new Float32Array(3);
      var bmax = changeMat ? mat.cubeMapMaxUniform : new Float32Array(3);
      bmin[0] = val.center.x - val.halfExtents.x;
      bmin[1] = val.center.y - val.halfExtents.y;
      bmin[2] = val.center.z - val.halfExtents.z;
      bmax[0] = val.center.x + val.halfExtents.x;
      bmax[1] = val.center.y + val.halfExtents.y;
      bmax[2] = val.center.z + val.halfExtents.z;
      return [{name:"envBoxMin", value:bmin}, {name:"envBoxMax", value:bmax}];
    });
    _defineChunks(obj);
    _defineFlag(obj, "ambientTint", false);
    _defineFlag(obj, "diffuseTint", false);
    _defineFlag(obj, "specularTint", false);
    _defineFlag(obj, "emissiveTint", false);
    _defineFlag(obj, "fastTbn", false);
    _defineFlag(obj, "specularAntialias", false);
    _defineFlag(obj, "useMetalness", false);
    _defineFlag(obj, "occludeDirect", false);
    _defineFlag(obj, "normalizeNormalMap", true);
    _defineFlag(obj, "conserveEnergy", true);
    _defineFlag(obj, "occludeSpecular", pc.SPECOCC_AO);
    _defineFlag(obj, "shadingModel", pc.SPECULAR_BLINN);
    _defineFlag(obj, "fresnelModel", pc.FRESNEL_NONE);
    _defineFlag(obj, "cubeMapProjection", pc.CUBEPROJ_NONE);
    _defineFlag(obj, "customFragmentShader", null);
    _defineFlag(obj, "forceFragmentPrecision", null);
    _defineFlag(obj, "useFog", true);
    _defineFlag(obj, "useLighting", true);
    _defineFlag(obj, "useGammaTonemap", true);
    _defineFlag(obj, "useSkybox", true);
    _defineFlag(obj, "forceUv1", false);
    _defineFlag(obj, "pixelSnap", false);
    _defineFlag(obj, "twoSidedLighting", false);
    _defineFlag(obj, "nineSlicedMode", pc.SPRITE_RENDERMODE_SLICED);
    _defineTex2D(obj, "diffuse", 0, 3);
    _defineTex2D(obj, "specular", 0, 3);
    _defineTex2D(obj, "emissive", 0, 3);
    _defineTex2D(obj, "normal", 0, -1);
    _defineTex2D(obj, "metalness", 0, 1);
    _defineTex2D(obj, "gloss", 0, 1);
    _defineTex2D(obj, "opacity", 0, 1, "a");
    _defineTex2D(obj, "height", 0, 1);
    _defineTex2D(obj, "ao", 0, 1);
    _defineTex2D(obj, "light", 1, 3);
    _defineTex2D(obj, "msdf", 0, 3);
    _defineObject(obj, "cubeMap");
    _defineObject(obj, "sphereMap");
    _defineObject(obj, "dpAtlas");
    _defineObject(obj, "prefilteredCubeMap128");
    _defineObject(obj, "prefilteredCubeMap64");
    _defineObject(obj, "prefilteredCubeMap32");
    _defineObject(obj, "prefilteredCubeMap16");
    _defineObject(obj, "prefilteredCubeMap8");
    _defineObject(obj, "prefilteredCubeMap4");
    _defineAlias(obj, "diffuseTint", "diffuseMapTint");
    _defineAlias(obj, "specularTint", "specularMapTint");
    _defineAlias(obj, "emissiveTint", "emissiveMapTint");
    _defineAlias(obj, "aoVertexColor", "aoMapVertexColor");
    _defineAlias(obj, "diffuseVertexColor", "diffuseMapVertexColor");
    _defineAlias(obj, "specularVertexColor", "specularMapVertexColor");
    _defineAlias(obj, "emissiveVertexColor", "emissiveMapVertexColor");
    _defineAlias(obj, "metalnessVertexColor", "metalnessMapVertexColor");
    _defineAlias(obj, "glossVertexColor", "glossMapVertexColor");
    _defineAlias(obj, "opacityVertexColor", "opacityMapVertexColor");
    _defineAlias(obj, "lightVertexColor", "lightMapVertexColor");
    for (var i = 0; i < _propsSerial.length; i++) {
      _propsSerialDefaultVal[i] = obj[_propsSerial[i]];
    }
    obj._propsSet = [];
  };
  _defineMaterialProps(StandardMaterial.prototype);
  return {StandardMaterial:StandardMaterial};
}());
(function() {
  pc.StandardMaterial.PARAMETER_TYPES = {name:"string", chunks:"chunks", mappingFormat:"string", _engine:"boolean", ambient:"rgb", ambientTint:"boolean", aoVertexColor:"boolean", aoVertexColorChannel:"string", aoMap:"texture", aoMapChannel:"string", aoMapUv:"number", aoMapTiling:"vec2", aoMapOffset:"vec2", diffuse:"rgb", diffuseTint:"boolean", diffuseVertexColor:"boolean", diffuseVertexColorChannel:"string", diffuseMap:"texture", diffuseMapChannel:"string", diffuseMapUv:"number", diffuseMapTiling:"vec2", 
  diffuseMapOffset:"vec2", specular:"rgb", specularTint:"boolean", specularVertexColor:"boolean", specularVertexColorChannel:"string", specularMap:"texture", specularMapChannel:"string", specularMapUv:"number", specularMapTiling:"vec2", specularMapOffset:"vec2", specularAntialias:"boolean", occludeSpecular:"enum:occludeSpecular", useMetalness:"boolean", metalness:"number", metalnessTint:"boolean", metalnessVertexColor:"boolean", metalnessVertexColorChannel:"string", metalnessMap:"texture", metalnessMapChannel:"string", 
  metalnessMapUv:"number", metalnessMapTiling:"vec2", metalnessMapOffset:"vec2", conserveEnergy:"boolean", shininess:"number", glossVertexColor:"boolean", glossVertexColorChannel:"string", glossMap:"texture", glossMapChannel:"string", glossMapUv:"number", glossMapTiling:"vec2", glossMapOffset:"vec2", fresnelModel:"number", emissive:"rgb", emissiveTint:"boolean", emissiveVertexColor:"boolean", emissiveVertexColorChannel:"string", emissiveMap:"texture", emissiveMapChannel:"string", emissiveMapUv:"number", 
  emissiveMapTiling:"vec2", emissiveMapOffset:"vec2", emissiveIntensity:"number", normalMap:"texture", normalMapTiling:"vec2", normalMapOffset:"vec2", normalMapUv:"number", bumpiness:"number", heightMap:"texture", heightMapChannel:"string", heightMapUv:"number", heightMapTiling:"vec2", heightMapOffset:"vec2", heightMapFactor:"number", alphaToCoverage:"boolean", alphaTest:"number", opacity:"number", opacityVertexColor:"boolean", opacityVertexColorChannel:"string", opacityMap:"texture", opacityMapChannel:"string", 
  opacityMapUv:"number", opacityMapTiling:"vec2", opacityMapOffset:"vec2", reflectivity:"number", refraction:"number", refractionIndex:"number", sphereMap:"texture", cubeMap:"cubemap", cubeMapProjection:"number", cubeMapProjectionBox:"boundingbox", lightVertexColor:"boolean", lightVertexColorChannel:"string", lightMap:"texture", lightMapChannel:"string", lightMapUv:"number", lightMapTiling:"vec2", lightMapOffset:"vec2", depthTest:"boolean", depthWrite:"boolean", depthBias:"number", slopeDepthBias:"number", 
  cull:"enum:cull", blendType:"enum:blendType", shadingModel:"enum:shadingModel", useFog:"boolean", useLighting:"boolean", useSkybox:"boolean", useGammaTonemap:"boolean", prefilteredCubeMap128:"texture", prefilteredCubeMap64:"texture", prefilteredCubeMap32:"texture", prefilteredCubeMap16:"texture", prefilteredCubeMap8:"texture", prefilteredCubeMap4:"texture"};
  var key, type;
  pc.StandardMaterial.TEXTURE_PARAMETERS = [];
  for (key in pc.StandardMaterial.PARAMETER_TYPES) {
    type = pc.StandardMaterial.PARAMETER_TYPES[key];
    if (type === "texture") {
      pc.StandardMaterial.TEXTURE_PARAMETERS.push(key);
    }
  }
  pc.StandardMaterial.CUBEMAP_PARAMETERS = [];
  for (key in pc.StandardMaterial.PARAMETER_TYPES) {
    type = pc.StandardMaterial.PARAMETER_TYPES[key];
    if (type === "cubemap") {
      pc.StandardMaterial.CUBEMAP_PARAMETERS.push(key);
    }
  }
})();
Object.assign(pc, function() {
  var StandardMaterialValidator = function() {
    this.removeInvalid = true;
    this.valid = true;
    this.enumValidators = {occludeSpecular:this._createEnumValidator([pc.SPECOCC_NONE, pc.SPECOCC_AO, pc.SPECOCC_GLOSSDEPENDENT]), cull:this._createEnumValidator([pc.CULLFACE_NONE, pc.CULLFACE_BACK, pc.CULLFACE_FRONT, pc.CULLFACE_FRONTANDBACK]), blendType:this._createEnumValidator([pc.BLEND_SUBTRACTIVE, pc.BLEND_ADDITIVE, pc.BLEND_NORMAL, pc.BLEND_NONE, pc.BLEND_PREMULTIPLIED, pc.BLEND_MULTIPLICATIVE, pc.BLEND_ADDITIVEALPHA, pc.BLEND_MULTIPLICATIVE2X, pc.BLEND_SCREEN, pc.BLEND_MIN, pc.BLEND_MAX]), 
    shadingModel:this._createEnumValidator([pc.SPECULAR_PHONG, pc.SPECULAR_BLINN])};
  };
  StandardMaterialValidator.prototype.setInvalid = function(key, data) {
    this.valid = false;
    if (this.removeInvalid) {
      delete data[key];
    }
  };
  StandardMaterialValidator.prototype.validate = function(data) {
    var TYPES = pc.StandardMaterial.PARAMETER_TYPES;
    var type;
    var i;
    var pathMapping = data.mappingFormat === "path";
    for (var key in data) {
      type = TYPES[key];
      if (!type) {
        this.valid = false;
        continue;
      }
      if (type.startsWith("enum")) {
        var enumType = type.split(":")[1];
        if (this.enumValidators[enumType]) {
          if (!this.enumValidators[enumType](data[key])) {
            this.setInvalid(key, data);
          }
        }
      } else {
        if (type === "number") {
          if (typeof data[key] !== "number") {
            this.setInvalid(key, data);
          }
        } else {
          if (type === "boolean") {
            if (typeof data[key] !== "boolean") {
              this.setInvalid(key, data);
            }
          } else {
            if (type === "string") {
              if (typeof data[key] !== "string") {
                this.setInvalid(key, data);
              }
            } else {
              if (type === "vec2") {
                if (!(data[key] instanceof Array && data[key].length === 2)) {
                  this.setInvalid(key, data);
                }
              } else {
                if (type === "rgb") {
                  if (!(data[key] instanceof Array && data[key].length === 3)) {
                    this.setInvalid(key, data);
                  }
                } else {
                  if (type === "texture") {
                    if (!pathMapping) {
                      if (typeof data[key] === "number" || data[key] === null) {
                      } else {
                        if (!(data[key] instanceof pc.Texture)) {
                          this.setInvalid(key, data);
                        }
                      }
                    } else {
                      if (typeof data[key] === "string" || data[key === null]) {
                      } else {
                        if (!(data[key] instanceof pc.Texture)) {
                          this.setInvalid(key, data);
                        }
                      }
                    }
                  } else {
                    if (type === "boundingbox") {
                      if (!(data[key].center && data[key].center instanceof Array && data[key].center.length === 3)) {
                        this.setInvalid(key, data);
                      }
                      if (!(data[key].halfExtents && data[key].halfExtents instanceof Array && data[key].halfExtents.length === 3)) {
                        this.setInvalid(key, data);
                      }
                    } else {
                      if (type === "cubemap") {
                        if (typeof data[key] === "number" || data[key] === null || data[key] === undefined) {
                        } else {
                          if (!(data[key] instanceof pc.Texture && data[key].cubemap)) {
                            this.setInvalid(key, data);
                          }
                        }
                      } else {
                        if (type === "chunks") {
                          var chunkNames = Object.keys(data[key]);
                          for (i = 0; i < chunkNames.length; i++) {
                            if (typeof data[key][chunkNames[i]] !== "string") {
                              this.setInvalid(chunkNames[i], data[key]);
                            }
                          }
                        } else {
                          console.error("Unknown material type: " + type);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    data.validated = true;
    return this.valid;
  };
  StandardMaterialValidator.prototype._createEnumValidator = function(values) {
    return function(value) {
      return values.indexOf(value) >= 0;
    };
  };
  return {StandardMaterialValidator:StandardMaterialValidator};
}());
Object.assign(pc, function() {
  var StandardMaterialOptionsBuilder = function() {
    this._mapXForms = null;
  };
  StandardMaterialOptionsBuilder.prototype.updateMinRef = function(options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights, prefilteredCubeMap128) {
    this._updateSharedOptions(options, stdMat, objDefs, pass);
    this._updateMinOptions(options, stdMat);
    this._updateUVOptions(options, stdMat, objDefs, true);
  };
  StandardMaterialOptionsBuilder.prototype.updateRef = function(options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights, prefilteredCubeMap128) {
    this._updateSharedOptions(options, stdMat, objDefs, pass);
    options.useTexCubeLod = device.useTexCubeLod;
    this._updateEnvOptions(options, stdMat, scene, prefilteredCubeMap128);
    this._updateMaterialOptions(options, stdMat);
    if (pass === pc.SHADER_FORWARDHDR) {
      if (options.gamma) {
        options.gamma = pc.GAMMA_SRGBHDR;
      }
      options.toneMap = pc.TONEMAP_LINEAR;
    }
    options.hasTangents = objDefs && stdMat.normalMap && (objDefs & pc.SHADERDEF_TANGENTS) !== 0;
    this._updateLightOptions(options, stdMat, objDefs, sortedLights, staticLightList);
    this._updateUVOptions(options, stdMat, objDefs, false);
  };
  StandardMaterialOptionsBuilder.prototype._updateSharedOptions = function(options, stdMat, objDefs, pass) {
    options.pass = pass;
    options.alphaTest = stdMat.alphaTest > 0;
    options.forceFragmentPrecision = stdMat.forceFragmentPrecision || "";
    options.chunks = stdMat.chunks || "";
    options.blendType = stdMat.blendType;
    options.forceUv1 = stdMat.forceUv1;
    options.screenSpace = objDefs && (objDefs & pc.SHADERDEF_SCREENSPACE) !== 0;
    options.skin = objDefs && (objDefs & pc.SHADERDEF_SKIN) !== 0;
    options.useInstancing = objDefs && (objDefs & pc.SHADERDEF_INSTANCING) !== 0;
  };
  StandardMaterialOptionsBuilder.prototype._updateUVOptions = function(options, stdMat, objDefs, minimalOptions) {
    var hasUv0 = false;
    var hasUv1 = false;
    var hasVcolor = false;
    if (objDefs) {
      hasUv0 = (objDefs & pc.SHADERDEF_UV0) !== 0;
      hasUv1 = (objDefs & pc.SHADERDEF_UV1) !== 0;
      hasVcolor = (objDefs & pc.SHADERDEF_VCOLOR) !== 0;
    }
    options.vertexColors = false;
    this._mapXForms = [];
    for (var p in pc._matTex2D) {
      this._updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions);
    }
    this._mapXForms = null;
  };
  StandardMaterialOptionsBuilder.prototype._updateMinOptions = function(options, stdMat) {
    options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== pc.BLEND_NONE;
    options.lights = [];
  };
  StandardMaterialOptionsBuilder.prototype._updateMaterialOptions = function(options, stdMat) {
    var diffuseTint = (stdMat.diffuse.r !== 1 || stdMat.diffuse.g !== 1 || stdMat.diffuse.b !== 1) && (stdMat.diffuseTint || !stdMat.diffuseMap && !stdMat.diffuseVertexColor) ? 3 : 0;
    var specularTint = false;
    var useSpecular = (stdMat.useMetalness ? true : !!stdMat.specularMap) || !!stdMat.sphereMap || !!stdMat.cubeMap || !!stdMat.dpAtlas;
    useSpecular = useSpecular || (stdMat.useMetalness ? true : !(stdMat.specular.r === 0 && stdMat.specular.g === 0 && stdMat.specular.b === 0));
    if (useSpecular) {
      if ((stdMat.specularTint || !stdMat.specularMap && !stdMat.specularVertexColor) && !stdMat.useMetalness) {
        specularTint = stdMat.specular.r !== 1 || stdMat.specular.g !== 1 || stdMat.specular.b !== 1;
      }
    }
    var emissiveTint = stdMat.emissiveMap ? 0 : 3;
    if (!emissiveTint) {
      emissiveTint = (stdMat.emissive.r !== 1 || stdMat.emissive.g !== 1 || stdMat.emissive.b !== 1 || stdMat.emissiveIntensity !== 1) && stdMat.emissiveTint;
      emissiveTint = emissiveTint ? 3 : stdMat.emissiveIntensity !== 1 ? 1 : 0;
    }
    options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== pc.BLEND_NONE ? 1 : 0;
    options.blendMapsWithColors = true;
    options.ambientTint = stdMat.ambientTint;
    options.diffuseTint = diffuseTint;
    options.specularTint = specularTint ? 3 : 0;
    options.metalnessTint = stdMat.useMetalness && stdMat.metalness < 1 ? 1 : 0;
    options.glossTint = 1;
    options.emissiveTint = emissiveTint;
    options.alphaToCoverage = stdMat.alphaToCoverage;
    options.needsNormalFloat = stdMat.normalizeNormalMap;
    options.sphereMap = !!stdMat.sphereMap;
    options.cubeMap = !!stdMat.cubeMap;
    options.dpAtlas = !!stdMat.dpAtlas;
    options.ambientSH = !!stdMat.ambientSH;
    options.useSpecular = useSpecular;
    options.emissiveFormat = stdMat.emissiveMap ? stdMat.emissiveMap.rgbm ? 1 : stdMat.emissiveMap.format === pc.PIXELFORMAT_RGBA32F ? 2 : 0 : null;
    options.lightMapFormat = stdMat.lightMap ? stdMat.lightMap.rgbm ? 1 : stdMat.lightMap.format === pc.PIXELFORMAT_RGBA32F ? 2 : 0 : null;
    options.specularAntialias = stdMat.specularAntialias;
    options.conserveEnergy = stdMat.conserveEnergy;
    options.occludeSpecular = stdMat.occludeSpecular;
    options.occludeSpecularFloat = stdMat.occludeSpecularIntensity !== 1.0;
    options.occludeDirect = stdMat.occludeDirect;
    options.shadingModel = stdMat.shadingModel;
    options.fresnelModel = stdMat.fresnelModel;
    options.packedNormal = stdMat.normalMap ? stdMat.normalMap.format === pc.PIXELFORMAT_DXT5 : false;
    options.fastTbn = stdMat.fastTbn;
    options.cubeMapProjection = stdMat.cubeMapProjection;
    options.customFragmentShader = stdMat.customFragmentShader;
    options.refraction = !!stdMat.refraction;
    options.useMetalness = stdMat.useMetalness;
    options.msdf = !!stdMat.msdfMap;
    options.twoSidedLighting = stdMat.twoSidedLighting;
    options.pixelSnap = stdMat.pixelSnap;
    options.nineSlicedMode = stdMat.nineSlicedMode || 0;
    options.aoMapUv = stdMat.aoUvSet;
  };
  StandardMaterialOptionsBuilder.prototype._updateEnvOptions = function(options, stdMat, scene, prefilteredCubeMap128) {
    var rgbmAmbient = (prefilteredCubeMap128 ? prefilteredCubeMap128.rgbm : false) || (stdMat.cubeMap ? stdMat.cubeMap.rgbm : false) || (stdMat.dpAtlas ? stdMat.dpAtlas.rgbm : false);
    var hdrAmbient = (prefilteredCubeMap128 ? prefilteredCubeMap128.rgbm || prefilteredCubeMap128.format === pc.PIXELFORMAT_RGBA32F : false) || (stdMat.cubeMap ? stdMat.cubeMap.rgbm || stdMat.cubeMap.format === pc.PIXELFORMAT_RGBA32F : false) || (stdMat.dpAtlas ? stdMat.dpAtlas.rgbm || stdMat.dpAtlas.format === pc.PIXELFORMAT_RGBA32F : false);
    var rgbmReflection = (prefilteredCubeMap128 && !stdMat.cubeMap && !stdMat.sphereMap && !stdMat.dpAtlas ? prefilteredCubeMap128.rgbm : false) || (stdMat.cubeMap ? stdMat.cubeMap.rgbm : false) || (stdMat.sphereMap ? stdMat.sphereMap.rgbm : false) || (stdMat.dpAtlas ? stdMat.dpAtlas.rgbm : false);
    var hdrReflection = (prefilteredCubeMap128 && !stdMat.cubeMap && !stdMat.sphereMap && !stdMat.dpAtlas ? prefilteredCubeMap128.rgbm || prefilteredCubeMap128.format === pc.PIXELFORMAT_RGBA32F : false) || (stdMat.cubeMap ? stdMat.cubeMap.rgbm || stdMat.cubeMap.format === pc.PIXELFORMAT_RGBA32F : false) || (stdMat.sphereMap ? stdMat.sphereMap.rgbm || stdMat.sphereMap.format === pc.PIXELFORMAT_RGBA32F : false) || (stdMat.dpAtlas ? stdMat.dpAtlas.rgbm || stdMat.dpAtlas.format === pc.PIXELFORMAT_RGBA32F : 
    false);
    var globalSky128;
    if (stdMat.useSkybox && scene._skyboxPrefiltered) {
      globalSky128 = scene._skyboxPrefiltered[0];
    }
    options.fog = stdMat.useFog ? scene.fog : "none";
    options.gamma = stdMat.useGammaTonemap ? scene.gammaCorrection : pc.GAMMA_NONE;
    options.toneMap = stdMat.useGammaTonemap ? scene.toneMapping : -1;
    options.rgbmAmbient = rgbmAmbient;
    options.hdrAmbient = hdrAmbient;
    options.rgbmReflection = rgbmReflection;
    options.hdrReflection = hdrReflection;
    options.useRgbm = rgbmReflection || rgbmAmbient || (stdMat.emissiveMap ? stdMat.emissiveMap.rgbm : false) || (stdMat.lightMap ? stdMat.lightMap.rgbm : false);
    options.fixSeams = prefilteredCubeMap128 ? prefilteredCubeMap128.fixCubemapSeams : stdMat.cubeMap ? stdMat.cubeMap.fixCubemapSeams : false;
    options.prefilteredCubemap = !!prefilteredCubeMap128;
    options.skyboxIntensity = prefilteredCubeMap128 && globalSky128 && prefilteredCubeMap128 === globalSky128 && scene.skyboxIntensity !== 1;
  };
  StandardMaterialOptionsBuilder.prototype._updateLightOptions = function(options, stdMat, objDefs, sortedLights, staticLightList) {
    options.lightMap = false;
    options.lightMapChannel = "";
    options.lightMapUv = 0;
    options.lightMapTransform = 0;
    options.lightMapWithoutAmbient = false;
    options.dirLightMap = false;
    if (objDefs) {
      options.noShadow = (objDefs & pc.SHADERDEF_NOSHADOW) !== 0;
      if ((objDefs & pc.SHADERDEF_LM) !== 0) {
        options.lightMapFormat = 1;
        options.lightMap = true;
        options.lightMapChannel = "rgb";
        options.lightMapUv = 1;
        options.lightMapTransform = 0;
        options.lightMapWithoutAmbient = !stdMat.lightMap;
        options.useRgbm = true;
        if ((objDefs & pc.SHADERDEF_DIRLM) !== 0) {
          options.dirLightMap = true;
        }
      }
    }
    if (stdMat.useLighting) {
      var lightsFiltered = [];
      var mask = objDefs ? objDefs >> 16 : 1;
      if (sortedLights) {
        this._collectLights(pc.LIGHTTYPE_DIRECTIONAL, sortedLights[pc.LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);
        this._collectLights(pc.LIGHTTYPE_POINT, sortedLights[pc.LIGHTTYPE_POINT], lightsFiltered, mask, staticLightList);
        this._collectLights(pc.LIGHTTYPE_SPOT, sortedLights[pc.LIGHTTYPE_SPOT], lightsFiltered, mask, staticLightList);
      }
      options.lights = lightsFiltered;
    } else {
      options.lights = [];
    }
    if (options.lights.length === 0) {
      options.noShadow = true;
    }
  };
  StandardMaterialOptionsBuilder.prototype._updateTexOptions = function(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions) {
    var mname = p + "Map";
    var vname = p + "VertexColor";
    var vcname = p + "VertexColorChannel";
    var cname = mname + "Channel";
    var tname = mname + "Transform";
    var uname = mname + "Uv";
    if (p !== "light") {
      options[mname] = false;
      options[cname] = "";
      options[tname] = 0;
      options[uname] = 0;
    }
    options[vname] = false;
    options[vcname] = "";
    var isOpacity = p === "opacity";
    if (isOpacity && stdMat.blendType === pc.BLEND_NONE && stdMat.alphaTest === 0.0 && !stdMat.alphaToCoverage) {
      return options;
    }
    if (!minimalOptions || isOpacity) {
      if (p !== "height" && stdMat[vname]) {
        if (hasVcolor) {
          options[vname] = stdMat[vname];
          options[vcname] = stdMat[vcname];
          options.vertexColors = true;
        }
      }
      if (stdMat[mname]) {
        var allow = true;
        if (stdMat[uname] === 0 && !hasUv0) {
          allow = false;
        }
        if (stdMat[uname] === 1 && !hasUv1) {
          allow = false;
        }
        if (allow) {
          options[mname] = !!stdMat[mname];
          options[tname] = this._getMapTransformID(stdMat[tname], stdMat[uname]);
          options[cname] = stdMat[cname];
          options[uname] = stdMat[uname];
        }
      }
    }
  };
  StandardMaterialOptionsBuilder.prototype._collectLights = function(lType, lights, lightsFiltered, mask, staticLightList) {
    var light;
    var i;
    for (i = 0; i < lights.length; i++) {
      light = lights[i];
      if (light._enabled) {
        if (light._mask & mask) {
          if (lType !== pc.LIGHTTYPE_DIRECTIONAL) {
            if (light.isStatic) {
              continue;
            }
          }
          lightsFiltered.push(light);
        }
      }
    }
    if (staticLightList) {
      for (i = 0; i < staticLightList.length; i++) {
        light = staticLightList[i];
        if (light._type === lType) {
          lightsFiltered.push(light);
        }
      }
    }
  };
  StandardMaterialOptionsBuilder.prototype._getMapTransformID = function(xform, uv) {
    if (!xform) {
      return 0;
    }
    if (!this._mapXForms[uv]) {
      this._mapXForms[uv] = [];
    }
    var i, same;
    for (i = 0; i < this._mapXForms[uv].length; i++) {
      same = true;
      if (this._mapXForms[uv][i][0] != xform.x) {
        same = false;
        break;
      }
      if (this._mapXForms[uv][i][1] != xform.y) {
        same = false;
        break;
      }
      if (this._mapXForms[uv][i][2] != xform.z) {
        same = false;
        break;
      }
      if (this._mapXForms[uv][i][3] != xform.w) {
        same = false;
        break;
      }
      if (same) {
        return i + 1;
      }
    }
    var newID = this._mapXForms[uv].length;
    this._mapXForms[uv][newID] = [];
    this._mapXForms[uv][newID][0] = xform.x;
    this._mapXForms[uv][newID][1] = xform.y;
    this._mapXForms[uv][newID][2] = xform.z;
    this._mapXForms[uv][newID][3] = xform.w;
    return newID + 1;
  };
  return {StandardMaterialOptionsBuilder:StandardMaterialOptionsBuilder};
}());
Object.assign(pc, function() {
  var id = 0;
  var _tmpAabb = new pc.BoundingBox;
  var Mesh = function() {
    this._refCount = 0;
    this.id = id++;
    this.vertexBuffer = null;
    this.indexBuffer = [null];
    this.primitive = [{type:0, base:0, count:0}];
    this.skin = null;
    this.morph = null;
    this._aabb = new pc.BoundingBox;
    this.boneAabb = null;
  };
  Object.defineProperty(Mesh.prototype, "aabb", {get:function() {
    return this.morph ? this.morph.aabb : this._aabb;
  }, set:function(aabb) {
    if (this.morph) {
      this._aabb = this.morph._baseAabb = aabb;
      this.morph._calculateAabb();
    } else {
      this._aabb = aabb;
    }
  }});
  var MeshInstance = function MeshInstance(node, mesh, material) {
    this._key = [0, 0];
    this._shader = [null, null, null];
    this.isStatic = false;
    this._staticLightList = null;
    this._staticSource = null;
    this.node = node;
    this._mesh = mesh;
    mesh._refCount++;
    this.material = material;
    this._shaderDefs = pc.MASK_DYNAMIC << 16;
    this._shaderDefs |= mesh.vertexBuffer.format.hasUv0 ? pc.SHADERDEF_UV0 : 0;
    this._shaderDefs |= mesh.vertexBuffer.format.hasUv1 ? pc.SHADERDEF_UV1 : 0;
    this._shaderDefs |= mesh.vertexBuffer.format.hasColor ? pc.SHADERDEF_VCOLOR : 0;
    this._shaderDefs |= mesh.vertexBuffer.format.hasTangents ? pc.SHADERDEF_TANGENTS : 0;
    this._lightHash = 0;
    this.visible = true;
    this.layer = pc.LAYER_WORLD;
    this.renderStyle = pc.RENDERSTYLE_SOLID;
    this.castShadow = false;
    this._receiveShadow = true;
    this._screenSpace = false;
    this._noDepthDrawGl1 = false;
    this.cull = true;
    this.pick = true;
    this._updateAabb = true;
    this._updateAabbFunc = null;
    this.updateKey();
    this._skinInstance = null;
    this.morphInstance = null;
    this.instancingData = null;
    this.aabb = new pc.BoundingBox;
    this._boneAabb = null;
    this._aabbVer = -1;
    this.drawOrder = 0;
    this.visibleThisFrame = 0;
    this.isVisibleFunc = null;
    this.parameters = {};
    this.stencilFront = null;
    this.stencilBack = null;
  };
  Object.defineProperty(MeshInstance.prototype, "mesh", {get:function() {
    return this._mesh;
  }, set:function(mesh) {
    if (this._mesh) {
      this._mesh._refCount--;
    }
    this._mesh = mesh;
    if (mesh) {
      mesh._refCount++;
    }
  }});
  Object.defineProperty(MeshInstance.prototype, "aabb", {get:function() {
    var aabb;
    if (!this._updateAabb) {
      return this._aabb;
    }
    if (this._updateAabbFunc) {
      return this._updateAabbFunc(this._aabb);
    }
    if (this.skinInstance) {
      var numBones = this.mesh.skin.boneNames.length;
      var boneUsed, i;
      if (!this.mesh.boneAabb) {
        this.mesh.boneAabb = [];
        this.mesh.boneUsed = [];
        var elems = this.mesh.vertexBuffer.format.elements;
        var numVerts = this.mesh.vertexBuffer.numVertices;
        var vertSize = this.mesh.vertexBuffer.format.size;
        var index;
        var offsetP, offsetI, offsetW;
        var j, k, l;
        for (i = 0; i < elems.length; i++) {
          if (elems[i].name === pc.SEMANTIC_POSITION) {
            offsetP = elems[i].offset;
          } else {
            if (elems[i].name === pc.SEMANTIC_BLENDINDICES) {
              offsetI = elems[i].offset;
            } else {
              if (elems[i].name === pc.SEMANTIC_BLENDWEIGHT) {
                offsetW = elems[i].offset;
              }
            }
          }
        }
        var data8 = new Uint8Array(this.mesh.vertexBuffer.storage);
        var dataF = new Float32Array(this.mesh.vertexBuffer.storage);
        var offsetPF = offsetP / 4;
        var offsetWF = offsetW / 4;
        var vertSizeF = vertSize / 4;
        var bMax, bMin;
        var x, y, z;
        var boneMin = [];
        var boneMax = [];
        boneUsed = this.mesh.boneUsed;
        for (i = 0; i < numBones; i++) {
          boneMin[i] = new pc.Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
          boneMax[i] = new pc.Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        }
        for (j = 0; j < numVerts; j++) {
          for (k = 0; k < 4; k++) {
            if (dataF[j * vertSizeF + offsetWF + k] > 0) {
              index = data8[j * vertSize + offsetI + k];
              x = dataF[j * vertSizeF + offsetPF];
              y = dataF[j * vertSizeF + offsetPF + 1];
              z = dataF[j * vertSizeF + offsetPF + 2];
              bMax = boneMax[index];
              bMin = boneMin[index];
              if (bMin.x > x) {
                bMin.x = x;
              }
              if (bMin.y > y) {
                bMin.y = y;
              }
              if (bMin.z > z) {
                bMin.z = z;
              }
              if (bMax.x < x) {
                bMax.x = x;
              }
              if (bMax.y < y) {
                bMax.y = y;
              }
              if (bMax.z < z) {
                bMax.z = z;
              }
              boneUsed[index] = true;
            }
          }
        }
        if (this.morphInstance) {
          var vertIndex;
          var targets = this.morphInstance.morph._targets;
          var minMorphedPos = new Float32Array(numVerts * 3);
          var maxMorphedPos = new Float32Array(numVerts * 3);
          var m, dx, dy, dz;
          var target, mtIndices, mtIndicesLength, deltaPos;
          for (j = 0; j < numVerts; j++) {
            minMorphedPos[j * 3] = maxMorphedPos[j * 3] = dataF[j * vertSizeF + offsetPF];
            minMorphedPos[j * 3 + 1] = maxMorphedPos[j * 3 + 1] = dataF[j * vertSizeF + offsetPF + 1];
            minMorphedPos[j * 3 + 2] = maxMorphedPos[j * 3 + 2] = dataF[j * vertSizeF + offsetPF + 2];
          }
          for (l = 0; l < targets.length; l++) {
            target = targets[l];
            mtIndices = target.indices;
            mtIndicesLength = mtIndices.length;
            deltaPos = target.deltaPositions;
            for (k = 0; k < mtIndicesLength; k++) {
              vertIndex = mtIndices[k];
              dx = deltaPos[k * 3];
              dy = deltaPos[k * 3 + 1];
              dz = deltaPos[k * 3 + 2];
              if (dx < 0) {
                minMorphedPos[vertIndex * 3] += dx;
              } else {
                maxMorphedPos[vertIndex * 3] += dx;
              }
              if (dy < 0) {
                minMorphedPos[vertIndex * 3 + 1] += dy;
              } else {
                maxMorphedPos[vertIndex * 3 + 1] += dy;
              }
              if (dz < 0) {
                minMorphedPos[vertIndex * 3 + 2] += dz;
              } else {
                maxMorphedPos[vertIndex * 3 + 2] += dz;
              }
            }
          }
          for (l = 0; l < targets.length; l++) {
            target = targets[l];
            mtIndices = target.indices;
            mtIndicesLength = mtIndices.length;
            deltaPos = target.deltaPositions;
            for (k = 0; k < mtIndicesLength; k++) {
              vertIndex = mtIndices[k];
              for (m = 0; m < 4; m++) {
                if (dataF[vertIndex * vertSizeF + offsetWF + m] > 0) {
                  index = data8[vertIndex * vertSize + offsetI + m];
                  bMax = boneMax[index];
                  bMin = boneMin[index];
                  x = minMorphedPos[vertIndex * 3];
                  y = minMorphedPos[vertIndex * 3 + 1];
                  z = minMorphedPos[vertIndex * 3 + 2];
                  if (bMin.x > x) {
                    bMin.x = x;
                  }
                  if (bMin.y > y) {
                    bMin.y = y;
                  }
                  if (bMin.z > z) {
                    bMin.z = z;
                  }
                  x = maxMorphedPos[vertIndex * 3];
                  y = maxMorphedPos[vertIndex * 3 + 1];
                  z = maxMorphedPos[vertIndex * 3 + 2];
                  if (bMax.x < x) {
                    bMax.x = x;
                  }
                  if (bMax.y < y) {
                    bMax.y = y;
                  }
                  if (bMax.z < z) {
                    bMax.z = z;
                  }
                }
              }
            }
          }
        }
        for (i = 0; i < numBones; i++) {
          aabb = new pc.BoundingBox;
          aabb.setMinMax(boneMin[i], boneMax[i]);
          this.mesh.boneAabb.push(aabb);
        }
      }
      if (!this._boneAabb) {
        this._boneAabb = [];
        for (i = 0; i < this.mesh.boneAabb.length; i++) {
          this._boneAabb[i] = new pc.BoundingBox;
        }
      }
      boneUsed = this.mesh.boneUsed;
      for (i = 0; i < this.mesh.boneAabb.length; i++) {
        if (!boneUsed[i]) {
          continue;
        }
        this._boneAabb[i].setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);
      }
      var rootNodeTransform = this.node.getWorldTransform();
      var first = true;
      for (i = 0; i < this.mesh.boneAabb.length; i++) {
        if (!boneUsed[i]) {
          continue;
        }
        if (first) {
          _tmpAabb.center.copy(this._boneAabb[i].center);
          _tmpAabb.halfExtents.copy(this._boneAabb[i].halfExtents);
          first = false;
        } else {
          _tmpAabb.add(this._boneAabb[i]);
        }
      }
      this._aabb.setFromTransformedAabb(_tmpAabb, rootNodeTransform);
    } else {
      if (this.node._aabbVer !== this._aabbVer) {
        aabb = this.mesh ? this.mesh.aabb : this._aabb;
        if (!this.mesh) {
          aabb.center.set(0, 0, 0);
          aabb.halfExtents.set(0, 0, 0);
        }
        this._aabb.setFromTransformedAabb(aabb, this.node.getWorldTransform());
        this._aabbVer = this.node._aabbVer;
      }
    }
    return this._aabb;
  }, set:function(aabb) {
    this._aabb = aabb;
  }});
  Object.defineProperty(MeshInstance.prototype, "material", {get:function() {
    return this._material;
  }, set:function(material) {
    var i;
    for (i = 0; i < this._shader.length; i++) {
      this._shader[i] = null;
    }
    if (this._material) {
      var meshInstances = this._material.meshInstances;
      i = meshInstances.indexOf(this);
      if (i !== -1) {
        meshInstances.splice(i, 1);
      }
    }
    var prevBlend = this._material ? this._material.blendType !== pc.BLEND_NONE : false;
    var prevMat = this._material;
    this._material = material;
    if (this._material) {
      this._material.meshInstances.push(this);
      this.updateKey();
    }
    if (material) {
      if (material.blendType !== pc.BLEND_NONE !== prevBlend) {
        var scene = material._scene;
        if (!scene && prevMat && prevMat._scene) {
          scene = prevMat._scene;
        }
        if (scene) {
          scene.layers._dirtyBlend = true;
        } else {
          material._dirtyBlend = true;
        }
      }
    }
  }});
  Object.defineProperty(MeshInstance.prototype, "layer", {get:function() {
    return this._layer;
  }, set:function(layer) {
    this._layer = layer;
    this.updateKey();
  }});
  Object.defineProperty(MeshInstance.prototype, "receiveShadow", {get:function() {
    return this._receiveShadow;
  }, set:function(val) {
    this._receiveShadow = val;
    this._shaderDefs = val ? this._shaderDefs & ~pc.SHADERDEF_NOSHADOW : this._shaderDefs | pc.SHADERDEF_NOSHADOW;
    this._shader[pc.SHADER_FORWARD] = null;
    this._shader[pc.SHADER_FORWARDHDR] = null;
  }});
  Object.defineProperty(MeshInstance.prototype, "skinInstance", {get:function() {
    return this._skinInstance;
  }, set:function(val) {
    this._skinInstance = val;
    this._shaderDefs = val ? this._shaderDefs | pc.SHADERDEF_SKIN : this._shaderDefs & ~pc.SHADERDEF_SKIN;
    for (var i = 0; i < this._shader.length; i++) {
      this._shader[i] = null;
    }
  }});
  Object.defineProperty(MeshInstance.prototype, "screenSpace", {get:function() {
    return this._screenSpace;
  }, set:function(val) {
    this._screenSpace = val;
    this._shaderDefs = val ? this._shaderDefs | pc.SHADERDEF_SCREENSPACE : this._shaderDefs & ~pc.SHADERDEF_SCREENSPACE;
    this._shader[pc.SHADER_FORWARD] = null;
  }});
  Object.defineProperty(MeshInstance.prototype, "key", {get:function() {
    return this._key[pc.SORTKEY_FORWARD];
  }, set:function(val) {
    this._key[pc.SORTKEY_FORWARD] = val;
  }});
  Object.defineProperty(MeshInstance.prototype, "mask", {get:function() {
    return this._shaderDefs >> 16;
  }, set:function(val) {
    var toggles = this._shaderDefs & 65535;
    this._shaderDefs = toggles | val << 16;
    this._shader[pc.SHADER_FORWARD] = null;
    this._shader[pc.SHADER_FORWARDHDR] = null;
  }});
  Object.assign(MeshInstance.prototype, {syncAabb:function() {
  }, updateKey:function() {
    var material = this.material;
    this._key[pc.SORTKEY_FORWARD] = getKey(this.layer, material.alphaToCoverage || material.alphaTest ? pc.BLEND_NORMAL : material.blendType, false, material.id);
  }, setParameter:pc.Material.prototype.setParameter, setParameters:pc.Material.prototype.setParameters, deleteParameter:pc.Material.prototype.deleteParameter, getParameter:pc.Material.prototype.getParameter, getParameters:pc.Material.prototype.getParameters, clearParameters:pc.Material.prototype.clearParameters});
  var Command = function(layer, blendType, command) {
    this._key = [];
    this._key[pc.SORTKEY_FORWARD] = getKey(layer, blendType, true, 0);
    this.command = command;
  };
  Object.defineProperty(Command.prototype, "key", {get:function() {
    return this._key[pc.SORTKEY_FORWARD];
  }, set:function(val) {
    this._key[pc.SORTKEY_FORWARD] = val;
  }});
  var InstancingData = function(numObjects, dynamic, instanceSize) {
    instanceSize = instanceSize || 16;
    this.buffer = new Float32Array(numObjects * instanceSize);
    this.count = numObjects;
    this.offset = 0;
    this.usage = dynamic ? pc.BUFFER_DYNAMIC : pc.BUFFER_STATIC;
    this._buffer = null;
  };
  Object.assign(InstancingData.prototype, {update:function() {
    if (this._buffer) {
      this._buffer.setData(this.buffer);
    }
  }});
  function getKey(layer, blendType, isCommand, materialId) {
    return (layer & 15) << 27 | (blendType === pc.BLEND_NONE ? 1 : 0) << 26 | (isCommand ? 1 : 0) << 25 | (materialId & 33554431) << 0;
  }
  return {Command:Command, Mesh:Mesh, MeshInstance:MeshInstance, InstancingData:InstancingData, _getDrawcallSortKey:getKey};
}());
Object.assign(pc, function() {
  var _morphMin = new pc.Vec3;
  var _morphMax = new pc.Vec3;
  var MorphTarget = function(options) {
    if (options.indices) {
      this.indices = options.indices;
    } else {
      var arr = options.deltaPositions;
      this.indices = [];
      this.indices.length = arr.length;
      for (var i = 0; i < arr.length; i++) {
        this.indices[i] = i;
      }
    }
    this.deltaPositions = options.deltaPositions;
    this.deltaNormals = options.deltaNormals;
    this.deltaTangents = options.deltaTangents;
    this.name = options.name;
    this.aabb = options.aabb;
  };
  var Morph = function(targets) {
    this.aabb = new pc.BoundingBox;
    this._baseBuffer = null;
    this._baseAabb = null;
    this._targets = targets;
    this._dirty = true;
    this._aabbDirty = true;
    this._baseData = null;
    this._offsetPF = 0;
    this._offsetNF = 0;
    this._offsetTF = 0;
    this._vertSizeF = 0;
  };
  Object.assign(Morph.prototype, {_setBaseMesh:function(baseMesh) {
    this._baseBuffer = baseMesh.vertexBuffer;
    this._baseAabb = baseMesh._aabb;
    this._baseData = new Float32Array(this._baseBuffer.storage);
    var offsetP = -1;
    var offsetN = -1;
    var offsetT = -1;
    var elems = this._baseBuffer.format.elements;
    var vertSize = this._baseBuffer.format.size;
    for (var j = 0; j < elems.length; j++) {
      if (elems[j].name === pc.SEMANTIC_POSITION) {
        offsetP = elems[j].offset;
      } else {
        if (elems[j].name === pc.SEMANTIC_NORMAL) {
          offsetN = elems[j].offset;
        } else {
          if (elems[j].name === pc.SEMANTIC_TANGENT) {
            offsetT = elems[j].offset;
          }
        }
      }
    }
    this._offsetPF = offsetP / 4;
    this._offsetNF = offsetN / 4;
    this._offsetTF = offsetT / 4;
    this._vertSizeF = vertSize / 4;
    this._dirty = true;
  }, _calculateAabb:function() {
    if (!this._baseBuffer) {
      return;
    }
    this.aabb.copy(this._baseAabb);
    var numIndices;
    var i, j, target, index, id;
    var x, y, z;
    var vertSizeF = this._vertSizeF;
    var offsetPF = this._offsetPF;
    var baseData = this._baseData;
    for (i = 0; i < this._targets.length; i++) {
      target = this._targets[i];
      if (!target.aabb && target.indices.length > 0) {
        target.aabb = this.aabb.clone();
        _morphMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        _morphMax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        numIndices = target.indices.length;
        for (j = 0; j < numIndices; j++) {
          index = target.indices[j];
          id = index * vertSizeF + offsetPF;
          x = baseData[id] + target.deltaPositions[j * 3];
          y = baseData[id + 1] + target.deltaPositions[j * 3 + 1];
          z = baseData[id + 2] + target.deltaPositions[j * 3 + 2];
          if (_morphMin.x > x) {
            _morphMin.x = x;
          }
          if (_morphMin.y > y) {
            _morphMin.y = y;
          }
          if (_morphMin.z > z) {
            _morphMin.z = z;
          }
          if (_morphMax.x < x) {
            _morphMax.x = x;
          }
          if (_morphMax.y < y) {
            _morphMax.y = y;
          }
          if (_morphMax.z < z) {
            _morphMax.z = z;
          }
        }
        target.aabb.setMinMax(_morphMin, _morphMax);
      }
      if (target.aabb) {
        this.aabb.add(target.aabb);
      }
    }
    this._aabbDirty = false;
  }, addTarget:function(target) {
    this._targets.push(target);
    this._aabbDirty = true;
  }, removeTarget:function(target) {
    var index = this._targets.indexOf(target);
    if (index !== -1) {
      this._targets.splice(index, 1);
      this._aabbDirty = true;
    }
  }, getTarget:function(index) {
    return this._targets[index];
  }});
  var MorphInstance = function(morph) {
    this.morph = morph;
    this._vertexBuffer = null;
    this._vertexData = null;
    this._weights = [];
    this._dirty = true;
  };
  Object.assign(MorphInstance.prototype, {_setBaseMesh:function(baseMesh) {
    this.destroy();
    this._vertexBuffer = new pc.VertexBuffer(this.morph._baseBuffer.device, this.morph._baseBuffer.format, this.morph._baseBuffer.numVertices, pc.BUFFER_DYNAMIC, this.morph._baseBuffer.storage.slice(0));
    this._vertexData = new Float32Array(this._vertexBuffer.storage);
    this._weights = [];
    this._weights.length = this.morph._targets.length;
    for (var i = 0; i < this.morph._targets.length; i++) {
      this._weights[i] = 0;
    }
    this._dirty = true;
  }, destroy:function() {
    if (this._vertexBuffer) {
      this._vertexBuffer.destroy();
      this._vertexBuffer = null;
    }
  }, getWeight:function(index) {
    return this._weights[index];
  }, setWeight:function(index, weight) {
    this._weights[index] = weight;
    this._dirty = true;
  }, updateBounds:function(mesh) {
    if (this.morph._baseBuffer !== mesh.vertexBuffer) {
      this.morph._setBaseMesh(mesh);
    }
    if (!this._vertexData) {
      this._setBaseMesh(mesh);
    }
    if (this.morph._aabbDirty) {
      this.morph._calculateAabb();
    }
  }, update:function(mesh) {
    if (this.morph._baseBuffer !== mesh.vertexBuffer) {
      this.morph._setBaseMesh(mesh);
    }
    if (!this._vertexData) {
      this._setBaseMesh(mesh);
    }
    var numIndices, index;
    var targets = this.morph._targets;
    var weights = this._weights;
    var target, weight, j, id, j3, j4;
    var vertSizeF = this.morph._vertSizeF;
    var offsetPF = this.morph._offsetPF;
    var offsetNF = this.morph._offsetNF;
    var offsetTF = this.morph._offsetTF;
    var vdata = this._vertexData;
    vdata.set(this.morph._baseData);
    for (var i = 0; i < targets.length; i++) {
      weight = weights[i];
      if (weight === 0) {
        continue;
      }
      target = targets[i];
      numIndices = target.indices.length;
      for (j = 0; j < numIndices; j++) {
        j3 = j * 3;
        index = target.indices[j];
        id = index * vertSizeF + offsetPF;
        vdata[id] += target.deltaPositions[j3] * weight;
        vdata[id + 1] += target.deltaPositions[j3 + 1] * weight;
        vdata[id + 2] += target.deltaPositions[j3 + 2] * weight;
        if (target.deltaNormals) {
          id = index * vertSizeF + offsetNF;
          vdata[id] += target.deltaNormals[j3] * weight;
          vdata[id + 1] += target.deltaNormals[j3 + 1] * weight;
          vdata[id + 2] += target.deltaNormals[j3 + 2] * weight;
          if (target.deltaTangents) {
            j4 = j * 4;
            id = index * vertSizeF + offsetTF;
            vdata[id] += target.deltaTangents[j4] * weight;
            vdata[id + 1] += target.deltaTangents[j4 + 1] * weight;
            vdata[id + 2] += target.deltaTangents[j4 + 2] * weight;
            vdata[id + 3] += target.deltaTangents[j4 + 3] * weight;
            vdata[id + 3] = vdata[id + 3] > 0 ? 1 : -1;
          }
        }
      }
    }
    this._vertexBuffer.unlock();
  }});
  return {MorphTarget:MorphTarget, Morph:Morph, MorphInstance:MorphInstance};
}());
Object.assign(pc, function() {
  var particleVerts = [[-1, -1], [1, -1], [1, 1], [-1, 1]];
  var _createTexture = function(device, width, height, pixelData, format, mult8Bit, filter) {
    if (!format) {
      format = pc.PIXELFORMAT_RGBA32F;
    }
    var mipFilter = pc.FILTER_NEAREST;
    if (filter && format === pc.PIXELFORMAT_R8_G8_B8_A8) {
      mipFilter = pc.FILTER_LINEAR;
    }
    var texture = new pc.Texture(device, {width:width, height:height, format:format, cubemap:false, mipmaps:false, minFilter:mipFilter, magFilter:mipFilter, addressU:pc.ADDRESS_CLAMP_TO_EDGE, addressV:pc.ADDRESS_CLAMP_TO_EDGE});
    texture.name = "PSTexture";
    var pixels = texture.lock();
    if (format === pc.PIXELFORMAT_R8_G8_B8_A8) {
      var temp = new Uint8Array(pixelData.length);
      for (var i = 0; i < pixelData.length; i++) {
        temp[i] = pixelData[i] * mult8Bit * 255;
      }
      pixelData = temp;
    }
    pixels.set(pixelData);
    texture.unlock();
    return texture;
  };
  function frac(f) {
    return f - Math.floor(f);
  }
  function encodeFloatRGBA(v) {
    var encX = frac(v);
    var encY = frac(255.0 * v);
    var encZ = frac(65025.0 * v);
    var encW = frac(160581375.0 * v);
    encX -= encY / 255.0;
    encY -= encZ / 255.0;
    encZ -= encW / 255.0;
    encW -= encW / 255.0;
    return [encX, encY, encZ, encW];
  }
  function encodeFloatRG(v) {
    var encX = frac(v);
    var encY = frac(255.0 * v);
    encX -= encY / 255.0;
    encY -= encY / 255.0;
    return [encX, encY];
  }
  function saturate(x) {
    return Math.max(Math.min(x, 1), 0);
  }
  function glMod(x, y) {
    return x - y * Math.floor(x / y);
  }
  var default0Curve = new pc.Curve([0, 0, 1, 0]);
  var default1Curve = new pc.Curve([0, 1, 1, 1]);
  var default0Curve3 = new pc.CurveSet([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]);
  var default1Curve3 = new pc.CurveSet([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);
  var particleTexHeight = 2;
  var particleTexChannels = 4;
  var velocityVec = new pc.Vec3;
  var localVelocityVec = new pc.Vec3;
  var velocityVec2 = new pc.Vec3;
  var localVelocityVec2 = new pc.Vec3;
  var rndFactor3Vec = new pc.Vec3;
  var particlePosPrev = new pc.Vec3;
  var particlePos = new pc.Vec3;
  var particleFinalPos = new pc.Vec3;
  var moveDirVec = new pc.Vec3;
  var rotMat = new pc.Mat4;
  var spawnMatrix3 = new pc.Mat3;
  var emitterMatrix3 = new pc.Mat3;
  var uniformScale = 1;
  var nonUniformScale;
  var spawnMatrix = new pc.Mat4;
  var randomPos = new pc.Vec3;
  var randomPosTformed = new pc.Vec3;
  var tmpVec3 = new pc.Vec3;
  var bMin = new pc.Vec3;
  var bMax = new pc.Vec3;
  var setPropertyTarget;
  var setPropertyOptions;
  function setProperty(pName, defaultVal) {
    if (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {
      setPropertyTarget[pName] = setPropertyOptions[pName];
    } else {
      setPropertyTarget[pName] = defaultVal;
    }
  }
  function pack3NFloats(a, b, c) {
    var packed = a * 255 << 16 | b * 255 << 8 | c * 255;
    return packed / (1 << 24);
  }
  function packTextureXYZ_NXYZ(qXYZ, qXYZ2) {
    var num = qXYZ.length / 3;
    var colors = new Array(num * 4);
    for (var i = 0; i < num; i++) {
      colors[i * 4] = qXYZ[i * 3];
      colors[i * 4 + 1] = qXYZ[i * 3 + 1];
      colors[i * 4 + 2] = qXYZ[i * 3 + 2];
      colors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);
    }
    return colors;
  }
  function packTextureRGBA(qRGB, qA) {
    var colors = new Array(qA.length * 4);
    for (var i = 0; i < qA.length; i++) {
      colors[i * 4] = qRGB[i * 3];
      colors[i * 4 + 1] = qRGB[i * 3 + 1];
      colors[i * 4 + 2] = qRGB[i * 3 + 2];
      colors[i * 4 + 3] = qA[i];
    }
    return colors;
  }
  function packTexture5Floats(qA, qB, qC, qD, qE) {
    var colors = new Array(qA.length * 4);
    for (var i = 0; i < qA.length; i++) {
      colors[i * 4] = qA[i];
      colors[i * 4 + 1] = qB[i];
      colors[i * 4 + 2] = 0;
      colors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);
    }
    return colors;
  }
  var ParticleEmitter = function(graphicsDevice, options) {
    this.graphicsDevice = graphicsDevice;
    var gd = graphicsDevice;
    var precision = 32;
    this.precision = precision;
    this._addTimeTime = 0;
    if (!ParticleEmitter.DEFAULT_PARAM_TEXTURE) {
      var resolution = 16;
      var centerPoint = resolution * 0.5 + 0.5;
      var dtex = new Float32Array(resolution * resolution * 4);
      var x, y, xgrad, ygrad, p, c;
      for (y = 0; y < resolution; y++) {
        for (x = 0; x < resolution; x++) {
          xgrad = x + 1 - centerPoint;
          ygrad = y + 1 - centerPoint;
          c = saturate(1 - saturate(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution) - 0.5);
          p = y * resolution + x;
          dtex[p * 4] = 1;
          dtex[p * 4 + 1] = 1;
          dtex[p * 4 + 2] = 1;
          dtex[p * 4 + 3] = c;
        }
      }
      ParticleEmitter.DEFAULT_PARAM_TEXTURE = _createTexture(gd, resolution, resolution, dtex, pc.PIXELFORMAT_R8_G8_B8_A8, 1.0, true);
      ParticleEmitter.DEFAULT_PARAM_TEXTURE.minFilter = pc.FILTER_LINEAR;
      ParticleEmitter.DEFAULT_PARAM_TEXTURE.magFilter = pc.FILTER_LINEAR;
    }
    setPropertyTarget = this;
    setPropertyOptions = options;
    setProperty("numParticles", 1);
    if (this.numParticles > graphicsDevice.maxTextureSize) {
      console.warn("WARNING: can't create more than " + graphicsDevice.maxTextureSize + " particles on this device.");
      this.numParticles = graphicsDevice.maxTextureSize;
    }
    setProperty("rate", 1);
    setProperty("rate2", this.rate);
    setProperty("lifetime", 50);
    setProperty("emitterExtents", new pc.Vec3(0, 0, 0));
    setProperty("emitterRadius", 0);
    setProperty("emitterShape", pc.EMITTERSHAPE_BOX);
    setProperty("initialVelocity", 1);
    setProperty("wrap", false);
    setProperty("localSpace", false);
    setProperty("wrapBounds", null);
    setProperty("colorMap", ParticleEmitter.DEFAULT_PARAM_TEXTURE);
    setProperty("normalMap", null);
    setProperty("loop", true);
    setProperty("preWarm", false);
    setProperty("sort", pc.PARTICLESORT_NONE);
    setProperty("mode", pc.PARTICLEMODE_GPU);
    setProperty("scene", null);
    setProperty("lighting", false);
    setProperty("halfLambert", false);
    setProperty("intensity", 1.0);
    setProperty("stretch", 0.0);
    setProperty("alignToMotion", false);
    setProperty("depthSoftening", 0);
    setProperty("mesh", null);
    setProperty("depthWrite", false);
    setProperty("noFog", false);
    setProperty("blendType", pc.BLEND_NORMAL);
    setProperty("node", null);
    setProperty("startAngle", 0);
    setProperty("startAngle2", this.startAngle);
    setProperty("animTilesX", 1);
    setProperty("animTilesY", 1);
    setProperty("animNumFrames", 1);
    setProperty("animSpeed", 1);
    setProperty("animLoop", true);
    this.frameRandomUniform = new Float32Array(3);
    this.emitterPosUniform = new Float32Array(3);
    this.wrapBoundsUniform = new Float32Array(3);
    this.emitterScaleUniform = new Float32Array([1, 1, 1]);
    setProperty("colorGraph", default1Curve3);
    setProperty("colorGraph2", this.colorGraph);
    setProperty("scaleGraph", default1Curve);
    setProperty("scaleGraph2", this.scaleGraph);
    setProperty("alphaGraph", default1Curve);
    setProperty("alphaGraph2", this.alphaGraph);
    setProperty("localVelocityGraph", default0Curve3);
    setProperty("localVelocityGraph2", this.localVelocityGraph);
    setProperty("velocityGraph", default0Curve3);
    setProperty("velocityGraph2", this.velocityGraph);
    setProperty("rotationSpeedGraph", default0Curve);
    setProperty("rotationSpeedGraph2", this.rotationSpeedGraph);
    this.constantParticleTexIN = gd.scope.resolve("particleTexIN");
    this.constantParticleTexOUT = gd.scope.resolve("particleTexOUT");
    this.constantEmitterPos = gd.scope.resolve("emitterPos");
    this.constantEmitterScale = gd.scope.resolve("emitterScale");
    this.constantSpawnBounds = gd.scope.resolve("spawnBounds");
    this.constantSpawnBoundsSphere = gd.scope.resolve("spawnBoundsSphere");
    this.constantInitialVelocity = gd.scope.resolve("initialVelocity");
    this.constantFrameRandom = gd.scope.resolve("frameRandom");
    this.constantDelta = gd.scope.resolve("delta");
    this.constantRate = gd.scope.resolve("rate");
    this.constantRateDiv = gd.scope.resolve("rateDiv");
    this.constantLifetime = gd.scope.resolve("lifetime");
    this.constantLightCube = gd.scope.resolve("lightCube[0]");
    this.constantGraphSampleSize = gd.scope.resolve("graphSampleSize");
    this.constantGraphNumSamples = gd.scope.resolve("graphNumSamples");
    this.constantInternalTex0 = gd.scope.resolve("internalTex0");
    this.constantInternalTex1 = gd.scope.resolve("internalTex1");
    this.constantInternalTex2 = gd.scope.resolve("internalTex2");
    this.constantEmitterMatrix = gd.scope.resolve("emitterMatrix");
    this.constantNumParticles = gd.scope.resolve("numParticles");
    this.constantNumParticlesPot = gd.scope.resolve("numParticlesPot");
    this.constantLocalVelocityDivMult = gd.scope.resolve("localVelocityDivMult");
    this.constantVelocityDivMult = gd.scope.resolve("velocityDivMult");
    this.constantRotSpeedDivMult = gd.scope.resolve("rotSpeedDivMult");
    this.constantSeed = gd.scope.resolve("seed");
    this.constantStartAngle = gd.scope.resolve("startAngle");
    this.constantStartAngle2 = gd.scope.resolve("startAngle2");
    this.constantOutBoundsMul = gd.scope.resolve("outBoundsMul");
    this.constantOutBoundsAdd = gd.scope.resolve("outBoundsAdd");
    this.constantInBoundsSize = gd.scope.resolve("inBoundsSize");
    this.constantInBoundsCenter = gd.scope.resolve("inBoundsCenter");
    this.constantMaxVel = gd.scope.resolve("maxVel");
    this.lightCube = new Float32Array(6 * 3);
    this.lightCubeDir = new Array(6);
    this.lightCubeDir[0] = new pc.Vec3(-1, 0, 0);
    this.lightCubeDir[1] = new pc.Vec3(1, 0, 0);
    this.lightCubeDir[2] = new pc.Vec3(0, -1, 0);
    this.lightCubeDir[3] = new pc.Vec3(0, 1, 0);
    this.lightCubeDir[4] = new pc.Vec3(0, 0, -1);
    this.lightCubeDir[5] = new pc.Vec3(0, 0, 1);
    this.animParams = new Float32Array(4);
    this.internalTex0 = null;
    this.internalTex1 = null;
    this.internalTex2 = null;
    this.internalTex3 = null;
    this.vbToSort = null;
    this.vbOld = null;
    this.particleDistance = null;
    this.camera = null;
    this.swapTex = false;
    this.useMesh = true;
    this.useCpu = false;
    this.pack8 = true;
    this.localBounds = new pc.BoundingBox;
    this.worldBoundsNoTrail = new pc.BoundingBox;
    this.worldBoundsTrail = [new pc.BoundingBox, new pc.BoundingBox];
    this.worldBounds = new pc.BoundingBox;
    this.inBoundsCenterUniform = new Float32Array(3);
    this.worldBoundsSize = new pc.Vec3;
    this.inBoundsSizeUniform = new Float32Array(3);
    this.prevWorldBoundsSize = new pc.Vec3;
    this.prevWorldBoundsCenter = new pc.Vec3;
    this.worldBoundsMul = new pc.Vec3;
    this.worldBoundsMulUniform = new Float32Array(3);
    this.worldBoundsAdd = new pc.Vec3;
    this.worldBoundsAddUniform = new Float32Array(3);
    this.timeToSwitchBounds = 0;
    this.shaderParticleUpdateRespawn = null;
    this.shaderParticleUpdateNoRespawn = null;
    this.shaderParticleUpdateOnStop = null;
    this.numParticleVerts = 0;
    this.numParticleIndices = 0;
    this.material = null;
    this.meshInstance = null;
    this.seed = 0;
    this.fixedTimeStep = 1.0 / 60;
    this.maxSubSteps = 10;
    this.simTime = 0;
    this.simTimeTotal = 0;
    this.beenReset = false;
    this._layer = null;
    this.rebuild();
  };
  function calcEndTime(emitter) {
    var interval = Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime;
    return Date.now() + interval * 1000;
  }
  function subGraph(A, B) {
    var r = new Float32Array(A.length);
    for (var i = 0; i < A.length; i++) {
      r[i] = A[i] - B[i];
    }
    return r;
  }
  function maxUnsignedGraphValue(A, outUMax) {
    var i, j;
    var chans = outUMax.length;
    var values = A.length / chans;
    for (i = 0; i < values; i++) {
      for (j = 0; j < chans; j++) {
        var a = Math.abs(A[i * chans + j]);
        outUMax[j] = Math.max(outUMax[j], a);
      }
    }
  }
  function normalizeGraph(A, uMax) {
    var chans = uMax.length;
    var i, j;
    var values = A.length / chans;
    for (i = 0; i < values; i++) {
      for (j = 0; j < chans; j++) {
        A[i * chans + j] /= uMax[j];
        A[i * chans + j] *= 0.5;
        A[i * chans + j] += 0.5;
      }
    }
  }
  function divGraphFrom2Curves(curve1, curve2, outUMax) {
    var sub = subGraph(curve2, curve1);
    maxUnsignedGraphValue(sub, outUMax);
    normalizeGraph(sub, outUMax);
    return sub;
  }
  function mat4ToMat3(mat4, mat3) {
    mat3.data[0] = mat4.data[0];
    mat3.data[1] = mat4.data[1];
    mat3.data[2] = mat4.data[2];
    mat3.data[3] = mat4.data[4];
    mat3.data[4] = mat4.data[5];
    mat3.data[5] = mat4.data[6];
    mat3.data[6] = mat4.data[8];
    mat3.data[7] = mat4.data[9];
    mat3.data[8] = mat4.data[10];
  }
  Object.assign(ParticleEmitter.prototype, {onChangeCamera:function() {
    this.regenShader();
    this.resetMaterial();
  }, calculateBoundsMad:function() {
    this.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;
    this.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;
    this.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;
    this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).scale(-1);
    this.worldBoundsAdd.x += 0.5;
    this.worldBoundsAdd.y += 0.5;
    this.worldBoundsAdd.z += 0.5;
  }, calculateWorldBounds:function() {
    if (!this.node) {
      return;
    }
    this.prevWorldBoundsSize.copy(this.worldBoundsSize);
    this.prevWorldBoundsCenter.copy(this.worldBounds.center);
    this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.node.getWorldTransform());
    this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);
    var now = this.simTimeTotal;
    if (now > this.timeToSwitchBounds) {
      var tmp = this.worldBoundsTrail[0];
      this.worldBoundsTrail[0] = this.worldBoundsTrail[1];
      this.worldBoundsTrail[1] = tmp;
      this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);
      this.timeToSwitchBounds = now + this.lifetime;
    }
    this.worldBounds.copy(this.worldBoundsTrail[0]);
    this.worldBounds.add(this.worldBoundsTrail[1]);
    this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2);
    this.meshInstance.mesh.aabb = this.worldBounds;
    this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;
    if (this.pack8) {
      this.calculateBoundsMad();
    }
  }, calculateLocalBounds:function() {
    var minx = Number.MAX_VALUE;
    var miny = Number.MAX_VALUE;
    var minz = Number.MAX_VALUE;
    var maxx = -Number.MAX_VALUE;
    var maxy = -Number.MAX_VALUE;
    var maxz = -Number.MAX_VALUE;
    var maxScale = 0;
    var stepWeight = this.lifetime / this.precision;
    var vels = [this.qVelocity, this.qVelocity2, this.qLocalVelocity, this.qLocalVelocity2];
    var accumX = [0, 0, 0, 0];
    var accumY = [0, 0, 0, 0];
    var accumZ = [0, 0, 0, 0];
    var i, j;
    var index;
    var x, y, z;
    for (i = 0; i < this.precision + 1; i++) {
      index = Math.min(i, this.precision - 1);
      for (j = 0; j < 4; j++) {
        x = vels[j][index * 3] * stepWeight + accumX[j];
        y = vels[j][index * 3 + 1] * stepWeight + accumY[j];
        z = vels[j][index * 3 + 2] * stepWeight + accumZ[j];
        if (minx > x) {
          minx = x;
        }
        if (miny > y) {
          miny = y;
        }
        if (minz > z) {
          minz = z;
        }
        if (maxx < x) {
          maxx = x;
        }
        if (maxy < y) {
          maxy = y;
        }
        if (maxz < z) {
          maxz = z;
        }
        accumX[j] = x;
        accumY[j] = y;
        accumZ[j] = z;
      }
      maxScale = Math.max(maxScale, this.qScale[index]);
    }
    if (this.emitterShape === pc.EMITTERSHAPE_BOX) {
      x = this.emitterExtents.x * 0.5;
      y = this.emitterExtents.y * 0.5;
      z = this.emitterExtents.z * 0.5;
      if (maxx < x) {
        maxx = x;
      }
      if (maxy < y) {
        maxy = y;
      }
      if (maxz < z) {
        maxz = z;
      }
      x = -x;
      y = -y;
      z = -z;
      if (minx > x) {
        minx = x;
      }
      if (miny > y) {
        miny = y;
      }
      if (minz > z) {
        minz = z;
      }
    } else {
      x = this.emitterRadius;
      y = this.emitterRadius;
      z = this.emitterRadius;
      if (maxx < x) {
        maxx = x;
      }
      if (maxy < y) {
        maxy = y;
      }
      if (maxz < z) {
        maxz = z;
      }
      x = -x;
      y = -y;
      z = -z;
      if (minx > x) {
        minx = x;
      }
      if (miny > y) {
        miny = y;
      }
      if (minz > z) {
        minz = z;
      }
    }
    bMin.x = minx - maxScale;
    bMin.y = miny - maxScale;
    bMin.z = minz - maxScale;
    bMax.x = maxx + maxScale;
    bMax.y = maxy + maxScale;
    bMax.z = maxz + maxScale;
    this.localBounds.setMinMax(bMin, bMax);
  }, rebuild:function() {
    var i;
    var gd = this.graphicsDevice;
    if (this.colorMap === null) {
      this.colorMap = ParticleEmitter.DEFAULT_PARAM_TEXTURE;
    }
    this.spawnBounds = this.emitterShape === pc.EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;
    this.useCpu = this.useCpu || this.sort > pc.PARTICLESORT_NONE || gd.maxVertexTextures <= 1 || gd.fragmentUniformsCount < 64 || gd.forceCpuParticles || !gd.extTextureFloat;
    this._destroyResources();
    this.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;
    particleTexHeight = this.useCpu || this.pack8 ? 4 : 2;
    this.useMesh = false;
    if (this.mesh) {
      var totalVertCount = this.numParticles * this.mesh.vertexBuffer.numVertices;
      if (totalVertCount > 65535) {
        console.warn("WARNING: particle system can't render mesh particles because numParticles * numVertices is more than 65k. Reverting to quad particles.");
      } else {
        this.useMesh = true;
      }
    }
    this.numParticlesPot = pc.math.nextPowerOfTwo(this.numParticles);
    this.rebuildGraphs();
    this.calculateLocalBounds();
    if (this.node) {
      this.worldBounds.setFromTransformedAabb(this.localBounds, this.node.getWorldTransform());
      this.worldBoundsTrail[0].copy(this.worldBounds);
      this.worldBoundsTrail[1].copy(this.worldBounds);
      this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2);
      this.prevWorldBoundsSize.copy(this.worldBoundsSize);
      this.prevWorldBoundsCenter.copy(this.worldBounds.center);
      if (this.pack8) {
        this.calculateBoundsMad();
      }
    }
    this.vbToSort = new Array(this.numParticles);
    this.particleDistance = new Float32Array(this.numParticles);
    this.frameRandomUniform[0] = Math.random();
    this.frameRandomUniform[1] = Math.random();
    this.frameRandomUniform[2] = Math.random();
    this.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
    var emitterPos = this.node === null || this.localSpace ? pc.Vec3.ZERO : this.node.getPosition();
    if (this.emitterShape === pc.EMITTERSHAPE_BOX) {
      if (this.node === null) {
        spawnMatrix.setTRS(pc.Vec3.ZERO, pc.Quat.IDENTITY, this.spawnBounds);
      } else {
        spawnMatrix.setTRS(pc.Vec3.ZERO, this.node.getRotation(), tmpVec3.copy(this.spawnBounds).mul(this.node.localScale));
      }
    }
    for (i = 0; i < this.numParticles; i++) {
      this.calcSpawnPosition(emitterPos, i);
      if (this.useCpu) {
        this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;
      }
    }
    this.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
    for (i = 0; i < this.particleTexStart.length; i++) {
      this.particleTexStart[i] = this.particleTex[i];
    }
    if (!this.useCpu) {
      if (this.pack8) {
        this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, pc.PIXELFORMAT_R8_G8_B8_A8, 1, false);
        this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, pc.PIXELFORMAT_R8_G8_B8_A8, 1, false);
        this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, pc.PIXELFORMAT_R8_G8_B8_A8, 1, false);
      } else {
        this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
        this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
        this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);
      }
      this.rtParticleTexIN = new pc.RenderTarget(gd, this.particleTexIN, {depth:false});
      this.rtParticleTexOUT = new pc.RenderTarget(gd, this.particleTexOUT, {depth:false});
      this.swapTex = false;
    }
    var chunks = pc.shaderChunks;
    var shaderCodeStart = chunks.particleUpdaterInitPS + (this.pack8 ? chunks.particleInputRgba8PS + chunks.particleOutputRgba8PS : chunks.particleInputFloatPS + chunks.particleOutputFloatPS) + (this.emitterShape === pc.EMITTERSHAPE_BOX ? chunks.particleUpdaterAABBPS : chunks.particleUpdaterSpherePS) + chunks.particleUpdaterStartPS;
    var shaderCodeRespawn = shaderCodeStart + chunks.particleUpdaterRespawnPS + chunks.particleUpdaterEndPS;
    var shaderCodeNoRespawn = shaderCodeStart + chunks.particleUpdaterNoRespawnPS + chunks.particleUpdaterEndPS;
    var shaderCodeOnStop = shaderCodeStart + chunks.particleUpdaterOnStopPS + chunks.particleUpdaterEndPS;
    this.shaderParticleUpdateRespawn = chunks.createShaderFromCode(gd, chunks.fullscreenQuadVS, shaderCodeRespawn, "fsQuad0" + this.emitterShape + "" + this.pack8);
    this.shaderParticleUpdateNoRespawn = chunks.createShaderFromCode(gd, chunks.fullscreenQuadVS, shaderCodeNoRespawn, "fsQuad1" + this.emitterShape + "" + this.pack8);
    this.shaderParticleUpdateOnStop = chunks.createShaderFromCode(gd, chunks.fullscreenQuadVS, shaderCodeOnStop, "fsQuad2" + this.emitterShape + "" + this.pack8);
    this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;
    this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;
    this._allocate(this.numParticles);
    var mesh = new pc.Mesh;
    mesh.vertexBuffer = this.vertexBuffer;
    mesh.indexBuffer[0] = this.indexBuffer;
    mesh.primitive[0].type = pc.PRIMITIVE_TRIANGLES;
    mesh.primitive[0].base = 0;
    mesh.primitive[0].count = this.numParticles * this.numParticleIndices;
    mesh.primitive[0].indexed = true;
    this.material = new pc.Material;
    this.material.name = this.node.name;
    this.material.cull = pc.CULLFACE_NONE;
    this.material.alphaWrite = false;
    this.material.blend = true;
    this.material.blendType = this.blendType;
    this.material.depthWrite = this.depthWrite;
    this.material.emitter = this;
    this.regenShader();
    this.resetMaterial();
    var wasVisible = this.meshInstance ? this.meshInstance.visible : true;
    this.meshInstance = new pc.MeshInstance(this.node, mesh, this.material);
    this.meshInstance.pick = false;
    this.meshInstance.updateKey();
    this.meshInstance.cull = true;
    this.meshInstance._noDepthDrawGl1 = true;
    this.meshInstance.aabb = this.worldBounds;
    this.meshInstance._updateAabb = false;
    this.meshInstance.visible = wasVisible;
    this._initializeTextures();
    this.addTime(0, false);
    if (this.preWarm) {
      this.prewarm(this.lifetime);
    }
    this.resetTime();
  }, _isAnimated:function() {
    return this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== ParticleEmitter.DEFAULT_PARAM_TEXTURE || this.normalMap);
  }, calcSpawnPosition:function(emitterPos, i) {
    var rX = Math.random();
    var rY = Math.random();
    var rZ = Math.random();
    var rW = Math.random();
    if (this.useCpu) {
      this.particleTex[i * particleTexChannels + 0 + this.numParticlesPot * 2 * particleTexChannels] = rX;
      this.particleTex[i * particleTexChannels + 1 + this.numParticlesPot * 2 * particleTexChannels] = rY;
      this.particleTex[i * particleTexChannels + 2 + this.numParticlesPot * 2 * particleTexChannels] = rZ;
    }
    randomPos.x = rX - 0.5;
    randomPos.y = rY - 0.5;
    randomPos.z = rZ - 0.5;
    if (this.emitterShape === pc.EMITTERSHAPE_BOX) {
      randomPosTformed.copy(emitterPos).add(spawnMatrix.transformPoint(randomPos));
    } else {
      randomPos.normalize();
      randomPosTformed.copy(emitterPos).add(randomPos.scale(rW * this.spawnBounds));
    }
    var particleRate, startSpawnTime;
    if (this.pack8) {
      var packX = (randomPosTformed.x - this.worldBounds.center.x) / this.worldBoundsSize.x + 0.5;
      var packY = (randomPosTformed.y - this.worldBounds.center.y) / this.worldBoundsSize.y + 0.5;
      var packZ = (randomPosTformed.z - this.worldBounds.center.z) / this.worldBoundsSize.z + 0.5;
      var packA = pc.math.lerp(this.startAngle * pc.math.DEG_TO_RAD, this.startAngle2 * pc.math.DEG_TO_RAD, rX);
      packA = packA % (Math.PI * 2) / (Math.PI * 2);
      var rg0 = encodeFloatRG(packX);
      this.particleTex[i * particleTexChannels] = rg0[0];
      this.particleTex[i * particleTexChannels + 1] = rg0[1];
      var ba0 = encodeFloatRG(packY);
      this.particleTex[i * particleTexChannels + 2] = ba0[0];
      this.particleTex[i * particleTexChannels + 3] = ba0[1];
      var rg1 = encodeFloatRG(packZ);
      this.particleTex[i * particleTexChannels + 0 + this.numParticlesPot * particleTexChannels] = rg1[0];
      this.particleTex[i * particleTexChannels + 1 + this.numParticlesPot * particleTexChannels] = rg1[1];
      var ba1 = encodeFloatRG(packA);
      this.particleTex[i * particleTexChannels + 2 + this.numParticlesPot * particleTexChannels] = ba1[0];
      this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * particleTexChannels] = ba1[1];
      var a2 = 1.0;
      this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * particleTexChannels * 2] = a2;
      particleRate = pc.math.lerp(this.rate, this.rate2, rX);
      startSpawnTime = -particleRate * i;
      var maxNegLife = Math.max(this.lifetime, (this.numParticles - 1.0) * Math.max(this.rate, this.rate2));
      var maxPosLife = this.lifetime + 1.0;
      startSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);
      var rgba3 = encodeFloatRGBA(startSpawnTime);
      this.particleTex[i * particleTexChannels + 0 + this.numParticlesPot * particleTexChannels * 3] = rgba3[0];
      this.particleTex[i * particleTexChannels + 1 + this.numParticlesPot * particleTexChannels * 3] = rgba3[1];
      this.particleTex[i * particleTexChannels + 2 + this.numParticlesPot * particleTexChannels * 3] = rgba3[2];
      this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * particleTexChannels * 3] = rgba3[3];
    } else {
      this.particleTex[i * particleTexChannels] = randomPosTformed.x;
      this.particleTex[i * particleTexChannels + 1] = randomPosTformed.y;
      this.particleTex[i * particleTexChannels + 2] = randomPosTformed.z;
      this.particleTex[i * particleTexChannels + 3] = pc.math.lerp(this.startAngle * pc.math.DEG_TO_RAD, this.startAngle2 * pc.math.DEG_TO_RAD, rX);
      particleRate = pc.math.lerp(this.rate, this.rate2, rX);
      startSpawnTime = -particleRate * i;
      this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * particleTexChannels] = startSpawnTime;
    }
  }, rebuildGraphs:function() {
    var precision = this.precision;
    var gd = this.graphicsDevice;
    var i;
    this.qLocalVelocity = this.localVelocityGraph.quantize(precision);
    this.qVelocity = this.velocityGraph.quantize(precision);
    this.qColor = this.colorGraph.quantize(precision);
    this.qRotSpeed = this.rotationSpeedGraph.quantize(precision);
    this.qScale = this.scaleGraph.quantize(precision);
    this.qAlpha = this.alphaGraph.quantize(precision);
    this.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);
    this.qVelocity2 = this.velocityGraph2.quantize(precision);
    this.qColor2 = this.colorGraph2.quantize(precision);
    this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(precision);
    this.qScale2 = this.scaleGraph2.quantize(precision);
    this.qAlpha2 = this.alphaGraph2.quantize(precision);
    for (i = 0; i < precision; i++) {
      this.qRotSpeed[i] *= pc.math.DEG_TO_RAD;
      this.qRotSpeed2[i] *= pc.math.DEG_TO_RAD;
    }
    this.localVelocityUMax = new Float32Array(3);
    this.velocityUMax = new Float32Array(3);
    this.colorUMax = new Float32Array(3);
    this.rotSpeedUMax = [0];
    this.scaleUMax = [0];
    this.alphaUMax = [0];
    this.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);
    this.qVelocityDiv = divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);
    this.qColorDiv = divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);
    this.qRotSpeedDiv = divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);
    this.qScaleDiv = divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);
    this.qAlphaDiv = divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);
    if (this.pack8) {
      var umax = [0, 0, 0];
      maxUnsignedGraphValue(this.qVelocity, umax);
      var umax2 = [0, 0, 0];
      maxUnsignedGraphValue(this.qVelocity2, umax2);
      var lumax = [0, 0, 0];
      maxUnsignedGraphValue(this.qLocalVelocity, lumax);
      var lumax2 = [0, 0, 0];
      maxUnsignedGraphValue(this.qLocalVelocity2, lumax2);
      var maxVel = Math.max(umax[0], umax2[0]);
      maxVel = Math.max(maxVel, umax[1]);
      maxVel = Math.max(maxVel, umax2[1]);
      maxVel = Math.max(maxVel, umax[2]);
      maxVel = Math.max(maxVel, umax2[2]);
      var lmaxVel = Math.max(lumax[0], lumax2[0]);
      lmaxVel = Math.max(lmaxVel, lumax[1]);
      lmaxVel = Math.max(lmaxVel, lumax2[1]);
      lmaxVel = Math.max(lmaxVel, lumax[2]);
      lmaxVel = Math.max(lmaxVel, lumax2[2]);
      this.maxVel = maxVel + lmaxVel;
    }
    if (!this.useCpu) {
      this.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));
      this.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));
      this.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));
    }
    this.internalTex3 = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), pc.PIXELFORMAT_R8_G8_B8_A8, 1.0, true);
  }, _initializeTextures:function() {
    if (this.colorMap) {
      this.material.setParameter("colorMap", this.colorMap);
      if (this.lighting && this.normalMap) {
        this.material.setParameter("normalMap", this.normalMap);
      }
    }
  }, regenShader:function() {
    var programLib = this.graphicsDevice.getProgramLibrary();
    var hasNormal = this.normalMap !== null;
    this.normalOption = 0;
    if (this.lighting) {
      this.normalOption = hasNormal ? 2 : 1;
    }
    this.material.updateShader = function() {
      if (this.emitter.scene) {
        if (this.emitter.camera != this.emitter.scene._activeCamera) {
          this.emitter.camera = this.emitter.scene._activeCamera;
          this.emitter.onChangeCamera();
        }
      }
      var shader = programLib.getProgram("particle", {useCpu:this.emitter.useCpu, normal:this.emitter.normalOption, halflambert:this.emitter.halfLambert, stretch:this.emitter.stretch, alignToMotion:this.emitter.alignToMotion, soft:this.emitter.depthSoftening, mesh:this.emitter.useMesh, gamma:this.emitter.scene ? this.emitter.scene.gammaCorrection : 0, toneMap:this.emitter.scene ? this.emitter.scene.toneMapping : 0, fog:this.emitter.scene && !this.emitter.noFog ? this.emitter.scene.fog : "none", wrap:this.emitter.wrap && 
      this.emitter.wrapBounds, localSpace:this.emitter.localSpace, blend:this.blendType, animTex:this.emitter._isAnimated(), animTexLoop:this.emitter.animLoop, pack8:this.emitter.pack8});
      this.shader = shader;
    };
    this.material.updateShader();
  }, resetMaterial:function() {
    var material = this.material;
    material.setParameter("stretch", this.stretch);
    if (this._isAnimated()) {
      material.setParameter("animTexParams", this.animParams);
    }
    material.setParameter("colorMult", this.intensity);
    if (!this.useCpu) {
      material.setParameter("internalTex0", this.internalTex0);
      material.setParameter("internalTex1", this.internalTex1);
      material.setParameter("internalTex2", this.internalTex2);
    }
    material.setParameter("internalTex3", this.internalTex3);
    material.setParameter("numParticles", this.numParticles);
    material.setParameter("numParticlesPot", this.numParticlesPot);
    material.setParameter("lifetime", this.lifetime);
    material.setParameter("rate", this.rate);
    material.setParameter("rateDiv", this.rate2 - this.rate);
    material.setParameter("seed", this.seed);
    material.setParameter("scaleDivMult", this.scaleUMax[0]);
    material.setParameter("alphaDivMult", this.alphaUMax[0]);
    material.setParameter("graphNumSamples", this.precision);
    material.setParameter("graphSampleSize", 1.0 / this.precision);
    material.setParameter("emitterScale", new Float32Array([1, 1, 1]));
    if (this.pack8) {
      this.inBoundsSizeUniform[0] = this.worldBoundsSize.x;
      this.inBoundsSizeUniform[1] = this.worldBoundsSize.y;
      this.inBoundsSizeUniform[2] = this.worldBoundsSize.z;
      material.setParameter("inBoundsSize", this.inBoundsSizeUniform);
      this.inBoundsCenterUniform[0] = this.worldBounds.center.x;
      this.inBoundsCenterUniform[1] = this.worldBounds.center.y;
      this.inBoundsCenterUniform[2] = this.worldBounds.center.z;
      material.setParameter("inBoundsCenter", this.inBoundsCenterUniform);
      material.setParameter("maxVel", this.maxVel);
    }
    if (this.wrap && this.wrapBounds) {
      this.wrapBoundsUniform[0] = this.wrapBounds.x;
      this.wrapBoundsUniform[1] = this.wrapBounds.y;
      this.wrapBoundsUniform[2] = this.wrapBounds.z;
      material.setParameter("wrapBounds", this.wrapBoundsUniform);
    }
    if (this.colorMap) {
      material.setParameter("colorMap", this.colorMap);
    }
    if (this.lighting) {
      if (this.normalMap) {
        material.setParameter("normalMap", this.normalMap);
      }
    }
    if (this.depthSoftening > 0) {
      material.setParameter("softening", 1.0 / (this.depthSoftening * this.depthSoftening * 100));
    }
    if (this.stretch > 0.0) {
      material.cull = pc.CULLFACE_NONE;
    }
  }, _allocate:function(numParticles) {
    var psysVertCount = numParticles * this.numParticleVerts;
    var psysIndexCount = numParticles * this.numParticleIndices;
    var elements, particleFormat;
    var i;
    if (this.vertexBuffer === undefined || this.vertexBuffer.getNumVertices() !== psysVertCount) {
      if (!this.useCpu) {
        elements = [{semantic:pc.SEMANTIC_ATTR0, components:4, type:pc.TYPE_FLOAT32}];
        particleFormat = new pc.VertexFormat(this.graphicsDevice, elements);
        this.vertexBuffer = new pc.VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, pc.BUFFER_DYNAMIC);
        this.indexBuffer = new pc.IndexBuffer(this.graphicsDevice, pc.INDEXFORMAT_UINT16, psysIndexCount);
      } else {
        elements = [{semantic:pc.SEMANTIC_ATTR0, components:4, type:pc.TYPE_FLOAT32}, {semantic:pc.SEMANTIC_ATTR1, components:4, type:pc.TYPE_FLOAT32}, {semantic:pc.SEMANTIC_ATTR2, components:4, type:pc.TYPE_FLOAT32}, {semantic:pc.SEMANTIC_ATTR3, components:2, type:pc.TYPE_FLOAT32}];
        particleFormat = new pc.VertexFormat(this.graphicsDevice, elements);
        this.vertexBuffer = new pc.VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, pc.BUFFER_DYNAMIC);
        this.indexBuffer = new pc.IndexBuffer(this.graphicsDevice, pc.INDEXFORMAT_UINT16, psysIndexCount);
      }
      var data = new Float32Array(this.vertexBuffer.lock());
      var meshData, stride;
      if (this.useMesh) {
        meshData = new Float32Array(this.mesh.vertexBuffer.lock());
        stride = meshData.length / this.mesh.vertexBuffer.numVertices;
      }
      var id;
      for (i = 0; i < psysVertCount; i++) {
        id = Math.floor(i / this.numParticleVerts);
        if (!this.useMesh) {
          var vertID = i % 4;
          data[i * 4] = particleVerts[vertID][0];
          data[i * 4 + 1] = particleVerts[vertID][1];
          data[i * 4 + 2] = 0;
        } else {
          var vert = i % this.numParticleVerts;
          data[i * 4] = meshData[vert * stride];
          data[i * 4 + 1] = meshData[vert * stride + 1];
          data[i * 4 + 2] = meshData[vert * stride + 2];
        }
        data[i * 4 + 3] = id;
      }
      if (this.useCpu) {
        this.vbCPU = new Float32Array(data);
        this.vbOld = new Float32Array(this.vbCPU.length);
      }
      this.vertexBuffer.unlock();
      if (this.useMesh) {
        this.mesh.vertexBuffer.unlock();
      }
      var dst = 0;
      var indices = new Uint16Array(this.indexBuffer.lock());
      if (this.useMesh) {
        meshData = new Uint16Array(this.mesh.indexBuffer[0].lock());
      }
      for (i = 0; i < numParticles; i++) {
        if (!this.useMesh) {
          var baseIndex = i * 4;
          indices[dst++] = baseIndex;
          indices[dst++] = baseIndex + 1;
          indices[dst++] = baseIndex + 2;
          indices[dst++] = baseIndex;
          indices[dst++] = baseIndex + 2;
          indices[dst++] = baseIndex + 3;
        } else {
          for (var j = 0; j < this.numParticleIndices; j++) {
            indices[i * this.numParticleIndices + j] = meshData[j] + i * this.numParticleVerts;
          }
        }
      }
      this.indexBuffer.unlock();
      if (this.useMesh) {
        this.mesh.indexBuffer[0].unlock();
      }
    }
  }, reset:function() {
    this.beenReset = true;
    this.seed = Math.random();
    this.material.setParameter("seed", this.seed);
    if (this.useCpu) {
      for (var i = 0; i < this.particleTexStart.length; i++) {
        this.particleTex[i] = this.particleTexStart[i];
      }
    } else {
      this._initializeTextures();
    }
    this.resetTime();
    var origLoop = this.loop;
    this.loop = true;
    this.addTime(0, false);
    this.loop = origLoop;
    if (this.preWarm) {
      this.prewarm(this.lifetime);
    }
  }, prewarm:function(time) {
    var lifetimeFraction = time / this.lifetime;
    var iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);
    var stepDelta = time / iterations;
    for (var i = 0; i < iterations; i++) {
      this.addTime(stepDelta, false);
    }
  }, resetTime:function() {
    this.endTime = calcEndTime(this);
  }, finishFrame:function() {
    if (this.useCpu) {
      this.vertexBuffer.unlock();
    }
  }, addTime:function(delta, isOnStop) {
    var a, b, c, i, j;
    var device = this.graphicsDevice;
    this.simTimeTotal += delta;
    this.calculateWorldBounds();
    if (this._isAnimated()) {
      var params = this.animParams;
      params[0] = 1.0 / this.animTilesX;
      params[1] = 1.0 / this.animTilesY;
      params[2] = this.animNumFrames * this.animSpeed;
      params[3] = this.animNumFrames - 1;
    }
    if (this.scene) {
      if (this.camera != this.scene._activeCamera) {
        this.camera = this.scene._activeCamera;
        this.onChangeCamera();
      }
    }
    if (this.emitterShape === pc.EMITTERSHAPE_BOX) {
      if (this.meshInstance.node === null) {
        spawnMatrix.setTRS(pc.Vec3.ZERO, pc.Quat.IDENTITY, this.emitterExtents);
      } else {
        spawnMatrix.setTRS(pc.Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));
      }
    }
    var emitterPos;
    var emitterScale = this.meshInstance.node === null ? pc.Vec3.ONE : this.meshInstance.node.localScale;
    this.emitterScaleUniform[0] = emitterScale.x;
    this.emitterScaleUniform[1] = emitterScale.y;
    this.emitterScaleUniform[2] = emitterScale.z;
    this.material.setParameter("emitterScale", this.emitterScaleUniform);
    if (this.localSpace && this.meshInstance.node) {
      emitterPos = this.meshInstance.node.getPosition();
      this.emitterPosUniform[0] = emitterPos.x;
      this.emitterPosUniform[1] = emitterPos.y;
      this.emitterPosUniform[2] = emitterPos.z;
      this.material.setParameter("emitterPos", this.emitterPosUniform);
    }
    if (!this.useCpu) {
      device.setBlending(false);
      device.setColorWrite(true, true, true, true);
      device.setCullMode(pc.CULLFACE_NONE);
      device.setDepthTest(false);
      device.setDepthWrite(false);
      this.frameRandomUniform[0] = Math.random();
      this.frameRandomUniform[1] = Math.random();
      this.frameRandomUniform[2] = Math.random();
      this.constantGraphSampleSize.setValue(1.0 / this.precision);
      this.constantGraphNumSamples.setValue(this.precision);
      this.constantNumParticles.setValue(this.numParticles);
      this.constantNumParticlesPot.setValue(this.numParticlesPot);
      this.constantInternalTex0.setValue(this.internalTex0);
      this.constantInternalTex1.setValue(this.internalTex1);
      this.constantInternalTex2.setValue(this.internalTex2);
      if (this.pack8) {
        this.worldBoundsMulUniform[0] = this.worldBoundsMul.x;
        this.worldBoundsMulUniform[1] = this.worldBoundsMul.y;
        this.worldBoundsMulUniform[2] = this.worldBoundsMul.z;
        this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);
        this.worldBoundsAddUniform[0] = this.worldBoundsAdd.x;
        this.worldBoundsAddUniform[1] = this.worldBoundsAdd.y;
        this.worldBoundsAddUniform[2] = this.worldBoundsAdd.z;
        this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);
        this.inBoundsSizeUniform[0] = this.prevWorldBoundsSize.x;
        this.inBoundsSizeUniform[1] = this.prevWorldBoundsSize.y;
        this.inBoundsSizeUniform[2] = this.prevWorldBoundsSize.z;
        this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);
        this.inBoundsCenterUniform[0] = this.prevWorldBoundsCenter.x;
        this.inBoundsCenterUniform[1] = this.prevWorldBoundsCenter.y;
        this.inBoundsCenterUniform[2] = this.prevWorldBoundsCenter.z;
        this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);
        var maxVel = this.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);
        maxVel = Math.max(maxVel, 1);
        this.constantMaxVel.setValue(maxVel);
      }
      emitterPos = this.meshInstance.node === null || this.localSpace ? pc.Vec3.ZERO : this.meshInstance.node.getPosition();
      var emitterMatrix = this.meshInstance.node === null ? pc.Mat4.IDENTITY : this.meshInstance.node.getWorldTransform();
      if (this.emitterShape === pc.EMITTERSHAPE_BOX) {
        mat4ToMat3(spawnMatrix, spawnMatrix3);
        this.constantSpawnBounds.setValue(spawnMatrix3.data);
      } else {
        this.constantSpawnBoundsSphere.setValue(this.emitterRadius);
      }
      this.constantInitialVelocity.setValue(this.initialVelocity);
      mat4ToMat3(emitterMatrix, emitterMatrix3);
      this.emitterPosUniform[0] = emitterPos.x;
      this.emitterPosUniform[1] = emitterPos.y;
      this.emitterPosUniform[2] = emitterPos.z;
      this.constantEmitterPos.setValue(this.emitterPosUniform);
      this.constantFrameRandom.setValue(this.frameRandomUniform);
      this.constantDelta.setValue(delta);
      this.constantRate.setValue(this.rate);
      this.constantRateDiv.setValue(this.rate2 - this.rate);
      this.constantStartAngle.setValue(this.startAngle * pc.math.DEG_TO_RAD);
      this.constantStartAngle2.setValue(this.startAngle2 * pc.math.DEG_TO_RAD);
      this.constantSeed.setValue(this.seed);
      this.constantLifetime.setValue(this.lifetime);
      this.emitterScaleUniform[0] = emitterScale.x;
      this.emitterScaleUniform[1] = emitterScale.y;
      this.emitterScaleUniform[2] = emitterScale.z;
      this.constantEmitterScale.setValue(this.emitterScaleUniform);
      this.constantEmitterMatrix.setValue(emitterMatrix3.data);
      this.constantLocalVelocityDivMult.setValue(this.localVelocityUMax);
      this.constantVelocityDivMult.setValue(this.velocityUMax);
      this.constantRotSpeedDivMult.setValue(this.rotSpeedUMax[0]);
      var texIN = this.swapTex ? this.particleTexOUT : this.particleTexIN;
      texIN = this.beenReset ? this.particleTexStart : texIN;
      var texOUT = this.swapTex ? this.particleTexIN : this.particleTexOUT;
      this.constantParticleTexIN.setValue(texIN);
      if (!isOnStop) {
        pc.drawQuadWithShader(device, this.swapTex ? this.rtParticleTexIN : this.rtParticleTexOUT, this.loop ? this.shaderParticleUpdateRespawn : this.shaderParticleUpdateNoRespawn);
      } else {
        pc.drawQuadWithShader(device, this.swapTex ? this.rtParticleTexIN : this.rtParticleTexOUT, this.shaderParticleUpdateOnStop);
      }
      this.constantParticleTexOUT.setValue(texOUT);
      this.material.setParameter("particleTexOUT", texIN);
      this.material.setParameter("particleTexIN", texOUT);
      this.beenReset = false;
      this.swapTex = !this.swapTex;
      device.setDepthTest(true);
      device.setDepthWrite(true);
    } else {
      var data = new Float32Array(this.vertexBuffer.lock());
      if (this.meshInstance.node) {
        var fullMat = this.meshInstance.node.worldTransform;
        for (j = 0; j < 12; j++) {
          rotMat.data[j] = fullMat.data[j];
        }
        nonUniformScale = this.meshInstance.node.localScale;
        uniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);
      }
      emitterPos = this.meshInstance.node === null || this.localSpace ? pc.Vec3.ZERO : this.meshInstance.node.getPosition();
      var posCam = this.camera ? this.camera._node.getPosition() : pc.Vec3.ZERO;
      var vertSize = 14;
      var cf, cc;
      var rotSpeed, rotSpeed2, scale2, alpha, alpha2;
      var precision1 = this.precision - 1;
      for (i = 0; i < this.numParticles; i++) {
        var id = Math.floor(this.vbCPU[i * this.numParticleVerts * 4 + 3]);
        var rndFactor = this.particleTex[id * particleTexChannels + 0 + this.numParticlesPot * 2 * particleTexChannels];
        rndFactor3Vec.x = rndFactor;
        rndFactor3Vec.y = this.particleTex[id * particleTexChannels + 1 + this.numParticlesPot * 2 * particleTexChannels];
        rndFactor3Vec.z = this.particleTex[id * particleTexChannels + 2 + this.numParticlesPot * 2 * particleTexChannels];
        var particleRate = this.rate + (this.rate2 - this.rate) * rndFactor;
        var particleLifetime = this.lifetime;
        var life = this.particleTex[id * particleTexChannels + 3 + this.numParticlesPot * particleTexChannels] + delta;
        var nlife = saturate(life / particleLifetime);
        var scale = 0;
        var alphaDiv = 0;
        var angle = 0;
        var particleEnabled = life > 0.0 && life < particleLifetime;
        if (particleEnabled) {
          c = nlife * precision1;
          cf = Math.floor(c);
          cc = Math.ceil(c);
          c %= 1;
          a = this.qRotSpeed[cf];
          b = this.qRotSpeed[cc];
          rotSpeed = a + (b - a) * c;
          a = this.qRotSpeed2[cf];
          b = this.qRotSpeed2[cc];
          rotSpeed2 = a + (b - a) * c;
          a = this.qScale[cf];
          b = this.qScale[cc];
          scale = a + (b - a) * c;
          a = this.qScale2[cf];
          b = this.qScale2[cc];
          scale2 = a + (b - a) * c;
          a = this.qAlpha[cf];
          b = this.qAlpha[cc];
          alpha = a + (b - a) * c;
          a = this.qAlpha2[cf];
          b = this.qAlpha2[cc];
          alpha2 = a + (b - a) * c;
          cf *= 3;
          cc *= 3;
          a = this.qLocalVelocity[cf];
          b = this.qLocalVelocity[cc];
          localVelocityVec.x = a + (b - a) * c;
          a = this.qLocalVelocity[cf + 1];
          b = this.qLocalVelocity[cc + 1];
          localVelocityVec.y = a + (b - a) * c;
          a = this.qLocalVelocity[cf + 2];
          b = this.qLocalVelocity[cc + 2];
          localVelocityVec.z = a + (b - a) * c;
          a = this.qLocalVelocity2[cf];
          b = this.qLocalVelocity2[cc];
          localVelocityVec2.x = a + (b - a) * c;
          a = this.qLocalVelocity2[cf + 1];
          b = this.qLocalVelocity2[cc + 1];
          localVelocityVec2.y = a + (b - a) * c;
          a = this.qLocalVelocity2[cf + 2];
          b = this.qLocalVelocity2[cc + 2];
          localVelocityVec2.z = a + (b - a) * c;
          a = this.qVelocity[cf];
          b = this.qVelocity[cc];
          velocityVec.x = a + (b - a) * c;
          a = this.qVelocity[cf + 1];
          b = this.qVelocity[cc + 1];
          velocityVec.y = a + (b - a) * c;
          a = this.qVelocity[cf + 2];
          b = this.qVelocity[cc + 2];
          velocityVec.z = a + (b - a) * c;
          a = this.qVelocity2[cf];
          b = this.qVelocity2[cc];
          velocityVec2.x = a + (b - a) * c;
          a = this.qVelocity2[cf + 1];
          b = this.qVelocity2[cc + 1];
          velocityVec2.y = a + (b - a) * c;
          a = this.qVelocity2[cf + 2];
          b = this.qVelocity2[cc + 2];
          velocityVec2.z = a + (b - a) * c;
          localVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;
          localVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;
          localVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;
          if (this.initialVelocity > 0) {
            if (this.emitterShape === pc.EMITTERSHAPE_SPHERE) {
              randomPos.copy(rndFactor3Vec).scale(2).sub(pc.Vec3.ONE).normalize();
              localVelocityVec.add(randomPos.scale(this.initialVelocity));
            } else {
              localVelocityVec.add(pc.Vec3.FORWARD.scale(this.initialVelocity));
            }
          }
          velocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;
          velocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;
          velocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;
          rotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;
          scale = (scale + (scale2 - scale) * (rndFactor * 10000.0 % 1.0)) * uniformScale;
          alphaDiv = (alpha2 - alpha) * (rndFactor * 1000.0 % 1.0);
          if (this.meshInstance.node) {
            rotMat.transformPoint(localVelocityVec, localVelocityVec);
          }
          localVelocityVec.add(velocityVec.mul(nonUniformScale));
          moveDirVec.copy(localVelocityVec);
          particlePosPrev.x = this.particleTex[id * particleTexChannels];
          particlePosPrev.y = this.particleTex[id * particleTexChannels + 1];
          particlePosPrev.z = this.particleTex[id * particleTexChannels + 2];
          particlePos.copy(particlePosPrev).add(localVelocityVec.scale(delta));
          particleFinalPos.copy(particlePos);
          this.particleTex[id * particleTexChannels] = particleFinalPos.x;
          this.particleTex[id * particleTexChannels + 1] = particleFinalPos.y;
          this.particleTex[id * particleTexChannels + 2] = particleFinalPos.z;
          this.particleTex[id * particleTexChannels + 3] += rotSpeed * delta;
          if (this.wrap && this.wrapBounds) {
            particleFinalPos.sub(emitterPos);
            particleFinalPos.x = glMod(particleFinalPos.x, this.wrapBounds.x) - this.wrapBounds.x * 0.5;
            particleFinalPos.y = glMod(particleFinalPos.y, this.wrapBounds.y) - this.wrapBounds.y * 0.5;
            particleFinalPos.z = glMod(particleFinalPos.z, this.wrapBounds.z) - this.wrapBounds.z * 0.5;
            particleFinalPos.add(emitterPos);
          }
          if (this.sort > 0) {
            if (this.sort === 1) {
              tmpVec3.copy(particleFinalPos).sub(posCam);
              this.particleDistance[id] = -(tmpVec3.x * tmpVec3.x + tmpVec3.y * tmpVec3.y + tmpVec3.z * tmpVec3.z);
            } else {
              if (this.sort === 2) {
                this.particleDistance[id] = life;
              } else {
                if (this.sort === 3) {
                  this.particleDistance[id] = -life;
                }
              }
            }
          }
        } else {
          this.calcSpawnPosition(emitterPos, id);
        }
        if (isOnStop) {
          if (life < 0) {
            this.particleTex[id * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = -1;
          }
        } else {
          if (life >= particleLifetime) {
            life -= Math.max(particleLifetime, (this.numParticles - 1) * particleRate);
            this.particleTex[id * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = this.loop ? 1 : -1;
          }
          if (life < 0 && this.loop) {
            this.particleTex[id * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;
          }
        }
        if (this.particleTex[id * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] < 0) {
          particleEnabled = false;
        }
        this.particleTex[id * particleTexChannels + 3 + this.numParticlesPot * particleTexChannels] = life;
        for (var v = 0; v < this.numParticleVerts; v++) {
          var quadX = this.vbCPU[i * this.numParticleVerts * 4 + v * 4];
          var quadY = this.vbCPU[i * this.numParticleVerts * 4 + v * 4 + 1];
          var quadZ = this.vbCPU[i * this.numParticleVerts * 4 + v * 4 + 2];
          if (!particleEnabled) {
            quadX = quadY = quadZ = 0;
          }
          var w = i * this.numParticleVerts * vertSize + v * vertSize;
          data[w] = particleFinalPos.x;
          data[w + 1] = particleFinalPos.y;
          data[w + 2] = particleFinalPos.z;
          data[w + 3] = nlife;
          data[w + 4] = this.alignToMotion ? angle : this.particleTex[id * particleTexChannels + 3];
          data[w + 5] = scale;
          data[w + 6] = alphaDiv;
          data[w + 7] = moveDirVec.x;
          data[w + 8] = quadX;
          data[w + 9] = quadY;
          data[w + 10] = quadZ;
          data[w + 11] = moveDirVec.y;
          data[w + 12] = moveDirVec.z;
        }
      }
      if (this.sort > pc.PARTICLESORT_NONE && this.camera) {
        var particleDistance = this.particleDistance;
        for (i = 0; i < this.numParticles; i++) {
          this.vbToSort[i] = [i, particleDistance[Math.floor(this.vbCPU[i * this.numParticleVerts * 4 + 3])]];
        }
        this.vbOld.set(this.vbCPU);
        this.vbToSort.sort(function(p1, p2) {
          return p1[1] - p2[1];
        });
        for (i = 0; i < this.numParticles; i++) {
          var src = this.vbToSort[i][0] * this.numParticleVerts * 4;
          var dest = i * this.numParticleVerts * 4;
          for (j = 0; j < this.numParticleVerts * 4; j++) {
            this.vbCPU[dest + j] = this.vbOld[src + j];
          }
        }
      }
    }
    if (!this.loop) {
      if (Date.now() > this.endTime) {
        if (this.onFinished) {
          this.onFinished();
        }
        this.meshInstance.visible = false;
      }
    }
  }, _destroyResources:function() {
    if (this.particleTexIN) {
      this.particleTexIN.destroy();
      this.particleTexIN = null;
    }
    if (this.particleTexOUT) {
      this.particleTexOUT.destroy();
      this.particleTexOUT = null;
    }
    if (this.particleTexStart && this.particleTexStart.destroy) {
      this.particleTexStart.destroy();
      this.particleTexStart = null;
    }
    if (this.rtParticleTexIN) {
      this.rtParticleTexIN.destroy();
      this.rtParticleTexIN = null;
    }
    if (this.rtParticleTexOUT) {
      this.rtParticleTexOUT.destroy();
      this.rtParticleTexOUT = null;
    }
    if (this.internalTex0) {
      this.internalTex0.destroy();
      this.internalTex0 = null;
    }
    if (this.internalTex1) {
      this.internalTex1.destroy();
      this.internalTex1 = null;
    }
    if (this.internalTex2) {
      this.internalTex2.destroy();
      this.internalTex2 = null;
    }
    if (this.internalTex3) {
      this.internalTex3.destroy();
      this.internalTex3 = null;
    }
    if (this.vertexBuffer) {
      this.vertexBuffer.destroy();
      this.vertexBuffer = undefined;
    }
    if (this.indexBuffer) {
      this.indexBuffer.destroy();
      this.indexBuffer = undefined;
    }
    if (this.material) {
      this.material.destroy();
      this.material = null;
    }
  }, destroy:function() {
    this.camera = null;
    this._destroyResources();
  }});
  return {ParticleEmitter:ParticleEmitter};
}());
Object.assign(pc, function() {
  var Model = function Model() {
    this.graph = null;
    this.meshInstances = [];
    this.skinInstances = [];
    this.morphInstances = [];
    this.cameras = [];
    this.lights = [];
    this._shadersVersion = 0;
  };
  Object.assign(Model.prototype, {getGraph:function() {
    return this.graph;
  }, setGraph:function(graph) {
    this.graph = graph;
  }, getCameras:function() {
    return this.cameras;
  }, setCameras:function(cameras) {
    this.cameras = cameras;
  }, getLights:function() {
    return this.lights;
  }, setLights:function(lights) {
    this.lights = lights;
  }, getMaterials:function() {
    var i;
    var materials = [];
    for (i = 0; i < this.meshInstances.length; i++) {
      var meshInstance = this.meshInstances[i];
      if (materials.indexOf(meshInstance.material) === -1) {
        materials.push(meshInstance.material);
      }
    }
    return materials;
  }, clone:function() {
    var i, j;
    var srcNodes = [];
    var cloneNodes = [];
    var _duplicate = function(node) {
      var newNode = node.clone();
      srcNodes.push(node);
      cloneNodes.push(newNode);
      for (var idx = 0; idx < node._children.length; idx++) {
        newNode.addChild(_duplicate(node._children[idx]));
      }
      return newNode;
    };
    var cloneGraph = _duplicate(this.graph);
    var cloneMeshInstances = [];
    var cloneSkinInstances = [];
    var cloneMorphInstances = [];
    for (i = 0; i < this.skinInstances.length; i++) {
      var skin = this.skinInstances[i].skin;
      var cloneSkinInstance = new pc.SkinInstance(skin);
      var bones = [];
      for (j = 0; j < skin.boneNames.length; j++) {
        var boneName = skin.boneNames[j];
        var bone = cloneGraph.findByName(boneName);
        bones.push(bone);
      }
      cloneSkinInstance.bones = bones;
      cloneSkinInstances.push(cloneSkinInstance);
    }
    for (i = 0; i < this.morphInstances.length; i++) {
      var morph = this.morphInstances[i].morph;
      var cloneMorphInstance = new pc.MorphInstance(morph);
      cloneMorphInstances.push(cloneMorphInstance);
    }
    for (i = 0; i < this.meshInstances.length; i++) {
      var meshInstance = this.meshInstances[i];
      var nodeIndex = srcNodes.indexOf(meshInstance.node);
      var cloneMeshInstance = new pc.MeshInstance(cloneNodes[nodeIndex], meshInstance.mesh, meshInstance.material);
      if (meshInstance.skinInstance) {
        var skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);
        cloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];
      }
      if (meshInstance.morphInstance) {
        var morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);
        cloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];
      }
      cloneMeshInstances.push(cloneMeshInstance);
    }
    var clone = new pc.Model;
    clone.graph = cloneGraph;
    clone.meshInstances = cloneMeshInstances;
    clone.skinInstances = cloneSkinInstances;
    clone.morphInstances = cloneMorphInstances;
    clone.getGraph().syncHierarchy();
    return clone;
  }, destroy:function() {
    var meshInstances = this.meshInstances;
    var meshInstance, mesh, skin, morph, ib, boneTex, j;
    var device;
    for (var i = 0; i < meshInstances.length; i++) {
      meshInstance = meshInstances[i];
      mesh = meshInstance.mesh;
      if (mesh) {
        mesh._refCount--;
        if (mesh._refCount < 1) {
          if (mesh.vertexBuffer) {
            device = device || mesh.vertexBuffer.device;
            mesh.vertexBuffer.destroy();
            mesh.vertexBuffer = null;
          }
          for (j = 0; j < mesh.indexBuffer.length; j++) {
            device = device || mesh.indexBuffer.device;
            ib = mesh.indexBuffer[j];
            if (!ib) {
              continue;
            }
            ib.destroy();
          }
          mesh.indexBuffer.length = 0;
        }
      }
      skin = meshInstance.skinInstance;
      if (skin) {
        boneTex = skin.boneTexture;
        if (boneTex) {
          boneTex.destroy();
        }
      }
      meshInstance.skinInstance = null;
      morph = meshInstance.morphInstance;
      if (morph) {
        morph.destroy();
      }
      meshInstance.morphInstance = null;
      meshInstance.material = null;
    }
  }, generateWireframe:function() {
    var i, j, k;
    var i1, i2;
    var mesh, base, count, indexBuffer, wireBuffer;
    var srcIndices, dstIndices;
    var meshes = [];
    for (i = 0; i < this.meshInstances.length; i++) {
      mesh = this.meshInstances[i].mesh;
      if (meshes.indexOf(mesh) === -1) {
        meshes.push(mesh);
      }
    }
    var offsets = [[0, 1], [1, 2], [2, 0]];
    for (i = 0; i < meshes.length; i++) {
      mesh = meshes[i];
      base = mesh.primitive[pc.RENDERSTYLE_SOLID].base;
      count = mesh.primitive[pc.RENDERSTYLE_SOLID].count;
      indexBuffer = mesh.indexBuffer[pc.RENDERSTYLE_SOLID];
      srcIndices = new Uint16Array(indexBuffer.lock());
      var uniqueLineIndices = {};
      var lines = [];
      for (j = base; j < base + count; j += 3) {
        for (k = 0; k < 3; k++) {
          i1 = srcIndices[j + offsets[k][0]];
          i2 = srcIndices[j + offsets[k][1]];
          var line = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;
          if (uniqueLineIndices[line] === undefined) {
            uniqueLineIndices[line] = 0;
            lines.push(i1, i2);
          }
        }
      }
      indexBuffer.unlock();
      wireBuffer = new pc.IndexBuffer(indexBuffer.device, pc.INDEXFORMAT_UINT16, lines.length);
      dstIndices = new Uint16Array(wireBuffer.lock());
      dstIndices.set(lines);
      wireBuffer.unlock();
      mesh.primitive[pc.RENDERSTYLE_WIREFRAME] = {type:pc.PRIMITIVE_LINES, base:0, count:lines.length, indexed:true};
      mesh.indexBuffer[pc.RENDERSTYLE_WIREFRAME] = wireBuffer;
    }
  }});
  return {Model:Model};
}());
Object.assign(pc, function() {
  var _deviceDeprecationWarning = false;
  var _getSelectionDeprecationWarning = false;
  var _prepareDeprecationWarning = false;
  var Picker = function(app, width, height) {
    if (app instanceof pc.GraphicsDevice) {
      app = pc.Application.getApplication();
      if (!_deviceDeprecationWarning) {
        _deviceDeprecationWarning = true;
      }
    }
    this.app = app;
    this.device = app.graphicsDevice;
    var device = this.device;
    this.library = device.getProgramLibrary();
    this.pickColor = new Float32Array(4);
    this.pickColor[3] = 1;
    this.scene = null;
    this.drawCalls = [];
    this.layer = null;
    this.layerComp = null;
    this.clearOptions = {color:[1, 1, 1, 1], depth:1, flags:pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH};
    var self = this;
    this._clearDepthOptions = {depth:1.0, flags:pc.CLEARFLAG_DEPTH};
    this.clearDepthCommand = new pc.Command(0, 0, function() {
      device.clear(self._clearDepthOptions);
    });
    this.resize(width, height);
    this._ignoreOpacityFor = null;
  };
  Picker.prototype.getSelection = function(x, y, width, height) {
    var device = this.device;
    if (typeof x === "object") {
      var rect = x;
      x = rect.x;
      y = rect.y;
      width = rect.width;
      height = rect.height;
    } else {
      y = this.layer.renderTarget.height - (y + (height || 1));
    }
    width = width || 1;
    height = height || 1;
    var prevRenderTarget = device.renderTarget;
    device.setRenderTarget(this.layer.renderTarget);
    device.updateBegin();
    var pixels = new Uint8Array(4 * width * height);
    device.readPixels(x, y, width, height, pixels);
    device.updateEnd();
    device.setRenderTarget(prevRenderTarget);
    var selection = [];
    var drawCalls = this.layer.instances.visibleOpaque[0].list;
    var r, g, b, index;
    for (var i = 0; i < width * height; i++) {
      r = pixels[4 * i + 0];
      g = pixels[4 * i + 1];
      b = pixels[4 * i + 2];
      index = r << 16 | g << 8 | b;
      if (index !== 16777215) {
        var selectedMeshInstance = drawCalls[index];
        if (selection.indexOf(selectedMeshInstance) === -1) {
          selection.push(selectedMeshInstance);
        }
      }
    }
    return selection;
  };
  Picker.prototype.prepare = function(camera, scene, arg) {
    var device = this.device;
    var i, j;
    var self = this;
    if (camera instanceof pc.Camera) {
      camera = camera._component;
    }
    this.scene = scene;
    var sourceLayer = null;
    var sourceRt = null;
    if (arg instanceof pc.Layer) {
      sourceLayer = arg;
    } else {
      sourceRt = arg;
    }
    if (!this.layer) {
      var pickColorId = device.scope.resolve("uColor");
      this.layer = new pc.Layer({name:"Picker", shaderPass:pc.SHADER_PICK, opaqueSortMode:pc.SORTMODE_NONE, onEnable:function() {
        if (this.renderTarget) {
          return;
        }
        var colorBuffer = new pc.Texture(device, {format:pc.PIXELFORMAT_R8_G8_B8_A8, width:self.width, height:self.height});
        colorBuffer.name = "pick";
        colorBuffer.minFilter = pc.FILTER_NEAREST;
        colorBuffer.magFilter = pc.FILTER_NEAREST;
        colorBuffer.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
        colorBuffer.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
        this.renderTarget = new pc.RenderTarget(device, colorBuffer, {depth:true});
      }, onDisable:function() {
        if (!this.renderTarget) {
          return;
        }
        this.renderTarget._colorBuffer.destroy();
        this.renderTarget.destroy();
        this.renderTarget = null;
      }, onDrawCall:function(meshInstance, index) {
        self.pickColor[0] = (index >> 16 & 255) / 255;
        self.pickColor[1] = (index >> 8 & 255) / 255;
        self.pickColor[2] = (index & 255) / 255;
        pickColorId.setValue(self.pickColor);
        device.setBlending(false);
      }});
      this.layerComp = new pc.LayerComposition;
      this.layerComp.pushOpaque(this.layer);
      this.meshInstances = this.layer.opaqueMeshInstances;
      this._instancesVersion = -1;
    }
    var instanceList, instanceListLength, drawCall;
    if (!sourceLayer) {
      this.layer.clearMeshInstances();
      var layers = scene.layers.layerList;
      var subLayerEnabled = scene.layers.subLayerEnabled;
      var isTransparent = scene.layers.subLayerList;
      var layer;
      var layerCamId, transparent;
      for (i = 0; i < layers.length; i++) {
        if (layers[i].overrideClear && layers[i]._clearDepthBuffer) {
          layers[i]._pickerCleared = false;
        }
      }
      for (i = 0; i < layers.length; i++) {
        layer = layers[i];
        if (layer.renderTarget !== sourceRt || !layer.enabled || !subLayerEnabled[i]) {
          continue;
        }
        layerCamId = layer.cameras.indexOf(camera);
        if (layerCamId < 0) {
          continue;
        }
        if (layer.overrideClear && layer._clearDepthBuffer && !layer._pickerCleared) {
          this.meshInstances.push(this.clearDepthCommand);
          layer._pickerCleared = true;
        }
        transparent = isTransparent[i];
        instanceList = transparent ? layer.instances.transparentMeshInstances : layer.instances.opaqueMeshInstances;
        instanceListLength = instanceList.length;
        for (j = 0; j < instanceListLength; j++) {
          drawCall = instanceList[j];
          if (drawCall.pick) {
            this.meshInstances.push(drawCall);
          }
        }
      }
    } else {
      if (this._instancesVersion !== sourceLayer._version) {
        this.layer.clearMeshInstances();
        instanceList = sourceLayer.instances.opaqueMeshInstances;
        instanceListLength = instanceList.length;
        for (j = 0; j < instanceListLength; j++) {
          drawCall = instanceList[j];
          if (drawCall.pick) {
            this.meshInstances.push(drawCall);
          }
        }
        instanceList = sourceLayer.instances.transparentMeshInstances;
        instanceListLength = instanceList.length;
        for (j = 0; j < instanceListLength; j++) {
          drawCall = instanceList[j];
          if (drawCall.pick) {
            this.meshInstances.push(drawCall);
          }
        }
        this._instancesVersion = sourceLayer._version;
      }
    }
    if (this.layer.cameras[0] !== camera) {
      this.layer.clearCameras();
      this.layer.addCamera(camera);
    }
    this.onLayerPreRender(this.layer, sourceLayer, sourceRt);
    this.app.renderer.renderComposition(this.layerComp);
    this.onLayerPostRender(this.layer);
  };
  Picker.prototype.onLayerPreRender = function(layer, sourceLayer, sourceRt) {
    if (this.width !== layer.renderTarget.width || this.height !== layer.renderTarget.height) {
      layer.onDisable();
      layer.onEnable();
    }
    layer.oldClear = layer.cameras[0].camera._clearOptions;
    layer.oldAspectMode = layer.cameras[0].aspectRatioMode;
    layer.oldAspect = layer.cameras[0].aspectRatio;
    layer.cameras[0].camera._clearOptions = this.clearOptions;
    layer.cameras[0].aspectRatioMode = pc.ASPECT_MANUAL;
    var rt = sourceRt ? sourceRt : sourceLayer ? sourceLayer.renderTarget : null;
    layer.cameras[0].aspectRatio = layer.cameras[0].calculateAspectRatio(rt);
    this.app.renderer.updateCameraFrustum(layer.cameras[0].camera);
  };
  Picker.prototype.onLayerPostRender = function(layer) {
    layer.cameras[0].camera._clearOptions = layer.oldClear;
    layer.cameras[0].aspectRatioMode = layer.oldAspectMode;
    layer.cameras[0].aspectRatio = layer.oldAspect;
  };
  Picker.prototype.resize = function(width, height) {
    this.width = width;
    this.height = height;
  };
  Object.defineProperty(Picker.prototype, "renderTarget", {get:function() {
    return this.layer.renderTarget;
  }});
  return {Picker:Picker};
}());
var primitiveUv1Padding = 4.0 / 64;
var primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;
pc.calculateNormals = function(positions, indices) {
  var triangleCount = indices.length / 3;
  var vertexCount = positions.length / 3;
  var i1, i2, i3;
  var i;
  var p1 = new pc.Vec3;
  var p2 = new pc.Vec3;
  var p3 = new pc.Vec3;
  var p1p2 = new pc.Vec3;
  var p1p3 = new pc.Vec3;
  var faceNormal = new pc.Vec3;
  var normals = [];
  for (i = 0; i < positions.length; i++) {
    normals[i] = 0;
  }
  for (i = 0; i < triangleCount; i++) {
    i1 = indices[i * 3];
    i2 = indices[i * 3 + 1];
    i3 = indices[i * 3 + 2];
    p1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
    p2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
    p3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
    p1p2.sub2(p2, p1);
    p1p3.sub2(p3, p1);
    faceNormal.cross(p1p2, p1p3).normalize();
    normals[i1 * 3] += faceNormal.x;
    normals[i1 * 3 + 1] += faceNormal.y;
    normals[i1 * 3 + 2] += faceNormal.z;
    normals[i2 * 3] += faceNormal.x;
    normals[i2 * 3 + 1] += faceNormal.y;
    normals[i2 * 3 + 2] += faceNormal.z;
    normals[i3 * 3] += faceNormal.x;
    normals[i3 * 3 + 1] += faceNormal.y;
    normals[i3 * 3 + 2] += faceNormal.z;
  }
  for (i = 0; i < vertexCount; i++) {
    var nx = normals[i * 3];
    var ny = normals[i * 3 + 1];
    var nz = normals[i * 3 + 2];
    var invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
    normals[i * 3] *= invLen;
    normals[i * 3 + 1] *= invLen;
    normals[i * 3 + 2] *= invLen;
  }
  return normals;
};
pc.calculateTangents = function(positions, normals, uvs, indices) {
  var triangleCount = indices.length / 3;
  var vertexCount = positions.length / 3;
  var i1, i2, i3;
  var x1, x2, y1, y2, z1, z2, s1, s2, t1, t2, r;
  var sdir = new pc.Vec3;
  var tdir = new pc.Vec3;
  var v1 = new pc.Vec3;
  var v2 = new pc.Vec3;
  var v3 = new pc.Vec3;
  var w1 = new pc.Vec2;
  var w2 = new pc.Vec2;
  var w3 = new pc.Vec2;
  var i;
  var tan1 = new Float32Array(vertexCount * 3);
  var tan2 = new Float32Array(vertexCount * 3);
  var tangents = [];
  var area = 0.0;
  for (i = 0; i < triangleCount; i++) {
    i1 = indices[i * 3];
    i2 = indices[i * 3 + 1];
    i3 = indices[i * 3 + 2];
    v1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
    v2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
    v3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
    w1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);
    w2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);
    w3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);
    x1 = v2.x - v1.x;
    x2 = v3.x - v1.x;
    y1 = v2.y - v1.y;
    y2 = v3.y - v1.y;
    z1 = v2.z - v1.z;
    z2 = v3.z - v1.z;
    s1 = w2.x - w1.x;
    s2 = w3.x - w1.x;
    t1 = w2.y - w1.y;
    t2 = w3.y - w1.y;
    area = s1 * t2 - s2 * t1;
    if (area == 0.0) {
      sdir.set(0.0, 1.0, 0.0);
      tdir.set(1.0, 0.0, 0.0);
    } else {
      r = 1.0 / area;
      sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
      tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
    }
    tan1[i1 * 3 + 0] += sdir.x;
    tan1[i1 * 3 + 1] += sdir.y;
    tan1[i1 * 3 + 2] += sdir.z;
    tan1[i2 * 3 + 0] += sdir.x;
    tan1[i2 * 3 + 1] += sdir.y;
    tan1[i2 * 3 + 2] += sdir.z;
    tan1[i3 * 3 + 0] += sdir.x;
    tan1[i3 * 3 + 1] += sdir.y;
    tan1[i3 * 3 + 2] += sdir.z;
    tan2[i1 * 3 + 0] += tdir.x;
    tan2[i1 * 3 + 1] += tdir.y;
    tan2[i1 * 3 + 2] += tdir.z;
    tan2[i2 * 3 + 0] += tdir.x;
    tan2[i2 * 3 + 1] += tdir.y;
    tan2[i2 * 3 + 2] += tdir.z;
    tan2[i3 * 3 + 0] += tdir.x;
    tan2[i3 * 3 + 1] += tdir.y;
    tan2[i3 * 3 + 2] += tdir.z;
  }
  t1 = new pc.Vec3;
  t2 = new pc.Vec3;
  var n = new pc.Vec3;
  var temp = new pc.Vec3;
  for (i = 0; i < vertexCount; i++) {
    n.set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);
    t1.set(tan1[i * 3], tan1[i * 3 + 1], tan1[i * 3 + 2]);
    t2.set(tan2[i * 3], tan2[i * 3 + 1], tan2[i * 3 + 2]);
    var ndott = n.dot(t1);
    temp.copy(n).scale(ndott);
    temp.sub2(t1, temp).normalize();
    tangents[i * 4] = temp.x;
    tangents[i * 4 + 1] = temp.y;
    tangents[i * 4 + 2] = temp.z;
    temp.cross(n, t1);
    tangents[i * 4 + 3] = temp.dot(t2) < 0.0 ? -1.0 : 1.0;
  }
  return tangents;
};
pc.createMesh = function(device, positions, opts) {
  var normals = opts && opts.normals !== undefined ? opts.normals : null;
  var tangents = opts && opts.tangents !== undefined ? opts.tangents : null;
  var colors = opts && opts.colors !== undefined ? opts.colors : null;
  var uvs = opts && opts.uvs !== undefined ? opts.uvs : null;
  var uvs1 = opts && opts.uvs1 !== undefined ? opts.uvs1 : null;
  var indices = opts && opts.indices !== undefined ? opts.indices : null;
  var blendIndices = opts && opts.blendIndices !== undefined ? opts.blendIndices : null;
  var blendWeights = opts && opts.blendWeights !== undefined ? opts.blendWeights : null;
  var vertexDesc = [{semantic:pc.SEMANTIC_POSITION, components:3, type:pc.TYPE_FLOAT32}];
  if (normals !== null) {
    vertexDesc.push({semantic:pc.SEMANTIC_NORMAL, components:3, type:pc.TYPE_FLOAT32});
  }
  if (tangents !== null) {
    vertexDesc.push({semantic:pc.SEMANTIC_TANGENT, components:4, type:pc.TYPE_FLOAT32});
  }
  if (colors !== null) {
    vertexDesc.push({semantic:pc.SEMANTIC_COLOR, components:4, type:pc.TYPE_UINT8, normalize:true});
  }
  if (uvs !== null) {
    vertexDesc.push({semantic:pc.SEMANTIC_TEXCOORD0, components:2, type:pc.TYPE_FLOAT32});
  }
  if (uvs1 !== null) {
    vertexDesc.push({semantic:pc.SEMANTIC_TEXCOORD1, components:2, type:pc.TYPE_FLOAT32});
  }
  if (blendIndices !== null) {
    vertexDesc.push({semantic:pc.SEMANTIC_BLENDINDICES, components:2, type:pc.TYPE_UINT8});
  }
  if (blendWeights !== null) {
    vertexDesc.push({semantic:pc.SEMANTIC_BLENDWEIGHT, components:2, type:pc.TYPE_FLOAT32});
  }
  var vertexFormat = new pc.VertexFormat(device, vertexDesc);
  var numVertices = positions.length / 3;
  var vertexBuffer = new pc.VertexBuffer(device, vertexFormat, numVertices);
  var iterator = new pc.VertexIterator(vertexBuffer);
  for (var i = 0; i < numVertices; i++) {
    iterator.element[pc.SEMANTIC_POSITION].set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
    if (normals !== null) {
      iterator.element[pc.SEMANTIC_NORMAL].set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);
    }
    if (tangents !== null) {
      iterator.element[pc.SEMANTIC_TANGENT].set(tangents[i * 4], tangents[i * 4 + 1], tangents[i * 4 + 2], tangents[i * 4 + 3]);
    }
    if (colors !== null) {
      iterator.element[pc.SEMANTIC_COLOR].set(colors[i * 4], colors[i * 4 + 1], colors[i * 4 + 2], colors[i * 4 + 3]);
    }
    if (uvs !== null) {
      iterator.element[pc.SEMANTIC_TEXCOORD0].set(uvs[i * 2], uvs[i * 2 + 1]);
    }
    if (uvs1 !== null) {
      iterator.element[pc.SEMANTIC_TEXCOORD1].set(uvs1[i * 2], uvs1[i * 2 + 1]);
    }
    if (blendIndices !== null) {
      iterator.element[pc.SEMANTIC_BLENDINDICES].set(blendIndices[i * 2], blendIndices[i * 2 + 1]);
    }
    if (blendWeights !== null) {
      iterator.element[pc.SEMANTIC_BLENDWEIGHT].set(blendWeights[i * 2], blendWeights[i * 2 + 1]);
    }
    iterator.next();
  }
  iterator.end();
  var indexBuffer = null;
  var indexed = indices !== null;
  if (indexed) {
    indexBuffer = new pc.IndexBuffer(device, pc.INDEXFORMAT_UINT16, indices.length);
    var dst = new Uint16Array(indexBuffer.lock());
    dst.set(indices);
    indexBuffer.unlock();
  }
  var aabb = new pc.BoundingBox;
  aabb.compute(positions);
  var mesh = new pc.Mesh;
  mesh.vertexBuffer = vertexBuffer;
  mesh.indexBuffer[0] = indexBuffer;
  mesh.primitive[0].type = pc.PRIMITIVE_TRIANGLES;
  mesh.primitive[0].base = 0;
  mesh.primitive[0].count = indexed ? indices.length : numVertices;
  mesh.primitive[0].indexed = indexed;
  mesh.aabb = aabb;
  return mesh;
};
pc.createTorus = function(device, opts) {
  var rc = opts && opts.tubeRadius !== undefined ? opts.tubeRadius : 0.2;
  var rt = opts && opts.ringRadius !== undefined ? opts.ringRadius : 0.3;
  var segments = opts && opts.segments !== undefined ? opts.segments : 30;
  var sides = opts && opts.sides !== undefined ? opts.sides : 20;
  var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
  var i, j;
  var x, y, z, nx, ny, nz, u, v;
  var positions = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  for (i = 0; i <= sides; i++) {
    for (j = 0; j <= segments; j++) {
      x = Math.cos(2.0 * Math.PI * j / segments) * (rt + rc * Math.cos(2.0 * Math.PI * i / sides));
      y = Math.sin(2.0 * Math.PI * i / sides) * rc;
      z = Math.sin(2.0 * Math.PI * j / segments) * (rt + rc * Math.cos(2.0 * Math.PI * i / sides));
      nx = Math.cos(2.0 * Math.PI * j / segments) * Math.cos(2.0 * Math.PI * i / sides);
      ny = Math.sin(2.0 * Math.PI * i / sides);
      nz = Math.sin(2.0 * Math.PI * j / segments) * Math.cos(2.0 * Math.PI * i / sides);
      u = i / sides;
      v = 1.0 - j / segments;
      positions.push(x, y, z);
      normals.push(nx, ny, nz);
      uvs.push(u, v);
      if (i < sides && j < segments) {
        var first, second, third, fourth;
        first = i * (segments + 1) + j;
        second = (i + 1) * (segments + 1) + j;
        third = i * (segments + 1) + (j + 1);
        fourth = (i + 1) * (segments + 1) + (j + 1);
        indices.push(first, second, third);
        indices.push(second, fourth, third);
      }
    }
  }
  var options = {normals:normals, uvs:uvs, indices:indices};
  if (calculateTangents) {
    options.tangents = pc.calculateTangents(positions, normals, uvs, indices);
  }
  return pc.createMesh(device, positions, options);
};
pc._createConeData = function(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {
  var i, j;
  var x, y, z, u, v;
  var pos = new pc.Vec3;
  var bottomToTop = new pc.Vec3;
  var norm = new pc.Vec3;
  var top, bottom, tangent;
  var positions = [];
  var normals = [];
  var uvs = [];
  var uvs1 = [];
  var indices = [];
  var theta, cosTheta, sinTheta;
  var phi, sinPhi, cosPhi;
  var first, second, third, fourth;
  var offset;
  if (height > 0) {
    for (i = 0; i <= heightSegments; i++) {
      for (j = 0; j <= capSegments; j++) {
        theta = j / capSegments * 2.0 * Math.PI - Math.PI;
        sinTheta = Math.sin(theta);
        cosTheta = Math.cos(theta);
        bottom = new pc.Vec3(sinTheta * baseRadius, -height / 2.0, cosTheta * baseRadius);
        top = new pc.Vec3(sinTheta * peakRadius, height / 2.0, cosTheta * peakRadius);
        pos.lerp(bottom, top, i / heightSegments);
        bottomToTop.sub2(top, bottom).normalize();
        tangent = new pc.Vec3(cosTheta, 0.0, -sinTheta);
        norm.cross(tangent, bottomToTop).normalize();
        positions.push(pos.x, pos.y, pos.z);
        normals.push(norm.x, norm.y, norm.z);
        u = j / capSegments;
        v = i / heightSegments;
        uvs.push(u, v);
        var _v = v;
        v = u;
        u = _v;
        u /= 3;
        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
        uvs1.push(u, v);
        if (i < heightSegments && j < capSegments) {
          first = i * (capSegments + 1) + j;
          second = i * (capSegments + 1) + (j + 1);
          third = (i + 1) * (capSegments + 1) + j;
          fourth = (i + 1) * (capSegments + 1) + (j + 1);
          indices.push(first, second, third);
          indices.push(second, fourth, third);
        }
      }
    }
  }
  if (roundedCaps) {
    var lat, lon;
    var latitudeBands = Math.floor(capSegments / 2);
    var longitudeBands = capSegments;
    var capOffset = height / 2;
    for (lat = 0; lat <= latitudeBands; lat++) {
      theta = lat * Math.PI * 0.5 / latitudeBands;
      sinTheta = Math.sin(theta);
      cosTheta = Math.cos(theta);
      for (lon = 0; lon <= longitudeBands; lon++) {
        phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2.0;
        sinPhi = Math.sin(phi);
        cosPhi = Math.cos(phi);
        x = cosPhi * sinTheta;
        y = cosTheta;
        z = sinPhi * sinTheta;
        u = 1.0 - lon / longitudeBands;
        v = 1.0 - lat / latitudeBands;
        positions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);
        normals.push(x, y, z);
        uvs.push(u, v);
        u /= 3;
        v /= 3;
        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
        u += 1.0 / 3;
        uvs1.push(u, v);
      }
    }
    offset = (heightSegments + 1) * (capSegments + 1);
    for (lat = 0; lat < latitudeBands; ++lat) {
      for (lon = 0; lon < longitudeBands; ++lon) {
        first = lat * (longitudeBands + 1) + lon;
        second = first + longitudeBands + 1;
        indices.push(offset + first + 1, offset + second, offset + first);
        indices.push(offset + first + 1, offset + second + 1, offset + second);
      }
    }
    for (lat = 0; lat <= latitudeBands; lat++) {
      theta = Math.PI * 0.5 + lat * Math.PI * 0.5 / latitudeBands;
      sinTheta = Math.sin(theta);
      cosTheta = Math.cos(theta);
      for (lon = 0; lon <= longitudeBands; lon++) {
        phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2.0;
        sinPhi = Math.sin(phi);
        cosPhi = Math.cos(phi);
        x = cosPhi * sinTheta;
        y = cosTheta;
        z = sinPhi * sinTheta;
        u = 1.0 - lon / longitudeBands;
        v = 1.0 - lat / latitudeBands;
        positions.push(x * peakRadius, y * peakRadius - capOffset, z * peakRadius);
        normals.push(x, y, z);
        uvs.push(u, v);
        u /= 3;
        v /= 3;
        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
        u += 2.0 / 3;
        uvs1.push(u, v);
      }
    }
    offset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);
    for (lat = 0; lat < latitudeBands; ++lat) {
      for (lon = 0; lon < longitudeBands; ++lon) {
        first = lat * (longitudeBands + 1) + lon;
        second = first + longitudeBands + 1;
        indices.push(offset + first + 1, offset + second, offset + first);
        indices.push(offset + first + 1, offset + second + 1, offset + second);
      }
    }
  } else {
    offset = (heightSegments + 1) * (capSegments + 1);
    if (baseRadius > 0.0) {
      for (i = 0; i < capSegments; i++) {
        theta = i / capSegments * 2.0 * Math.PI;
        x = Math.sin(theta);
        y = -height / 2.0;
        z = Math.cos(theta);
        u = 1.0 - (x + 1.0) / 2.0;
        v = (z + 1.0) / 2.0;
        positions.push(x * baseRadius, y, z * baseRadius);
        normals.push(0.0, -1.0, 0.0);
        uvs.push(u, v);
        u /= 3;
        v /= 3;
        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
        u += 1.0 / 3;
        uvs1.push(u, v);
        if (i > 1) {
          indices.push(offset, offset + i, offset + i - 1);
        }
      }
    }
    offset += capSegments;
    if (peakRadius > 0.0) {
      for (i = 0; i < capSegments; i++) {
        theta = i / capSegments * 2.0 * Math.PI;
        x = Math.sin(theta);
        y = height / 2.0;
        z = Math.cos(theta);
        u = 1.0 - (x + 1.0) / 2.0;
        v = (z + 1.0) / 2.0;
        positions.push(x * peakRadius, y, z * peakRadius);
        normals.push(0.0, 1.0, 0.0);
        uvs.push(u, v);
        u /= 3;
        v /= 3;
        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
        u += 2.0 / 3;
        uvs1.push(u, v);
        if (i > 1) {
          indices.push(offset, offset + i - 1, offset + i);
        }
      }
    }
  }
  return {positions:positions, normals:normals, uvs:uvs, uvs1:uvs1, indices:indices};
};
pc.createCylinder = function(device, opts) {
  var radius = opts && (opts.radius || opts.baseRadius);
  radius = radius !== undefined ? radius : 0.5;
  var height = opts && opts.height !== undefined ? opts.height : 1.0;
  var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
  var capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 20;
  var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
  var options = pc._createConeData(radius, radius, height, heightSegments, capSegments, false);
  if (calculateTangents) {
    options.tangents = pc.calculateTangents(options.positions, options.normals, options.uvs, options.indices);
  }
  return pc.createMesh(device, options.positions, options);
};
pc.createCapsule = function(device, opts) {
  var radius = opts && opts.radius !== undefined ? opts.radius : 0.3;
  var height = opts && opts.height !== undefined ? opts.height : 1.0;
  var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
  var sides = opts && opts.sides !== undefined ? opts.sides : 20;
  var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
  var options = pc._createConeData(radius, radius, height - 2 * radius, heightSegments, sides, true);
  if (calculateTangents) {
    options.tangents = pc.calculateTangents(options.positions, options.normals, options.uvs, options.indices);
  }
  return pc.createMesh(device, options.positions, options);
};
pc.createCone = function(device, opts) {
  var baseRadius = opts && opts.baseRadius !== undefined ? opts.baseRadius : 0.5;
  var peakRadius = opts && opts.peakRadius !== undefined ? opts.peakRadius : 0.0;
  var height = opts && opts.height !== undefined ? opts.height : 1.0;
  var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
  var capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 18;
  var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
  var options = pc._createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, false);
  if (calculateTangents) {
    options.tangents = pc.calculateTangents(options.positions, options.normals, options.uvs, options.indices);
  }
  return pc.createMesh(device, options.positions, options);
};
pc.createSphere = function(device, opts) {
  var radius = opts && opts.radius !== undefined ? opts.radius : 0.5;
  var latitudeBands = opts && opts.latitudeBands !== undefined ? opts.latitudeBands : 16;
  var longitudeBands = opts && opts.longitudeBands !== undefined ? opts.longitudeBands : 16;
  var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
  var lon, lat;
  var theta, sinTheta, cosTheta, phi, sinPhi, cosPhi;
  var first, second;
  var x, y, z, u, v;
  var positions = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  for (lat = 0; lat <= latitudeBands; lat++) {
    theta = lat * Math.PI / latitudeBands;
    sinTheta = Math.sin(theta);
    cosTheta = Math.cos(theta);
    for (lon = 0; lon <= longitudeBands; lon++) {
      phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2.0;
      sinPhi = Math.sin(phi);
      cosPhi = Math.cos(phi);
      x = cosPhi * sinTheta;
      y = cosTheta;
      z = sinPhi * sinTheta;
      u = 1.0 - lon / longitudeBands;
      v = 1.0 - lat / latitudeBands;
      positions.push(x * radius, y * radius, z * radius);
      normals.push(x, y, z);
      uvs.push(u, v);
    }
  }
  for (lat = 0; lat < latitudeBands; ++lat) {
    for (lon = 0; lon < longitudeBands; ++lon) {
      first = lat * (longitudeBands + 1) + lon;
      second = first + longitudeBands + 1;
      indices.push(first + 1, second, first);
      indices.push(first + 1, second + 1, second);
    }
  }
  var options = {normals:normals, uvs:uvs, uvs1:uvs, indices:indices};
  if (calculateTangents) {
    options.tangents = pc.calculateTangents(positions, normals, uvs, indices);
  }
  return pc.createMesh(device, positions, options);
};
pc.createPlane = function(device, opts) {
  var he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new pc.Vec2(0.5, 0.5);
  var ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 5;
  var ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 5;
  var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
  var i, j;
  var x, y, z, u, v;
  var positions = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  var vcounter = 0;
  for (i = 0; i <= ws; i++) {
    for (j = 0; j <= ls; j++) {
      x = -he.x + 2.0 * he.x * i / ws;
      y = 0.0;
      z = -(-he.y + 2.0 * he.y * j / ls);
      u = i / ws;
      v = j / ls;
      positions.push(x, y, z);
      normals.push(0.0, 1.0, 0.0);
      uvs.push(u, v);
      if (i < ws && j < ls) {
        indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
        indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
      }
      vcounter++;
    }
  }
  var options = {normals:normals, uvs:uvs, uvs1:uvs, indices:indices};
  if (calculateTangents) {
    options.tangents = pc.calculateTangents(positions, normals, uvs, indices);
  }
  return pc.createMesh(device, positions, options);
};
pc.createBox = function(device, opts) {
  var he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new pc.Vec3(0.5, 0.5, 0.5);
  var ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 1;
  var ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 1;
  var hs = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
  var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
  var corners = [new pc.Vec3(-he.x, -he.y, he.z), new pc.Vec3(he.x, -he.y, he.z), new pc.Vec3(he.x, he.y, he.z), new pc.Vec3(-he.x, he.y, he.z), new pc.Vec3(he.x, -he.y, -he.z), new pc.Vec3(-he.x, -he.y, -he.z), new pc.Vec3(-he.x, he.y, -he.z), new pc.Vec3(he.x, he.y, -he.z)];
  var faceAxes = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]];
  var faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];
  var sides = {FRONT:0, BACK:1, TOP:2, BOTTOM:3, RIGHT:4, LEFT:5};
  var positions = [];
  var normals = [];
  var uvs = [];
  var uvs1 = [];
  var indices = [];
  var vcounter = 0;
  var generateFace = function(side, uSegments, vSegments) {
    var u, v;
    var i, j;
    for (i = 0; i <= uSegments; i++) {
      for (j = 0; j <= vSegments; j++) {
        var temp1 = new pc.Vec3;
        var temp2 = new pc.Vec3;
        var temp3 = new pc.Vec3;
        var r = new pc.Vec3;
        temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
        temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
        temp3.sub2(temp2, corners[faceAxes[side][0]]);
        r.add2(temp1, temp3);
        u = i / uSegments;
        v = j / vSegments;
        positions.push(r.x, r.y, r.z);
        normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
        uvs.push(u, v);
        u /= 3;
        v /= 3;
        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
        u += side % 3 / 3;
        v += Math.floor(side / 3) / 3;
        uvs1.push(u, v);
        if (i < uSegments && j < vSegments) {
          indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
          indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
        }
        vcounter++;
      }
    }
  };
  generateFace(sides.FRONT, ws, hs);
  generateFace(sides.BACK, ws, hs);
  generateFace(sides.TOP, ws, ls);
  generateFace(sides.BOTTOM, ws, ls);
  generateFace(sides.RIGHT, ls, hs);
  generateFace(sides.LEFT, ls, hs);
  var options = {normals:normals, uvs:uvs, uvs1:uvs1, indices:indices};
  if (calculateTangents) {
    options.tangents = pc.calculateTangents(positions, normals, uvs, indices);
  }
  return pc.createMesh(device, positions, options);
};
pc.getDefaultMaterial = function() {
  return pc.Application.getApplication().scene.defaultMaterial;
};
Object.assign(pc, function() {
  var keyA, keyB, sortPos, sortDir;
  function sortManual(drawCallA, drawCallB) {
    return drawCallA.drawOrder - drawCallB.drawOrder;
  }
  function sortMaterialMesh(drawCallA, drawCallB) {
    keyA = drawCallA._key[pc.SORTKEY_FORWARD];
    keyB = drawCallB._key[pc.SORTKEY_FORWARD];
    if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
      return drawCallB.mesh.id - drawCallA.mesh.id;
    }
    return keyB - keyA;
  }
  function sortBackToFront(drawCallA, drawCallB) {
    return drawCallB.zdist - drawCallA.zdist;
  }
  function sortFrontToBack(drawCallA, drawCallB) {
    return drawCallA.zdist - drawCallB.zdist;
  }
  var sortCallbacks = [null, sortManual, sortMaterialMesh, sortBackToFront, sortFrontToBack];
  function sortCameras(camA, camB) {
    return camA.priority - camB.priority;
  }
  function sortLights(lightA, lightB) {
    return lightB.key - lightA.key;
  }
  var layerCounter = 0;
  var VisibleInstanceList = function() {
    this.list = [];
    this.length = 0;
    this.done = false;
  };
  var InstanceList = function() {
    this.opaqueMeshInstances = [];
    this.transparentMeshInstances = [];
    this.shadowCasters = [];
    this.visibleOpaque = [];
    this.visibleTransparent = [];
  };
  InstanceList.prototype.clearVisibleLists = function(cameraPass) {
    if (this.visibleOpaque[cameraPass]) {
      this.visibleOpaque[cameraPass].length = 0;
      this.visibleOpaque[cameraPass].list.length = 0;
    }
    if (this.visibleTransparent[cameraPass]) {
      this.visibleTransparent[cameraPass].length = 0;
      this.visibleTransparent[cameraPass].list.length = 0;
    }
  };
  var Layer = function(options) {
    options = options || {};
    if (options.id !== undefined) {
      this.id = options.id;
      layerCounter = Math.max(this.id + 1, layerCounter);
    } else {
      this.id = layerCounter++;
    }
    this.name = options.name;
    this._enabled = options.enabled === undefined ? true : options.enabled;
    this._refCounter = this._enabled ? 1 : 0;
    this.opaqueSortMode = options.opaqueSortMode === undefined ? pc.SORTMODE_MATERIALMESH : options.opaqueSortMode;
    this.transparentSortMode = options.transparentSortMode === undefined ? pc.SORTMODE_BACK2FRONT : options.transparentSortMode;
    this.renderTarget = options.renderTarget;
    this.shaderPass = options.shaderPass === undefined ? pc.SHADER_FORWARD : options.shaderPass;
    this.passThrough = options.passThrough === undefined ? false : options.passThrough;
    this.overrideClear = options.overrideClear === undefined ? false : options.overrideClear;
    this._clearColor = new pc.Color(0, 0, 0, 1);
    if (options.clearColor) {
      this._clearColor.copy(options.clearColor);
    }
    this._clearColorBuffer = options.clearColorBuffer === undefined ? false : options.clearColorBuffer;
    this._clearDepthBuffer = options.clearDepthBuffer === undefined ? false : options.clearDepthBuffer;
    this._clearStencilBuffer = options.clearStencilBuffer === undefined ? false : options.clearStencilBuffer;
    this._clearOptions = {color:[this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a], depth:1, stencil:0, flags:(this._clearColorBuffer ? pc.CLEARFLAG_COLOR : 0) | (this._clearDepthBuffer ? pc.CLEARFLAG_DEPTH : 0) | (this._clearStencilBuffer ? pc.CLEARFLAG_STENCIL : 0)};
    this.onPreCull = options.onPreCull;
    this.onPreRender = options.onPreRender;
    this.onPreRenderOpaque = options.onPreRenderOpaque;
    this.onPreRenderTransparent = options.onPreRenderTransparent;
    this.onPostCull = options.onPostCull;
    this.onPostRender = options.onPostRender;
    this.onPostRenderOpaque = options.onPostRenderOpaque;
    this.onPostRenderTransparent = options.onPostRenderTransparent;
    this.onDrawCall = options.onDrawCall;
    this.onEnable = options.onEnable;
    this.onDisable = options.onDisable;
    if (this._enabled && this.onEnable) {
      this.onEnable();
    }
    this.layerReference = options.layerReference;
    this.instances = options.layerReference ? options.layerReference.instances : new InstanceList;
    this.cullingMask = options.cullingMask ? options.cullingMask : 4294967295;
    this.opaqueMeshInstances = this.instances.opaqueMeshInstances;
    this.transparentMeshInstances = this.instances.transparentMeshInstances;
    this.shadowCasters = this.instances.shadowCasters;
    this.customSortCallback = null;
    this.customCalculateSortValues = null;
    this._lightComponents = [];
    this._lights = [];
    this._sortedLights = [[], [], []];
    this.cameras = [];
    this._dirty = false;
    this._dirtyLights = false;
    this._dirtyCameras = false;
    this._cameraHash = 0;
    this._lightHash = 0;
    this._staticLightHash = 0;
    this._needsStaticPrepare = true;
    this._staticPrepareDone = false;
    this._shaderVersion = -1;
    this._version = 0;
    this._lightCube = null;
  };
  Object.defineProperty(Layer.prototype, "enabled", {get:function() {
    return this._enabled;
  }, set:function(val) {
    if (val !== this._enabled) {
      this._enabled = val;
      if (val) {
        this.incrementCounter();
        if (this.onEnable) {
          this.onEnable();
        }
      } else {
        this.decrementCounter();
        if (this.onDisable) {
          this.onDisable();
        }
      }
    }
  }});
  Object.defineProperty(Layer.prototype, "clearColor", {get:function() {
    return this._clearColor;
  }, set:function(val) {
    this._clearColor.copy(val);
  }});
  Layer.prototype._updateClearFlags = function() {
    var flags = 0;
    if (this._clearColorBuffer) {
      flags |= pc.CLEARFLAG_COLOR;
    }
    if (this._clearDepthBuffer) {
      flags |= pc.CLEARFLAG_DEPTH;
    }
    if (this._clearStencilBuffer) {
      flags |= pc.CLEARFLAG_STENCIL;
    }
    this._clearOptions.flags = flags;
  };
  Object.defineProperty(Layer.prototype, "clearColorBuffer", {get:function() {
    return this._clearColorBuffer;
  }, set:function(val) {
    this._clearColorBuffer = val;
    this._updateClearFlags();
  }});
  Object.defineProperty(Layer.prototype, "clearDepthBuffer", {get:function() {
    return this._clearDepthBuffer;
  }, set:function(val) {
    this._clearDepthBuffer = val;
    this._updateClearFlags();
  }});
  Object.defineProperty(Layer.prototype, "clearStencilBuffer", {get:function() {
    return this._clearStencilBuffer;
  }, set:function(val) {
    this._clearStencilBuffer = val;
    this._updateClearFlags();
  }});
  Layer.prototype.incrementCounter = function() {
    if (this._refCounter === 0) {
      this._enabled = true;
      if (this.onEnable) {
        this.onEnable();
      }
    }
    this._refCounter++;
  };
  Layer.prototype.decrementCounter = function() {
    if (this._refCounter === 1) {
      this._enabled = false;
      if (this.onDisable) {
        this.onDisable();
      }
    } else {
      if (this._refCounter === 0) {
        return;
      }
    }
    this._refCounter--;
  };
  Layer.prototype.addMeshInstances = function(meshInstances, skipShadowCasters) {
    var sceneShaderVer = this._shaderVersion;
    var m, arr, mat;
    var casters = this.shadowCasters;
    for (var i = 0; i < meshInstances.length; i++) {
      m = meshInstances[i];
      mat = m.material;
      if (mat.blendType === pc.BLEND_NONE) {
        arr = this.opaqueMeshInstances;
      } else {
        arr = this.transparentMeshInstances;
      }
      if (arr.indexOf(m) < 0) {
        arr.push(m);
      }
      if (!skipShadowCasters && m.castShadow && casters.indexOf(m) < 0) {
        casters.push(m);
      }
      if (!this.passThrough && sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) {
        if (mat.updateShader !== pc.Material.prototype.updateShader) {
          mat.clearVariants();
          mat.shader = null;
        }
        mat._shaderVersion = sceneShaderVer;
      }
    }
    if (!this.passThrough) {
      this._dirty = true;
    }
  };
  Layer.prototype.removeMeshInstances = function(meshInstances, skipShadowCasters) {
    var i, j, m, spliceOffset, spliceCount, len, drawCall;
    var opaque = this.opaqueMeshInstances;
    var transparent = this.transparentMeshInstances;
    var casters = this.shadowCasters;
    for (i = 0; i < meshInstances.length; i++) {
      m = meshInstances[i];
      spliceOffset = -1;
      spliceCount = 0;
      len = opaque.length;
      for (j = 0; j < len; j++) {
        drawCall = opaque[j];
        if (drawCall === m) {
          spliceOffset = j;
          spliceCount = 1;
          break;
        }
        if (drawCall._staticSource === m) {
          if (spliceOffset < 0) {
            spliceOffset = j;
          }
          spliceCount++;
        } else {
          if (spliceOffset >= 0) {
            break;
          }
        }
      }
      if (spliceOffset >= 0) {
        opaque.splice(spliceOffset, spliceCount);
      }
      spliceOffset = -1;
      spliceCount = 0;
      len = transparent.length;
      for (j = 0; j < len; j++) {
        drawCall = transparent[j];
        if (drawCall === m) {
          spliceOffset = j;
          spliceCount = 1;
          break;
        }
        if (drawCall._staticSource === m) {
          if (spliceOffset < 0) {
            spliceOffset = j;
          }
          spliceCount++;
        } else {
          if (spliceOffset >= 0) {
            break;
          }
        }
      }
      if (spliceOffset >= 0) {
        transparent.splice(spliceOffset, spliceCount);
      }
      if (skipShadowCasters) {
        continue;
      }
      j = casters.indexOf(m);
      if (j >= 0) {
        casters.splice(j, 1);
      }
    }
    this._dirty = true;
  };
  Layer.prototype.clearMeshInstances = function(skipShadowCasters) {
    if (this.opaqueMeshInstances.length === 0 && this.transparentMeshInstances.length === 0) {
      if (skipShadowCasters || this.shadowCasters.length === 0) {
        return;
      }
    }
    this.opaqueMeshInstances.length = 0;
    this.transparentMeshInstances.length = 0;
    if (!skipShadowCasters) {
      this.shadowCasters.length = 0;
    }
    if (!this.passThrough) {
      this._dirty = true;
    }
  };
  Layer.prototype.addLight = function(light) {
    if (this._lightComponents.indexOf(light) >= 0) {
      return;
    }
    this._lightComponents.push(light);
    this._lights.push(light.light);
    this._dirtyLights = true;
    this._generateLightHash();
  };
  Layer.prototype.removeLight = function(light) {
    var id = this._lightComponents.indexOf(light);
    if (id < 0) {
      return;
    }
    this._lightComponents.splice(id, 1);
    id = this._lights.indexOf(light.light);
    this._lights.splice(id, 1);
    this._dirtyLights = true;
    this._generateLightHash();
  };
  Layer.prototype.clearLights = function() {
    this._lightComponents.length = 0;
    this._lights.length = 0;
    this._dirtyLights = true;
  };
  Layer.prototype.addShadowCasters = function(meshInstances) {
    var m;
    var arr = this.shadowCasters;
    for (var i = 0; i < meshInstances.length; i++) {
      m = meshInstances[i];
      if (!m.castShadow) {
        continue;
      }
      if (arr.indexOf(m) < 0) {
        arr.push(m);
      }
    }
    this._dirtyLights = true;
  };
  Layer.prototype.removeShadowCasters = function(meshInstances) {
    var id;
    var arr = this.shadowCasters;
    for (var i = 0; i < meshInstances.length; i++) {
      id = arr.indexOf(meshInstances[i]);
      if (id >= 0) {
        arr.splice(id, 1);
      }
    }
    this._dirtyLights = true;
  };
  Layer.prototype._generateLightHash = function() {
    if (this._lights.length > 0) {
      this._lights.sort(sortLights);
      var str = "";
      var strStatic = "";
      for (var i = 0; i < this._lights.length; i++) {
        if (this._lights[i].isStatic) {
          strStatic += this._lights[i].key;
        } else {
          str += this._lights[i].key;
        }
      }
      if (str.length === 0) {
        this._lightHash = 0;
      } else {
        this._lightHash = pc.hashCode(str);
      }
      if (strStatic.length === 0) {
        this._staticLightHash = 0;
      } else {
        this._staticLightHash = pc.hashCode(strStatic);
      }
    } else {
      this._lightHash = 0;
      this._staticLightHash = 0;
    }
  };
  Layer.prototype._generateCameraHash = function() {
    if (this.cameras.length > 1) {
      this.cameras.sort(sortCameras);
      var str = "";
      for (var i = 0; i < this.cameras.length; i++) {
        str += this.cameras[i].entity.getGuid();
      }
      this._cameraHash = pc.hashCode(str);
    } else {
      this._cameraHash = 0;
    }
    this._dirtyCameras = true;
  };
  Layer.prototype.addCamera = function(camera) {
    if (this.cameras.indexOf(camera) >= 0) {
      return;
    }
    this.cameras.push(camera);
    this._generateCameraHash();
  };
  Layer.prototype.removeCamera = function(camera) {
    var id = this.cameras.indexOf(camera);
    if (id < 0) {
      return;
    }
    this.cameras.splice(id, 1);
    this._generateCameraHash();
    this.instances.clearVisibleLists(id);
  };
  Layer.prototype.clearCameras = function() {
    this.cameras.length = 0;
    this._cameraHash = 0;
    this._dirtyCameras = true;
  };
  Layer.prototype._sortCameras = function() {
    this._generateCameraHash();
  };
  Layer.prototype._calculateSortDistances = function(drawCalls, drawCallsCount, camPos, camFwd) {
    var i, drawCall, meshPos;
    var tempx, tempy, tempz;
    for (i = 0; i < drawCallsCount; i++) {
      drawCall = drawCalls[i];
      if (drawCall.command) {
        continue;
      }
      if (drawCall.layer <= pc.LAYER_FX) {
        continue;
      }
      meshPos = drawCall.aabb.center;
      tempx = meshPos.x - camPos.x;
      tempy = meshPos.y - camPos.y;
      tempz = meshPos.z - camPos.z;
      drawCall.zdist = tempx * camFwd.x + tempy * camFwd.y + tempz * camFwd.z;
    }
  };
  Layer.prototype._sortVisible = function(transparent, cameraNode, cameraPass) {
    var objects = this.instances;
    var sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;
    if (sortMode === pc.SORTMODE_NONE) {
      return;
    }
    var visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];
    if (sortMode === pc.SORTMODE_CUSTOM) {
      sortPos = cameraNode.getPosition();
      sortDir = cameraNode.forward;
      if (this.customCalculateSortValues) {
        this.customCalculateSortValues(visible.list, visible.length, sortPos, sortDir);
      }
      if (visible.list.length !== visible.length) {
        visible.list.length = visible.length;
      }
      if (this.customSortCallback) {
        visible.list.sort(this.customSortCallback);
      }
    } else {
      if (sortMode === pc.SORTMODE_BACK2FRONT || sortMode === pc.SORTMODE_FRONT2BACK) {
        sortPos = cameraNode.getPosition();
        sortDir = cameraNode.forward;
        this._calculateSortDistances(visible.list, visible.length, sortPos, sortDir);
      }
      if (visible.list.length !== visible.length) {
        visible.list.length = visible.length;
      }
      visible.list.sort(sortCallbacks[sortMode]);
    }
  };
  return {Layer:Layer, InstanceList:InstanceList, VisibleInstanceList:VisibleInstanceList};
}());
Object.assign(pc, function() {
  var LayerComposition = function() {
    this.layerList = [];
    this.subLayerList = [];
    this.subLayerEnabled = [];
    this._opaqueOrder = {};
    this._transparentOrder = {};
    this._dirty = false;
    this._dirtyBlend = false;
    this._dirtyLights = false;
    this._dirtyCameras = false;
    this._meshInstances = [];
    this._lights = [];
    this.cameras = [];
    this._sortedLights = [[], [], []];
    this._lightShadowCasters = [];
    this._globalLightCameras = [];
    this._globalLightCameraIds = [];
    this._renderedRt = [];
    this._renderedByCam = [];
    this._renderedLayer = [];
    this._renderList = [];
    this._renderListCamera = [];
    pc.events.attach(this);
  };
  LayerComposition.prototype._sortLights = function(target) {
    var light;
    var lights = target._lights;
    target._sortedLights[pc.LIGHTTYPE_DIRECTIONAL].length = 0;
    target._sortedLights[pc.LIGHTTYPE_POINT].length = 0;
    target._sortedLights[pc.LIGHTTYPE_SPOT].length = 0;
    for (var i = 0; i < lights.length; i++) {
      light = lights[i];
      if (light._enabled) {
        target._sortedLights[light._type].push(light);
      }
    }
  };
  LayerComposition.prototype._update = function() {
    var i, j, k, l;
    var layer;
    var len = this.layerList.length;
    var result = 0;
    if (!this._dirty || !this._dirtyLights || !this._dirtyCameras) {
      for (i = 0; i < len; i++) {
        layer = this.layerList[i];
        if (layer._dirty) {
          this._dirty = true;
        }
        if (layer._dirtyLights) {
          this._dirtyLights = true;
        }
        if (layer._dirtyCameras) {
          this._dirtyCameras = true;
        }
      }
    }
    var arr;
    if (this._dirty) {
      result |= pc.COMPUPDATED_INSTANCES;
      this._meshInstances.length = 0;
      var mi;
      for (i = 0; i < len; i++) {
        layer = this.layerList[i];
        if (layer.passThrough) {
          continue;
        }
        arr = layer.opaqueMeshInstances;
        for (j = 0; j < arr.length; j++) {
          mi = arr[j];
          if (this._meshInstances.indexOf(mi) < 0) {
            this._meshInstances.push(mi);
            if (mi.material && mi.material._dirtyBlend) {
              this._dirtyBlend = true;
              mi.material._dirtyBlend = false;
            }
          }
        }
        arr = layer.transparentMeshInstances;
        for (j = 0; j < arr.length; j++) {
          mi = arr[j];
          if (this._meshInstances.indexOf(mi) < 0) {
            this._meshInstances.push(mi);
            if (mi.material && mi.material._dirtyBlend) {
              this._dirtyBlend = true;
              mi.material._dirtyBlend = false;
            }
          }
        }
      }
      for (i = 0; i < len; i++) {
        this.layerList[i]._dirty = false;
        this.layerList[i]._version++;
      }
    }
    if (this._dirtyBlend) {
      result |= pc.COMPUPDATED_BLEND;
      var opaqueOld, transparentOld, opaqueNew, transparentNew;
      for (i = 0; i < len; i++) {
        layer = this.layerList[i];
        if (layer.passThrough) {
          continue;
        }
        opaqueOld = layer.opaqueMeshInstances;
        transparentOld = layer.transparentMeshInstances;
        opaqueNew = [];
        transparentNew = [];
        for (j = 0; j < opaqueOld.length; j++) {
          if (opaqueOld[j].material && opaqueOld[j].material.blendType !== pc.BLEND_NONE) {
            transparentNew.push(opaqueOld[j]);
          } else {
            opaqueNew.push(opaqueOld[j]);
          }
        }
        for (j = 0; j < transparentOld.length; j++) {
          if (transparentOld[j].material && transparentOld[j].material.blendType !== pc.BLEND_NONE) {
            transparentNew.push(transparentOld[j]);
          } else {
            opaqueNew.push(transparentOld[j]);
          }
        }
        layer.opaqueMeshInstances.length = opaqueNew.length;
        for (j = 0; j < opaqueNew.length; j++) {
          layer.opaqueMeshInstances[j] = opaqueNew[j];
        }
        layer.transparentMeshInstances.length = transparentNew.length;
        for (j = 0; j < transparentNew.length; j++) {
          layer.transparentMeshInstances[j] = transparentNew[j];
        }
      }
      this._dirtyBlend = false;
    }
    this._dirty = false;
    var casters, lid, light;
    if (this._dirtyLights) {
      result |= pc.COMPUPDATED_LIGHTS;
      this._lights.length = 0;
      this._lightShadowCasters.length = 0;
      for (i = 0; i < len; i++) {
        layer = this.layerList[i];
        arr = layer._lights;
        for (j = 0; j < arr.length; j++) {
          light = arr[j];
          lid = this._lights.indexOf(light);
          if (lid < 0) {
            this._lights.push(light);
            lid = this._lights.length - 1;
          }
          casters = this._lightShadowCasters[lid];
          if (!casters) {
            this._lightShadowCasters[lid] = casters = [];
          }
        }
      }
    }
    if (this._dirtyLights) {
      this._sortLights(this);
      this._dirtyLights = false;
      for (i = 0; i < len; i++) {
        layer = this.layerList[i];
        this._sortLights(layer);
        layer._dirtyLights = false;
      }
    }
    if (result) {
      for (i = 0; i < len; i++) {
        layer = this.layerList[i];
        arr = layer._lights;
        for (j = 0; j < arr.length; j++) {
          light = arr[j];
          lid = this._lights.indexOf(light);
          casters = this._lightShadowCasters[lid];
          var meshInstances = layer.shadowCasters;
          for (k = 0; k < casters.length;) {
            if (this._meshInstances.indexOf(casters[k]) < 0) {
              casters[k] = casters[casters.length - 1];
              casters.length -= 1;
            } else {
              k++;
            }
          }
          for (k = 0; k < meshInstances.length; k++) {
            if (casters.indexOf(meshInstances[k]) < 0) {
              casters.push(meshInstances[k]);
            }
          }
        }
      }
    }
    if (result & pc.COMPUPDATED_LIGHTS || this._dirtyCameras) {
      this._globalLightCameras.length = 0;
      var globalLights = this._sortedLights[pc.LIGHTTYPE_DIRECTIONAL];
      for (l = 0; l < globalLights.length; l++) {
        light = globalLights[l];
        this._globalLightCameras[l] = [];
        for (i = 0; i < len; i++) {
          layer = this.layerList[i];
          if (layer._sortedLights[pc.LIGHTTYPE_DIRECTIONAL].indexOf(light) < 0) {
            continue;
          }
          for (k = 0; k < layer.cameras.length; k++) {
            if (this._globalLightCameras[l].indexOf(layer.cameras[k]) >= 0) {
              continue;
            }
            this._globalLightCameras[l].push(layer.cameras[k]);
          }
        }
      }
    }
    var camera, index;
    if (this._dirtyCameras) {
      result |= pc.COMPUPDATED_CAMERAS;
      this.cameras.length = 0;
      for (i = 0; i < len; i++) {
        layer = this.layerList[i];
        for (j = 0; j < layer.cameras.length; j++) {
          camera = layer.cameras[j];
          index = this.cameras.indexOf(camera);
          if (index < 0) {
            index = this.cameras.length;
            this.cameras.push(camera);
          }
        }
      }
      this._renderList.length = 0;
      this._renderListCamera.length = 0;
      var hash, hash2, groupLength, cam;
      var skipCount = 0;
      for (i = 0; i < len; i++) {
        if (skipCount) {
          skipCount--;
          continue;
        }
        layer = this.layerList[i];
        if (layer.cameras.length === 0 && !layer.isPostEffect) {
          continue;
        }
        hash = layer._cameraHash;
        if (hash === 0) {
          this._renderList.push(i);
          this._renderListCamera.push(0);
        } else {
          groupLength = 1;
          for (j = i + 1; j < len; j++) {
            hash2 = this.layerList[j]._cameraHash;
            if (hash !== hash2) {
              groupLength = j - i - 1;
              break;
            } else {
              if (j === len - 1) {
                groupLength = j - i;
              }
            }
          }
          if (groupLength === 1) {
            for (cam = 0; cam < layer.cameras.length; cam++) {
              this._renderList.push(i);
              this._renderListCamera.push(cam);
            }
          } else {
            cam = 0;
            for (cam = 0; cam < layer.cameras.length; cam++) {
              for (j = 0; j <= groupLength; j++) {
                this._renderList.push(i + j);
                this._renderListCamera.push(cam);
              }
            }
            skipCount = groupLength;
          }
        }
      }
      this._dirtyCameras = false;
      for (i = 0; i < len; i++) {
        this.layerList[i]._dirtyCameras = false;
      }
    }
    if (result & pc.COMPUPDATED_LIGHTS || result & pc.COMPUPDATED_CAMERAS) {
      this._globalLightCameraIds.length = 0;
      for (l = 0; l < this._globalLightCameras.length; l++) {
        arr = [];
        for (i = 0; i < this._globalLightCameras[l].length; i++) {
          index = this.cameras.indexOf(this._globalLightCameras[l][i]);
          if (index < 0) {
            continue;
          }
          arr.push(index);
        }
        this._globalLightCameraIds.push(arr);
      }
    }
    return result;
  };
  LayerComposition.prototype._isLayerAdded = function(layer) {
    if (this.layerList.indexOf(layer) >= 0) {
      return true;
    }
    return false;
  };
  LayerComposition.prototype._isSublayerAdded = function(layer, transparent) {
    for (var i = 0; i < this.layerList.length; i++) {
      if (this.layerList[i] === layer && this.subLayerList[i] === transparent) {
        return true;
      }
    }
    return false;
  };
  LayerComposition.prototype.push = function(layer) {
    if (this._isLayerAdded(layer)) {
      return;
    }
    this.layerList.push(layer);
    this.layerList.push(layer);
    this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
    this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
    this.subLayerEnabled.push(true);
    this.subLayerEnabled.push(true);
    this._dirty = true;
    this._dirtyLights = true;
    this._dirtyCameras = true;
    this.fire("add", layer);
  };
  LayerComposition.prototype.insert = function(layer, index) {
    if (this._isLayerAdded(layer)) {
      return;
    }
    this.layerList.splice(index, 0, layer, layer);
    this.subLayerList.splice(index, 0, false, true);
    var count = this.layerList.length;
    this._updateOpaqueOrder(index, count - 1);
    this._updateTransparentOrder(index, count - 1);
    this.subLayerEnabled.splice(index, 0, true, true);
    this._dirty = true;
    this._dirtyLights = true;
    this._dirtyCameras = true;
    this.fire("add", layer);
  };
  LayerComposition.prototype.remove = function(layer) {
    var id = this.layerList.indexOf(layer);
    delete this._opaqueOrder[id];
    delete this._transparentOrder[id];
    while (id >= 0) {
      this.layerList.splice(id, 1);
      this.subLayerList.splice(id, 1);
      this.subLayerEnabled.splice(id, 1);
      id = this.layerList.indexOf(layer);
      this._dirty = true;
      this._dirtyLights = true;
      this._dirtyCameras = true;
      this.fire("remove", layer);
    }
    var count = this.layerList.length;
    this._updateOpaqueOrder(0, count - 1);
    this._updateTransparentOrder(0, count - 1);
  };
  LayerComposition.prototype.pushOpaque = function(layer) {
    if (this._isSublayerAdded(layer, false)) {
      return;
    }
    this.layerList.push(layer);
    this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
    this.subLayerEnabled.push(true);
    this._dirty = true;
    this._dirtyLights = true;
    this._dirtyCameras = true;
    this.fire("add", layer);
  };
  LayerComposition.prototype.insertOpaque = function(layer, index) {
    if (this._isSublayerAdded(layer, false)) {
      return;
    }
    this.layerList.splice(index, 0, layer);
    this.subLayerList.splice(index, 0, false);
    var count = this.subLayerList.length;
    this._updateOpaqueOrder(index, count - 1);
    this.subLayerEnabled.splice(index, 0, true);
    this._dirty = true;
    this._dirtyLights = true;
    this._dirtyCameras = true;
    this.fire("add", layer);
  };
  LayerComposition.prototype.removeOpaque = function(layer) {
    for (var i = 0, len = this.layerList.length; i < len; i++) {
      if (this.layerList[i] === layer && !this.subLayerList[i]) {
        this.layerList.splice(i, 1);
        this.subLayerList.splice(i, 1);
        len--;
        this._updateOpaqueOrder(i, len - 1);
        this.subLayerEnabled.splice(i, 1);
        this._dirty = true;
        this._dirtyLights = true;
        this._dirtyCameras = true;
        if (this.layerList.indexOf(layer) < 0) {
          this.fire("remove", layer);
        }
        return;
      }
    }
  };
  LayerComposition.prototype.pushTransparent = function(layer) {
    if (this._isSublayerAdded(layer, true)) {
      return;
    }
    this.layerList.push(layer);
    this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
    this.subLayerEnabled.push(true);
    this._dirty = true;
    this._dirtyLights = true;
    this._dirtyCameras = true;
    this.fire("add", layer);
  };
  LayerComposition.prototype.insertTransparent = function(layer, index) {
    if (this._isSublayerAdded(layer, true)) {
      return;
    }
    this.layerList.splice(index, 0, layer);
    this.subLayerList.splice(index, 0, true);
    var count = this.subLayerList.length;
    this._updateTransparentOrder(index, count - 1);
    this.subLayerEnabled.splice(index, 0, true);
    this._dirty = true;
    this._dirtyLights = true;
    this._dirtyCameras = true;
    this.fire("add", layer);
  };
  LayerComposition.prototype.removeTransparent = function(layer) {
    for (var i = 0, len = this.layerList.length; i < len; i++) {
      if (this.layerList[i] === layer && this.subLayerList[i]) {
        this.layerList.splice(i, 1);
        this.subLayerList.splice(i, 1);
        len--;
        this._updateTransparentOrder(i, len - 1);
        this.subLayerEnabled.splice(i, 1);
        this._dirty = true;
        this._dirtyLights = true;
        this._dirtyCameras = true;
        if (this.layerList.indexOf(layer) < 0) {
          this.fire("remove", layer);
        }
        return;
      }
    }
  };
  LayerComposition.prototype._getSublayerIndex = function(layer, transparent) {
    var id = this.layerList.indexOf(layer);
    if (id < 0) {
      return -1;
    }
    if (this.subLayerList[id] !== transparent) {
      id = this.layerList.indexOf(layer, id + 1);
      if (id < 0) {
        return -1;
      }
      if (this.subLayerList[id] !== transparent) {
        return -1;
      }
    }
    return id;
  };
  LayerComposition.prototype.getOpaqueIndex = function(layer) {
    return this._getSublayerIndex(layer, false);
  };
  LayerComposition.prototype.getTransparentIndex = function(layer) {
    return this._getSublayerIndex(layer, true);
  };
  LayerComposition.prototype.getLayerById = function(id) {
    for (var i = 0; i < this.layerList.length; i++) {
      if (this.layerList[i].id === id) {
        return this.layerList[i];
      }
    }
    return null;
  };
  LayerComposition.prototype.getLayerByName = function(name) {
    for (var i = 0; i < this.layerList.length; i++) {
      if (this.layerList[i].name === name) {
        return this.layerList[i];
      }
    }
    return null;
  };
  LayerComposition.prototype._updateOpaqueOrder = function(startIndex, endIndex) {
    for (var i = startIndex; i <= endIndex; i++) {
      if (this.subLayerList[i] === false) {
        this._opaqueOrder[this.layerList[i].id] = i;
      }
    }
  };
  LayerComposition.prototype._updateTransparentOrder = function(startIndex, endIndex) {
    for (var i = startIndex; i <= endIndex; i++) {
      if (this.subLayerList[i] === true) {
        this._transparentOrder[this.layerList[i].id] = i;
      }
    }
  };
  LayerComposition.prototype._sortLayersDescending = function(layersA, layersB, order) {
    var i = 0;
    var len = 0;
    var id = 0;
    var topLayerA = -1;
    var topLayerB = -1;
    for (i = 0, len = layersA.length; i < len; i++) {
      id = layersA[i];
      if (order.hasOwnProperty(id)) {
        topLayerA = Math.max(topLayerA, order[id]);
      }
    }
    for (i = 0, len = layersB.length; i < len; i++) {
      id = layersB[i];
      if (order.hasOwnProperty(id)) {
        topLayerB = Math.max(topLayerB, order[id]);
      }
    }
    if (topLayerA === -1 && topLayerB !== -1) {
      return 1;
    } else {
      if (topLayerB === -1 && topLayerA !== -1) {
        return -1;
      }
    }
    return topLayerB - topLayerA;
  };
  LayerComposition.prototype.sortTransparentLayers = function(layersA, layersB) {
    return this._sortLayersDescending(layersA, layersB, this._transparentOrder);
  };
  LayerComposition.prototype.sortOpaqueLayers = function(layersA, layersB) {
    return this._sortLayersDescending(layersA, layersB, this._opaqueOrder);
  };
  return {LayerComposition:LayerComposition};
}());
Object.assign(pc, function() {
  pc.SPRITE_RENDERMODE_SIMPLE = 0;
  pc.SPRITE_RENDERMODE_SLICED = 1;
  pc.SPRITE_RENDERMODE_TILED = 2;
  var spriteNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
  var spriteIndices = [0, 1, 3, 2, 3, 1];
  var Sprite = function(device, options) {
    this._device = device;
    this._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;
    this._renderMode = options && options.renderMode !== undefined ? options.renderMode : pc.SPRITE_RENDERMODE_SIMPLE;
    this._atlas = options && options.atlas !== undefined ? options.atlas : null;
    this._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;
    this._meshes = [];
    this._updatingProperties = false;
    this._meshesDirty = false;
    pc.events.attach(this);
    if (this._atlas && this._frameKeys) {
      this._createMeshes();
    }
  };
  Sprite.prototype._createMeshes = function() {
    var i, len;
    for (i = 0, len = this._meshes.length; i < len; i++) {
      var mesh = this._meshes[i];
      if (!mesh) {
        continue;
      }
      mesh.vertexBuffer.destroy();
      for (var j = 0, len2 = mesh.indexBuffer.length; j < len2; j++) {
        mesh.indexBuffer[j].destroy();
      }
    }
    var count = this._frameKeys.length;
    this._meshes = new Array(count);
    var createMeshFunc = this.renderMode === pc.SPRITE_RENDERMODE_SLICED || this._renderMode === pc.SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh;
    for (i = 0; i < count; i++) {
      var frame = this._atlas.frames[this._frameKeys[i]];
      this._meshes[i] = frame ? createMeshFunc.call(this, frame) : null;
    }
    this.fire("set:meshes");
  };
  Sprite.prototype._createSimpleMesh = function(frame) {
    var rect = frame.rect;
    var texWidth = this._atlas.texture.width;
    var texHeight = this._atlas.texture.height;
    var w = rect.z / this._pixelsPerUnit;
    var h = rect.w / this._pixelsPerUnit;
    var hp = frame.pivot.x;
    var vp = frame.pivot.y;
    var positions = [-hp * w, -vp * h, 0, (1 - hp) * w, -vp * h, 0, (1 - hp) * w, (1 - vp) * h, 0, -hp * w, (1 - vp) * h, 0];
    var lu = rect.x / texWidth;
    var bv = rect.y / texHeight;
    var ru = (rect.x + rect.z) / texWidth;
    var tv = (rect.y + rect.w) / texHeight;
    var uvs = [lu, bv, ru, bv, ru, tv, lu, tv];
    var mesh = pc.createMesh(this._device, positions, {uvs:uvs, normals:spriteNormals, indices:spriteIndices});
    return mesh;
  };
  Sprite.prototype._create9SliceMesh = function() {
    var he = pc.Vec2.ONE;
    var ws = 3;
    var ls = 3;
    var i, j;
    var x, y, z, u, v;
    var positions = [];
    var normals = [];
    var uvs = [];
    var indices = [];
    var vcounter = 0;
    for (i = 0; i <= ws; i++) {
      u = i === 0 || i === ws ? 0 : 1;
      for (j = 0; j <= ls; j++) {
        x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;
        y = 0.0;
        z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);
        v = j === 0 || j === ls ? 0 : 1;
        positions.push(-x, y, z);
        normals.push(0.0, 1.0, 0.0);
        uvs.push(u, v);
        if (i < ws && j < ls) {
          indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
          indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
        }
        vcounter++;
      }
    }
    var options = {normals:normals, uvs:uvs, indices:indices};
    return pc.createMesh(this._device, positions, options);
  };
  Sprite.prototype._onSetFrames = function(frames) {
    if (this._updatingProperties) {
      this._meshesDirty = true;
    } else {
      this._createMeshes();
    }
  };
  Sprite.prototype._onFrameChanged = function(frameKey, frame) {
    var idx = this._frameKeys.indexOf(frameKey);
    if (idx < 0) {
      return;
    }
    if (frame) {
      if (this.renderMode === pc.SPRITE_RENDERMODE_SIMPLE) {
        this._meshes[idx] = this._createSimpleMesh(frame);
      }
    } else {
      this._meshes[idx] = null;
    }
    this.fire("set:meshes");
  };
  Sprite.prototype._onFrameRemoved = function(frameKey) {
    var idx = this._frameKeys.indexOf(frameKey);
    if (idx < 0) {
      return;
    }
    this._meshes[idx] = null;
    this.fire("set:meshes");
  };
  Sprite.prototype.startUpdate = function() {
    this._updatingProperties = true;
    this._meshesDirty = false;
  };
  Sprite.prototype.endUpdate = function() {
    this._updatingProperties = false;
    if (this._meshesDirty && this._atlas && this._frameKeys) {
      this._createMeshes();
    }
    this._meshesDirty = false;
  };
  Sprite.prototype.destroy = function() {
    var i;
    var len;
    for (i = 0, len = this._meshes.length; i < len; i++) {
      var mesh = this._meshes[i];
      if (!mesh) {
        continue;
      }
      mesh.vertexBuffer.destroy();
      for (var j = 0, len2 = mesh.indexBuffer.length; j < len2; j++) {
        mesh.indexBuffer[j].destroy();
      }
    }
    this._meshes.length = 0;
  };
  Object.defineProperty(Sprite.prototype, "frameKeys", {get:function() {
    return this._frameKeys;
  }, set:function(value) {
    this._frameKeys = value;
    if (this._atlas && this._frameKeys) {
      if (this._updatingProperties) {
        this._meshesDirty = true;
      } else {
        this._createMeshes();
      }
    }
    this.fire("set:frameKeys", value);
  }});
  Object.defineProperty(Sprite.prototype, "atlas", {get:function() {
    return this._atlas;
  }, set:function(value) {
    if (value === this._atlas) {
      return;
    }
    if (this._atlas) {
      this._atlas.off("set:frames", this._onSetFrames, this);
      this._atlas.off("set:frame", this._onFrameChanged, this);
      this._atlas.off("remove:frame", this._onFrameRemoved, this);
    }
    this._atlas = value;
    if (this._atlas && this._frameKeys) {
      this._atlas.on("set:frames", this._onSetFrames, this);
      this._atlas.on("set:frame", this._onFrameChanged, this);
      this._atlas.on("remove:frame", this._onFrameRemoved, this);
      if (this._updatingProperties) {
        this._meshesDirty = true;
      } else {
        this._createMeshes();
      }
    }
    this.fire("set:atlas", value);
  }});
  Object.defineProperty(Sprite.prototype, "pixelsPerUnit", {get:function() {
    return this._pixelsPerUnit;
  }, set:function(value) {
    if (this._pixelsPerUnit === value) {
      return;
    }
    this._pixelsPerUnit = value;
    this.fire("set:pixelsPerUnit", value);
    if (this._atlas && this._frameKeys && this.renderMode === pc.SPRITE_RENDERMODE_SIMPLE) {
      if (this._updatingProperties) {
        this._meshesDirty = true;
      } else {
        this._createMeshes();
      }
    }
  }});
  Object.defineProperty(Sprite.prototype, "renderMode", {get:function() {
    return this._renderMode;
  }, set:function(value) {
    if (this._renderMode === value) {
      return;
    }
    var prev = this._renderMode;
    this._renderMode = value;
    this.fire("set:renderMode", value);
    if (prev === pc.SPRITE_RENDERMODE_SIMPLE || value === pc.SPRITE_RENDERMODE_SIMPLE) {
      if (this._atlas && this._frameKeys) {
        if (this._updatingProperties) {
          this._meshesDirty = true;
        } else {
          this._createMeshes();
        }
      }
    }
  }});
  Object.defineProperty(Sprite.prototype, "meshes", {get:function() {
    return this._meshes;
  }});
  return {Sprite:Sprite};
}());
Object.assign(pc, function() {
  var SyncQueue = function() {
    this._index = [];
    this._values = [];
  };
  SyncQueue.prototype.runSync = function() {
    for (var i = 0, len = this._values.length; i < len; i++) {
      this._values[i].syncHierarchy();
    }
    this._values.length = 0;
    this._index.length = 0;
  };
  SyncQueue.prototype.erase = function(n) {
    var idx = this._values.indexOf(n);
    if (idx >= 0) {
      this._index.splice(idx, 1);
      this._values.splice(idx, 1);
    }
  };
  var bs = function(index, s, e, k) {
    if (s === e) {
      return s;
    }
    var m = Math.floor((s + e) / 2);
    if (index[m] > k) {
      return bs(index, s, m, k);
    } else {
      if (index[m] < k) {
        return bs(index, m + 1, e, k);
      }
    }
    return m;
  };
  SyncQueue.prototype.push = function(p, v) {
    var i = bs(this._index, 0, this._index.length, p);
    this._values.splice(i, 0, v);
    this._index.splice(i, 0, p);
  };
  return {SyncQueue:SyncQueue};
}());
Object.assign(pc, function() {
  var TextureAtlas = function() {
    this._texture = null;
    this._frames = null;
    pc.events.attach(this);
  };
  TextureAtlas.prototype.setFrame = function(key, data) {
    var frame = this._frames[key];
    if (!frame) {
      frame = {rect:data.rect.clone(), pivot:data.pivot.clone(), border:data.border.clone()};
      this._frames[key] = frame;
    } else {
      frame.rect.copy(data.rect);
      frame.pivot.copy(data.pivot);
      frame.border.copy(data.border);
    }
    this.fire("set:frame", key.toString(), frame);
  };
  TextureAtlas.prototype.removeFrame = function(key) {
    var frame = this._frames[key];
    if (frame) {
      delete this._frames[key];
      this.fire("remove:frame", key.toString(), frame);
    }
  };
  TextureAtlas.prototype.destroy = function() {
    if (this._texture) {
      this._texture.destroy();
    }
  };
  Object.defineProperty(TextureAtlas.prototype, "texture", {get:function() {
    return this._texture;
  }, set:function(value) {
    this._texture = value;
    this.fire("set:texture", value);
  }});
  Object.defineProperty(TextureAtlas.prototype, "frames", {get:function() {
    return this._frames;
  }, set:function(value) {
    this._frames = value;
    this.fire("set:frames", value);
  }});
  return {TextureAtlas:TextureAtlas};
}());
Object.assign(pc, function() {
  var StencilParameters = function(options) {
    this.func = options.func === undefined ? pc.FUNC_ALWAYS : options.func;
    this.ref = options.ref || 0;
    this.readMask = options.readMask === undefined ? 255 : options.readMask;
    this.writeMask = options.writeMask === undefined ? 255 : options.writeMask;
    this.fail = options.fail || pc.STENCILOP_KEEP;
    this.zfail = options.zfail || pc.STENCILOP_KEEP;
    this.zpass = options.zpass || pc.STENCILOP_KEEP;
  };
  StencilParameters.prototype.clone = function() {
    var clone = new pc.StencilParameters({func:this.func, ref:this.ref, readMask:this.readMask, writeMask:this.writeMask, fail:this.fail, zfail:this.zfail, zpass:this.zpass});
    return clone;
  };
  return {StencilParameters:StencilParameters};
}());
(function() {
  var enums = {ACTION_MOUSE:"mouse", ACTION_KEYBOARD:"keyboard", ACTION_GAMEPAD:"gamepad", AXIS_MOUSE_X:"mousex", AXIS_MOUSE_Y:"mousey", AXIS_PAD_L_X:"padlx", AXIS_PAD_L_Y:"padly", AXIS_PAD_R_X:"padrx", AXIS_PAD_R_Y:"padry", AXIS_KEY:"key", EVENT_KEYDOWN:"keydown", EVENT_KEYUP:"keyup", EVENT_MOUSEDOWN:"mousedown", EVENT_MOUSEMOVE:"mousemove", EVENT_MOUSEUP:"mouseup", EVENT_MOUSEWHEEL:"mousewheel", EVENT_TOUCHSTART:"touchstart", EVENT_TOUCHEND:"touchend", EVENT_TOUCHMOVE:"touchmove", EVENT_TOUCHCANCEL:"touchcancel", 
  KEY_BACKSPACE:8, KEY_TAB:9, KEY_RETURN:13, KEY_ENTER:13, KEY_SHIFT:16, KEY_CONTROL:17, KEY_ALT:18, KEY_PAUSE:19, KEY_CAPS_LOCK:20, KEY_ESCAPE:27, KEY_SPACE:32, KEY_PAGE_UP:33, KEY_PAGE_DOWN:34, KEY_END:35, KEY_HOME:36, KEY_LEFT:37, KEY_UP:38, KEY_RIGHT:39, KEY_DOWN:40, KEY_PRINT_SCREEN:44, KEY_INSERT:45, KEY_DELETE:46, KEY_0:48, KEY_1:49, KEY_2:50, KEY_3:51, KEY_4:52, KEY_5:53, KEY_6:54, KEY_7:55, KEY_8:56, KEY_9:57, KEY_SEMICOLON:59, KEY_EQUAL:61, KEY_A:65, KEY_B:66, KEY_C:67, KEY_D:68, KEY_E:69, 
  KEY_F:70, KEY_G:71, KEY_H:72, KEY_I:73, KEY_J:74, KEY_K:75, KEY_L:76, KEY_M:77, KEY_N:78, KEY_O:79, KEY_P:80, KEY_Q:81, KEY_R:82, KEY_S:83, KEY_T:84, KEY_U:85, KEY_V:86, KEY_W:87, KEY_X:88, KEY_Y:89, KEY_Z:90, KEY_WINDOWS:91, KEY_CONTEXT_MENU:93, KEY_NUMPAD_0:96, KEY_NUMPAD_1:97, KEY_NUMPAD_2:98, KEY_NUMPAD_3:99, KEY_NUMPAD_4:100, KEY_NUMPAD_5:101, KEY_NUMPAD_6:102, KEY_NUMPAD_7:103, KEY_NUMPAD_8:104, KEY_NUMPAD_9:105, KEY_MULTIPLY:106, KEY_ADD:107, KEY_SEPARATOR:108, KEY_SUBTRACT:109, KEY_DECIMAL:110, 
  KEY_DIVIDE:111, KEY_F1:112, KEY_F2:113, KEY_F3:114, KEY_F4:115, KEY_F5:116, KEY_F6:117, KEY_F7:118, KEY_F8:119, KEY_F9:120, KEY_F10:121, KEY_F11:122, KEY_F12:123, KEY_COMMA:188, KEY_PERIOD:190, KEY_SLASH:191, KEY_OPEN_BRACKET:219, KEY_BACK_SLASH:220, KEY_CLOSE_BRACKET:221, KEY_META:224, MOUSEBUTTON_NONE:-1, MOUSEBUTTON_LEFT:0, MOUSEBUTTON_MIDDLE:1, MOUSEBUTTON_RIGHT:2, PAD_1:0, PAD_2:1, PAD_3:2, PAD_4:3, PAD_FACE_1:0, PAD_FACE_2:1, PAD_FACE_3:2, PAD_FACE_4:3, PAD_L_SHOULDER_1:4, PAD_R_SHOULDER_1:5, 
  PAD_L_SHOULDER_2:6, PAD_R_SHOULDER_2:7, PAD_SELECT:8, PAD_START:9, PAD_L_STICK_BUTTON:10, PAD_R_STICK_BUTTON:11, PAD_UP:12, PAD_DOWN:13, PAD_LEFT:14, PAD_RIGHT:15, PAD_VENDOR:16, PAD_L_STICK_X:0, PAD_L_STICK_Y:1, PAD_R_STICK_X:2, PAD_R_STICK_Y:3};
  Object.assign(pc, enums);
  pc.input = {};
  Object.assign(pc.input, enums);
})();
Object.assign(pc, function() {
  var MouseEvent = function(mouse, event) {
    var coords = {x:0, y:0};
    if (event) {
      if (event instanceof MouseEvent) {
        throw Error("Expected MouseEvent");
      }
      coords = mouse._getTargetCoords(event);
    } else {
      event = {};
    }
    if (coords) {
      this.x = coords.x;
      this.y = coords.y;
    } else {
      if (pc.Mouse.isPointerLocked()) {
        this.x = 0;
        this.y = 0;
      } else {
        return;
      }
    }
    if (event.detail) {
      this.wheel = -1 * event.detail;
    } else {
      if (event.wheelDelta) {
        this.wheel = event.wheelDelta / 120;
      } else {
        this.wheel = 0;
      }
    }
    if (pc.Mouse.isPointerLocked()) {
      this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
      this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
    } else {
      this.dx = this.x - mouse._lastX;
      this.dy = this.y - mouse._lastY;
    }
    if (event.type === "mousedown" || event.type === "mouseup") {
      this.button = event.button;
    } else {
      this.button = pc.MOUSEBUTTON_NONE;
    }
    this.buttons = mouse._buttons.slice(0);
    this.element = event.target;
    this.ctrlKey = event.ctrlKey || false;
    this.altKey = event.altKey || false;
    this.shiftKey = event.shiftKey || false;
    this.metaKey = event.metaKey || false;
    this.event = event;
  };
  var Mouse = function(element) {
    this._lastX = 0;
    this._lastY = 0;
    this._buttons = [false, false, false];
    this._lastbuttons = [false, false, false];
    this._upHandler = this._handleUp.bind(this);
    this._downHandler = this._handleDown.bind(this);
    this._moveHandler = this._handleMove.bind(this);
    this._wheelHandler = this._handleWheel.bind(this);
    this._contextMenuHandler = function(event) {
      event.preventDefault();
    };
    this._target = null;
    this._attached = false;
    this.attach(element);
    pc.events.attach(this);
  };
  Mouse.isPointerLocked = function() {
    return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);
  };
  Object.assign(Mouse.prototype, {attach:function(element) {
    this._target = element;
    if (this._attached) {
      return;
    }
    this._attached = true;
    window.addEventListener("mouseup", this._upHandler, false);
    window.addEventListener("mousedown", this._downHandler, false);
    window.addEventListener("mousemove", this._moveHandler, false);
    window.addEventListener("mousewheel", this._wheelHandler, false);
    window.addEventListener("DOMMouseScroll", this._wheelHandler, false);
  }, detach:function() {
    if (!this._attached) {
      return;
    }
    this._attached = false;
    this._target = null;
    window.removeEventListener("mouseup", this._upHandler);
    window.removeEventListener("mousedown", this._downHandler);
    window.removeEventListener("mousemove", this._moveHandler);
    window.removeEventListener("mousewheel", this._wheelHandler);
    window.removeEventListener("DOMMouseScroll", this._wheelHandler);
  }, disableContextMenu:function() {
    if (!this._target) {
      return;
    }
    this._target.addEventListener("contextmenu", this._contextMenuHandler);
  }, enableContextMenu:function() {
    if (!this._target) {
      return;
    }
    this._target.removeEventListener("contextmenu", this._contextMenuHandler);
  }, enablePointerLock:function(success, error) {
    if (!document.body.requestPointerLock) {
      if (error) {
        error();
      }
      return;
    }
    var s = function() {
      success();
      document.removeEventListener("pointerlockchange", s);
    };
    var e = function() {
      error();
      document.removeEventListener("pointerlockerror", e);
    };
    if (success) {
      document.addEventListener("pointerlockchange", s, false);
    }
    if (error) {
      document.addEventListener("pointerlockerror", e, false);
    }
    document.body.requestPointerLock();
  }, disablePointerLock:function(success) {
    if (!document.exitPointerLock) {
      return;
    }
    var s = function() {
      success();
      document.removeEventListener("pointerlockchange", s);
    };
    if (success) {
      document.addEventListener("pointerlockchange", s, false);
    }
    document.exitPointerLock();
  }, update:function() {
    this._lastbuttons[0] = this._buttons[0];
    this._lastbuttons[1] = this._buttons[1];
    this._lastbuttons[2] = this._buttons[2];
  }, isPressed:function(button) {
    return this._buttons[button];
  }, wasPressed:function(button) {
    return this._buttons[button] && !this._lastbuttons[button];
  }, wasReleased:function(button) {
    return !this._buttons[button] && this._lastbuttons[button];
  }, _handleUp:function(event) {
    this._buttons[event.button] = false;
    var e = new MouseEvent(this, event);
    if (!e.event) {
      return;
    }
    this.fire(pc.EVENT_MOUSEUP, e);
  }, _handleDown:function(event) {
    this._buttons[event.button] = true;
    var e = new MouseEvent(this, event);
    if (!e.event) {
      return;
    }
    this.fire(pc.EVENT_MOUSEDOWN, e);
  }, _handleMove:function(event) {
    var e = new MouseEvent(this, event);
    if (!e.event) {
      return;
    }
    this.fire(pc.EVENT_MOUSEMOVE, e);
    this._lastX = e.x;
    this._lastY = e.y;
  }, _handleWheel:function(event) {
    var e = new MouseEvent(this, event);
    if (!e.event) {
      return;
    }
    this.fire(pc.EVENT_MOUSEWHEEL, e);
  }, _getTargetCoords:function(event) {
    var rect = this._target.getBoundingClientRect();
    var left = Math.floor(rect.left);
    var top = Math.floor(rect.top);
    if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
      return null;
    }
    return {x:event.clientX - left, y:event.clientY - top};
  }});
  return {Mouse:Mouse, MouseEvent:MouseEvent};
}());
Object.assign(pc, function() {
  var KeyboardEvent = function(keyboard, event) {
    if (event) {
      this.key = event.keyCode;
      this.element = event.target;
      this.event = event;
    } else {
      this.key = null;
      this.element = null;
      this.event = null;
    }
  };
  var _keyboardEvent = new KeyboardEvent;
  function makeKeyboardEvent(event) {
    _keyboardEvent.key = event.keyCode;
    _keyboardEvent.element = event.target;
    _keyboardEvent.event = event;
    return _keyboardEvent;
  }
  function toKeyCode(s) {
    if (typeof s === "string") {
      return s.toUpperCase().charCodeAt(0);
    }
    return s;
  }
  var _keyCodeToKeyIdentifier = {9:"Tab", 13:"Enter", 16:"Shift", 17:"Control", 18:"Alt", 27:"Escape", 37:"Left", 38:"Up", 39:"Right", 40:"Down", 46:"Delete", 91:"Win"};
  var Keyboard = function(element, options) {
    options = options || {};
    this._element = null;
    this._keyDownHandler = this._handleKeyDown.bind(this);
    this._keyUpHandler = this._handleKeyUp.bind(this);
    this._keyPressHandler = this._handleKeyPress.bind(this);
    pc.events.attach(this);
    this._keymap = {};
    this._lastmap = {};
    if (element) {
      this.attach(element);
    }
    this.preventDefault = options.preventDefault || false;
    this.stopPropagation = options.stopPropagation || false;
  };
  Keyboard.prototype.attach = function(element) {
    if (this._element) {
      this.detach();
    }
    this._element = element;
    this._element.addEventListener("keydown", this._keyDownHandler, false);
    this._element.addEventListener("keypress", this._keyPressHandler, false);
    this._element.addEventListener("keyup", this._keyUpHandler, false);
  };
  Keyboard.prototype.detach = function() {
    this._element.removeEventListener("keydown", this._keyDownHandler);
    this._element.removeEventListener("keypress", this._keyPressHandler);
    this._element.removeEventListener("keyup", this._keyUpHandler);
    this._element = null;
  };
  Keyboard.prototype.toKeyIdentifier = function(keyCode) {
    keyCode = toKeyCode(keyCode);
    var count;
    var hex;
    var length;
    var id = _keyCodeToKeyIdentifier[keyCode.toString()];
    if (id) {
      return id;
    }
    hex = keyCode.toString(16).toUpperCase();
    length = hex.length;
    for (count = 0; count < 4 - length; count++) {
      hex = "0" + hex;
    }
    return "U+" + hex;
  };
  Keyboard.prototype._handleKeyDown = function(event) {
    var code = event.keyCode || event.charCode;
    if (code === undefined) {
      return;
    }
    var id = this.toKeyIdentifier(code);
    this._keymap[id] = true;
    this.fire("keydown", makeKeyboardEvent(event));
    if (this.preventDefault) {
      event.preventDefault();
    }
    if (this.stopPropagation) {
      event.stopPropagation();
    }
  };
  Keyboard.prototype._handleKeyUp = function(event) {
    var code = event.keyCode || event.charCode;
    if (code === undefined) {
      return;
    }
    var id = this.toKeyIdentifier(code);
    delete this._keymap[id];
    this.fire("keyup", makeKeyboardEvent(event));
    if (this.preventDefault) {
      event.preventDefault();
    }
    if (this.stopPropagation) {
      event.stopPropagation();
    }
  };
  Keyboard.prototype._handleKeyPress = function(event) {
    this.fire("keypress", makeKeyboardEvent(event));
    if (this.preventDefault) {
      event.preventDefault();
    }
    if (this.stopPropagation) {
      event.stopPropagation();
    }
  };
  Keyboard.prototype.update = function() {
    var prop;
    for (prop in this._lastmap) {
      delete this._lastmap[prop];
    }
    for (prop in this._keymap) {
      if (this._keymap.hasOwnProperty(prop)) {
        this._lastmap[prop] = this._keymap[prop];
      }
    }
  };
  Keyboard.prototype.isPressed = function(key) {
    var keyCode = toKeyCode(key);
    var id = this.toKeyIdentifier(keyCode);
    return !!this._keymap[id];
  };
  Keyboard.prototype.wasPressed = function(key) {
    var keyCode = toKeyCode(key);
    var id = this.toKeyIdentifier(keyCode);
    return !!this._keymap[id] && !!!this._lastmap[id];
  };
  Keyboard.prototype.wasReleased = function(key) {
    var keyCode = toKeyCode(key);
    var id = this.toKeyIdentifier(keyCode);
    return !!!this._keymap[id] && !!this._lastmap[id];
  };
  return {Keyboard:Keyboard, KeyboardEvent:KeyboardEvent};
}());
Object.assign(pc, function() {
  var GamePads = function() {
    this.gamepadsSupported = !!navigator.getGamepads || !!navigator.webkitGetGamepads;
    this.current = [];
    this.previous = [];
    this.deadZone = 0.25;
  };
  var MAPS = {DEFAULT:{buttons:["PAD_FACE_1", "PAD_FACE_2", "PAD_FACE_3", "PAD_FACE_4", "PAD_L_SHOULDER_1", "PAD_R_SHOULDER_1", "PAD_L_SHOULDER_2", "PAD_R_SHOULDER_2", "PAD_SELECT", "PAD_START", "PAD_L_STICK_BUTTON", "PAD_R_STICK_BUTTON", "PAD_UP", "PAD_DOWN", "PAD_LEFT", "PAD_RIGHT", "PAD_VENDOR"], axes:["PAD_L_STICK_X", "PAD_L_STICK_Y", "PAD_R_STICK_X", "PAD_R_STICK_Y"]}, PS3:{buttons:["PAD_FACE_1", "PAD_FACE_2", "PAD_FACE_4", "PAD_FACE_3", "PAD_L_SHOULDER_1", "PAD_R_SHOULDER_1", "PAD_L_SHOULDER_2", 
  "PAD_R_SHOULDER_2", "PAD_SELECT", "PAD_START", "PAD_L_STICK_BUTTON", "PAD_R_STICK_BUTTON", "PAD_UP", "PAD_DOWN", "PAD_LEFT", "PAD_RIGHT", "PAD_VENDOR"], axes:["PAD_L_STICK_X", "PAD_L_STICK_Y", "PAD_R_STICK_X", "PAD_R_STICK_Y"]}};
  var PRODUCT_CODES = {"Product: 0268":"PS3"};
  Object.assign(GamePads.prototype, {update:function() {
    var i, j, l;
    var buttons, buttonsLen;
    for (i = 0, l = this.current.length; i < l; i++) {
      buttons = this.current[i].pad.buttons;
      buttonsLen = buttons.length;
      for (j = 0; j < buttonsLen; j++) {
        if (this.previous[i] === undefined) {
          this.previous[i] = [];
        }
        this.previous[i][j] = buttons[j].pressed;
      }
    }
    var pads = this.poll();
    for (i = 0, l = pads.length; i < l; i++) {
      this.current[i] = pads[i];
    }
  }, poll:function() {
    var pads = [];
    if (this.gamepadsSupported) {
      var padDevices = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads();
      var i, len = padDevices.length;
      for (i = 0; i < len; i++) {
        if (padDevices[i]) {
          pads.push({map:this.getMap(padDevices[i]), pad:padDevices[i]});
        }
      }
    }
    return pads;
  }, getMap:function(pad) {
    for (var code in PRODUCT_CODES) {
      if (pad.id.indexOf(code) >= 0) {
        return MAPS[PRODUCT_CODES[code]];
      }
    }
    return MAPS.DEFAULT;
  }, isPressed:function(index, button) {
    if (!this.current[index]) {
      return false;
    }
    var key = this.current[index].map.buttons[button];
    return this.current[index].pad.buttons[pc[key]].pressed;
  }, wasPressed:function(index, button) {
    if (!this.current[index]) {
      return false;
    }
    var key = this.current[index].map.buttons[button];
    var i = pc[key];
    return this.current[index].pad.buttons[i].pressed && !this.previous[index][i];
  }, getAxis:function(index, axes) {
    if (!this.current[index]) {
      return false;
    }
    var key = this.current[index].map.axes[axes];
    var value = this.current[index].pad.axes[pc[key]];
    if (Math.abs(value) < this.deadZone) {
      value = 0;
    }
    return value;
  }});
  return {GamePads:GamePads};
}());
Object.assign(pc, function() {
  var Touch = function(touch) {
    var coords = pc.getTouchTargetCoords(touch);
    this.id = touch.identifier;
    this.x = coords.x;
    this.y = coords.y;
    this.target = touch.target;
    this.touch = touch;
  };
  var TouchEvent = function(device, event) {
    this.element = event.target;
    this.event = event;
    this.touches = [];
    this.changedTouches = [];
    if (event) {
      var i, l = event.touches.length;
      for (i = 0; i < l; i++) {
        this.touches.push(new Touch(event.touches[i]));
      }
      l = event.changedTouches.length;
      for (i = 0; i < l; i++) {
        this.changedTouches.push(new Touch(event.changedTouches[i]));
      }
    }
  };
  Object.assign(TouchEvent.prototype, {getTouchById:function(id, list) {
    var i, l = list.length;
    for (i = 0; i < l; i++) {
      if (list[i].id === id) {
        return list[i];
      }
    }
    return null;
  }});
  var TouchDevice = function(element) {
    this._element = null;
    this._startHandler = this._handleTouchStart.bind(this);
    this._endHandler = this._handleTouchEnd.bind(this);
    this._moveHandler = this._handleTouchMove.bind(this);
    this._cancelHandler = this._handleTouchCancel.bind(this);
    this.attach(element);
    pc.events.attach(this);
  };
  Object.assign(TouchDevice.prototype, {attach:function(element) {
    if (this._element) {
      this.detach();
    }
    this._element = element;
    this._element.addEventListener("touchstart", this._startHandler, false);
    this._element.addEventListener("touchend", this._endHandler, false);
    this._element.addEventListener("touchmove", this._moveHandler, false);
    this._element.addEventListener("touchcancel", this._cancelHandler, false);
  }, detach:function() {
    if (this._element) {
      this._element.removeEventListener("touchstart", this._startHandler, false);
      this._element.removeEventListener("touchend", this._endHandler, false);
      this._element.removeEventListener("touchmove", this._moveHandler, false);
      this._element.removeEventListener("touchcancel", this._cancelHandler, false);
    }
    this._element = null;
  }, _handleTouchStart:function(e) {
    this.fire("touchstart", new TouchEvent(this, e));
  }, _handleTouchEnd:function(e) {
    this.fire("touchend", new TouchEvent(this, e));
  }, _handleTouchMove:function(e) {
    e.preventDefault();
    this.fire("touchmove", new TouchEvent(this, e));
  }, _handleTouchCancel:function(e) {
    this.fire("touchcancel", new TouchEvent(this, e));
  }});
  return {getTouchTargetCoords:function(touch) {
    var totalOffsetX = 0;
    var totalOffsetY = 0;
    var target = touch.target;
    while (!(target instanceof HTMLElement)) {
      target = target.parentNode;
    }
    var currentElement = target;
    do {
      totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
      totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
      currentElement = currentElement.offsetParent;
    } while (currentElement);
    return {x:touch.pageX - totalOffsetX, y:touch.pageY - totalOffsetY};
  }, TouchDevice:TouchDevice, TouchEvent:TouchEvent};
}());
Object.assign(pc, function() {
  var Controller = function(element, options) {
    options = options || {};
    this._keyboard = options.keyboard || null;
    this._mouse = options.mouse || null;
    this._gamepads = options.gamepads || null;
    this._element = null;
    this._actions = {};
    this._axes = {};
    this._axesValues = {};
    if (element) {
      this.attach(element);
    }
  };
  Controller.prototype.attach = function(element) {
    this._element = element;
    if (this._keyboard) {
      this._keyboard.attach(element);
    }
    if (this._mouse) {
      this._mouse.attach(element);
    }
  };
  Controller.prototype.detach = function() {
    if (this._keyboard) {
      this._keyboard.detach();
    }
    if (this._mouse) {
      this._mouse.detach();
    }
    this._element = null;
  };
  Controller.prototype.disableContextMenu = function() {
    if (!this._mouse) {
      this._enableMouse();
    }
    this._mouse.disableContextMenu();
  };
  Controller.prototype.enableContextMenu = function() {
    if (!this._mouse) {
      this._enableMouse();
    }
    this._mouse.enableContextMenu();
  };
  Controller.prototype.update = function(dt) {
    if (this._keyboard) {
      this._keyboard.update(dt);
    }
    if (this._mouse) {
      this._mouse.update(dt);
    }
    if (this._gamepads) {
      this._gamepads.update(dt);
    }
    this._axesValues = {};
    for (var key in this._axes) {
      this._axesValues[key] = [];
    }
  };
  Controller.prototype.registerKeys = function(action, keys) {
    if (!this._keyboard) {
      this._enableKeyboard();
    }
    if (this._actions[action]) {
      throw new Error(pc.string.format("Action: {0} already registered", action));
    }
    if (keys === undefined) {
      throw new Error("Invalid button");
    }
    if (!keys.length) {
      keys = [keys];
    }
    if (this._actions[action]) {
      this._actions[action].push({type:pc.ACTION_KEYBOARD, keys:keys});
    } else {
      this._actions[action] = [{type:pc.ACTION_KEYBOARD, keys:keys}];
    }
  };
  Controller.prototype.registerMouse = function(action, button) {
    if (!this._mouse) {
      this._enableMouse();
    }
    if (button === undefined) {
      throw new Error("Invalid button");
    }
    if (this._actions[action]) {
      this._actions[action].push({type:pc.ACTION_MOUSE, button:button});
    } else {
      this._actions[action] = [{type:pc.ACTION_MOUSE, button:-button}];
    }
  };
  Controller.prototype.registerPadButton = function(action, pad, button) {
    if (button === undefined) {
      throw new Error("Invalid button");
    }
    if (this._actions[action]) {
      this._actions[action].push({type:pc.ACTION_GAMEPAD, button:button, pad:pad});
    } else {
      this._actions[action] = [{type:pc.ACTION_GAMEPAD, button:button, pad:pad}];
    }
  };
  Controller.prototype.registerAxis = function(options) {
    var name = options.name;
    if (!this._axes[name]) {
      this._axes[name] = [];
    }
    var i = this._axes[name].push(name);
    options = options || {};
    options.pad = options.pad || pc.PAD_1;
    var bind = function(controller, source, value, key) {
      switch(source) {
        case "mousex":
          controller._mouse.on(pc.EVENT_MOUSEMOVE, function(e) {
            controller._axesValues[name][i] = e.dx / 10;
          });
          break;
        case "mousey":
          controller._mouse.on(pc.EVENT_MOUSEMOVE, function(e) {
            controller._axesValues[name][i] = e.dy / 10;
          });
          break;
        case "key":
          controller._axes[name].push(function() {
            return controller._keyboard.isPressed(key) ? value : 0;
          });
          break;
        case "padrx":
          controller._axes[name].push(function() {
            return controller._gamepads.getAxis(options.pad, pc.PAD_R_STICK_X);
          });
          break;
        case "padry":
          controller._axes[name].push(function() {
            return controller._gamepads.getAxis(options.pad, pc.PAD_R_STICK_Y);
          });
          break;
        case "padlx":
          controller._axes[name].push(function() {
            return controller._gamepads.getAxis(options.pad, pc.PAD_L_STICK_X);
          });
          break;
        case "padly":
          controller._axes[name].push(function() {
            return controller._gamepads.getAxis(options.pad, pc.PAD_L_STICK_Y);
          });
          break;
        default:
          throw new Error("Unknown axis");
      }
    };
    bind(this, options.positive, 1, options.positiveKey);
    if (options.negativeKey || options.negative !== options.positive) {
      bind(this, options.negative, -1, options.negativeKey);
    }
  };
  Controller.prototype.isPressed = function(actionName) {
    if (!this._actions[actionName]) {
      return false;
    }
    var action;
    var index = 0;
    var length = this._actions[actionName].length;
    for (index = 0; index < length; ++index) {
      action = this._actions[actionName][index];
      switch(action.type) {
        case pc.ACTION_KEYBOARD:
          if (this._keyboard) {
            var i, len = action.keys.length;
            for (i = 0; i < len; i++) {
              if (this._keyboard.isPressed(action.keys[i])) {
                return true;
              }
            }
          }
          break;
        case pc.ACTION_MOUSE:
          if (this._mouse && this._mouse.isPressed(action.button)) {
            return true;
          }
          break;
        case pc.ACTION_GAMEPAD:
          if (this._gamepads && this._gamepads.isPressed(action.pad, action.button)) {
            return true;
          }
          break;
      }
    }
    return false;
  };
  Controller.prototype.wasPressed = function(actionName) {
    if (!this._actions[actionName]) {
      return false;
    }
    var index = 0;
    var length = this._actions[actionName].length;
    for (index = 0; index < length; ++index) {
      var action = this._actions[actionName][index];
      switch(action.type) {
        case pc.ACTION_KEYBOARD:
          if (this._keyboard) {
            var i, len = action.keys.length;
            for (i = 0; i < len; i++) {
              if (this._keyboard.wasPressed(action.keys[i])) {
                return true;
              }
            }
          }
          break;
        case pc.ACTION_MOUSE:
          if (this._mouse && this._mouse.wasPressed(action.button)) {
            return true;
          }
          break;
        case pc.ACTION_GAMEPAD:
          if (this._gamepads && this._gamepads.wasPressed(action.pad, action.button)) {
            return true;
          }
          break;
      }
    }
    return false;
  };
  Controller.prototype.getAxis = function(name) {
    var value = 0;
    if (this._axes[name]) {
      var i, len = this._axes[name].length;
      for (i = 0; i < len; i++) {
        if (pc.type(this._axes[name][i]) === "function") {
          var v = this._axes[name][i]();
          if (Math.abs(v) > Math.abs(value)) {
            value = v;
          }
        } else {
          if (this._axesValues[name]) {
            if (Math.abs(this._axesValues[name][i]) > Math.abs(value)) {
              value = this._axesValues[name][i];
            }
          }
        }
      }
    }
    return value;
  };
  Controller.prototype._enableMouse = function() {
    this._mouse = new pc.Mouse;
    if (!this._element) {
      throw new Error("Controller must be attached to an Element");
    }
    this._mouse.attach(this._element);
  };
  Controller.prototype._enableKeyboard = function() {
    this._keyboard = new pc.Keyboard;
    if (!this._element) {
      throw new Error("Controller must be attached to an Element");
    }
    this._keyboard.attach(this._element);
  };
  return {Controller:Controller};
}());
Object.assign(pc, function() {
  var targetX, targetY;
  var vecA = new pc.Vec3;
  var vecB = new pc.Vec3;
  var _pq = new pc.Vec3;
  var _pa = new pc.Vec3;
  var _pb = new pc.Vec3;
  var _pc = new pc.Vec3;
  var _pd = new pc.Vec3;
  var _m = new pc.Vec3;
  var _sct = new pc.Vec3;
  var _accumulatedScale = new pc.Vec2;
  var _paddingTop = new pc.Vec3;
  var _paddingBottom = new pc.Vec3;
  var _paddingLeft = new pc.Vec3;
  var _paddingRight = new pc.Vec3;
  var _cornerBottomLeft = new pc.Vec3;
  var _cornerBottomRight = new pc.Vec3;
  var _cornerTopRight = new pc.Vec3;
  var _cornerTopLeft = new pc.Vec3;
  var ZERO_VEC4 = new pc.Vec4;
  var scalarTriple = function(p1, p2, p3) {
    return _sct.cross(p1, p2).dot(p3);
  };
  var intersectLineQuad = function(p, q, corners) {
    _pq.sub2(q, p);
    _pa.sub2(corners[0], p);
    _pb.sub2(corners[1], p);
    _pc.sub2(corners[2], p);
    _m.cross(_pc, _pq);
    var v = _pa.dot(_m);
    if (v >= 0) {
      if (-_pb.dot(_m) < 0) {
        return false;
      }
      if (scalarTriple(_pq, _pb, _pa) < 0) {
        return false;
      }
    } else {
      _pd.sub2(corners[3], p);
      if (_pd.dot(_m) < 0) {
        return false;
      }
      if (scalarTriple(_pq, _pa, _pd) < 0) {
        return false;
      }
    }
    if (_pq.sub2(corners[0], corners[2]).lengthSq() < 0.0001 * 0.0001) {
      return false;
    }
    if (_pq.sub2(corners[1], corners[3]).lengthSq() < 0.0001 * 0.0001) {
      return false;
    }
    return true;
  };
  var ElementInputEvent = function(event, element, camera) {
    this.event = event;
    this.element = element;
    this.camera = camera;
    this._stopPropagation = false;
  };
  Object.assign(ElementInputEvent.prototype, {stopPropagation:function() {
    this._stopPropagation = true;
    this.event.stopImmediatePropagation();
    this.event.stopPropagation();
  }});
  var ElementMouseEvent = function(event, element, camera, x, y, lastX, lastY) {
    ElementInputEvent.call(this, event, element, camera);
    this.x = x;
    this.y = y;
    this.ctrlKey = event.ctrlKey || false;
    this.altKey = event.altKey || false;
    this.shiftKey = event.shiftKey || false;
    this.metaKey = event.metaKey || false;
    this.button = event.button;
    if (pc.Mouse.isPointerLocked()) {
      this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
      this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
    } else {
      this.dx = x - lastX;
      this.dy = y - lastY;
    }
    if (event.detail) {
      this.wheel = -1 * event.detail;
    } else {
      if (event.wheelDelta) {
        this.wheel = event.wheelDelta / 120;
      } else {
        this.wheel = 0;
      }
    }
  };
  ElementMouseEvent.prototype = Object.create(ElementInputEvent.prototype);
  ElementMouseEvent.prototype.constructor = ElementMouseEvent;
  var ElementTouchEvent = function(event, element, camera, x, y, input) {
    ElementInputEvent.call(this, event, element, camera);
    this.touches = event.touches;
    this.changedTouches = event.changedTouches;
    this.x = x;
    this.y = y;
  };
  ElementTouchEvent.prototype = Object.create(ElementInputEvent.prototype);
  ElementTouchEvent.prototype.constructor = ElementTouchEvent;
  var ElementInput = function(domElement, options) {
    this._app = null;
    this._attached = false;
    this._target = null;
    this._enabled = true;
    this._lastX = 0;
    this._lastY = 0;
    this._upHandler = this._handleUp.bind(this);
    this._downHandler = this._handleDown.bind(this);
    this._moveHandler = this._handleMove.bind(this);
    this._wheelHandler = this._handleWheel.bind(this);
    this._touchstartHandler = this._handleTouchStart.bind(this);
    this._touchendHandler = this._handleTouchEnd.bind(this);
    this._touchcancelHandler = this._touchendHandler;
    this._touchmoveHandler = this._handleTouchMove.bind(this);
    this._sortHandler = this._sortElements.bind(this);
    this._elements = [];
    this._hoveredElement = null;
    this._pressedElement = null;
    this._touchedElements = {};
    this._touchesForWhichTouchLeaveHasFired = {};
    this._useMouse = !options || options.useMouse !== false;
    this._useTouch = !options || options.useTouch !== false;
    if (pc.platform.touch) {
      this._clickedEntities = {};
    }
    this.attach(domElement, options);
  };
  Object.assign(ElementInput.prototype, {attach:function(domElement) {
    if (this._attached) {
      this._attached = false;
      this.detach();
    }
    this._target = domElement;
    this._attached = true;
    if (this._useMouse) {
      window.addEventListener("mouseup", this._upHandler, {passive:true});
      window.addEventListener("mousedown", this._downHandler, {passive:true});
      window.addEventListener("mousemove", this._moveHandler, {passive:true});
      window.addEventListener("mousewheel", this._wheelHandler, {passive:true});
      window.addEventListener("DOMMouseScroll", this._wheelHandler, {passive:true});
    }
    if (this._useTouch && pc.platform.touch) {
      this._target.addEventListener("touchstart", this._touchstartHandler, {passive:true});
      this._target.addEventListener("touchend", this._touchendHandler, false);
      this._target.addEventListener("touchmove", this._touchmoveHandler, false);
      this._target.addEventListener("touchcancel", this._touchcancelHandler, false);
    }
  }, detach:function() {
    if (!this._attached) {
      return;
    }
    this._attached = false;
    if (this._useMouse) {
      window.removeEventListener("mouseup", this._upHandler, false);
      window.removeEventListener("mousedown", this._downHandler, false);
      window.removeEventListener("mousemove", this._moveHandler, false);
      window.removeEventListener("mousewheel", this._wheelHandler, false);
      window.removeEventListener("DOMMouseScroll", this._wheelHandler, false);
    }
    if (this._useTouch) {
      this._target.removeEventListener("touchstart", this._touchstartHandler, false);
      this._target.removeEventListener("touchend", this._touchendHandler, false);
      this._target.removeEventListener("touchmove", this._touchmoveHandler, false);
      this._target.removeEventListener("touchcancel", this._touchcancelHandler, false);
    }
    this._target = null;
  }, addElement:function(element) {
    if (this._elements.indexOf(element) === -1) {
      this._elements.push(element);
    }
  }, removeElement:function(element) {
    var idx = this._elements.indexOf(element);
    if (idx !== -1) {
      this._elements.splice(idx, 1);
    }
  }, _handleUp:function(event) {
    if (!this._enabled) {
      return;
    }
    if (pc.Mouse.isPointerLocked()) {
      return;
    }
    this._calcMouseCoords(event);
    if (targetX === null) {
      return;
    }
    this._onElementMouseEvent(event);
  }, _handleDown:function(event) {
    if (!this._enabled) {
      return;
    }
    if (pc.Mouse.isPointerLocked()) {
      return;
    }
    this._calcMouseCoords(event);
    if (targetX === null) {
      return;
    }
    this._onElementMouseEvent(event);
  }, _handleMove:function(event) {
    if (!this._enabled) {
      return;
    }
    this._calcMouseCoords(event);
    if (targetX === null) {
      return;
    }
    this._onElementMouseEvent(event);
    this._lastX = targetX;
    this._lastY = targetY;
  }, _handleWheel:function(event) {
    if (!this._enabled) {
      return;
    }
    this._calcMouseCoords(event);
    if (targetX === null) {
      return;
    }
    this._onElementMouseEvent(event);
  }, _determineTouchedElements:function(event) {
    var touchedElements = {};
    var cameras = this.app.systems.camera.cameras;
    var i, j, len;
    for (i = cameras.length - 1; i >= 0; i--) {
      var camera = cameras[i];
      var done = 0;
      for (j = 0, len = event.changedTouches.length; j < len; j++) {
        if (touchedElements[event.changedTouches[j].identifier]) {
          done++;
          continue;
        }
        var coords = this._calcTouchCoords(event.changedTouches[j]);
        var element = this._getTargetElement(camera, coords.x, coords.y);
        if (element) {
          done++;
          touchedElements[event.changedTouches[j].identifier] = {element:element, camera:camera, x:coords.x, y:coords.y};
        }
      }
      if (done === len) {
        break;
      }
    }
    return touchedElements;
  }, _handleTouchStart:function(event) {
    if (!this._enabled) {
      return;
    }
    var newTouchedElements = this._determineTouchedElements(event);
    for (var i = 0, len = event.changedTouches.length; i < len; i++) {
      var touch = event.changedTouches[i];
      var newTouchInfo = newTouchedElements[touch.identifier];
      var oldTouchInfo = this._touchedElements[touch.identifier];
      if (newTouchInfo && (!oldTouchInfo || newTouchInfo.element !== oldTouchInfo.element)) {
        this._fireEvent(event.type, new ElementTouchEvent(event, newTouchInfo.element, newTouchInfo.camera, newTouchInfo.x, newTouchInfo.y, this));
        this._touchesForWhichTouchLeaveHasFired[touch.identifier] = false;
      }
    }
    for (var touchId in newTouchedElements) {
      this._touchedElements[touchId] = newTouchedElements[touchId];
    }
  }, _handleTouchEnd:function(event) {
    if (!this._enabled) {
      return;
    }
    var cameras = this.app.systems.camera.cameras;
    for (var key in this._clickedEntities) {
      delete this._clickedEntities[key];
    }
    for (var i = 0, len = event.changedTouches.length; i < len; i++) {
      var touch = event.changedTouches[i];
      var touchInfo = this._touchedElements[touch.identifier];
      if (!touchInfo) {
        continue;
      }
      var element = touchInfo.element;
      var camera = touchInfo.camera;
      var x = touchInfo.x;
      var y = touchInfo.y;
      delete this._touchedElements[touch.identifier];
      delete this._touchesForWhichTouchLeaveHasFired[touch.identifier];
      this._fireEvent(event.type, new ElementTouchEvent(event, element, camera, x, y, this));
      if (event.touches.length === 0) {
        var coords = this._calcTouchCoords(touch);
        for (var c = cameras.length - 1; c >= 0; c--) {
          var hovered = this._getTargetElement(cameras[c], coords.x, coords.y);
          if (hovered === element) {
            if (!this._clickedEntities[element.entity.getGuid()]) {
              this._fireEvent("click", new ElementTouchEvent(event, element, camera, x, y, this));
              this._clickedEntities[element.entity.getGuid()] = true;
            }
          }
        }
      }
    }
  }, _handleTouchMove:function(event) {
    event.preventDefault();
    if (!this._enabled) {
      return;
    }
    var newTouchedElements = this._determineTouchedElements(event);
    for (var i = 0, len = event.changedTouches.length; i < len; i++) {
      var touch = event.changedTouches[i];
      var newTouchInfo = newTouchedElements[touch.identifier];
      var oldTouchInfo = this._touchedElements[touch.identifier];
      if (oldTouchInfo) {
        var coords = this._calcTouchCoords(touch);
        if ((!newTouchInfo || newTouchInfo.element !== oldTouchInfo.element) && !this._touchesForWhichTouchLeaveHasFired[touch.identifier]) {
          this._fireEvent("touchleave", new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, this));
          this._touchesForWhichTouchLeaveHasFired[touch.identifier] = true;
        }
        this._fireEvent("touchmove", new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, this));
      }
    }
  }, _onElementMouseEvent:function(event) {
    var element;
    var hovered = this._hoveredElement;
    this._hoveredElement = null;
    var cameras = this.app.systems.camera.cameras;
    var camera;
    for (var i = cameras.length - 1; i >= 0; i--) {
      camera = cameras[i];
      element = this._getTargetElement(camera, targetX, targetY);
      if (element) {
        break;
      }
    }
    if (element) {
      this._fireEvent(event.type, new ElementMouseEvent(event, element, camera, targetX, targetY, this._lastX, this._lastY));
      this._hoveredElement = element;
      if (event.type === pc.EVENT_MOUSEDOWN) {
        this._pressedElement = element;
      }
    }
    if (hovered !== this._hoveredElement) {
      if (hovered) {
        this._fireEvent("mouseleave", new ElementMouseEvent(event, hovered, camera, targetX, targetY, this._lastX, this._lastY));
      }
      if (this._hoveredElement) {
        this._fireEvent("mouseenter", new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
      }
    }
    if (event.type === pc.EVENT_MOUSEUP && this._pressedElement) {
      if (this._pressedElement === this._hoveredElement) {
        this._pressedElement = null;
        if (!this._clickedEntities || !this._clickedEntities[this._hoveredElement.entity.getGuid()]) {
          this._fireEvent("click", new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
        }
      } else {
        this._pressedElement = null;
      }
    }
  }, _fireEvent:function(name, evt) {
    var element = evt.element;
    while (true) {
      element.fire(name, evt);
      if (evt._stopPropagation) {
        break;
      }
      if (!element.entity.parent) {
        break;
      }
      element = element.entity.parent.element;
      if (!element) {
        break;
      }
    }
  }, _calcMouseCoords:function(event) {
    var rect = this._target.getBoundingClientRect();
    var left = Math.floor(rect.left);
    var top = Math.floor(rect.top);
    if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
      targetX = null;
      targetY = null;
    } else {
      targetX = event.clientX - left;
      targetY = event.clientY - top;
    }
  }, _calcTouchCoords:function(touch) {
    var totalOffsetX = 0;
    var totalOffsetY = 0;
    var target = touch.target;
    while (!(target instanceof HTMLElement)) {
      target = target.parentNode;
    }
    var currentElement = target;
    do {
      totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
      totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
      currentElement = currentElement.offsetParent;
    } while (currentElement);
    return {x:touch.pageX - totalOffsetX, y:touch.pageY - totalOffsetY};
  }, _sortElements:function(a, b) {
    var layerOrder = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);
    if (layerOrder !== 0) {
      return layerOrder;
    }
    if (a.screen && !b.screen) {
      return -1;
    }
    if (!a.screen && b.screen) {
      return 1;
    }
    if (!a.screen && !b.screen) {
      return 0;
    }
    if (a.screen.screen.screenSpace && !b.screen.screen.screenSpace) {
      return -1;
    }
    if (b.screen.screen.screenSpace && !a.screen.screen.screenSpace) {
      return 1;
    }
    return b.drawOrder - a.drawOrder;
  }, _getTargetElement:function(camera, x, y) {
    var result = null;
    this._elements.sort(this._sortHandler);
    for (var i = 0, len = this._elements.length; i < len; i++) {
      var element = this._elements[i];
      if (element.screen && element.screen.screen.screenSpace) {
        if (this._checkElement2d(x, y, element, camera)) {
          result = element;
          break;
        }
      } else {
        if (this._checkElement3d(x, y, element, camera)) {
          result = element;
          break;
        }
      }
    }
    return result;
  }, _buildHitCorners:function(element, screenOrWorldCorners, scaleX, scaleY) {
    var hitCorners = screenOrWorldCorners;
    var button = element.entity && element.entity.button;
    if (button) {
      var hitPadding = element.entity.button.hitPadding || ZERO_VEC4;
      _paddingTop.copy(element.entity.up);
      _paddingBottom.copy(_paddingTop).scale(-1);
      _paddingRight.copy(element.entity.right);
      _paddingLeft.copy(_paddingRight).scale(-1);
      _paddingTop.scale(hitPadding.w * scaleY);
      _paddingBottom.scale(hitPadding.y * scaleY);
      _paddingRight.scale(hitPadding.z * scaleX);
      _paddingLeft.scale(hitPadding.x * scaleX);
      _cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);
      _cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);
      _cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);
      _cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);
      hitCorners = [_cornerBottomLeft, _cornerBottomRight, _cornerTopRight, _cornerTopLeft];
    }
    return hitCorners;
  }, _calculateScaleToScreen:function(element) {
    var current = element.entity;
    var screenScale = element.screen.screen.scale;
    _accumulatedScale.set(screenScale, screenScale);
    while (current && !current.screen) {
      _accumulatedScale.mul(current.getLocalScale());
      current = current.parent;
    }
    return _accumulatedScale;
  }, _checkElement2d:function(x, y, element, camera) {
    if (element.maskedBy) {
      var result = this._checkElement2d(x, y, element.maskedBy.element, camera);
      if (!result) {
        return false;
      }
    }
    var sw = this.app.graphicsDevice.width;
    var sh = this.app.graphicsDevice.height;
    var cameraWidth = camera.rect.z * sw;
    var cameraHeight = camera.rect.w * sh;
    var cameraLeft = camera.rect.x * sw;
    var cameraRight = cameraLeft + cameraWidth;
    var cameraBottom = (1 - camera.rect.y) * sh;
    var cameraTop = cameraBottom - cameraHeight;
    var _x = x * sw / this._target.clientWidth;
    var _y = y * sh / this._target.clientHeight;
    if (_x >= cameraLeft && _x <= cameraRight && _y <= cameraBottom && _y >= cameraTop) {
      _x = sw * (_x - cameraLeft) / cameraWidth;
      _y = sh * (_y - cameraTop) / cameraHeight;
      _y = sh - _y;
      var scale = this._calculateScaleToScreen(element);
      var hitCorners = this._buildHitCorners(element, element.screenCorners, scale.x, scale.y);
      vecA.set(_x, _y, 1);
      vecB.set(_x, _y, -1);
      if (intersectLineQuad(vecA, vecB, hitCorners)) {
        return true;
      }
    }
    return false;
  }, _checkElement3d:function(x, y, element, camera) {
    if (element.maskedBy) {
      var result = this._checkElement3d(x, y, element.maskedBy.element, camera);
      if (!result) {
        return false;
      }
    }
    var sw = this._target.clientWidth;
    var sh = this._target.clientHeight;
    var cameraWidth = camera.rect.z * sw;
    var cameraHeight = camera.rect.w * sh;
    var cameraLeft = camera.rect.x * sw;
    var cameraRight = cameraLeft + cameraWidth;
    var cameraBottom = (1 - camera.rect.y) * sh;
    var cameraTop = cameraBottom - cameraHeight;
    var _x = x;
    var _y = y;
    if (x >= cameraLeft && x <= cameraRight && y <= cameraBottom && _y >= cameraTop) {
      _x = sw * (_x - cameraLeft) / cameraWidth;
      _y = sh * (_y - cameraTop) / cameraHeight;
      var scale = element.entity.getWorldTransform().getScale();
      var worldCorners = this._buildHitCorners(element, element.worldCorners, scale.x, scale.y);
      var start = vecA;
      var end = vecB;
      camera.screenToWorld(_x, _y, camera.nearClip, start);
      camera.screenToWorld(_x, _y, camera.farClip, end);
      if (intersectLineQuad(start, end, worldCorners)) {
        return true;
      }
    }
    return false;
  }});
  Object.defineProperty(ElementInput.prototype, "enabled", {get:function() {
    return this._enabled;
  }, set:function(value) {
    this._enabled = value;
  }});
  Object.defineProperty(ElementInput.prototype, "app", {get:function() {
    return this._app || pc.app;
  }, set:function(value) {
    this._app = value;
  }});
  return {ElementInput:ElementInput, ElementInputEvent:ElementInputEvent, ElementMouseEvent:ElementMouseEvent, ElementTouchEvent:ElementTouchEvent};
}());
Object.assign(pc, function() {
  var Http = function Http() {
  };
  Http.ContentType = {FORM_URLENCODED:"application/x-www-form-urlencoded", GIF:"image/gif", JPEG:"image/jpeg", DDS:"image/dds", JSON:"application/json", PNG:"image/png", TEXT:"text/plain", XML:"application/xml", WAV:"audio/x-wav", OGG:"audio/ogg", MP3:"audio/mpeg", MP4:"audio/mp4", AAC:"audio/aac", BIN:"application/octet-stream"};
  Http.ResponseType = {TEXT:"text", ARRAY_BUFFER:"arraybuffer", BLOB:"blob", DOCUMENT:"document", JSON:"json"};
  Http.binaryExtensions = [".model", ".wav", ".ogg", ".mp3", ".mp4", ".m4a", ".aac", ".dds"];
  Object.assign(Http.prototype, {ContentType:Http.ContentType, ResponseType:Http.ResponseType, binaryExtensions:Http.binaryExtensions, get:function(url, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    return this.request("GET", url, options, callback);
  }, post:function(url, data, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options.postdata = data;
    return this.request("POST", url, options, callback);
  }, put:function(url, data, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options.postdata = data;
    return this.request("PUT", url, options, callback);
  }, del:function(url, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    return this.request("DELETE", url, options, callback);
  }, request:function(method, url, options, callback) {
    var uri, query, timestamp, postdata, xhr;
    var errored = false;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options.callback = callback;
    if (options.async == null) {
      options.async = true;
    }
    if (options.headers == null) {
      options.headers = {};
    }
    if (options.postdata != null) {
      if (options.postdata instanceof Document) {
        postdata = options.postdata;
      } else {
        if (options.postdata instanceof FormData) {
          postdata = options.postdata;
        } else {
          if (options.postdata instanceof Object) {
            var contentType = options.headers["Content-Type"];
            if (contentType === undefined) {
              options.headers["Content-Type"] = Http.ContentType.FORM_URLENCODED;
              contentType = options.headers["Content-Type"];
            }
            switch(contentType) {
              case Http.ContentType.FORM_URLENCODED:
                postdata = "";
                var bFirstItem = true;
                for (var key in options.postdata) {
                  if (options.postdata.hasOwnProperty(key)) {
                    if (bFirstItem) {
                      bFirstItem = false;
                    } else {
                      postdata += "&";
                    }
                    postdata += escape(key) + "=" + escape(options.postdata[key]);
                  }
                }
                break;
              default:
              case Http.ContentType.JSON:
                if (contentType == null) {
                  options.headers["Content-Type"] = Http.ContentType.JSON;
                }
                postdata = JSON.stringify(options.postdata);
                break;
            }
          } else {
            postdata = options.postdata;
          }
        }
      }
    }
    if (!xhr) {
      xhr = new XMLHttpRequest;
    }
    if (options.cache === false) {
      timestamp = pc.time.now();
      uri = new pc.URI(url);
      if (!uri.query) {
        uri.query = "ts=" + timestamp;
      } else {
        uri.query = uri.query + "&ts=" + timestamp;
      }
      url = uri.toString();
    }
    if (options.query) {
      uri = new pc.URI(url);
      query = pc.extend(uri.getQuery(), options.query);
      uri.setQuery(query);
      url = uri.toString();
    }
    xhr.open(method, url, options.async);
    xhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;
    xhr.responseType = options.responseType || this._guessResponseType(url);
    for (var header in options.headers) {
      if (options.headers.hasOwnProperty(header)) {
        xhr.setRequestHeader(header, options.headers[header]);
      }
    }
    xhr.onreadystatechange = function() {
      this._onReadyStateChange(method, url, options, xhr);
    }.bind(this);
    xhr.onerror = function() {
      this._onError(method, url, options, xhr);
      errored = true;
    }.bind(this);
    try {
      xhr.send(postdata);
    } catch (e) {
      if (!errored) {
        options.error(xhr.status, xhr, e);
      }
    }
    return xhr;
  }, _guessResponseType:function(url) {
    var uri = new pc.URI(url);
    var ext = pc.path.getExtension(uri.path);
    if (Http.binaryExtensions.indexOf(ext) >= 0) {
      return Http.ResponseType.ARRAY_BUFFER;
    }
    if (ext === ".xml") {
      return Http.ResponseType.DOCUMENT;
    }
    return Http.ResponseType.TEXT;
  }, _isBinaryContentType:function(contentType) {
    var binTypes = [Http.ContentType.MP4, Http.ContentType.WAV, Http.ContentType.OGG, Http.ContentType.MP3, Http.ContentType.BIN, Http.ContentType.DDS];
    if (binTypes.indexOf(contentType) >= 0) {
      return true;
    }
    return false;
  }, _onReadyStateChange:function(method, url, options, xhr) {
    if (xhr.readyState === 4) {
      switch(xhr.status) {
        case 0:
          {
            if (url[0] != "/") {
              this._onSuccess(method, url, options, xhr);
            } else {
              this._onError(method, url, options, xhr);
            }
            break;
          }
        case 200:
        case 201:
        case 206:
        case 304:
          {
            this._onSuccess(method, url, options, xhr);
            break;
          }
        default:
          {
            this._onError(method, url, options, xhr);
            break;
          }
      }
    }
  }, _onSuccess:function(method, url, options, xhr) {
    var response;
    var header;
    var contentType;
    var parts;
    header = xhr.getResponseHeader("Content-Type");
    if (header) {
      parts = header.split(";");
      contentType = parts[0].trim();
    }
    try {
      if (contentType === this.ContentType.JSON || url.split("?")[0].endsWith(".json")) {
        response = JSON.parse(xhr.responseText);
      } else {
        if (this._isBinaryContentType(contentType)) {
          response = xhr.response;
        } else {
          if (contentType) {
            logWARNING(pc.string.format("responseType: {0} being served with Content-Type: {1}", xhr.responseType, contentType));
          }
          if (xhr.responseType === Http.ResponseType.ARRAY_BUFFER) {
            response = xhr.response;
          } else {
            if (xhr.responseType === Http.ResponseType.BLOB || xhr.responseType === Http.ResponseType.JSON) {
              response = xhr.response;
            } else {
              if (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === this.ContentType.XML) {
                response = xhr.responseXML;
              } else {
                response = xhr.responseText;
              }
            }
          }
        }
      }
      options.callback(null, response);
    } catch (err) {
      options.callback(err);
    }
  }, _onError:function(method, url, options, xhr) {
    options.callback(xhr.status, null);
  }});
  return {Http:Http, http:new Http};
}());
Object.assign(pc, function() {
  var ScriptRegistry = function(app) {
    pc.events.attach(this);
    this.app = app;
    this._scripts = {};
    this._list = [];
  };
  ScriptRegistry.prototype.destroy = function() {
    this.app = null;
    this.off();
  };
  ScriptRegistry.prototype.add = function(script) {
    var self = this;
    if (this._scripts.hasOwnProperty(script.__name)) {
      setTimeout(function() {
        if (script.prototype.swap) {
          var old = self._scripts[script.__name];
          var ind = self._list.indexOf(old);
          self._list[ind] = script;
          self._scripts[script.__name] = script;
          self.fire("swap", script.__name, script);
          self.fire("swap:" + script.__name, script);
        } else {
          console.warn("script registry already has '" + script.__name + "' script, define 'swap' method for new script type to enable code hot swapping");
        }
      });
      return false;
    }
    this._scripts[script.__name] = script;
    this._list.push(script);
    this.fire("add", script.__name, script);
    this.fire("add:" + script.__name, script);
    setTimeout(function() {
      if (!self._scripts.hasOwnProperty(script.__name)) {
        return;
      }
      if (!self.app || !self.app.systems || !self.app.systems.script) {
        return;
      }
      var components = self.app.systems.script._components;
      var i, scriptInstance, attributes;
      var scriptInstances = [];
      var scriptInstancesInitialized = [];
      for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
        var component = components.items[components.loopIndex];
        if (component._scriptsIndex[script.__name] && component._scriptsIndex[script.__name].awaiting) {
          if (component._scriptsData && component._scriptsData[script.__name]) {
            attributes = component._scriptsData[script.__name].attributes;
          }
          scriptInstance = component.create(script.__name, {preloading:true, ind:component._scriptsIndex[script.__name].ind, attributes:attributes});
          if (scriptInstance) {
            scriptInstances.push(scriptInstance);
          }
        }
      }
      for (i = 0; i < scriptInstances.length; i++) {
        scriptInstances[i].__initializeAttributes();
      }
      for (i = 0; i < scriptInstances.length; i++) {
        if (scriptInstances[i].enabled) {
          scriptInstances[i]._initialized = true;
          scriptInstancesInitialized.push(scriptInstances[i]);
          if (scriptInstances[i].initialize) {
            scriptInstances[i].initialize();
          }
        }
      }
      for (i = 0; i < scriptInstancesInitialized.length; i++) {
        if (!scriptInstancesInitialized[i].enabled || scriptInstancesInitialized[i]._postInitialized) {
          continue;
        }
        scriptInstancesInitialized[i]._postInitialized = true;
        if (scriptInstancesInitialized[i].postInitialize) {
          scriptInstancesInitialized[i].postInitialize();
        }
      }
    });
    return true;
  };
  ScriptRegistry.prototype.remove = function(name) {
    if (typeof name === "function") {
      name = name.__name;
    }
    if (!this._scripts.hasOwnProperty(name)) {
      return false;
    }
    var item = this._scripts[name];
    delete this._scripts[name];
    var ind = this._list.indexOf(item);
    this._list.splice(ind, 1);
    this.fire("remove", name, item);
    this.fire("remove:" + name, item);
    return true;
  };
  ScriptRegistry.prototype.get = function(name) {
    return this._scripts[name] || null;
  };
  ScriptRegistry.prototype.has = function(name) {
    return this._scripts.hasOwnProperty(name);
  };
  ScriptRegistry.prototype.list = function() {
    return this._list;
  };
  return {ScriptRegistry:ScriptRegistry};
}());
Object.assign(pc, function() {
  var components = ["x", "y", "z", "w"];
  var rawToValue = function(app, args, value, old) {
    var i;
    switch(args.type) {
      case "boolean":
        return !!value;
      case "number":
        if (typeof value === "number") {
          return value;
        } else {
          if (typeof value === "string") {
            var v = parseInt(value, 10);
            if (isNaN(v)) {
              return null;
            }
            return v;
          } else {
            if (typeof value === "boolean") {
              return 0 + value;
            }
          }
        }
        return null;
      case "json":
        if (typeof value === "object") {
          return value;
        }
        try {
          return JSON.parse(value);
        } catch (ex) {
          return null;
        }
      case "asset":
        if (value instanceof pc.Asset) {
          return value;
        } else {
          if (typeof value === "number") {
            return app.assets.get(value) || null;
          } else {
            if (typeof value === "string") {
              return app.assets.get(parseInt(value, 10)) || null;
            }
          }
        }
        return null;
      case "entity":
        if (value instanceof pc.GraphNode) {
          return value;
        } else {
          if (typeof value === "string") {
            return app.root.findByGuid(value);
          }
        }
        return null;
      case "rgb":
      case "rgba":
        if (value instanceof pc.Color) {
          if (old instanceof pc.Color) {
            old.copy(value);
            return old;
          }
          return value.clone();
        } else {
          if (value instanceof Array && value.length >= 3 && value.length <= 4) {
            for (i = 0; i < value.length; i++) {
              if (typeof value[i] !== "number") {
                return null;
              }
            }
            if (!old) {
              old = new pc.Color;
            }
            old.r = value[0];
            old.g = value[1];
            old.b = value[2];
            old.a = value.length === 3 ? 1 : value[3];
            return old;
          } else {
            if (typeof value === "string" && /#([0-9abcdef]{2}){3,4}/i.test(value)) {
              if (!old) {
                old = new pc.Color;
              }
              old.fromString(value);
              return old;
            }
          }
        }
        return null;
      case "vec2":
      case "vec3":
      case "vec4":
        var len = parseInt(args.type.slice(3), 10);
        if (value instanceof pc["Vec" + len]) {
          if (old instanceof pc["Vec" + len]) {
            old.copy(value);
            return old;
          }
          return value.clone();
        } else {
          if (value instanceof Array && value.length === len) {
            for (i = 0; i < value.length; i++) {
              if (typeof value[i] !== "number") {
                return null;
              }
            }
            if (!old) {
              old = new pc["Vec" + len];
            }
            for (i = 0; i < len; i++) {
              old[components[i]] = value[i];
            }
            return old;
          }
        }
        return null;
      case "curve":
        if (value) {
          var curve;
          if (value instanceof pc.Curve || value instanceof pc.CurveSet) {
            curve = value.clone();
          } else {
            var CurveType = value.keys[0] instanceof Array ? pc.CurveSet : pc.Curve;
            curve = new CurveType(value.keys);
            curve.type = value.type;
          }
          return curve;
        }
        break;
    }
    return value;
  };
  var ScriptAttributes = function(scriptType) {
    this.scriptType = scriptType;
    this.index = {};
  };
  ScriptAttributes.prototype.add = function(name, args) {
    if (this.index[name]) {
      return;
    } else {
      if (pc.createScript.reservedAttributes[name]) {
        return;
      }
    }
    this.index[name] = args;
    Object.defineProperty(this.scriptType.prototype, name, {get:function() {
      return this.__attributes[name];
    }, set:function(raw) {
      var old = this.__attributes[name];
      if (args.array) {
        this.__attributes[name] = [];
        if (raw) {
          var i;
          var len;
          for (i = 0, len = raw.length; i < len; i++) {
            this.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));
          }
        }
      } else {
        this.__attributes[name] = rawToValue(this.app, args, raw, old);
      }
      this.fire("attr", name, this.__attributes[name], old);
      this.fire("attr:" + name, this.__attributes[name], old);
    }});
  };
  ScriptAttributes.prototype.remove = function(name) {
    if (!this.index[name]) {
      return false;
    }
    delete this.index[name];
    delete this.scriptType.prototype[name];
    return true;
  };
  ScriptAttributes.prototype.has = function(name) {
    return !!this.index[name];
  };
  ScriptAttributes.prototype.get = function(name) {
    return this.index[name] || null;
  };
  var createScript = function(name, app) {
    if (pc.script.legacy) {
      return null;
    }
    if (createScript.reservedScripts[name]) {
      throw new Error("script name: '" + name + "' is reserved, please change script name");
    }
    var script = function(args) {
      pc.events.attach(this);
      this.app = args.app;
      this.entity = args.entity;
      this._enabled = typeof args.enabled === "boolean" ? args.enabled : true;
      this._enabledOld = this.enabled;
      this.__destroyed = false;
      this.__attributes = {};
      this.__attributesRaw = args.attributes || null;
      this.__scriptType = script;
      this.__executionOrder = -1;
    };
    script.__name = name;
    script.attributes = new ScriptAttributes(script);
    script.prototype.__initializeAttributes = function(force) {
      if (!force && !this.__attributesRaw) {
        return;
      }
      for (var key in script.attributes.index) {
        if (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {
          this[key] = this.__attributesRaw[key];
        } else {
          if (!this.__attributes.hasOwnProperty(key)) {
            if (script.attributes.index[key].hasOwnProperty("default")) {
              this[key] = script.attributes.index[key].default;
            } else {
              this[key] = null;
            }
          }
        }
      }
      this.__attributesRaw = null;
    };
    script.extend = function(methods) {
      for (var key in methods) {
        if (!methods.hasOwnProperty(key)) {
          continue;
        }
        script.prototype[key] = methods[key];
      }
    };
    Object.defineProperty(script.prototype, "enabled", {get:function() {
      return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;
    }, set:function(value) {
      this._enabled = !!value;
      if (this.enabled === this._enabledOld) {
        return;
      }
      this._enabledOld = this.enabled;
      this.fire(this.enabled ? "enable" : "disable");
      this.fire("state", this.enabled);
      if (!this._initialized && this.enabled) {
        this._initialized = true;
        this.__initializeAttributes(true);
        if (this.initialize) {
          this.entity.script._scriptMethod(this, pc.ScriptComponent.scriptMethods.initialize);
        }
      }
      if (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {
        this._postInitialized = true;
        if (this.postInitialize) {
          this.entity.script._scriptMethod(this, pc.ScriptComponent.scriptMethods.postInitialize);
        }
      }
    }});
    var registry = app ? app.scripts : pc.Application.getApplication().scripts;
    registry.add(script);
    pc.ScriptHandler._push(script);
    return script;
  };
  createScript.reservedScripts = ["system", "entity", "create", "destroy", "swap", "move", "scripts", "_scripts", "_scriptsIndex", "_scriptsData", "enabled", "_oldState", "onEnable", "onDisable", "onPostStateChange", "_onSetEnabled", "_checkState", "_onBeforeRemove", "_onInitializeAttributes", "_onInitialize", "_onPostInitialize", "_onUpdate", "_onPostUpdate", "_callbacks", "has", "on", "off", "fire", "once", "hasEvent"];
  var reservedScripts = {};
  var i;
  for (i = 0; i < createScript.reservedScripts.length; i++) {
    reservedScripts[createScript.reservedScripts[i]] = 1;
  }
  createScript.reservedScripts = reservedScripts;
  createScript.reservedAttributes = ["app", "entity", "enabled", "_enabled", "_enabledOld", "_destroyed", "__attributes", "__attributesRaw", "__scriptType", "__executionOrder", "_callbacks", "has", "on", "off", "fire", "once", "hasEvent"];
  var reservedAttributes = {};
  for (i = 0; i < createScript.reservedAttributes.length; i++) {
    reservedAttributes[createScript.reservedAttributes[i]] = 1;
  }
  createScript.reservedAttributes = reservedAttributes;
  return {createScript:createScript};
}());
Object.assign(pc, function() {
  var Bundle = function(files) {
    this._blobUrls = {};
    for (var i = 0, len = files.length; i < len; i++) {
      if (files[i].url) {
        this._blobUrls[files[i].name] = files[i].url;
      }
    }
  };
  Bundle.prototype.hasBlobUrl = function(url) {
    return !!this._blobUrls[url];
  };
  Bundle.prototype.getBlobUrl = function(url) {
    return this._blobUrls[url];
  };
  Bundle.prototype.destroy = function() {
    for (var key in this._blobUrls) {
      URL.revokeObjectURL(this._blobUrls[key]);
    }
    this._blobUrls = null;
  };
  return {Bundle:Bundle};
}());
Object.assign(pc, function() {
  var BundleRegistry = function(assets) {
    this._assets = assets;
    this._bundleAssets = {};
    this._assetsInBundles = {};
    this._urlsInBundles = {};
    this._fileRequests = {};
    this._assets.on("add", this._onAssetAdded, this);
    this._assets.on("remove", this._onAssetRemoved, this);
  };
  Object.assign(BundleRegistry.prototype, {_onAssetAdded:function(asset) {
    if (asset.type === "bundle") {
      this._bundleAssets[asset.id] = asset;
      this._registerBundleEventListeners(asset.id);
      for (var i = 0, len = asset.data.assets.length; i < len; i++) {
        this._indexAssetInBundle(asset.data.assets[i], asset);
      }
    } else {
      if (this._assetsInBundles[asset.id]) {
        this._indexAssetFileUrls(asset);
      }
    }
  }, _registerBundleEventListeners:function(bundleAssetId) {
    this._assets.on("load:" + bundleAssetId, this._onBundleLoaded, this);
    this._assets.on("error:" + bundleAssetId, this._onBundleError, this);
  }, _unregisterBundleEventListeners:function(bundleAssetId) {
    this._assets.off("load:" + bundleAssetId, this._onBundleLoaded, this);
    this._assets.off("error:" + bundleAssetId, this._onBundleError, this);
  }, _indexAssetInBundle:function(assetId, bundleAsset) {
    if (!this._assetsInBundles[assetId]) {
      this._assetsInBundles[assetId] = [bundleAsset];
    } else {
      var bundles = this._assetsInBundles[assetId];
      var idx = bundles.indexOf(bundleAsset);
      if (idx === -1) {
        bundles.push(bundleAsset);
      }
    }
    var asset = this._assets.get(assetId);
    if (asset) {
      this._indexAssetFileUrls(asset);
    }
  }, _indexAssetFileUrls:function(asset) {
    var urls = this._getAssetFileUrls(asset);
    if (!urls) {
      return;
    }
    for (var i = 0, len = urls.length; i < len; i++) {
      var url = urls[i];
      this._urlsInBundles[url] = this._assetsInBundles[asset.id];
    }
  }, _getAssetFileUrls:function(asset) {
    var url = asset.getFileUrl();
    if (!url) {
      return null;
    }
    url = this._normalizeUrl(url);
    var urls = [url];
    if (asset.type === "font") {
      var numFiles = asset.data.info.maps.length;
      for (var i = 1; i < numFiles; i++) {
        urls.push(url.replace(".png", i + ".png"));
      }
    }
    return urls;
  }, _normalizeUrl:function(url) {
    return url && url.split("?")[0];
  }, _onAssetRemoved:function(asset) {
    if (asset.type === "bundle") {
      delete this._bundleAssets[asset.id];
      this._unregisterBundleEventListeners(asset.id);
      var idx, id;
      for (id in this._assetsInBundles) {
        var array = this._assetsInBundles[id];
        idx = array.indexOf(asset);
        if (idx !== -1) {
          array.splice(idx, 1);
          if (!array.length) {
            delete this._assetsInBundles[id];
            for (var url in this._urlsInBundles) {
              if (this._urlsInBundles[url] === array) {
                delete this._urlsInBundles[url];
              }
            }
          }
        }
      }
      this._onBundleError("Bundle " + asset.id + " was removed", asset);
    } else {
      if (this._assetsInBundles[asset.id]) {
        delete this._assetsInBundles[asset.id];
        var urls = this._getAssetFileUrls(asset);
        for (var i = 0, len = urls.length; i < len; i++) {
          delete this._urlsInBundles[urls[i]];
        }
      }
    }
  }, _onBundleLoaded:function(bundleAsset) {
    if (!bundleAsset.resource) {
      this._onBundleError("Bundle " + bundleAsset.id + " failed to load", bundleAsset);
      return;
    }
    requestAnimationFrame(function() {
      if (!this._fileRequests) {
        return;
      }
      for (var url in this._fileRequests) {
        var bundles = this._urlsInBundles[url];
        if (!bundles || bundles.indexOf(bundleAsset) === -1) {
          continue;
        }
        var decodedUrl = decodeURIComponent(url);
        var err = null;
        if (!bundleAsset.resource.hasBlobUrl(decodedUrl)) {
          err = "Bundle " + bundleAsset.id + " does not contain URL " + url;
        }
        var requests = this._fileRequests[url];
        for (var i = 0, len = requests.length; i < len; i++) {
          if (err) {
            requests[i](err);
          } else {
            requests[i](null, bundleAsset.resource.getBlobUrl(decodedUrl));
          }
        }
        delete this._fileRequests[url];
      }
    }.bind(this));
  }, _onBundleError:function(err, bundleAsset) {
    for (var url in this._fileRequests) {
      var bundle = this._findLoadedOrLoadingBundleForUrl(url);
      if (!bundle) {
        var requests = this._fileRequests[url];
        for (var i = 0, len = requests.length; i < len; i++) {
          requests[i](err);
        }
        delete this._fileRequests[url];
      }
    }
  }, _findLoadedOrLoadingBundleForUrl:function(url) {
    var bundles = this._urlsInBundles[url];
    if (!bundles) {
      return null;
    }
    var len = bundles.length;
    var i;
    for (i = 0; i < len; i++) {
      if (bundles[i].loaded && bundles[i].resource) {
        return bundles[i];
      }
    }
    for (i = 0; i < len; i++) {
      if (bundles[i].loading) {
        return bundles[i];
      }
    }
    return null;
  }, listBundlesForAsset:function(asset) {
    return this._assetsInBundles[asset.id] || null;
  }, list:function() {
    var result = [];
    for (var id in this._bundleAssets) {
      result.push(this._bundleAssets[id]);
    }
    return result;
  }, hasUrl:function(url) {
    return !!this._urlsInBundles[url];
  }, canLoadUrl:function(url) {
    return !!this._findLoadedOrLoadingBundleForUrl(url);
  }, loadUrl:function(url, callback) {
    var bundle = this._findLoadedOrLoadingBundleForUrl(url);
    if (!bundle) {
      callback("URL " + url + " not found in any bundles");
      return;
    }
    if (bundle.loaded) {
      var decodedUrl = decodeURIComponent(url);
      if (!bundle.resource.hasBlobUrl(decodedUrl)) {
        callback("Bundle " + bundle.id + " does not contain URL " + url);
        return;
      }
      callback(null, bundle.resource.getBlobUrl(decodedUrl));
    } else {
      if (this._fileRequests.hasOwnProperty(url)) {
        this._fileRequests[url].push(callback);
      } else {
        this._fileRequests[url] = [callback];
      }
    }
  }, destroy:function() {
    this._assets.off("add", this._onAssetAdded, this);
    this._assets.off("remove", this._onAssetRemoved, this);
    for (var id in this._bundleAssets) {
      this._unregisterBundleEventListeners(id);
    }
    this._assets = null;
    this._bundleAssets = null;
    this._assetsInBundles = null;
    this._urlsInBundles = null;
    this._fileRequests = null;
  }});
  return {BundleRegistry:BundleRegistry};
}());
Object.assign(pc, function() {
  var I18nParser = function() {
  };
  I18nParser.prototype._validate = function(data) {
    if (!data.header) {
      throw new Error('pc.I18n#addData: Missing "header" field');
    }
    if (!data.header.version) {
      throw new Error('pc.I18n#addData: Missing "header.version" field');
    }
    if (data.header.version !== 1) {
      throw new Error('pc.I18n#addData: Invalid "header.version" field');
    }
    if (!data.data) {
      throw new Error('pc.I18n#addData: Missing "data" field');
    } else {
      if (!Array.isArray(data.data)) {
        throw new Error('pc.I18n#addData: "data" field must be an array');
      }
    }
    for (var i = 0, len = data.data.length; i < len; i++) {
      var entry = data.data[i];
      if (!entry.info) {
        throw new Error('pc.I18n#addData: missing "data[' + i + '].info" field');
      }
      if (!entry.info.locale) {
        throw new Error('pc.I18n#addData: missing "data[' + i + '].info.locale" field');
      }
      if (typeof entry.info.locale !== "string") {
        throw new Error('pc.I18n#addData: "data[' + i + '].info.locale" must be a string');
      }
      if (!entry.messages) {
        throw new Error('pc.I18n#addData: missing "data[' + i + '].messages" field');
      }
    }
  };
  I18nParser.prototype.parse = function(data) {
    return data.data;
  };
  return {I18nParser:I18nParser};
}());
Object.assign(pc, function() {
  var PLURALS = {};
  var definePluralFn = function(locales, fn) {
    for (var i = 0, len = locales.length; i < len; i++) {
      PLURALS[locales[i]] = fn;
    }
  };
  var getLang = function(locale) {
    var idx = locale.indexOf("-");
    if (idx !== -1) {
      return locale.substring(0, idx);
    }
    return locale;
  };
  var DEFAULT_LOCALE = "en-US";
  var DEFAULT_PLURAL_FN = PLURALS[getLang(DEFAULT_LOCALE)];
  var DEFAULT_LOCALE_FALLBACKS = {"en":"en-US", "es":"en-ES", "zh":"zh-CN", "fr":"fr-FR", "de":"de-DE", "it":"it-IT", "ru":"ru-RU", "ja":"ja-JP"};
  var getPluralFn = function(lang) {
    return PLURALS[lang] || DEFAULT_PLURAL_FN;
  };
  definePluralFn(["ja", "ko", "th", "vi", "zh"], function(n) {
    return 0;
  });
  definePluralFn(["fa", "hi"], function(n) {
    if (n >= 0 && n <= 1) {
      return 0;
    }
    return 1;
  });
  definePluralFn(["fr"], function(n) {
    if (n >= 0 && n < 2) {
      return 0;
    }
    return 1;
  });
  definePluralFn(["de", "en", "it", "el", "es", "tr"], function(n) {
    if (n === 1) {
      return 0;
    }
    return 1;
  });
  definePluralFn(["ru", "uk"], function(n) {
    if (Number.isInteger(n)) {
      var mod10 = n % 10;
      var mod100 = n % 100;
      if (mod10 === 1 && mod100 !== 11) {
        return 0;
      } else {
        if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
          return 1;
        } else {
          if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {
            return 2;
          }
        }
      }
    }
    return 3;
  });
  definePluralFn(["ar"], function(n) {
    if (n === 0) {
      return 0;
    } else {
      if (n === 1) {
        return 1;
      } else {
        if (n === 2) {
          return 2;
        }
      }
    }
    if (Number.isInteger(n)) {
      var mod100 = n % 100;
      if (mod100 >= 3 && mod100 <= 10) {
        return 3;
      } else {
        if (mod100 >= 11 && mod100 <= 99) {
          return 4;
        }
      }
    }
    return 5;
  });
  var I18n = function(app) {
    pc.events.attach(this);
    this.locale = DEFAULT_LOCALE;
    this._translations = {};
    this._availableLangs = {};
    this._app = app;
    this._assets = [];
    this._parser = new pc.I18nParser;
  };
  I18n.prototype.getText = function(key, locale) {
    var result = key;
    var lang;
    if (!locale) {
      locale = this._locale;
      lang = this._lang;
    }
    var translations = this._translations[locale];
    if (!translations) {
      if (!lang) {
        lang = getLang(locale);
      }
      locale = this._findFallbackLocale(lang);
      translations = this._translations[locale];
    }
    if (translations) {
      result = translations[key];
      if (result) {
        if (Array.isArray(result)) {
          result = result[0] || "";
        }
      } else {
        result = key;
      }
    }
    return result;
  };
  I18n.prototype.getPluralText = function(key, n, locale) {
    var result = key;
    var pluralFn;
    var lang;
    if (!locale) {
      locale = this._locale;
      lang = this._lang;
      pluralFn = this._pluralFn;
    } else {
      lang = getLang(locale);
      pluralFn = getPluralFn(lang);
    }
    var translations = this._translations[locale];
    if (!translations) {
      locale = this._findFallbackLocale(lang);
      pluralFn = getPluralFn(lang);
      translations = this._translations[locale];
    }
    if (translations && translations[key]) {
      var index = pluralFn(n);
      result = translations[key][index] || key;
    }
    return result;
  };
  I18n.prototype.addData = function(data) {
    var parsed;
    try {
      parsed = this._parser.parse(data);
    } catch (err) {
      console.error(err);
      return;
    }
    for (var i = 0, len = parsed.length; i < len; i++) {
      var entry = parsed[i];
      var locale = entry.info.locale;
      var messages = entry.messages;
      if (!this._translations[locale]) {
        this._translations[locale] = {};
        var lang = getLang(locale);
        if (!this._availableLangs[lang]) {
          this._availableLangs[lang] = locale;
        }
      }
      Object.assign(this._translations[locale], messages);
      this.fire("data:add", locale, messages);
    }
  };
  I18n.prototype.removeData = function(data) {
    var parsed;
    var key;
    try {
      parsed = this._parser.parse(data);
    } catch (err) {
      console.error(err);
      return;
    }
    for (var i = 0, len = parsed.length; i < len; i++) {
      var entry = parsed[i];
      var locale = entry.info.locale;
      var translations = this._translations[locale];
      if (!translations) {
        continue;
      }
      var messages = entry.messages;
      for (key in messages) {
        delete translations[key];
      }
      var hasAny = false;
      for (key in translations) {
        hasAny = true;
        break;
      }
      if (!hasAny) {
        delete this._translations[locale];
        delete this._availableLangs[getLang(locale)];
      }
      this.fire("data:remove", locale, messages);
    }
  };
  I18n.prototype.destroy = function() {
    this._translations = null;
    this._availableLangs = null;
    this._assets = null;
    this._parser = null;
    this.off();
  };
  Object.defineProperty(I18n.prototype, "locale", {get:function() {
    return this._locale;
  }, set:function(value) {
    if (this._locale === value) {
      return;
    }
    var old = this._locale;
    this._locale = value;
    this._lang = getLang(value);
    this._pluralFn = getPluralFn(this._lang);
    this.fire("set:locale", value, old);
  }});
  Object.defineProperty(I18n.prototype, "assets", {get:function() {
    return this._assets;
  }, set:function(value) {
    var i;
    var len;
    var id;
    var asset;
    var index = {};
    for (i = 0, len = value.length; i < len; i++) {
      id = value[i] instanceof pc.Asset ? value[i].id : value[i];
      index[id] = true;
    }
    i = this._assets.length;
    while (i--) {
      id = this._assets[i];
      if (!index[id]) {
        this._app.assets.off("add:" + id, this._onAssetAdd, this);
        asset = this._app.assets.get(id);
        if (asset) {
          this._onAssetRemove(asset);
        }
        this._assets.splice(i, 1);
      }
    }
    for (id in index) {
      id = parseInt(id, 10);
      if (this._assets.indexOf(id) !== -1) {
        continue;
      }
      this._assets.push(id);
      asset = this._app.assets.get(id);
      if (!asset) {
        this._app.assets.once("add:" + id, this._onAssetAdd, this);
      } else {
        this._onAssetAdd(asset);
      }
    }
  }});
  I18n.prototype._findFallbackLocale = function(lang) {
    var result = DEFAULT_LOCALE_FALLBACKS[lang];
    if (result && this._translations[result]) {
      return result;
    }
    result = this._availableLangs[lang];
    if (result && this._translations[result]) {
      return result;
    }
    return DEFAULT_LOCALE;
  };
  I18n.prototype._onAssetAdd = function(asset) {
    asset.on("load", this._onAssetLoad, this);
    asset.on("change", this._onAssetChange, this);
    asset.on("remove", this._onAssetRemove, this);
    asset.on("unload", this._onAssetUnload, this);
    if (asset.resource) {
      this._onAssetLoad(asset);
    }
  };
  I18n.prototype._onAssetLoad = function(asset) {
    this.addData(asset.resource);
  };
  I18n.prototype._onAssetChange = function(asset) {
    if (asset.resource) {
      this.addData(asset.resource);
    }
  };
  I18n.prototype._onAssetRemove = function(asset) {
    asset.off("load", this._onAssetLoad, this);
    asset.off("change", this._onAssetChange, this);
    asset.off("remove", this._onAssetRemove, this);
    asset.off("unload", this._onAssetUnload, this);
    if (asset.resource) {
      this.removeData(asset.resource);
    }
    this._app.assets.once("add:" + asset.id, this._onAssetAdd, this);
  };
  I18n.prototype._onAssetUnload = function(asset) {
    if (asset.resource) {
      this.removeData(asset.resource);
    }
  };
  return {I18n:I18n};
}());
pc.script = function() {
  var _legacy = false;
  var _createdLoadingScreen = false;
  var script = {app:null, create:function(name, callback) {
    if (!_legacy) {
      return;
    }
    var ScriptType = callback(pc.script.app);
    ScriptType._pcScriptName = name;
    pc.ScriptHandler._push(ScriptType);
    this.fire("created", name, callback);
  }, attribute:function(name, type, defaultValue, options) {
  }, createLoadingScreen:function(callback) {
    if (_createdLoadingScreen) {
      return;
    }
    _createdLoadingScreen = true;
    var app = pc.Application.getApplication();
    callback(app);
  }};
  Object.defineProperty(script, "legacy", {get:function() {
    return _legacy;
  }, set:function(value) {
    _legacy = value;
  }});
  pc.events.attach(script);
  return script;
}();
Object.assign(pc, function() {
  var Application = function(canvas, options) {
    options = options || {};
    pc.log.open();
    pc.events.attach(this);
    Application._applications[canvas.id] = this;
    Application._currentApplication = this;
    pc.app = this;
    this._time = 0;
    this.timeScale = 1;
    this.maxDeltaTime = 0.1;
    this.frame = 0;
    this.autoRender = true;
    this.renderNextFrame = false;
    this.useLegacyScriptAttributeCloning = pc.script.legacy;
    this._librariesLoaded = false;
    this._fillMode = pc.FILLMODE_KEEP_ASPECT;
    this._resolutionMode = pc.RESOLUTION_FIXED;
    this._allowResize = true;
    this.context = this;
    this.graphicsDevice = new pc.GraphicsDevice(canvas, options.graphicsDeviceOptions);
    this.stats = new pc.ApplicationStats(this.graphicsDevice);
    this.loader = new pc.ResourceLoader(this);
    this._entityIndex = {};
    this.scene = new pc.Scene;
    this.root = new pc.Entity(this);
    this.root._enabledInHierarchy = true;
    this._enableList = [];
    this._enableList.size = 0;
    this.assets = new pc.AssetRegistry(this.loader);
    if (options.assetPrefix) {
      this.assets.prefix = options.assetPrefix;
    }
    this.bundles = new pc.BundleRegistry(this.assets);
    this.enableBundles = typeof TextDecoder !== "undefined";
    this.scriptsOrder = options.scriptsOrder || [];
    this.scripts = new pc.ScriptRegistry(this);
    this.i18n = new pc.I18n(this);
    this._sceneRegistry = new pc.SceneRegistry(this);
    var self = this;
    this.defaultLayerWorld = new pc.Layer({name:"World", id:pc.LAYERID_WORLD});
    if (this.graphicsDevice.webgl2) {
      this.defaultLayerDepth = new pc.Layer({enabled:false, name:"Depth", id:pc.LAYERID_DEPTH, onEnable:function() {
        if (this.renderTarget) {
          return;
        }
        var depthBuffer = new pc.Texture(self.graphicsDevice, {format:pc.PIXELFORMAT_DEPTHSTENCIL, width:self.graphicsDevice.width, height:self.graphicsDevice.height});
        depthBuffer.name = "rt-depth2";
        depthBuffer.minFilter = pc.FILTER_NEAREST;
        depthBuffer.magFilter = pc.FILTER_NEAREST;
        depthBuffer.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
        depthBuffer.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
        this.renderTarget = new pc.RenderTarget({colorBuffer:null, depthBuffer:depthBuffer, autoResolve:false});
        self.graphicsDevice.scope.resolve("uDepthMap").setValue(depthBuffer);
      }, onDisable:function() {
        if (!this.renderTarget) {
          return;
        }
        this.renderTarget._depthBuffer.destroy();
        this.renderTarget.destroy();
        this.renderTarget = null;
      }, onPreRenderOpaque:function(cameraPass) {
        var gl = self.graphicsDevice.gl;
        this.srcFbo = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        if (!this.renderTarget || (this.renderTarget.width !== self.graphicsDevice.width || this.renderTarget.height !== self.graphicsDevice.height)) {
          this.onDisable();
          this.onEnable();
        }
        this.oldClear = this.cameras[cameraPass].camera._clearOptions;
        this.cameras[cameraPass].camera._clearOptions = this.depthClearOptions;
      }, onPostRenderOpaque:function(cameraPass) {
        if (!this.renderTarget) {
          return;
        }
        this.cameras[cameraPass].camera._clearOptions = this.oldClear;
        var gl = self.graphicsDevice.gl;
        self.graphicsDevice.setRenderTarget(this.renderTarget);
        self.graphicsDevice.updateBegin();
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.srcFbo);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.renderTarget._glFrameBuffer);
        gl.blitFramebuffer(0, 0, this.renderTarget.width, this.renderTarget.height, 0, 0, this.renderTarget.width, this.renderTarget.height, gl.DEPTH_BUFFER_BIT, gl.NEAREST);
      }});
      this.defaultLayerDepth.depthClearOptions = {flags:0};
    } else {
      this.defaultLayerDepth = new pc.Layer({enabled:false, name:"Depth", id:pc.LAYERID_DEPTH, shaderPass:pc.SHADER_DEPTH, onEnable:function() {
        if (this.renderTarget) {
          return;
        }
        var colorBuffer = new pc.Texture(self.graphicsDevice, {format:pc.PIXELFORMAT_R8_G8_B8_A8, width:self.graphicsDevice.width, height:self.graphicsDevice.height});
        colorBuffer.name = "rt-depth1";
        colorBuffer.minFilter = pc.FILTER_NEAREST;
        colorBuffer.magFilter = pc.FILTER_NEAREST;
        colorBuffer.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
        colorBuffer.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
        this.renderTarget = new pc.RenderTarget(self.graphicsDevice, colorBuffer, {depth:true, stencil:self.graphicsDevice.supportsStencil});
        self.graphicsDevice.scope.resolve("uDepthMap").setValue(colorBuffer);
      }, onDisable:function() {
        if (!this.renderTarget) {
          return;
        }
        this.renderTarget._colorBuffer.destroy();
        this.renderTarget.destroy();
        this.renderTarget = null;
      }, onPostCull:function(cameraPass) {
        var visibleObjects = this.instances.visibleOpaque[cameraPass];
        var visibleList = visibleObjects.list;
        var visibleLength = 0;
        var layers = self.scene.layers.layerList;
        var subLayerEnabled = self.scene.layers.subLayerEnabled;
        var isTransparent = self.scene.layers.subLayerList;
        var rt = self.defaultLayerWorld.renderTarget;
        var cam = this.cameras[cameraPass];
        var layer;
        var j;
        var layerVisibleList, layerCamId, layerVisibleListLength, drawCall, transparent;
        for (var i = 0; i < layers.length; i++) {
          layer = layers[i];
          if (layer === this) {
            break;
          }
          if (layer.renderTarget !== rt || !layer.enabled || !subLayerEnabled[i]) {
            continue;
          }
          layerCamId = layer.cameras.indexOf(cam);
          if (layerCamId < 0) {
            continue;
          }
          transparent = isTransparent[i];
          layerVisibleList = transparent ? layer.instances.visibleTransparent[layerCamId] : layer.instances.visibleOpaque[layerCamId];
          layerVisibleListLength = layerVisibleList.length;
          layerVisibleList = layerVisibleList.list;
          for (j = 0; j < layerVisibleListLength; j++) {
            drawCall = layerVisibleList[j];
            if (drawCall.material && drawCall.material.depthWrite && !drawCall._noDepthDrawGl1) {
              visibleList[visibleLength] = drawCall;
              visibleLength++;
            }
          }
        }
        visibleObjects.length = visibleLength;
      }, onPreRenderOpaque:function(cameraPass) {
        if (!this.renderTarget || (this.renderTarget.width !== self.graphicsDevice.width || this.renderTarget.height !== self.graphicsDevice.height)) {
          this.onDisable();
          this.onEnable();
        }
        this.oldClear = this.cameras[cameraPass].camera._clearOptions;
        this.cameras[cameraPass].camera._clearOptions = this.rgbaDepthClearOptions;
      }, onDrawCall:function() {
        self.graphicsDevice.setColorWrite(true, true, true, true);
      }, onPostRenderOpaque:function(cameraPass) {
        if (!this.renderTarget) {
          return;
        }
        this.cameras[cameraPass].camera._clearOptions = this.oldClear;
      }});
      this.defaultLayerDepth.rgbaDepthClearOptions = {color:[254.0 / 255, 254.0 / 255, 254.0 / 255, 254.0 / 255], depth:1.0, flags:pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH};
    }
    this.defaultLayerSkybox = new pc.Layer({enabled:false, name:"Skybox", id:pc.LAYERID_SKYBOX, opaqueSortMode:pc.SORTMODE_NONE});
    this.defaultLayerUi = new pc.Layer({enabled:true, name:"UI", id:pc.LAYERID_UI, transparentSortMode:pc.SORTMODE_MANUAL, passThrough:false});
    this.defaultLayerImmediate = new pc.Layer({enabled:true, name:"Immediate", id:pc.LAYERID_IMMEDIATE, opaqueSortMode:pc.SORTMODE_NONE, passThrough:true});
    this.defaultLayerComposition = new pc.LayerComposition;
    this.defaultLayerComposition.pushOpaque(this.defaultLayerWorld);
    this.defaultLayerComposition.pushOpaque(this.defaultLayerDepth);
    this.defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);
    this.defaultLayerComposition.pushTransparent(this.defaultLayerWorld);
    this.defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);
    this.defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);
    this.defaultLayerComposition.pushTransparent(this.defaultLayerUi);
    this.scene.layers = this.defaultLayerComposition;
    this._immediateLayer = this.defaultLayerImmediate;
    this.scene.on("set:layers", function(oldComp, newComp) {
      var list = newComp.layerList;
      var layer;
      for (var i = 0; i < list.length; i++) {
        layer = list[i];
        switch(layer.id) {
          case pc.LAYERID_DEPTH:
            layer.onEnable = self.defaultLayerDepth.onEnable;
            layer.onDisable = self.defaultLayerDepth.onDisable;
            layer.onPreRenderOpaque = self.defaultLayerDepth.onPreRenderOpaque;
            layer.onPostRenderOpaque = self.defaultLayerDepth.onPostRenderOpaque;
            layer.depthClearOptions = self.defaultLayerDepth.depthClearOptions;
            layer.rgbaDepthClearOptions = self.defaultLayerDepth.rgbaDepthClearOptions;
            layer.shaderPass = self.defaultLayerDepth.shaderPass;
            layer.onPostCull = self.defaultLayerDepth.onPostCull;
            layer.onDrawCall = self.defaultLayerDepth.onDrawCall;
            break;
          case pc.LAYERID_UI:
            layer.passThrough = self.defaultLayerUi.passThrough;
            break;
          case pc.LAYERID_IMMEDIATE:
            layer.passThrough = self.defaultLayerImmediate.passThrough;
            break;
        }
      }
    });
    this.renderer = new pc.ForwardRenderer(this.graphicsDevice);
    this.renderer.scene = this.scene;
    this.lightmapper = new pc.Lightmapper(this.graphicsDevice, this.root, this.scene, this.renderer, this.assets);
    this.once("prerender", this._firstBake, this);
    this.batcher = new pc.BatchManager(this.graphicsDevice, this.root, this.scene);
    this.once("prerender", this._firstBatch, this);
    this.keyboard = options.keyboard || null;
    this.mouse = options.mouse || null;
    this.touch = options.touch || null;
    this.gamepads = options.gamepads || null;
    this.elementInput = options.elementInput || null;
    if (this.elementInput) {
      this.elementInput.app = this;
    }
    this._inTools = false;
    this._skyboxLast = 0;
    this._scriptPrefix = options.scriptPrefix || "";
    this.loader.addHandler("texture", new pc.TextureHandler(this.graphicsDevice, this.assets, this.loader));
    this.loader.addHandler("text", new pc.TextHandler);
    this.loader.addHandler("json", new pc.JsonHandler);
    this.loader.addHandler("script", new pc.ScriptHandler(this));
    this.loader.addHandler("scene", new pc.SceneHandler(this));
    this.loader.addHandler("hierarchy", new pc.HierarchyHandler(this));
    this.loader.addHandler("scenesettings", new pc.SceneSettingsHandler(this));
    this.loader.addHandler("folder", new pc.FolderHandler);
    this.loader.addHandler("textureatlas", new pc.TextureAtlasHandler(this.loader));
    this.loader.addHandler("sprite", new pc.SpriteHandler(this.assets, this.graphicsDevice));
    this.systems = new pc.ComponentSystemRegistry;
    this.systems.add(new pc.CameraComponentSystem(this));
    this.systems.add(new pc.LightComponentSystem(this));
    this.systems.add(new pc.ScriptComponentSystem(this));
    this.systems.add(new pc.SpriteComponentSystem(this));
    this.systems.add(new pc.ParticleSystemComponentSystem(this));
    this._visibilityChangeHandler = this.onVisibilityChange.bind(this);
    if (document.hidden !== undefined) {
      this._hiddenAttr = "hidden";
      document.addEventListener("visibilitychange", this._visibilityChangeHandler, false);
    } else {
      if (document.mozHidden !== undefined) {
        this._hiddenAttr = "mozHidden";
        document.addEventListener("mozvisibilitychange", this._visibilityChangeHandler, false);
      } else {
        if (document.msHidden !== undefined) {
          this._hiddenAttr = "msHidden";
          document.addEventListener("msvisibilitychange", this._visibilityChangeHandler, false);
        } else {
          if (document.webkitHidden !== undefined) {
            this._hiddenAttr = "webkitHidden";
            document.addEventListener("webkitvisibilitychange", this._visibilityChangeHandler, false);
          }
        }
      }
    }
    this.tick = makeTick(this);
  };
  Application._currentApplication = null;
  Application._applications = {};
  Application.getApplication = function(id) {
    return id ? Application._applications[id] : Application._currentApplication;
  };
  var Progress = function(length) {
    this.length = length;
    this.count = 0;
    this.inc = function() {
      this.count++;
    };
    this.done = function() {
      return this.count === this.length;
    };
  };
  Object.assign(Application.prototype, {configure:function(url, callback) {
    var self = this;
    var response = url;
    var props = response.application_properties;
    var scenes = response.scenes;
    var assets = response.assets;
    self._parseApplicationProperties(props, function(err) {
      self._onVrChange(props.vr);
      self._parseScenes(scenes);
      self._parseAssets(assets);
      if (!err) {
        callback(null);
      } else {
        callback(err);
      }
    });
  }, preload:function(callback) {
    var self = this;
    var i, total;
    self.fire("preload:start");
    var assets = this.assets.list({preload:true});
    var _assets = new Progress(assets.length);
    var _done = false;
    var done = function() {
      if (!self.graphicsDevice) {
        return;
      }
      if (!_done && _assets.done()) {
        _done = true;
        self.fire("preload:end");
        callback();
      }
    };
    total = assets.length;
    var count = function() {
      return _assets.count;
    };
    if (_assets.length) {
      var onAssetLoad = function(asset) {
        _assets.inc();
        self.fire("preload:progress", count() / total);
        if (_assets.done()) {
          done();
        }
      };
      var onAssetError = function(err, asset) {
        _assets.inc();
        self.fire("preload:progress", count() / total);
        if (_assets.done()) {
          done();
        }
      };
      for (i = 0; i < assets.length; i++) {
        if (!assets[i].loaded) {
          assets[i].once("load", onAssetLoad);
          assets[i].once("error", onAssetError);
          this.assets.load(assets[i]);
        } else {
          _assets.inc();
          self.fire("preload:progress", count() / total);
          if (_assets.done()) {
            done();
          }
        }
      }
    } else {
      done();
    }
  }, getSceneUrl:function(name) {
    var entry = this._sceneRegistry.find(name);
    if (entry) {
      return entry.url;
    }
    return null;
  }, loadSceneHierarchy:function(url, callback) {
    this._sceneRegistry.loadSceneHierarchy(url, callback);
  }, loadSceneSettings:function(url, callback) {
    this._sceneRegistry.loadSceneSettings(url, callback);
  }, loadScene:function(url, callback) {
    this._sceneRegistry.loadScene(url, callback);
  }, _preloadScripts:function(sceneData, callback) {
    if (!pc.script.legacy) {
      callback();
      return;
    }
    var self = this;
    self.systems.script.preloading = true;
    var scripts = this._getScriptReferences(sceneData);
    var i = 0, l = scripts.length;
    var progress = new Progress(l);
    var scriptUrl;
    var regex = /^http(s)?:\/\//;
    if (l) {
      var onLoad = function(err, ScriptType) {
        if (err) {
          console.error(err);
        }
        progress.inc();
        if (progress.done()) {
          self.systems.script.preloading = false;
          callback();
        }
      };
      for (i = 0; i < l; i++) {
        scriptUrl = scripts[i];
        if (!regex.test(scriptUrl.toLowerCase()) && self._scriptPrefix) {
          scriptUrl = pc.path.join(self._scriptPrefix, scripts[i]);
        }
        this.loader.load(scriptUrl, "script", onLoad);
      }
    } else {
      self.systems.script.preloading = false;
      callback();
    }
  }, _parseApplicationProperties:function(props, callback) {
    var i;
    var len;
    if (!props.useDevicePixelRatio) {
      props.useDevicePixelRatio = props.use_device_pixel_ratio;
    }
    if (!props.resolutionMode) {
      props.resolutionMode = props.resolution_mode;
    }
    if (!props.fillMode) {
      props.fillMode = props.fill_mode;
    }
    if (!props.vrPolyfillUrl) {
      props.vrPolyfillUrl = props.vr_polyfill_url;
    }
    this._width = props.width;
    this._height = props.height;
    if (props.useDevicePixelRatio) {
      this.graphicsDevice.maxPixelRatio = window.devicePixelRatio;
    }
    this.setCanvasResolution(props.resolutionMode, this._width, this._height);
    this.setCanvasFillMode(props.fillMode, this._width, this._height);
    if (props.vr && props.vrPolyfillUrl) {
      if (!pc.VrManager.isSupported || pc.platform.android) {
        props.libraries.push(props.vrPolyfillUrl);
      }
    }
    if (props.layers && props.layerOrder) {
      var composition = new pc.LayerComposition;
      var layers = {};
      for (var key in props.layers) {
        var data = props.layers[key];
        data.id = parseInt(key, 10);
        data.enabled = data.id !== pc.LAYERID_DEPTH;
        layers[key] = new pc.Layer(data);
      }
      for (i = 0, len = props.layerOrder.length; i < len; i++) {
        var sublayer = props.layerOrder[i];
        var layer = layers[sublayer.layer];
        if (!layer) {
          continue;
        }
        if (sublayer.transparent) {
          composition.pushTransparent(layer);
        } else {
          composition.pushOpaque(layer);
        }
        composition.subLayerEnabled[i] = sublayer.enabled;
      }
      this.scene.layers = composition;
    }
    if (props.batchGroups) {
      for (i = 0, len = props.batchGroups.length; i < len; i++) {
        var grp = props.batchGroups[i];
        this.batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);
      }
    }
    if (props.i18nAssets) {
      this.i18n.assets = props.i18nAssets;
    }
    this._loadLibraries(props.libraries, callback);
  }, _loadLibraries:function(urls, callback) {
    var len = urls.length;
    var count = len;
    var self = this;
    var regex = /^http(s)?:\/\//;
    if (len) {
      var onLoad = function(err, script) {
        count--;
        if (err) {
          callback(err);
        } else {
          if (count === 0) {
            self.onLibrariesLoaded();
            callback(null);
          }
        }
      };
      for (var i = 0; i < len; ++i) {
        var url = urls[i];
        if (!regex.test(url.toLowerCase()) && self._scriptPrefix) {
          url = pc.path.join(self._scriptPrefix, url);
        }
        this.loader.load(url, "script", onLoad);
      }
    } else {
      callback(null);
    }
  }, _parseScenes:function(scenes) {
    if (!scenes) {
      return;
    }
    for (var i = 0; i < scenes.length; i++) {
      this._sceneRegistry.add(scenes[i].name, scenes[i].url);
    }
  }, _parseAssets:function(assets) {
    var i, id;
    var list = [];
    var scriptsIndex = {};
    var bundlesIndex = {};
    if (!pc.script.legacy) {
      for (i = 0; i < this.scriptsOrder.length; i++) {
        id = this.scriptsOrder[i];
        if (!assets[id]) {
          continue;
        }
        scriptsIndex[id] = true;
        list.push(assets[id]);
      }
      if (this.enableBundles) {
        for (id in assets) {
          if (assets[id].type === "bundle") {
            bundlesIndex[id] = true;
            list.push(assets[id]);
          }
        }
      }
      for (id in assets) {
        if (scriptsIndex[id] || bundlesIndex[id]) {
          continue;
        }
        list.push(assets[id]);
      }
    } else {
      if (this.enableBundles) {
        for (id in assets) {
          if (assets[id].type === "bundle") {
            bundlesIndex[id] = true;
            list.push(assets[id]);
          }
        }
      }
      for (id in assets) {
        if (bundlesIndex[id]) {
          continue;
        }
        list.push(assets[id]);
      }
    }
    for (i = 0; i < list.length; i++) {
      var data = list[i];
      var asset = new pc.Asset(data.name, data.type, data.file, data.data);
      asset.id = parseInt(data.id, 10);
      asset.preload = data.preload ? data.preload : false;
      asset.tags.add(data.tags);
      this.assets.add(asset);
    }
  }, _getScriptReferences:function(scene) {
    var i, key;
    var priorityScripts = [];
    if (scene.settings.priority_scripts) {
      priorityScripts = scene.settings.priority_scripts;
    }
    var _scripts = [];
    var _index = {};
    for (i = 0; i < priorityScripts.length; i++) {
      _scripts.push(priorityScripts[i]);
      _index[priorityScripts[i]] = true;
    }
    var entities = scene.entities;
    for (key in entities) {
      if (!entities[key].components.script) {
        continue;
      }
      var scripts = entities[key].components.script.scripts;
      for (i = 0; i < scripts.length; i++) {
        if (_index[scripts[i].url]) {
          continue;
        }
        _scripts.push(scripts[i].url);
        _index[scripts[i].url] = true;
      }
    }
    return _scripts;
  }, start:function() {
    this.frame = 0;
    this.fire("start", {timestamp:pc.now(), target:this});
    if (!this._librariesLoaded) {
      this.onLibrariesLoaded();
    }
    pc.ComponentSystem.initialize(this.root);
    this.fire("initialize");
    pc.ComponentSystem.postInitialize(this.root);
    this.fire("postinitialize");
    this.tick();
  }, update:function(dt) {
    this.frame++;
    this.graphicsDevice.updateClientRect();
    if (this.vr) {
      this.vr.poll();
    }
    if (pc.script.legacy) {
      pc.ComponentSystem.fixedUpdate(1.0 / 60.0, this._inTools);
    }
    pc.ComponentSystem.update(dt, this._inTools);
    pc.ComponentSystem.postUpdate(dt, this._inTools);
    this.fire("update", dt);
    if (this.controller) {
      this.controller.update(dt);
    }
    if (this.mouse) {
      this.mouse.update(dt);
    }
    if (this.keyboard) {
      this.keyboard.update(dt);
    }
    if (this.gamepads) {
      this.gamepads.update(dt);
    }
  }, render:function() {
    this.fire("prerender");
    this.root.syncHierarchy();
    this.batcher.updateAll();
    pc._skipRenderCounter = 0;
    this.renderer.renderComposition(this.scene.layers);
    this.fire("postrender");
  }, _fillFrameStats:function(now, dt, ms) {
    var stats = this.stats.frame;
    stats.dt = dt;
    stats.ms = ms;
    if (now > stats._timeToCountFrames) {
      stats.fps = stats._fpsAccum;
      stats._fpsAccum = 0;
      stats._timeToCountFrames = now + 1000;
    } else {
      stats._fpsAccum++;
    }
    stats.cameras = this.renderer._camerasRendered;
    stats.materials = this.renderer._materialSwitches;
    stats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;
    stats.shadowMapUpdates = this.renderer._shadowMapUpdates;
    stats.shadowMapTime = this.renderer._shadowMapTime;
    stats.depthMapTime = this.renderer._depthMapTime;
    stats.forwardTime = this.renderer._forwardTime;
    var prims = this.graphicsDevice._primsPerFrame;
    stats.triangles = prims[pc.PRIMITIVE_TRIANGLES] / 3 + Math.max(prims[pc.PRIMITIVE_TRISTRIP] - 2, 0) + Math.max(prims[pc.PRIMITIVE_TRIFAN] - 2, 0);
    stats.cullTime = this.renderer._cullTime;
    stats.sortTime = this.renderer._sortTime;
    stats.skinTime = this.renderer._skinTime;
    stats.morphTime = this.renderer._morphTime;
    stats.instancingTime = this.renderer._instancingTime;
    stats.otherPrimitives = 0;
    for (var i = 0; i < prims.length; i++) {
      if (i < pc.PRIMITIVE_TRIANGLES) {
        stats.otherPrimitives += prims[i];
      }
      prims[i] = 0;
    }
    this.renderer._camerasRendered = 0;
    this.renderer._materialSwitches = 0;
    this.renderer._shadowMapUpdates = 0;
    this.graphicsDevice._shaderSwitchesPerFrame = 0;
    this.renderer._cullTime = 0;
    this.renderer._sortTime = 0;
    this.renderer._skinTime = 0;
    this.renderer._morphTime = 0;
    this.renderer._instancingTime = 0;
    this.renderer._shadowMapTime = 0;
    this.renderer._depthMapTime = 0;
    this.renderer._forwardTime = 0;
    stats = this.stats.drawCalls;
    stats.forward = this.renderer._forwardDrawCalls;
    stats.culled = this.renderer._numDrawCallsCulled;
    stats.depth = 0;
    stats.shadow = this.renderer._shadowDrawCalls;
    stats.skinned = this.renderer._skinDrawCalls;
    stats.immediate = 0;
    stats.instanced = 0;
    stats.removedByInstancing = 0;
    stats.total = this.graphicsDevice._drawCallsPerFrame;
    stats.misc = stats.total - (stats.forward + stats.shadow);
    this.renderer._depthDrawCalls = 0;
    this.renderer._shadowDrawCalls = 0;
    this.renderer._forwardDrawCalls = 0;
    this.renderer._numDrawCallsCulled = 0;
    this.renderer._skinDrawCalls = 0;
    this.renderer._immediateRendered = 0;
    this.renderer._instancedDrawCalls = 0;
    this.renderer._removedByInstancing = 0;
    this.graphicsDevice._drawCallsPerFrame = 0;
    this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;
    stats = this.stats.particles;
    stats.updatesPerFrame = stats._updatesPerFrame;
    stats.frameTime = stats._frameTime;
    stats._updatesPerFrame = 0;
    stats._frameTime = 0;
  }, setCanvasFillMode:function(mode, width, height) {
    this._fillMode = mode;
    this.resizeCanvas(width, height);
  }, setCanvasResolution:function(mode, width, height) {
    this._resolutionMode = mode;
    if (mode === pc.RESOLUTION_AUTO && width === undefined) {
      width = this.graphicsDevice.canvas.clientWidth;
      height = this.graphicsDevice.canvas.clientHeight;
    }
    this.graphicsDevice.resizeCanvas(width, height);
  }, isFullscreen:function() {
    return !!document.fullscreenElement;
  }, enableFullscreen:function(element, success, error) {
    element = element || this.graphicsDevice.canvas;
    var s = function() {
      success();
      document.removeEventListener("fullscreenchange", s);
    };
    var e = function() {
      error();
      document.removeEventListener("fullscreenerror", e);
    };
    if (success) {
      document.addEventListener("fullscreenchange", s, false);
    }
    if (error) {
      document.addEventListener("fullscreenerror", e, false);
    }
    if (element.requestFullscreen) {
      element.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    } else {
      error();
    }
  }, disableFullscreen:function(success) {
    var s = function() {
      success();
      document.removeEventListener("fullscreenchange", s);
    };
    if (success) {
      document.addEventListener("fullscreenchange", s, false);
    }
    document.exitFullscreen();
  }, isHidden:function() {
    return document[this._hiddenAttr];
  }, onVisibilityChange:function() {
  }, resizeCanvas:function(width, height) {
    if (!this._allowResize) {
      return;
    }
    var windowWidth = window.innerWidth;
    var windowHeight = window.innerHeight;
    if (navigator.isCocoonJS) {
      width = windowWidth;
      height = windowHeight;
      this.graphicsDevice.resizeCanvas(width, height);
    } else {
      if (this._fillMode === pc.FILLMODE_KEEP_ASPECT) {
        var r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
        var winR = windowWidth / windowHeight;
        if (r > winR) {
          width = windowWidth;
          height = width / r;
        } else {
          height = windowHeight;
          width = height * r;
        }
      } else {
        if (this._fillMode === pc.FILLMODE_FILL_WINDOW) {
          width = windowWidth;
          height = windowHeight;
        } else {
        }
      }
      this.graphicsDevice.canvas.style.width = width + "px";
      this.graphicsDevice.canvas.style.height = height + "px";
      if (this._resolutionMode === pc.RESOLUTION_AUTO) {
        this.setCanvasResolution(pc.RESOLUTION_AUTO);
      }
    }
    return {width:width, height:height};
  }, onLibrariesLoaded:function() {
    this._librariesLoaded = true;
  }, applySceneSettings:function(settings) {
    var asset;
    if (this.systems.rigidbody && typeof Ammo !== "undefined") {
      var gravity = settings.physics.gravity;
      this.systems.rigidbody.setGravity(gravity[0], gravity[1], gravity[2]);
    }
    this.scene.applySettings(settings);
    if (settings.render.hasOwnProperty("skybox")) {
      if (settings.render.skybox) {
        asset = this.assets.get(settings.render.skybox);
        if (asset) {
          this.setSkybox(asset);
        } else {
          this.assets.once("add:" + settings.render.skybox, this.setSkybox, this);
        }
      } else {
        this.setSkybox(null);
      }
    }
  }, setSkybox:function(asset) {
    if (asset) {
      if (this._skyboxLast === asset.id) {
        if (this.scene.skyboxMip === 0 && !asset.loadFaces) {
          this._skyboxLoad(asset);
        } else {
          this._onSkyboxChange(asset);
        }
        return;
      }
      if (this._skyboxLast) {
        this.assets.off("add:" + this._skyboxLast, this.setSkybox, this);
        this.assets.off("load:" + this._skyboxLast, this._onSkyboxChange, this);
        this.assets.off("remove:" + this._skyboxLast, this._skyboxRemove, this);
      }
      this._skyboxLast = asset.id;
      this.assets.on("load:" + asset.id, this._onSkyboxChange, this);
      this.assets.once("remove:" + asset.id, this._skyboxRemove, this);
      if (asset.resource) {
        this.scene.setSkybox(asset.resources);
      }
      this._skyboxLoad(asset);
    } else {
      if (!this._skyboxLast) {
        return;
      }
      this._skyboxRemove({id:this._skyboxLast});
    }
  }, _onVrChange:function(enabled) {
    if (enabled) {
      if (!this.vr) {
        this.vr = new pc.VrManager(this);
      }
    } else {
      if (this.vr) {
        this.vr.destroy();
        this.vr = null;
      }
    }
  }, _onSkyboxChange:function(asset) {
    this.scene.setSkybox(asset.resources);
  }, _skyboxLoad:function(asset) {
    if (this.scene.skyboxMip === 0) {
      asset.loadFaces = true;
    }
    this.assets.load(asset);
    this._onSkyboxChange(asset);
  }, _skyboxRemove:function(asset) {
    if (!this._skyboxLast) {
      return;
    }
    this.assets.off("add:" + asset.id, this.setSkybox, this);
    this.assets.off("load:" + asset.id, this._onSkyboxChange, this);
    this.assets.off("remove:" + asset.id, this._skyboxRemove, this);
    this.scene.setSkybox(null);
    this._skyboxLast = null;
  }, _firstBake:function() {
    this.lightmapper.bake(null, this.scene.lightmapMode);
  }, _firstBatch:function() {
    if (this.scene._needsStaticPrepare) {
      this.renderer.prepareStaticMeshes(this.graphicsDevice, this.scene);
      this.scene._needsStaticPrepare = false;
    }
    this.batcher.generate();
  }, destroy:function() {
    var i, l;
    var canvasId = this.graphicsDevice.canvas.id;
    this.off("librariesloaded");
    document.removeEventListener("visibilitychange", this._visibilityChangeHandler, false);
    document.removeEventListener("mozvisibilitychange", this._visibilityChangeHandler, false);
    document.removeEventListener("msvisibilitychange", this._visibilityChangeHandler, false);
    document.removeEventListener("webkitvisibilitychange", this._visibilityChangeHandler, false);
    this._visibilityChangeHandler = null;
    this.onVisibilityChange = null;
    this.root.destroy();
    this.root = null;
    if (this.mouse) {
      this.mouse.off();
      this.mouse.detach();
      this.mouse = null;
    }
    if (this.keyboard) {
      this.keyboard.off();
      this.keyboard.detach();
      this.keyboard = null;
    }
    if (this.touch) {
      this.touch.off();
      this.touch.detach();
      this.touch = null;
    }
    if (this.elementInput) {
      this.elementInput.detach();
      this.elementInput = null;
    }
    if (this.controller) {
      this.controller = null;
    }
    var systems = this.systems.list;
    for (i = 0, l = systems.length; i < l; i++) {
      systems[i].destroy();
    }
    pc.ComponentSystem.destroy();
    var assets = this.assets.list();
    for (i = 0; i < assets.length; i++) {
      assets[i].unload();
      assets[i].off();
    }
    this.assets.off();
    this.bundles.destroy();
    this.bundles = null;
    this.i18n.destroy();
    this.i18n = null;
    for (var key in this.loader.getHandler("script")._cache) {
      var element = this.loader.getHandler("script")._cache[key];
      var parent = element.parentNode;
      if (parent) {
        parent.removeChild(element);
      }
    }
    this.loader.getHandler("script")._cache = {};
    this.loader.destroy();
    this.loader = null;
    this.scene.destroy();
    this.scene = null;
    this.systems = [];
    this.context = null;
    this.scripts.destroy();
    this.scripts = null;
    this._sceneRegistry.destroy();
    this._sceneRegistry = null;
    this.lightmapper.destroy();
    this.lightmapper = null;
    this.batcher.destroyManager();
    this.batcher = null;
    this._entityIndex = {};
    this.defaultLayerDepth.onPreRenderOpaque = null;
    this.defaultLayerDepth.onPostRenderOpaque = null;
    this.defaultLayerDepth.onDisable = null;
    this.defaultLayerDepth.onEnable = null;
    this.defaultLayerDepth = null;
    this.defaultLayerWorld = null;
    pc.destroyPostEffectQuad();
    this.graphicsDevice.destroy();
    this.graphicsDevice = null;
    this.renderer = null;
    this.tick = null;
    this.off();
    pc.http = new pc.Http;
    pc.script.app = null;
    pc.ParticleEmitter.DEFAULT_PARAM_TEXTURE = null;
    Application._applications[canvasId] = null;
    if (Application._currentApplication === this) {
      Application._currentApplication = null;
    }
  }});
  var _frameEndData = {};
  var makeTick = function(_app) {
    var app = _app;
    return function(timestamp) {
      if (!app.graphicsDevice) {
        return;
      }
      Application._currentApplication = app;
      pc.app = app;
      var now = timestamp || pc.now();
      var ms = now - (app._time || now);
      var dt = ms / 1000.0;
      dt = pc.math.clamp(dt, 0, app.maxDeltaTime);
      dt *= app.timeScale;
      app._time = now;
      if (app.vr && app.vr.display) {
        app.vr.display.requestAnimationFrame(app.tick);
      } else {
        window.requestAnimationFrame(app.tick);
      }
      if (app.graphicsDevice.contextLost) {
        return;
      }
      app.update(dt);
      if (app.autoRender || app.renderNextFrame) {
        app.render();
        app.renderNextFrame = false;
      }
      _frameEndData.timestamp = pc.now();
      _frameEndData.target = app;
      app.fire("frameend", _frameEndData);
      app.fire("frameEnd", _frameEndData);
      if (app.vr && app.vr.display && app.vr.display.presenting) {
        app.vr.display.submitFrame();
      }
    };
  };
  return {FILLMODE_NONE:"NONE", FILLMODE_FILL_WINDOW:"FILL_WINDOW", FILLMODE_KEEP_ASPECT:"KEEP_ASPECT", RESOLUTION_AUTO:"AUTO", RESOLUTION_FIXED:"FIXED", Application:Application};
}());
pc.ApplicationStats = function(device) {
  this.frame = {fps:0, ms:0, dt:0, updateStart:0, updateTime:0, renderStart:0, renderTime:0, physicsStart:0, physicsTime:0, cullTime:0, sortTime:0, skinTime:0, morphTime:0, instancingTime:0, triangles:0, otherPrimitives:0, shaders:0, materials:0, cameras:0, shadowMapUpdates:0, shadowMapTime:0, depthMapTime:0, forwardTime:0, _timeToCountFrames:0, _fpsAccum:0};
  this.drawCalls = {forward:0, depth:0, shadow:0, immediate:0, misc:0, total:0, skinned:0, instanced:0, removedByInstancing:0};
  this.misc = {renderTargetCreationTime:0};
  this.particles = {updatesPerFrame:0, _updatesPerFrame:0, frameTime:0, _frameTime:0};
  this.vram = device._vram;
  this.shaders = device._shaderStats;
  Object.defineProperty(this.vram, "totalUsed", {get:function() {
    return this.tex + this.vb + this.ib;
  }});
  Object.defineProperty(this, "scene", {get:function() {
    return pc.Application._currentApplication.scene._stats;
  }});
  Object.defineProperty(this, "lightmapper", {get:function() {
    return pc.Application._currentApplication.lightmapper._stats;
  }});
  Object.defineProperty(this, "batcher", {get:function() {
    return pc.Application._currentApplication.batcher._stats;
  }});
  pc.events.attach(this);
};
Object.assign(pc, function() {
  var SceneRegistryItem = function(name, url) {
    this.name = name;
    this.url = url;
  };
  var SceneRegistry = function(app) {
    this._app = app;
    this._list = [];
    this._index = {};
    this._urlIndex = {};
  };
  SceneRegistry.prototype.destroy = function() {
    this._app = null;
  };
  SceneRegistry.prototype.list = function() {
    return this._list;
  };
  SceneRegistry.prototype.add = function(name, url) {
    if (this._index.hasOwnProperty(name)) {
      return false;
    }
    var item = new pc.SceneRegistryItem(name, url);
    var i = this._list.push(item);
    this._index[item.name] = i - 1;
    this._urlIndex[item.url] = i - 1;
    return true;
  };
  SceneRegistry.prototype.find = function(name) {
    if (this._index.hasOwnProperty(name)) {
      return this._list[this._index[name]];
    }
    return null;
  };
  SceneRegistry.prototype.findByUrl = function(url) {
    if (this._urlIndex.hasOwnProperty(url)) {
      return this._list[this._urlIndex[url]];
    }
    return null;
  };
  SceneRegistry.prototype.remove = function(name) {
    if (this._index.hasOwnProperty(name)) {
      var i = this._index[name];
      var item = this._list[i];
      delete this._urlIndex[item.url];
      delete this._index[name];
      this._list.splice(i, 1);
      for (i = 0; i < this._list.length; i++) {
        item = this._list[i];
        this._index[item.name] = i;
        this._urlIndex[item.url] = i;
      }
    }
  };
  SceneRegistry.prototype.loadSceneHierarchy = function(url, callback) {
    var self = this;
    var handler = this._app.loader.getHandler("hierarchy");
    if (this._app.assets && this._app.assets.prefix && !pc.ABSOLUTE_URL.test(url)) {
      url = pc.path.join(this._app.assets.prefix, url);
    }
    handler.load(url, function(err, data) {
      if (err) {
        if (callback) {
          callback(err);
        }
        return;
      }
      var _loaded = function() {
        self._app.systems.script.preloading = true;
        var entity = handler.open(url, data);
        self._app.systems.script.preloading = false;
        self._app.loader.clearCache(url, "hierarchy");
        self._app.root.addChild(entity);
        pc.ComponentSystem.initialize(entity);
        pc.ComponentSystem.postInitialize(entity);
        if (callback) {
          callback(err, entity);
        }
      };
      self._app._preloadScripts(data, _loaded);
    });
  };
  SceneRegistry.prototype.loadSceneSettings = function(url, callback) {
    var self = this;
    if (this._app.assets && this._app.assets.prefix && !pc.ABSOLUTE_URL.test(url)) {
      url = pc.path.join(this._app.assets.prefix, url);
    }
    this._app.loader.load(url, "scenesettings", function(err, settings) {
      if (!err) {
        self._app.applySceneSettings(settings);
        if (callback) {
          callback(null);
        }
      } else {
        if (callback) {
          callback(err);
        }
      }
    });
  };
  SceneRegistry.prototype.loadScene = function(url, callback) {
    var self = this;
    var handler = this._app.loader.getHandler("scene");
    var data = url;
    var _loaded = function() {
      self._app.systems.script.preloading = true;
      var scene = handler.open(url, data);
      self._app.systems.script.preloading = false;
      self._app.loader.clearCache(url, "scene");
      self._app.loader.patch({resource:scene, type:"scene"}, self._app.assets);
      self._app.root.addChild(scene.root);
      if (self._app.systems.rigidbody && typeof Ammo !== "undefined") {
        self._app.systems.rigidbody.setGravity(scene._gravity.x, scene._gravity.y, scene._gravity.z);
      }
      if (callback) {
        callback(null, scene);
      }
    };
    self._app._preloadScripts(data, _loaded);
  };
  return {SceneRegistry:SceneRegistry, SceneRegistryItem:SceneRegistryItem};
}());
Object.assign(pc, function() {
  var ComponentSystemRegistry = function() {
    this.list = [];
  };
  Object.assign(ComponentSystemRegistry.prototype, {add:function(system) {
    var id = system.id;
    if (this[id]) {
      throw new Error(pc.string.format("ComponentSystem name '{0}' already registered or not allowed", id));
    }
    this[id] = system;
    this.list.push(system);
  }, remove:function(system) {
    var id = system.id;
    if (!this[id]) {
      throw new Error(pc.string.format("No ComponentSystem named '{0}' registered", id));
    }
    delete this[id];
    var index = this.list.indexOf(this[id]);
    if (index !== -1) {
      this.list.splice(index, 1);
    }
  }});
  return {ComponentSystemRegistry:ComponentSystemRegistry};
}());
Object.assign(pc, function() {
  var ComponentSystem = function(app) {
    this.app = app;
    this.store = {};
    this.schema = [];
    pc.events.attach(this);
  };
  Object.assign(ComponentSystem, {_helper:function(a, p) {
    for (var i = 0, l = a.length; i < l; i++) {
      a[i].f.call(a[i].s, p);
    }
  }, initialize:function(root) {
    this._helper(this._init, root);
  }, postInitialize:function(root) {
    this._helper(this._postInit, root);
    this.fire("postinitialize", root);
  }, update:function(dt, inTools) {
    this._helper(inTools ? this._toolsUpdate : this._update, dt);
  }, fixedUpdate:function(dt, inTools) {
    this._helper(this._fixedUpdate, dt);
  }, postUpdate:function(dt, inTools) {
    this._helper(this._postUpdate, dt);
  }, _init:[], _postInit:[], _toolsUpdate:[], _update:[], _fixedUpdate:[], _postUpdate:[], bind:function(event, func, scope) {
    switch(event) {
      case "initialize":
        this._init.push({f:func, s:scope});
        break;
      case "postInitialize":
        this._postInit.push({f:func, s:scope});
        break;
      case "update":
        this._update.push({f:func, s:scope});
        break;
      case "postUpdate":
        this._postUpdate.push({f:func, s:scope});
        break;
      case "fixedUpdate":
        this._fixedUpdate.push({f:func, s:scope});
        break;
      case "toolsUpdate":
        this._toolsUpdate.push({f:func, s:scope});
        break;
      default:
        console.error("Component System does not support event", event);
    }
  }, _erase:function(a, f, s) {
    for (var i = 0; i < a.length; i++) {
      if (a[i].f === f && a[i].s === s) {
        a.splice(i--, 1);
      }
    }
  }, unbind:function(event, func, scope) {
    switch(event) {
      case "initialize":
        this._erase(this._init, func, scope);
        break;
      case "postInitialize":
        this._erase(this._postInit, func, scope);
        break;
      case "update":
        this._erase(this._update, func, scope);
        break;
      case "postUpdate":
        this._erase(this._postUpdate, func, scope);
        break;
      case "fixedUpdate":
        this._erase(this._fixedUpdate, func, scope);
        break;
      case "toolsUpdate":
        this._erase(this._toolsUpdate, func, scope);
        break;
      default:
        console.error("Component System does not support event", event);
    }
  }});
  ComponentSystem.prototype = {addComponent:function(entity, data) {
    var component = new this.ComponentType(this, entity);
    var componentData = new this.DataType;
    data = data || {};
    this.store[entity.getGuid()] = {entity:entity, data:componentData};
    entity[this.id] = component;
    entity.c[this.id] = component;
    this.initializeComponentData(component, data, []);
    this.fire("add", entity, component);
    return component;
  }, removeComponent:function(entity) {
    var record = this.store[entity.getGuid()];
    var component = entity.c[this.id];
    this.fire("beforeremove", entity, component);
    delete this.store[entity.getGuid()];
    delete entity[this.id];
    delete entity.c[this.id];
    this.fire("remove", entity, record.data);
  }, cloneComponent:function(entity, clone) {
    var src = this.store[entity.getGuid()];
    return this.addComponent(clone, src.data);
  }, initializeComponentData:function(component, data, properties) {
    data = data || {};
    var descriptor;
    var name, type, value;
    for (var i = 0, len = properties.length; i < len; i++) {
      descriptor = properties[i];
      if (typeof descriptor === "object") {
        name = descriptor.name;
        type = descriptor.type;
      } else {
        name = descriptor;
        type = undefined;
      }
      value = data[name];
      if (value !== undefined) {
        if (type !== undefined) {
          value = convertValue(value, type);
        }
        component[name] = value;
      } else {
        component[name] = component.data[name];
      }
    }
    if (component.enabled && component.entity.enabled) {
      component.onEnable();
    }
  }, getPropertiesOfType:function(type) {
    var matchingProperties = [];
    var schema = this.schema || [];
    schema.forEach(function(descriptor) {
      if (descriptor && typeof descriptor === "object" && descriptor.type === type) {
        matchingProperties.push(descriptor);
      }
    });
    return matchingProperties;
  }, destroy:function() {
    this.off();
  }};
  function convertValue(value, type) {
    if (!value) {
      return value;
    }
    switch(type) {
      case "rgb":
        if (value instanceof pc.Color) {
          return value.clone();
        }
        return new pc.Color(value[0], value[1], value[2]);
      case "rgba":
        if (value instanceof pc.Color) {
          return value.clone();
        }
        return new pc.Color(value[0], value[1], value[2], value[3]);
      case "vec2":
        if (value instanceof pc.Vec2) {
          return value.clone();
        }
        return new pc.Vec2(value[0], value[1]);
      case "vec3":
        if (value instanceof pc.Vec3) {
          return value.clone();
        }
        return new pc.Vec3(value[0], value[1], value[2]);
      case "vec4":
        if (value instanceof pc.Vec4) {
          return value.clone();
        }
        return new pc.Vec4(value[0], value[1], value[2], value[3]);
      case "boolean":
      case "number":
      case "string":
        return value;
      case "entity":
        return value;
      default:
        throw new Error("Could not convert unhandled type: " + type);
    }
  }
  pc.events.attach(ComponentSystem);
  ComponentSystem.destroy = function() {
    ComponentSystem.off("initialize");
    ComponentSystem.off("postInitialize");
    ComponentSystem.off("toolsUpdate");
    ComponentSystem.off("update");
    ComponentSystem.off("fixedUpdate");
    ComponentSystem.off("postUpdate");
  };
  return {ComponentSystem:ComponentSystem};
}());
Object.assign(pc, function() {
  var Component = function(system, entity) {
    this.system = system;
    this.entity = entity;
    pc.events.attach(this);
    if (this.system.schema && !this._accessorsBuilt) {
      this.buildAccessors(this.system.schema);
    }
    this.on("set", function(name, oldValue, newValue) {
      this.fire("set_" + name, name, oldValue, newValue);
    });
    this.on("set_enabled", this.onSetEnabled, this);
  };
  Component._buildAccessors = function(obj, schema) {
    schema.forEach(function(descriptor) {
      var name = typeof descriptor === "object" ? descriptor.name : descriptor;
      Object.defineProperty(obj, name, {get:function() {
        return this.data[name];
      }, set:function(value) {
        var data = this.data;
        var oldValue = data[name];
        data[name] = value;
        this.fire("set", name, oldValue, value);
      }, configurable:true});
    });
    obj._accessorsBuilt = true;
  };
  Component.prototype = {buildAccessors:function(schema) {
    Component._buildAccessors(this, schema);
  }, onSetEnabled:function(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      if (this.entity.enabled) {
        if (newValue) {
          this.onEnable();
        } else {
          this.onDisable();
        }
      }
    }
  }, onEnable:function() {
  }, onDisable:function() {
  }, onPostStateChange:function() {
  }};
  Object.defineProperty(Component.prototype, "data", {get:function() {
    var record = this.system.store[this.entity.getGuid()];
    return record ? record.data : null;
  }});
  return {Component:Component};
}());
Object.assign(pc, function() {
  var ComponentData = function() {
  };
  return {ComponentData:ComponentData};
}());
Object.assign(pc, function() {
  var CameraComponent = function CameraComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this.on("set_aspectRatioMode", this.onSetAspectRatioMode, this);
    this.on("set_aspectRatio", this.onSetAspectRatio, this);
    this.on("set_camera", this.onSetCamera, this);
    this.on("set_clearColor", this.onSetClearColor, this);
    this.on("set_fov", this.onSetFov, this);
    this.on("set_orthoHeight", this.onSetOrthoHeight, this);
    this.on("set_nearClip", this.onSetNearClip, this);
    this.on("set_farClip", this.onSetFarClip, this);
    this.on("set_projection", this.onSetProjection, this);
    this.on("set_priority", this.onSetPriority, this);
    this.on("set_clearColorBuffer", this.updateClearFlags, this);
    this.on("set_clearDepthBuffer", this.updateClearFlags, this);
    this.on("set_clearStencilBuffer", this.updateClearFlags, this);
    this.on("set_renderTarget", this.onSetRenderTarget, this);
    this.on("set_rect", this.onSetRect, this);
    this.on("set_scissorRect", this.onSetScissorRect, this);
    this.on("set_horizontalFov", this.onSetHorizontalFov, this);
    this.on("set_frustumCulling", this.onSetFrustumCulling, this);
    this.on("set_calculateTransform", this.onSetCalculateTransform, this);
    this.on("set_calculateProjection", this.onSetCalculateProjection, this);
    this.on("set_cullFaces", this.onSetCullFaces, this);
    this.on("set_flipFaces", this.onSetFlipFaces, this);
    this.on("set_layers", this.onSetLayers, this);
  };
  CameraComponent.prototype = Object.create(pc.Component.prototype);
  CameraComponent.prototype.constructor = CameraComponent;
  Object.defineProperty(CameraComponent.prototype, "projectionMatrix", {get:function() {
    return this.data.camera.getProjectionMatrix();
  }});
  Object.defineProperty(CameraComponent.prototype, "viewMatrix", {get:function() {
    return this.data.camera.getViewMatrix();
  }});
  Object.defineProperty(CameraComponent.prototype, "frustum", {get:function() {
    return this.data.camera.frustum;
  }});
  Object.defineProperty(CameraComponent.prototype, "vrDisplay", {get:function() {
    return this.data.camera.vrDisplay;
  }, set:function(value) {
    this.data.camera.vrDisplay = value;
    if (value) {
      value._camera = this.data.camera;
    }
  }});
  Object.defineProperty(CameraComponent.prototype, "node", {get:function() {
    return this.data.camera._node;
  }});
  Object.assign(CameraComponent.prototype, {screenToWorld:function(screenx, screeny, cameraz, worldCoord) {
    var device = this.system.app.graphicsDevice;
    return this.data.camera.screenToWorld(screenx, screeny, cameraz, device.clientRect.width, device.clientRect.height, worldCoord);
  }, onPrerender:function() {
    this.data.camera._viewMatDirty = true;
    this.data.camera._viewProjMatDirty = true;
  }, worldToScreen:function(worldCoord, screenCoord) {
    var device = this.system.app.graphicsDevice;
    return this.data.camera.worldToScreen(worldCoord, device.clientRect.width, device.clientRect.height, screenCoord);
  }, onSetAspectRatioMode:function(name, oldValue, newValue) {
    this.data.camera.aspectRatioMode = newValue;
  }, onSetAspectRatio:function(name, oldValue, newValue) {
    this.data.camera.aspectRatio = newValue;
  }, onSetCamera:function(name, oldValue, newValue) {
    if (oldValue) {
      oldValue._node = null;
    }
    newValue._node = this.entity;
  }, onSetClearColor:function(name, oldValue, newValue) {
    var clearColor = this.data.camera.clearColor;
    clearColor[0] = newValue.r;
    clearColor[1] = newValue.g;
    clearColor[2] = newValue.b;
    clearColor[3] = newValue.a;
  }, onSetFov:function(name, oldValue, newValue) {
    this.data.camera.fov = newValue;
  }, onSetOrthoHeight:function(name, oldValue, newValue) {
    this.data.camera.orthoHeight = newValue;
  }, onSetNearClip:function(name, oldValue, newValue) {
    this.data.camera.nearClip = newValue;
  }, onSetFarClip:function(name, oldValue, newValue) {
    this.data.camera.farClip = newValue;
  }, onSetHorizontalFov:function(name, oldValue, newValue) {
    this.data.camera.horizontalFov = newValue;
  }, onSetFrustumCulling:function(name, oldValue, newValue) {
    this.data.camera.frustumCulling = newValue;
  }, onSetCalculateTransform:function(name, oldValue, newValue) {
    this._calculateTransform = newValue;
    this.camera.overrideCalculateTransform = !!newValue;
  }, onSetCalculateProjection:function(name, oldValue, newValue) {
    this._calculateProjection = newValue;
    this.camera._projMatDirty = true;
    this.camera.overrideCalculateProjection = !!newValue;
  }, onSetCullFaces:function(name, oldValue, newValue) {
    this.camera._cullFaces = newValue;
  }, onSetFlipFaces:function(name, oldValue, newValue) {
    this.camera._flipFaces = newValue;
  }, onSetProjection:function(name, oldValue, newValue) {
    this.data.camera.projection = newValue;
  }, onSetPriority:function(name, oldValue, newValue) {
    var layer;
    for (var i = 0; i < this.layers.length; i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer._sortCameras();
    }
  }, onSetLayers:function(name, oldValue, newValue) {
    var i, layer;
    for (i = 0; i < oldValue.length; i++) {
      layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
      if (!layer) {
        continue;
      }
      layer.removeCamera(this);
    }
    if (!this.enabled || !this.entity.enabled) {
      return;
    }
    for (i = 0; i < newValue.length; i++) {
      layer = this.system.app.scene.layers.getLayerById(newValue[i]);
      if (!layer) {
        continue;
      }
      layer.addCamera(this);
    }
  }, addCameraToLayers:function() {
    var layer;
    for (var i = 0; i < this.layers.length; i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.addCamera(this);
    }
  }, removeCameraFromLayers:function() {
    var layer;
    for (var i = 0; i < this.layers.length; i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.removeCamera(this);
    }
  }, onLayersChanged:function(oldComp, newComp) {
    this.addCameraToLayers();
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
  }, onLayerAdded:function(layer) {
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    layer.addCamera(this);
  }, onLayerRemoved:function(layer) {
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    layer.removeCamera(this);
  }, updateClearFlags:function() {
    var flags = 0;
    if (this.clearColorBuffer) {
      flags |= pc.CLEARFLAG_COLOR;
    }
    if (this.clearDepthBuffer) {
      flags |= pc.CLEARFLAG_DEPTH;
    }
    if (this.clearStencilBuffer) {
      flags |= pc.CLEARFLAG_STENCIL;
    }
    this.data.camera.clearFlags = flags;
  }, onSetRenderTarget:function(name, oldValue, newValue) {
    this.data.camera.renderTarget = newValue;
  }, onSetRect:function(name, oldValue, newValue) {
    this.data.camera.setRect(newValue.x, newValue.y, newValue.z, newValue.w);
  }, onSetScissorRect:function(name, oldValue, newValue) {
    this.data.camera.setScissorRect(newValue.x, newValue.y, newValue.z, newValue.w);
  }, onEnable:function() {
    this.system.addCamera(this);
    this.system.app.scene.on("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.on("add", this.onLayerAdded, this);
      this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
    }
    if (this.enabled && this.entity.enabled) {
      this.addCameraToLayers();
    }
    this.postEffects.enable();
  }, onDisable:function() {
    this.postEffects.disable();
    this.removeCameraFromLayers();
    this.system.app.scene.off("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.off("add", this.onLayerAdded, this);
      this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
    }
    this.system.removeCamera(this);
  }, onRemove:function() {
    this.off();
  }, calculateAspectRatio:function(rt) {
    var src = rt ? rt : this.system.app.graphicsDevice;
    var rect = this.rect;
    return src.width * rect.z / (src.height * rect.w);
  }, frameBegin:function(rt) {
    if (this.aspectRatioMode === pc.ASPECT_AUTO) {
      this.aspectRatio = this.calculateAspectRatio(rt);
    }
    this.data.isRendering = true;
  }, frameEnd:function() {
    this.data.isRendering = false;
  }, enterVr:function(display, callback) {
    if (display instanceof Function && !callback) {
      callback = display;
      display = null;
    }
    if (!this.system.app.vr) {
      callback("VrManager not created. Enable VR in project settings.");
      return;
    }
    if (!display) {
      display = this.system.app.vr.display;
    }
    if (display) {
      var self = this;
      if (display.capabilities.canPresent) {
        display.requestPresent(function(err) {
          if (!err) {
            self.vrDisplay = display;
            self.vrDisplay.once("beforepresentchange", function(display) {
              if (!display.presenting) {
                self.vrDisplay = null;
              }
            });
          }
          callback(err);
        });
      } else {
        self.vrDisplay = display;
        callback();
      }
    } else {
      callback("No pc.VrDisplay to present");
    }
  }, exitVr:function(callback) {
    if (this.vrDisplay) {
      if (this.vrDisplay.capabilities.canPresent) {
        var display = this.vrDisplay;
        this.vrDisplay = null;
        display.exitPresent(callback);
      } else {
        this.vrDisplay = null;
        callback();
      }
    } else {
      callback("Not presenting VR");
    }
  }});
  return {CameraComponent:CameraComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled", "clearColorBuffer", "clearColor", "clearDepthBuffer", "clearStencilBuffer", "frustumCulling", "projection", "fov", "orthoHeight", "nearClip", "farClip", "priority", "rect", "scissorRect", "camera", "aspectRatio", "aspectRatioMode", "horizontalFov", "model", "renderTarget", "calculateTransform", "calculateProjection", "cullFaces", "flipFaces", "layers"];
  var CameraComponentSystem = function(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "camera";
    this.description = "Renders the scene from the location of the Entity.";
    this.ComponentType = pc.CameraComponent;
    this.DataType = pc.CameraComponentData;
    this.schema = _schema;
    this.cameras = [];
    this.on("beforeremove", this.onBeforeRemove, this);
    this.on("remove", this.onRemove, this);
    this.app.on("prerender", this.onPrerender, this);
    pc.ComponentSystem.bind("update", this.onUpdate, this);
  };
  CameraComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  CameraComponentSystem.prototype.constructor = CameraComponentSystem;
  pc.Component._buildAccessors(pc.CameraComponent.prototype, _schema);
  Object.assign(CameraComponentSystem.prototype, {initializeComponentData:function(component, _data, properties) {
    properties = ["postEffects", "enabled", "model", "camera", "aspectRatio", "aspectRatioMode", "horizontalFov", "renderTarget", "clearColor", "fov", "orthoHeight", "nearClip", "farClip", "projection", "priority", "clearColorBuffer", "clearDepthBuffer", "clearStencilBuffer", "frustumCulling", "rect", "scissorRect", "calculateTransform", "calculateProjection", "cullFaces", "flipFaces", "layers"];
    var data = {};
    for (var i = 0, len = properties.length; i < len; i++) {
      var property = properties[i];
      data[property] = _data[property];
    }
    if (data.layers && pc.type(data.layers) === "array") {
      data.layers = data.layers.slice(0);
    }
    if (data.clearColor && pc.type(data.clearColor) === "array") {
      var c = data.clearColor;
      data.clearColor = new pc.Color(c[0], c[1], c[2], c[3]);
    }
    if (data.rect && pc.type(data.rect) === "array") {
      var rect = data.rect;
      data.rect = new pc.Vec4(rect[0], rect[1], rect[2], rect[3]);
    }
    if (data.scissorRect && pc.type(data.scissorRect) === "array") {
      var scissorRect = data.scissorRect;
      data.scissorRect = new pc.Vec4(scissorRect[0], scissorRect[1], scissorRect[2], scissorRect[3]);
    }
    if (data.activate) {
      console.warn("WARNING: activate: Property is deprecated. Set enabled property instead.");
      data.enabled = data.activate;
    }
    data.camera = new pc.Camera;
    data._node = component.entity;
    data.camera._component = component;
    var self = component;
    data.camera.calculateTransform = function(mat, mode) {
      if (!self._calculateTransform) {
        return null;
      }
      return self._calculateTransform(mat, mode);
    };
    data.camera.calculateProjection = function(mat, mode) {
      if (!self._calculateProjection) {
        return null;
      }
      return self._calculateProjection(mat, mode);
    };
    data.postEffects = new pc.PostEffectQueue(this.app, component);
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, onBeforeRemove:function(entity, component) {
    this.removeCamera(component);
    component.onRemove();
  }, onRemove:function(entity, data) {
    data.camera = null;
  }, onUpdate:function(dt) {
    var components = this.store;
    var component, componentData, cam, vrDisplay;
    if (this.app.vr) {
      for (var id in components) {
        component = components[id];
        componentData = component.data;
        cam = componentData.camera;
        vrDisplay = cam.vrDisplay;
        if (componentData.enabled && component.entity.enabled && vrDisplay) {
          vrDisplay.setClipPlanes(cam._nearClip, cam._farClip);
          if (cam._node) {
            cam._node.localTransform.copy(vrDisplay.combinedViewInv);
            cam._node._dirtyLocal = false;
            cam._node._dirtifyWorld();
          }
        }
      }
    }
  }, onPrerender:function() {
    for (var i = 0, len = this.cameras.length; i < len; i++) {
      this.cameras[i].onPrerender();
    }
  }, addCamera:function(camera) {
    this.cameras.push(camera);
    this.sortCamerasByPriority();
  }, removeCamera:function(camera) {
    var index = this.cameras.indexOf(camera);
    if (index >= 0) {
      this.cameras.splice(index, 1);
      this.sortCamerasByPriority();
    }
  }, sortCamerasByPriority:function() {
    this.cameras.sort(function(a, b) {
      return a.priority - b.priority;
    });
  }});
  return {CameraComponentSystem:CameraComponentSystem};
}());
Object.assign(pc, function() {
  var CameraComponentData = function() {
    this.clearColor = new pc.Color(0.722, 0.722, 0.722, 1);
    this.clearColorBuffer = true;
    this.clearDepthBuffer = true;
    this.clearStencilBuffer = true;
    this.nearClip = 0.1;
    this.farClip = 1000;
    this.fov = 45;
    this.orthoHeight = 100;
    this.projection = pc.PROJECTION_PERSPECTIVE;
    this.priority = 0;
    this.rect = new pc.Vec4(0, 0, 1, 1);
    this.scissorRect = new pc.Vec4(0, 0, 1, 1);
    this.enabled = true;
    this.frustumCulling = false;
    this.cullFaces = true;
    this.flipFaces = false;
    this.layers = [pc.LAYERID_WORLD, pc.LAYERID_DEPTH, pc.LAYERID_SKYBOX, pc.LAYERID_UI, pc.LAYERID_IMMEDIATE];
    this.camera = null;
    this.aspectRatio = 16 / 9;
    this.aspectRatioMode = pc.ASPECT_AUTO;
    this.renderTarget = null;
    this.postEffects = null;
    this.isRendering = false;
    this.calculateTransform = null;
    this.calculateProjection = null;
  };
  return {CameraComponentData:CameraComponentData};
}());
Object.assign(pc, function() {
  var depthLayer;
  function PostEffectQueue(app, camera) {
    var self = this;
    this.app = app;
    this.camera = camera;
    this.effects = [];
    this.enabled = false;
    this.depthTarget = null;
    this.renderTargetScale = 1;
    this.resizeTimeout = null;
    this.resizeLast = 0;
    this._resizeTimeoutCallback = function() {
      self.resizeRenderTargets();
    };
    camera.on("set_rect", this.onCameraRectChanged, this);
    this._origOverrideClear = false;
    this._origClearColorBuffer = false;
    this._origDepthColorBuffer = false;
    this._origStencilColorBuffer = false;
  }
  Object.assign(PostEffectQueue.prototype, {_createOffscreenTarget:function(useDepth, hdr) {
    var rect = this.camera.rect;
    var width = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
    var height = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);
    var device = this.app.graphicsDevice;
    var format = hdr ? device.getHdrFormat() : pc.PIXELFORMAT_R8_G8_B8_A8;
    var useStencil = this.app.graphicsDevice.supportsStencil;
    var colorBuffer = new pc.Texture(device, {format:format, width:width, height:height});
    colorBuffer.name = "posteffect #" + this.effects.length;
    colorBuffer.minFilter = pc.FILTER_NEAREST;
    colorBuffer.magFilter = pc.FILTER_NEAREST;
    colorBuffer.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
    colorBuffer.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
    return new pc.RenderTarget(this.app.graphicsDevice, colorBuffer, {depth:useDepth, stencil:useStencil});
  }, _resizeOffscreenTarget:function(rt) {
    var rect = this.camera.rect;
    var width = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
    var height = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);
    var device = this.app.graphicsDevice;
    var format = rt.colorBuffer.format;
    rt._colorBuffer.destroy();
    var colorBuffer = new pc.Texture(device, {format:format, width:width, height:height});
    colorBuffer.name = "posteffect";
    colorBuffer.minFilter = pc.FILTER_NEAREST;
    colorBuffer.magFilter = pc.FILTER_NEAREST;
    colorBuffer.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
    colorBuffer.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
    rt._colorBuffer = colorBuffer;
    rt.destroy();
  }, _destroyOffscreenTarget:function(rt) {
    if (rt._colorBuffer) {
      rt._colorBuffer.destroy();
    }
    if (rt._depthBuffer) {
      rt._depthBuffer.destroy();
    }
    rt.destroy();
  }, setRenderTargetScale:function(scale) {
    this.renderTargetScale = scale;
    this.resizeRenderTargets();
  }, addEffect:function(effect) {
    var isFirstEffect = this.effects.length === 0;
    var effects = this.effects;
    var newEntry = {effect:effect, inputTarget:this._createOffscreenTarget(isFirstEffect, effect.hdr), outputTarget:null};
    if (!this.layer) {
      this.layer = new pc.Layer({opaqueSortMode:pc.SORTMODE_NONE, transparentSortMode:pc.SORTMODE_NONE, passThrough:true, name:"PostEffectQueue", renderTarget:this.camera.renderTarget, clear:false, onPostRender:function() {
        for (var i = 0; i < this._commandList.length; i++) {
          this._commandList[i]();
        }
      }});
      var layerList = this.app.scene.layers.layerList;
      var order = 0;
      var i;
      var start = layerList.length - 1;
      for (i = start; i >= 0; i--) {
        if (layerList[i].id === pc.LAYERID_UI) {
          start = i - 1;
          this._origOverrideClear = layerList[i].overrideClear;
          this._origClearColorBuffer = layerList[i].clearColorBuffer;
          this._origDepthColorBuffer = layerList[i].clearDepthBuffer;
          this._origStencilColorBuffer = layerList[i].clearStencilBuffer;
          layerList[i].overrideClear = true;
          layerList[i].clearColorBuffer = false;
          layerList[i].clearDepthBuffer = this.camera.clearDepthBuffer;
          layerList[i].clearStencilBuffer = this.camera.clearStencilBuffer;
          break;
        }
      }
      this._sourceLayers = [];
      for (i = 0; i < this.camera.layers.length; i++) {
        var layerID = this.camera.layers[i];
        var layer = this.app.scene.layers.getLayerById(layerID);
        var index = this.app.scene.layers.layerList.indexOf(layer);
        if (index <= start) {
          if (layerID != pc.LAYERID_DEPTH) {
            layer.renderTarget = newEntry.inputTarget;
            this._sourceLayers.push(layer);
          }
          if (index > order) {
            order = index;
          }
        }
      }
      this.app.scene.layers.insertOpaque(this.layer, order + 1);
      this._sourceTarget = newEntry.inputTarget;
      this.layer._commandList = [];
      this.layer.isPostEffect = true;
    }
    effects.push(newEntry);
    var len = effects.length;
    if (len > 1) {
      effects[len - 2].outputTarget = newEntry.inputTarget;
    }
    this._newPostEffect = effect;
    if (effect.needsDepthBuffer) {
      this._requestDepthMap();
    }
    this.enable();
    this._newPostEffect = undefined;
  }, removeEffect:function(effect) {
    var i, len, index = -1;
    for (i = 0, len = this.effects.length; i < len; i++) {
      if (this.effects[i].effect === effect) {
        index = i;
        break;
      }
    }
    if (index >= 0) {
      if (index > 0) {
        this.effects[index - 1].outputTarget = index + 1 < this.effects.length ? this.effects[index + 1].inputTarget : null;
      } else {
        if (this.effects.length > 1) {
          if (!this.effects[1].inputTarget._depth) {
            this._destroyOffscreenTarget(this.effects[1].inputTarget);
            this.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);
            this._sourceTarget = this.effects[1].inputTarget;
          }
          for (i = 0; i < this._sourceLayers.length; i++) {
            this._sourceLayers[i].renderTarget = this.effects[1].inputTarget;
          }
        }
      }
      this._destroyOffscreenTarget(this.effects[index].inputTarget);
      this.effects.splice(index, 1);
    }
    if (this.enabled) {
      if (effect.needsDepthBuffer) {
        this._releaseDepthMap();
      }
    }
    if (this.effects.length === 0) {
      this.disable();
    }
  }, _requestDepthMaps:function() {
    for (var i = 0, len = this.effects.length; i < len; i++) {
      var effect = this.effects[i].effect;
      if (this._newPostEffect === effect) {
        continue;
      }
      if (effect.needsDepthBuffer) {
        this._requestDepthMap();
      }
    }
  }, _releaseDepthMaps:function() {
    for (var i = 0, len = this.effects.length; i < len; i++) {
      var effect = this.effects[i].effect;
      if (effect.needsDepthBuffer) {
        this._releaseDepthMap();
      }
    }
  }, _requestDepthMap:function() {
    if (!depthLayer) {
      depthLayer = this.app.scene.layers.getLayerById(pc.LAYERID_DEPTH);
    }
    if (depthLayer) {
      depthLayer.incrementCounter();
    }
  }, _releaseDepthMap:function() {
    if (depthLayer) {
      depthLayer.decrementCounter();
    }
  }, destroy:function() {
    for (var i = 0, len = this.effects.length; i < len; i++) {
      this.effects[i].inputTarget.destroy();
    }
    this.effects.length = 0;
    this.disable();
  }, enable:function() {
    if (!this.enabled && this.effects.length) {
      this.enabled = true;
      var self = this;
      this._requestDepthMaps();
      this.app.graphicsDevice.on("resizecanvas", this._onCanvasResized, this);
      this.command = function() {
        if (self.enabled) {
          var rect = null;
          var len = self.effects.length;
          if (len) {
            self.layer.renderTarget = self.effects[0].inputTarget;
            for (var i = 0; i < len; i++) {
              var fx = self.effects[i];
              if (i === len - 1) {
                rect = self.camera.rect;
              }
              fx.effect.render(fx.inputTarget, fx.outputTarget, rect);
            }
          }
        }
      };
      this.layer._commandList.push(this.command);
    }
  }, disable:function() {
    if (this.enabled) {
      this.enabled = false;
      this.app.graphicsDevice.off("resizecanvas", this._onCanvasResized, this);
      this._releaseDepthMaps();
      this._destroyOffscreenTarget(this._sourceTarget);
      var i = this.layer._commandList.indexOf(this.command);
      if (i >= 0) {
        this.layer._commandList.splice(i, 1);
      }
      var layerList = this.app.scene.layers.layerList;
      var start = layerList.length - 1;
      for (i = 0; i <= layerList.length; i++) {
        if (layerList[i].id === pc.LAYERID_UI) {
          start = i - 1;
          layerList[i].overrideClear = this._origOverrideClear;
          layerList[i].clearColorBuffer = this._origClearColorBuffer;
          layerList[i].clearDepthBuffer = this._origDepthColorBuffer;
          layerList[i].clearStencilBuffer = this._origStencilColorBuffer;
          break;
        }
      }
      for (i = start; i >= 0; i--) {
        if (layerList[i].cameras.indexOf(this.camera) >= 0) {
          layerList[i].renderTarget = undefined;
        }
      }
      this.app.scene.layers.removeOpaque(this.layer);
      this.layer = null;
    }
  }, _onCanvasResized:function(width, height) {
    var rect = this.camera.rect;
    var device = this.app.graphicsDevice;
    this.camera.camera.aspectRatio = device.width * rect.z / (device.height * rect.w);
    if (this.resizeTimeout) {
      return;
    }
    if (pc.now() - this.resizeLast > 100) {
      this.resizeRenderTargets();
    } else {
      this.resizeTimeout = setTimeout(this._resizeTimeoutCallback, 100);
    }
  }, resizeRenderTargets:function() {
    if (this.resizeTimeout) {
      clearTimeout(this.resizeTimeout);
      this.resizeTimeout = null;
    }
    this.resizeLast = pc.now();
    var rect = this.camera.rect;
    var desiredWidth = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
    var desiredHeight = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);
    var effects = this.effects;
    for (var i = 0, len = effects.length; i < len; i++) {
      var fx = effects[i];
      if (fx.inputTarget.width !== desiredWidth || fx.inputTarget.height !== desiredHeight) {
        this._resizeOffscreenTarget(fx.inputTarget);
      }
    }
  }, onCameraRectChanged:function(name, oldValue, newValue) {
    if (this.enabled) {
      this.resizeRenderTargets();
    }
  }});
  return {PostEffectQueue:PostEffectQueue};
}());
Object.assign(pc, function() {
  var _backbufferRt = [null, null];
  var _constInput = null;
  var _constScreenSize;
  var _constScreenSizeValue = new pc.Vec4;
  var _constScreenSizeValueUniform = new Float32Array(4);
  var _postEffectChain = [];
  var _backbufferRtUsed = false;
  var _backbufferRt2Used = false;
  var _backbufferRtWrittenByPost = false;
  var _regexUniforms = /uniform[ \t\n\r]+\S+[ \t\n\r]+\S+[ \t\n\r]*;/g;
  var _regexUniformStart = /\S+[ \t\n\r]*;/;
  var _regexUniformEnd = /[ \t\n\r]*;/;
  var _regexVariables = /(float|int|bool|vec2|vec3|vec4|struct)([ \t\n\r]+[^;]+[ \t\n\r]*,*)+;/g;
  var _regexVariableSurroundings = /(float|int|bool|vec2|vec3|vec4|struct|,|;|\{|\})/g;
  var _regexIrrelevantVariables = /(uniform|varying|in|out)[ \t\n\r]+(float|int|bool|vec2|vec3|vec4|struct)([ \t\n\r]+[^;]+[ \t\n\r]*,*)+;/g;
  var _regexIrrelevantVariableSurroundings = /(float|int|bool|vec2|vec3|vec4|struct|uniform|varying|in|out|,|;|\{|\})/g;
  var _regexVersion = /#version/g;
  var _regexFragColor = /out highp vec4 pc_fragColor;/g;
  var _regexFragColor2 = /#define gl_FragColor/g;
  var _regexFragColor3 = /gl_FragColor/g;
  var _regexColorBuffer = /uniform[ \t\n\r]+sampler2D[ \t\n\r]+uColorBuffer;/g;
  var _regexUv = /(varying|in)[ \t\n\r]+vec2[ \t\n\r]+vUv0;/g;
  var _regexColorBufferSample = /(texture2D|texture)[ \t\n\r]*\([ \t\n\r]*uColorBuffer/g;
  var _regexMain = /void[ \t\n\r]+main/g;
  var _createBackbufferRt = function(id, device, format) {
    var tex = new pc.Texture(device, {format:format, width:device.width, height:device.height});
    tex.name = "posteffect-pass";
    tex.minFilter = pc.FILTER_NEAREST;
    tex.magFilter = pc.FILTER_NEAREST;
    tex.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
    tex.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
    _backbufferRt[id]._colorBuffer = tex;
  };
  var _destroyBackbufferRt = function(id) {
    _backbufferRt[id].colorBuffer.destroy();
    _backbufferRt[id].destroy();
  };
  var _collectUniforms = function(code) {
    var strs = code.match(_regexUniforms) || [];
    var start, end, uname;
    var uniforms = [];
    for (var i = 0; i < strs.length; i++) {
      start = strs[i].search(_regexUniformStart);
      end = strs[i].search(_regexUniformEnd);
      uname = strs[i].substr(start, end - start);
      if (uname !== "uColorBuffer") {
        uniforms.push(uname);
      }
    }
    return uniforms;
  };
  var _uniformsCollide = function(layers, chain, count, shader) {
    var uniforms = _collectUniforms(shader.definition.fshader);
    if (uniforms.length === 0) {
      return false;
    }
    var i, j, k, uniforms2;
    var uname;
    for (i = 0; i < count; i++) {
      for (j = 0; j < uniforms.length; j++) {
        uname = uniforms[j];
        uniforms2 = _collectUniforms(layers[chain[i]].shader.definition.fshader);
        for (k = 0; k < uniforms2.length; k++) {
          if (uniforms2[k] === uname) {
            return true;
          }
        }
      }
    }
    return false;
  };
  var _collectGlobalTempVars = function(code, list) {
    var len = code.length;
    var chr;
    var scopeStart = 0;
    var scopeEnd = 0;
    var scopeDepth = 0;
    var codeStart = 0;
    var codeWithoutScopes = "";
    var i, j;
    for (i = 0; i < len; i++) {
      chr = code.charAt(i);
      if (chr === "{") {
        if (scopeDepth === 0) {
          scopeStart = i;
        }
        scopeDepth++;
      } else {
        if (chr === "}") {
          if (scopeDepth === 1) {
            scopeEnd = i;
            codeWithoutScopes += code.substr(codeStart, scopeStart - codeStart + 1);
            codeStart = scopeEnd;
          }
          scopeDepth--;
        }
      }
    }
    codeWithoutScopes += code.substr(codeStart, code.length - codeStart + 1);
    var collisions = null;
    var decls = codeWithoutScopes.match(_regexVariables) || [];
    var vars, varName;
    for (i = 0; i < decls.length; i++) {
      vars = decls[i].split(",");
      for (j = 0; j < vars.length; j++) {
        varName = vars[j].replace(_regexVariableSurroundings, "").trim();
        if (list.indexOf(varName) >= 0) {
          if (!collisions) {
            collisions = [];
          }
          collisions.push(varName);
        } else {
          list.push(varName);
        }
      }
    }
    var irrelevantDecls = codeWithoutScopes.match(_regexIrrelevantVariables) || [];
    var index;
    for (i = 0; i < irrelevantDecls.length; i++) {
      vars = irrelevantDecls[i].split(",");
      for (j = 0; j < vars.length; j++) {
        varName = vars[j].replace(_regexIrrelevantVariableSurroundings, "").trim();
        index = list.indexOf(varName);
        if (index >= 0) {
          list.splice(index, 1);
        }
      }
    }
    return collisions;
  };
  function PostEffectPass(app, options) {
    this.app = app;
    this.srcRenderTarget = options.srcRenderTarget;
    this.hdr = options.hdr;
    this.blending = options.blending;
    this.shader = options.shader;
    this.setup = options.setup;
    var self = this;
    var device = app.graphicsDevice;
    this.layer = new pc.Layer({opaqueSortMode:pc.SORTMODE_NONE, transparentSortMode:pc.SORTMODE_NONE, passThrough:true, name:options.name, onPostRender:function() {
      if (self.srcRenderTarget) {
        _constScreenSizeValue.x = self.srcRenderTarget.width;
        _constScreenSizeValue.y = self.srcRenderTarget.height;
        _constScreenSizeValue.z = 1.0 / self.srcRenderTarget.width;
        _constScreenSizeValue.w = 1.0 / self.srcRenderTarget.height;
      } else {
        _constScreenSizeValue.x = device.width;
        _constScreenSizeValue.y = device.height;
        _constScreenSizeValue.z = 1.0 / device.width;
        _constScreenSizeValue.w = 1.0 / device.height;
      }
      _constScreenSizeValueUniform[0] = _constScreenSizeValue.x;
      _constScreenSizeValueUniform[1] = _constScreenSizeValue.y;
      _constScreenSizeValueUniform[2] = _constScreenSizeValue.z;
      _constScreenSizeValueUniform[3] = _constScreenSizeValue.w;
      _constScreenSize.setValue(_constScreenSizeValueUniform);
      if (this._postEffectCombined && this._postEffectCombined < 0) {
        if (self.setup) {
          self.setup(device, self, _constScreenSizeValue, null, this.renderTarget);
        }
        return;
      }
      var src;
      if (this._postEffectCombinedSrc) {
        src = this._postEffectCombinedSrc;
      } else {
        src = self.srcRenderTarget ? self.srcRenderTarget : _backbufferRt[this._backbufferRtId];
      }
      if (src._samples > 1) {
        src.resolve(true, false);
      }
      var tex = src._colorBuffer;
      tex.magFilter = (this._postEffectCombinedShader ? this._postEffectCombinedBilinear : this.postEffectBilinear) ? pc.FILTER_LINEAR : pc.FILTER_NEAREST;
      _constInput.setValue(tex);
      if (self.setup) {
        self.setup(device, self, _constScreenSizeValue, src, this.renderTarget);
      }
      var shader = this._postEffectCombinedShader ? this._postEffectCombinedShader : this.shader;
      if (shader) {
        pc.drawQuadWithShader(device, this.renderTarget, shader, null, null, self.blending);
      }
      if (self.srcRenderTarget) {
        return;
      }
      var layers = app.scene.layers.layerList;
      for (var i = 0; i < layers.length; i++) {
        if (layers[i] === self.layer) {
          break;
        }
        if (layers[i].renderTarget === _backbufferRt[0] || layers[i].renderTarget === _backbufferRt[1]) {
          layers[i].renderTarget = null;
        }
      }
    }});
    this.layer._generateCameraHash();
    this.layer.isPostEffect = true;
    this.layer.unmodifiedUvs = options.unmodifiedUvs;
    this.layer.postEffectBilinear = options.bilinear;
    this.layer.postEffect = this;
    this.layer.shader = options.shader;
    this.layer.renderTarget = options.destRenderTarget;
    if (!_constInput) {
      _constInput = device.scope.resolve("uColorBuffer");
      _constScreenSize = device.scope.resolve("uScreenSize");
      var _backbufferMsaa = device.supportsMsaa ? 4 : 1;
      for (var i = 0; i < 2; i++) {
        _backbufferRt[i] = new pc.RenderTarget({depth:true, stencil:device.supportsStencil, samples:_backbufferMsaa, autoResolve:false});
        _backbufferRt[i].name = "backbuffer" + i;
      }
      app.on("prerender", function() {
        var layers = app.scene.layers.layerList;
        var i, j;
        var offset = 0;
        var rtId = 0;
        _backbufferRtUsed = false;
        _backbufferRt2Used = false;
        _backbufferRtWrittenByPost = false;
        var backbufferRtFormat = pc.PIXELFORMAT_R8_G8_B8_A8;
        if (app.scene.layers._dirty) {
          var iterator = 0;
          var breakChain = false;
          var collisions, k;
          for (i = 0; i < layers.length; i++) {
            breakChain = false;
            if (layers[i].isPostEffect && (iterator === 0 || layers[i].unmodifiedUvs && layers[i].shader && !_uniformsCollide(layers, _postEffectChain, iterator, layers[i].shader))) {
              _postEffectChain[iterator] = i;
              iterator++;
              if (i === layers.length - 1) {
                breakChain = true;
              }
            } else {
              if (iterator > 0) {
                breakChain = true;
              }
            }
            if (breakChain) {
              if (iterator > 1) {
                var cachedName = "post_";
                var layer;
                for (j = 0; j < iterator; j++) {
                  layer = layers[_postEffectChain[j]];
                  cachedName += layer.name ? layer.name : layer.id;
                  if (j < iterator - 1) {
                    cachedName += "_";
                  }
                }
                var shader = device.programLib._cache[cachedName];
                if (!shader) {
                  var subCode;
                  var code = "vec4 shaderOutput;\n";
                  var mainCode = "void main() {\n";
                  var globalTempVars = [];
                  for (j = 0; j < iterator; j++) {
                    subCode = layers[_postEffectChain[j]].shader.definition.fshader + "\n";
                    subCode = subCode.replace(_regexVersion, "//").replace(_regexFragColor, "//").replace(_regexFragColor2, "//").replace(_regexFragColor3, "shaderOutput");
                    if (j > 0) {
                      subCode = subCode.replace(_regexColorBuffer, "//").replace(_regexUv, "//").replace(_regexColorBufferSample, "shaderOutput;//");
                    }
                    subCode = subCode.replace(_regexMain, "void main" + j);
                    collisions = _collectGlobalTempVars(subCode, globalTempVars);
                    if (collisions) {
                      for (k = 0; k < collisions.length; k++) {
                        subCode = subCode.replace(new RegExp("\\b" + collisions[k] + "\\b", "g"), collisions[k] + "NNNN" + j);
                      }
                    }
                    code += subCode;
                    mainCode += "main" + j + "();\n";
                  }
                  mainCode += "gl_FragColor = shaderOutput;\n}\n";
                  shader = pc.shaderChunks.createShaderFromCode(device, pc.shaderChunks.fullscreenQuadVS, code + mainCode, cachedName);
                }
                for (j = 0; j < iterator; j++) {
                  layers[_postEffectChain[j]]._postEffectCombined = j === iterator - 1 ? 1 : -1;
                }
                layers[_postEffectChain[iterator - 1]]._postEffectCombinedShader = shader;
                layers[_postEffectChain[iterator - 1]]._postEffectCombinedBilinear = layers[_postEffectChain[0]].postEffectBilinear;
                layers[_postEffectChain[iterator - 1]]._postEffectCombinedSrc = layers[_postEffectChain[0]].postEffect.srcRenderTarget;
              }
              _postEffectChain[0] = i;
              iterator = 1;
            }
          }
        }
        for (i = 0; i < layers.length; i++) {
          if (layers[i].isPostEffect && (!layers[i].postEffect.srcRenderTarget && !layers[i]._postEffectCombined || !layers[i].postEffect._postEffectCombinedSrc && layers[i]._postEffectCombined >= 0)) {
            for (j = i - 1; j >= offset; j--) {
              if (!layers[j].renderTarget) {
                layers[j].renderTarget = _backbufferRt[rtId];
              }
            }
            layers[i]._backbufferRtId = rtId;
            offset = i;
            _backbufferRtUsed = true;
            if (rtId === 1) {
              _backbufferRt2Used = true;
            }
            if (layers[i].postEffect.hdr) {
              if (device.webgl2 && device.textureFloatRenderable) {
                backbufferRtFormat = pc.PIXELFORMAT_111110F;
              } else {
                if (device.extTextureHalfFloatLinear && device.textureHalfFloatRenderable) {
                  backbufferRtFormat = pc.PIXELFORMAT_RGBA16F;
                } else {
                  backbufferRtFormat = pc.PIXELFORMAT_R8_G8_B8_A8;
                }
              }
            }
            if (layers[i].postEffect.shader && !layers[i].renderTarget) {
              rtId = 1 - rtId;
            }
          } else {
            if (!layers[i].isPostEffect && !layers[i].renderTarget && _backbufferRtUsed) {
              layers[i].renderTarget = _backbufferRt[rtId];
            }
          }
          if (layers[i].isPostEffect && !layers[i].renderTarget) {
            _backbufferRtWrittenByPost = true;
          }
        }
        if (_backbufferRtUsed) {
          if (!_backbufferRt[0].colorBuffer) {
            _createBackbufferRt(0, device, backbufferRtFormat);
          } else {
            if (_backbufferRt[0].width !== device.width || _backbufferRt[0].height !== device.height || _backbufferRt[0]._colorBuffer._format !== backbufferRtFormat) {
              _destroyBackbufferRt(0);
              _createBackbufferRt(0, device, backbufferRtFormat);
            }
          }
        }
        if (_backbufferRt2Used) {
          if (!_backbufferRt[1].colorBuffer) {
            _createBackbufferRt(1, device, backbufferRtFormat);
          } else {
            if (_backbufferRt[1].width !== device.width || _backbufferRt[1].height !== device.height || _backbufferRt[1]._colorBuffer._format !== backbufferRtFormat) {
              _destroyBackbufferRt(1);
              _createBackbufferRt(1, device, backbufferRtFormat);
            }
          }
        }
      }, this);
      app.on("postrender", function() {
        var device = app.graphicsDevice;
        if (_backbufferRtUsed && !_backbufferRtWrittenByPost) {
          var layers = app.scene.layers.layerList;
          var rt;
          for (var i = layers.length - 1; i >= 0; i--) {
            rt = layers[i].renderTarget;
            if (rt === _backbufferRt[0] || rt === _backbufferRt[1]) {
              break;
            }
          }
          if (rt) {
            if (rt._samples > 1) {
              rt.resolve(true, false);
            }
            device.copyRenderTarget(rt, null, true, false);
          }
        }
      }, this);
    }
  }
  PostEffectPass.prototype.addToComposition = function(order) {
    this.app.scene.layers.insertTransparent(this.layer, order);
  };
  return {PostEffectPass:PostEffectPass};
}());
Object.assign(pc, function() {
  var LightComponent = function LightComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this._cookieAsset = null;
    this._cookieAssetId = null;
    this._cookieAssetAdd = false;
    this._cookieMatrix = null;
  };
  LightComponent.prototype = Object.create(pc.Component.prototype);
  LightComponent.prototype.constructor = LightComponent;
  var _props = [];
  var _propsDefault = [];
  var _defineProperty = function(name, defaultValue, setFunc, skipEqualsCheck) {
    var c = LightComponent.prototype;
    _props.push(name);
    _propsDefault.push(defaultValue);
    Object.defineProperty(c, name, {get:function() {
      return this.data[name];
    }, set:function(value) {
      var data = this.data;
      var oldValue = data[name];
      if (!skipEqualsCheck && oldValue === value) {
        return;
      }
      data[name] = value;
      if (setFunc) {
        setFunc.call(this, value, oldValue);
      }
    }, configurable:true});
  };
  var _defineProps = function() {
    _defineProperty("enabled", true, function(newValue, oldValue) {
      this.onSetEnabled(null, oldValue, newValue);
    });
    _defineProperty("light", null);
    _defineProperty("type", "directional", function(newValue, oldValue) {
      this.system.changeType(this, oldValue, newValue);
      this.refreshProperties();
    });
    _defineProperty("color", new pc.Color(1, 1, 1), function(newValue, oldValue) {
      this.light.setColor(newValue);
    }, true);
    _defineProperty("intensity", 1, function(newValue, oldValue) {
      this.light.intensity = newValue;
    });
    _defineProperty("castShadows", false, function(newValue, oldValue) {
      this.light.castShadows = newValue;
    });
    _defineProperty("shadowDistance", 40, function(newValue, oldValue) {
      this.light.shadowDistance = newValue;
    });
    _defineProperty("shadowResolution", 1024, function(newValue, oldValue) {
      this.light.shadowResolution = newValue;
    });
    _defineProperty("shadowBias", 0.05, function(newValue, oldValue) {
      this.light.shadowBias = -0.01 * newValue;
    });
    _defineProperty("normalOffsetBias", 0, function(newValue, oldValue) {
      this.light.normalOffsetBias = newValue;
    });
    _defineProperty("range", 10, function(newValue, oldValue) {
      this.light.attenuationEnd = newValue;
    });
    _defineProperty("innerConeAngle", 40, function(newValue, oldValue) {
      this.light.innerConeAngle = newValue;
    });
    _defineProperty("outerConeAngle", 45, function(newValue, oldValue) {
      this.light.outerConeAngle = newValue;
    });
    _defineProperty("falloffMode", pc.LIGHTFALLOFF_LINEAR, function(newValue, oldValue) {
      this.light.falloffMode = newValue;
    });
    _defineProperty("shadowType", pc.SHADOW_PCF3, function(newValue, oldValue) {
      this.light.shadowType = newValue;
    });
    _defineProperty("vsmBlurSize", 11, function(newValue, oldValue) {
      this.light.vsmBlurSize = newValue;
    });
    _defineProperty("vsmBlurMode", pc.BLUR_GAUSSIAN, function(newValue, oldValue) {
      this.light.vsmBlurMode = newValue;
    });
    _defineProperty("vsmBias", 0.01 * 0.25, function(newValue, oldValue) {
      this.light.vsmBias = newValue;
    });
    _defineProperty("cookieAsset", null, function(newValue, oldValue) {
      if (this._cookieAssetId && (newValue instanceof pc.Asset && newValue.id === this._cookieAssetId || newValue === this._cookieAssetId)) {
        return;
      }
      this.onCookieAssetRemove();
      this._cookieAssetId = null;
      if (newValue instanceof pc.Asset) {
        this.data.cookieAsset = newValue.id;
        this._cookieAssetId = newValue.id;
        this.onCookieAssetAdd(newValue);
      } else {
        if (typeof newValue === "number") {
          this._cookieAssetId = newValue;
          var asset = this.system.app.assets.get(newValue);
          if (asset) {
            this.onCookieAssetAdd(asset);
          } else {
            this._cookieAssetAdd = true;
            this.system.app.assets.on("add:" + this._cookieAssetId, this.onCookieAssetAdd, this);
          }
        }
      }
    });
    _defineProperty("cookie", null, function(newValue, oldValue) {
      this.light.cookie = newValue;
    });
    _defineProperty("cookieIntensity", 1, function(newValue, oldValue) {
      this.light.cookieIntensity = newValue;
    });
    _defineProperty("cookieFalloff", true, function(newValue, oldValue) {
      this.light.cookieFalloff = newValue;
    });
    _defineProperty("cookieChannel", "rgb", function(newValue, oldValue) {
      this.light.cookieChannel = newValue;
    });
    _defineProperty("cookieAngle", 0, function(newValue, oldValue) {
      if (newValue !== 0 || this.cookieScale !== null) {
        if (!this._cookieMatrix) {
          this._cookieMatrix = new pc.Vec4;
        }
        var scx = 1;
        var scy = 1;
        if (this.cookieScale) {
          scx = this.cookieScale.x;
          scy = this.cookieScale.y;
        }
        var c = Math.cos(newValue * pc.math.DEG_TO_RAD);
        var s = Math.sin(newValue * pc.math.DEG_TO_RAD);
        this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
        this.light.cookieTransform = this._cookieMatrix;
      } else {
        this.light.cookieTransform = null;
      }
    });
    _defineProperty("cookieScale", null, function(newValue, oldValue) {
      if (newValue !== null || this.cookieAngle !== 0) {
        if (!this._cookieMatrix) {
          this._cookieMatrix = new pc.Vec4;
        }
        var scx = newValue.x;
        var scy = newValue.y;
        var c = Math.cos(this.cookieAngle * pc.math.DEG_TO_RAD);
        var s = Math.sin(this.cookieAngle * pc.math.DEG_TO_RAD);
        this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
        this.light.cookieTransform = this._cookieMatrix;
      } else {
        this.light.cookieTransform = null;
      }
    }, true);
    _defineProperty("cookieOffset", null, function(newValue, oldValue) {
      this.light.cookieOffset = newValue;
    }, true);
    _defineProperty("shadowUpdateMode", pc.SHADOWUPDATE_REALTIME, function(newValue, oldValue) {
      this.light.shadowUpdateMode = newValue;
    });
    _defineProperty("mask", 1, function(newValue, oldValue) {
      this.light.mask = newValue;
    });
    _defineProperty("affectDynamic", true, function(newValue, oldValue) {
      if (newValue) {
        this.light.mask |= pc.MASK_DYNAMIC;
      } else {
        this.light.mask &= ~pc.MASK_DYNAMIC;
      }
      this.light.mask = this.light._mask;
    });
    _defineProperty("affectLightmapped", false, function(newValue, oldValue) {
      if (newValue) {
        this.light.mask |= pc.MASK_BAKED;
        if (this.bake) {
          this.light.mask &= ~pc.MASK_LIGHTMAP;
        }
      } else {
        this.light.mask &= ~pc.MASK_BAKED;
        if (this.bake) {
          this.light.mask |= pc.MASK_LIGHTMAP;
        }
      }
      this.light.mask = this.light._mask;
    });
    _defineProperty("bake", false, function(newValue, oldValue) {
      if (newValue) {
        this.light.mask |= pc.MASK_LIGHTMAP;
        if (this.affectLightmapped) {
          this.light.mask &= ~pc.MASK_BAKED;
        }
      } else {
        this.light.mask &= ~pc.MASK_LIGHTMAP;
        if (this.affectLightmapped) {
          this.light.mask |= pc.MASK_BAKED;
        }
      }
      this.light.mask = this.light._mask;
    });
    _defineProperty("bakeDir", true, function(newValue, oldValue) {
      this.light.bakeDir = newValue;
    });
    _defineProperty("isStatic", false, function(newValue, oldValue) {
      this.light.isStatic = newValue;
    });
    _defineProperty("layers", [pc.LAYERID_WORLD], function(newValue, oldValue) {
      var i, layer;
      for (i = 0; i < oldValue.length; i++) {
        layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
        if (!layer) {
          continue;
        }
        layer.removeLight(this);
      }
      for (i = 0; i < newValue.length; i++) {
        layer = this.system.app.scene.layers.getLayerById(newValue[i]);
        if (!layer) {
          continue;
        }
        if (this.enabled && this.entity.enabled) {
          layer.addLight(this);
        }
      }
    });
  };
  _defineProps();
  Object.defineProperty(LightComponent.prototype, "enable", {get:function() {
    console.warn("WARNING: enable: Property is deprecated. Query enabled property instead.");
    return this.enabled;
  }, set:function(value) {
    console.warn("WARNING: enable: Property is deprecated. Set enabled property instead.");
    this.enabled = value;
  }});
  Object.assign(LightComponent.prototype, {addLightToLayers:function() {
    var layer;
    for (var i = 0; i < this.layers.length; i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.addLight(this);
    }
  }, removeLightFromLayers:function() {
    var layer;
    for (var i = 0; i < this.layers.length; i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.removeLight(this);
    }
  }, onLayersChanged:function(oldComp, newComp) {
    if (this.enabled && this.entity.enabled) {
      this.addLightToLayers();
    }
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
  }, onLayerAdded:function(layer) {
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    if (this.enabled && this.entity.enabled) {
      layer.addLight(this);
    }
  }, onLayerRemoved:function(layer) {
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    layer.removeLight(this);
  }, refreshProperties:function() {
    var name;
    for (var i = 0; i < _props.length; i++) {
      name = _props[i];
      this[name] = this[name];
    }
    if (this.enabled && this.entity.enabled) {
      this.onEnable();
    }
  }, updateShadow:function() {
    this.light.updateShadow();
  }, onCookieAssetSet:function() {
    var forceLoad = false;
    if (this._cookieAsset.type === "cubemap" && !this._cookieAsset.loadFaces) {
      this._cookieAsset.loadFaces = true;
      forceLoad = true;
    }
    if (!this._cookieAsset.resource || forceLoad) {
      this.system.app.assets.load(this._cookieAsset);
    }
    if (this._cookieAsset.resource) {
      this.onCookieAssetLoad();
    }
  }, onCookieAssetAdd:function(asset) {
    if (this._cookieAssetId !== asset.id) {
      return;
    }
    this._cookieAsset = asset;
    if (this.light._enabled) {
      this.onCookieAssetSet();
    }
    this._cookieAsset.on("load", this.onCookieAssetLoad, this);
    this._cookieAsset.on("remove", this.onCookieAssetRemove, this);
  }, onCookieAssetLoad:function() {
    if (!this._cookieAsset || !this._cookieAsset.resource) {
      return;
    }
    this.cookie = this._cookieAsset.resource;
  }, onCookieAssetRemove:function() {
    if (!this._cookieAssetId) {
      return;
    }
    if (this._cookieAssetAdd) {
      this.system.app.assets.off("add:" + this._cookieAssetId, this.onCookieAssetAdd, this);
      this._cookieAssetAdd = false;
    }
    if (this._cookieAsset) {
      this._cookieAsset.off("load", this.onCookieAssetLoad, this);
      this._cookieAsset.off("remove", this.onCookieAssetRemove, this);
      this._cookieAsset = null;
    }
    this.cookie = null;
  }, onEnable:function() {
    this.light.enabled = true;
    this.system.app.scene.on("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.on("add", this.onLayerAdded, this);
      this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
    }
    if (this.enabled && this.entity.enabled) {
      this.addLightToLayers();
    }
    if (this._cookieAsset && !this.cookie) {
      this.onCookieAssetSet();
    }
  }, onDisable:function() {
    this.light.enabled = false;
    this.system.app.scene.off("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.off("add", this.onLayerAdded, this);
      this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
    }
    this.removeLightFromLayers();
  }});
  return {LightComponent:LightComponent, _lightProps:_props, _lightPropsDefault:_propsDefault};
}());
Object.assign(pc, function() {
  var lightTypes = {"directional":pc.LIGHTTYPE_DIRECTIONAL, "point":pc.LIGHTTYPE_POINT, "spot":pc.LIGHTTYPE_SPOT};
  var LightComponentSystem = function(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "light";
    this.description = "Enables the Entity to emit light.";
    this.ComponentType = pc.LightComponent;
    this.DataType = pc.LightComponentData;
  };
  LightComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  LightComponentSystem.prototype.constructor = LightComponentSystem;
  Object.assign(LightComponentSystem.prototype, {initializeComponentData:function(component, _data) {
    var properties = pc._lightProps;
    var data = {};
    for (var i = 0, len = properties.length; i < len; i++) {
      var property = properties[i];
      data[property] = _data[property];
    }
    if (!data.type) {
      data.type = component.data.type;
    }
    component.data.type = data.type;
    if (data.layers && pc.type(data.layers) === "array") {
      data.layers = data.layers.slice(0);
    }
    if (data.color && pc.type(data.color) === "array") {
      data.color = new pc.Color(data.color[0], data.color[1], data.color[2]);
    }
    if (data.cookieOffset && data.cookieOffset instanceof Array) {
      data.cookieOffset = new pc.Vec2(data.cookieOffset[0], data.cookieOffset[1]);
    }
    if (data.cookieScale && data.cookieScale instanceof Array) {
      data.cookieScale = new pc.Vec2(data.cookieScale[0], data.cookieScale[1]);
    }
    if (data.enable) {
      console.warn("WARNING: enable: Property is deprecated. Set enabled property instead.");
      data.enabled = data.enable;
    }
    var light = new pc.Light;
    light.type = lightTypes[data.type];
    light._node = component.entity;
    light._scene = this.app.scene;
    component.data.light = light;
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, removeComponent:function(entity) {
    var data = entity.light.data;
    data.light.destroy();
    pc.ComponentSystem.prototype.removeComponent.call(this, entity);
  }, cloneComponent:function(entity, clone) {
    var light = entity.light;
    var data = [];
    var name;
    var _props = pc._lightProps;
    for (var i = 0; i < _props.length; i++) {
      name = _props[i];
      if (name === "light") {
        continue;
      }
      if (light[name] && light[name].clone) {
        data[name] = light[name].clone();
      } else {
        data[name] = light[name];
      }
    }
    this.addComponent(clone, data);
  }, changeType:function(component, oldValue, newValue) {
    if (oldValue !== newValue) {
      component.light.type = lightTypes[newValue];
    }
  }});
  return {LightComponentSystem:LightComponentSystem};
}());
Object.assign(pc, function() {
  var LightComponentData = function() {
    var _props = pc._lightProps;
    var _propsDefault = pc._lightPropsDefault;
    var value;
    for (var i = 0; i < _props.length; i++) {
      value = _propsDefault[i];
      if (value && value.clone) {
        this[_props[i]] = value.clone();
      } else {
        this[_props[i]] = value;
      }
    }
  };
  return {LightComponentData:LightComponentData};
}());
Object.assign(pc, function() {
  var ScriptComponent = function ScriptComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this._scripts = [];
    this._updateList = new pc.SortedLoopArray({sortBy:"__executionOrder"});
    this._postUpdateList = new pc.SortedLoopArray({sortBy:"__executionOrder"});
    this._scriptsIndex = {};
    this._destroyedScripts = [];
    this._destroyed = false;
    this._scriptsData = null;
    this._oldState = true;
    this._enabled = true;
    this._beingEnabled = false;
    this._isLoopingThroughScripts = false;
    this._executionOrder = -1;
    this.on("set_enabled", this._onSetEnabled, this);
  };
  ScriptComponent.prototype = Object.create(pc.Component.prototype);
  ScriptComponent.prototype.constructor = ScriptComponent;
  ScriptComponent.scriptMethods = {initialize:"initialize", postInitialize:"postInitialize", update:"update", postUpdate:"postUpdate", swap:"swap"};
  Object.assign(ScriptComponent.prototype, {onEnable:function() {
    this._beingEnabled = true;
    this._checkState();
    if (!this.entity._beingEnabled) {
      this.onPostStateChange();
    }
    this._beingEnabled = false;
  }, onDisable:function() {
    this._checkState();
  }, onPostStateChange:function() {
    var script;
    var wasLooping = this._beginLooping();
    for (var i = 0, len = this.scripts.length; i < len; i++) {
      script = this.scripts[i];
      if (script._initialized && !script._postInitialized && script.enabled) {
        script._postInitialized = true;
        if (script.postInitialize) {
          this._scriptMethod(script, ScriptComponent.scriptMethods.postInitialize);
        }
      }
    }
    this._endLooping(wasLooping);
  }, _beginLooping:function() {
    var looping = this._isLoopingThroughScripts;
    this._isLoopingThroughScripts = true;
    return looping;
  }, _endLooping:function(wasLoopingBefore) {
    this._isLoopingThroughScripts = wasLoopingBefore;
    if (!this._isLoopingThroughScripts) {
      this._removeDestroyedScripts();
    }
  }, _onSetEnabled:function(prop, old, value) {
    this._beingEnabled = true;
    this._checkState();
    this._beingEnabled = false;
  }, _checkState:function() {
    var state = this.enabled && this.entity.enabled;
    if (state === this._oldState) {
      return;
    }
    this._oldState = state;
    this.fire(state ? "enable" : "disable");
    this.fire("state", state);
    if (state) {
      this.system._addComponentToEnabled(this);
    } else {
      this.system._removeComponentFromEnabled(this);
    }
    var wasLooping = this._beginLooping();
    var script;
    for (var i = 0, len = this.scripts.length; i < len; i++) {
      script = this.scripts[i];
      script.enabled = script._enabled;
    }
    this._endLooping(wasLooping);
  }, _onBeforeRemove:function() {
    this.fire("remove");
    var wasLooping = this._beginLooping();
    for (var i = 0; i < this.scripts.length; i++) {
      var script = this.scripts[i];
      if (!script) {
        continue;
      }
      this.destroy(script.__scriptType.__name);
    }
    this._endLooping(wasLooping);
  }, _removeDestroyedScripts:function() {
    var len = this._destroyedScripts.length;
    if (!len) {
      return;
    }
    var i;
    for (i = 0; i < len; i++) {
      var script = this._destroyedScripts[i];
      this._removeScriptInstance(script);
    }
    this._destroyedScripts.length = 0;
    this._resetExecutionOrder(0, this._scripts.length);
  }, _onInitializeAttributes:function() {
    for (var i = 0, len = this.scripts.length; i < len; i++) {
      this.scripts[i].__initializeAttributes();
    }
  }, _scriptMethod:function(script, method, arg) {
    script[method](arg);
  }, _onInitialize:function() {
    var script, scripts = this._scripts;
    var wasLooping = this._beginLooping();
    for (var i = 0, len = scripts.length; i < len; i++) {
      script = scripts[i];
      if (!script._initialized && script.enabled) {
        script._initialized = true;
        if (script.initialize) {
          this._scriptMethod(script, ScriptComponent.scriptMethods.initialize);
        }
      }
    }
    this._endLooping(wasLooping);
  }, _onPostInitialize:function() {
    this.onPostStateChange();
  }, _onUpdate:function(dt) {
    var self = this;
    var list = self._updateList;
    if (!list.length) {
      return;
    }
    var script;
    var wasLooping = self._beginLooping();
    for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
      script = list.items[list.loopIndex];
      if (script.enabled) {
        self._scriptMethod(script, ScriptComponent.scriptMethods.update, dt);
      }
    }
    self._endLooping(wasLooping);
  }, _onPostUpdate:function(dt) {
    var self = this;
    var list = self._postUpdateList;
    if (!list.length) {
      return;
    }
    var wasLooping = self._beginLooping();
    var script;
    for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
      script = list.items[list.loopIndex];
      if (script.enabled) {
        self._scriptMethod(script, ScriptComponent.scriptMethods.postUpdate, dt);
      }
    }
    self._endLooping(wasLooping);
  }, _insertScriptInstance:function(scriptInstance, index, scriptsLength) {
    if (index === -1) {
      this._scripts.push(scriptInstance);
      scriptInstance.__executionOrder = scriptsLength;
      if (scriptInstance.update) {
        this._updateList.append(scriptInstance);
      }
      if (scriptInstance.postUpdate) {
        this._postUpdateList.append(scriptInstance);
      }
    } else {
      this._scripts.splice(index, 0, scriptInstance);
      scriptInstance.__executionOrder = index;
      this._resetExecutionOrder(index + 1, scriptsLength + 1);
      if (scriptInstance.update) {
        this._updateList.insert(scriptInstance);
      }
      if (scriptInstance.postUpdate) {
        this._postUpdateList.insert(scriptInstance);
      }
    }
  }, _removeScriptInstance:function(scriptInstance) {
    var idx = this._scripts.indexOf(scriptInstance);
    if (idx === -1) {
      return idx;
    }
    this._scripts.splice(idx, 1);
    if (scriptInstance.update) {
      this._updateList.remove(scriptInstance);
    }
    if (scriptInstance.postUpdate) {
      this._postUpdateList.remove(scriptInstance);
    }
    return idx;
  }, _resetExecutionOrder:function(startIndex, scriptsLength) {
    for (var i = startIndex; i < scriptsLength; i++) {
      this._scripts[i].__executionOrder = i;
    }
  }, has:function(name) {
    var scriptType = name;
    if (typeof scriptType === "string") {
      scriptType = this.system.app.scripts.get(scriptType);
    }
    return !!this._scriptsIndex[scriptType.__name];
  }, create:function(name, args) {
    var self = this;
    args = args || {};
    var scriptType = name;
    var scriptName = name;
    if (typeof scriptType === "string") {
      scriptType = this.system.app.scripts.get(scriptType);
    } else {
      if (scriptType) {
        scriptName = scriptType.__name;
      }
    }
    if (scriptType) {
      if (!this._scriptsIndex[scriptType.__name] || !this._scriptsIndex[scriptType.__name].instance) {
        var scriptInstance = new scriptType({app:this.system.app, entity:this.entity, enabled:args.hasOwnProperty("enabled") ? args.enabled : true, attributes:args.attributes || null});
        var len = this._scripts.length;
        var ind = -1;
        if (typeof args.ind === "number" && args.ind !== -1 && len > args.ind) {
          ind = args.ind;
        }
        this._insertScriptInstance(scriptInstance, ind, len);
        this._scriptsIndex[scriptType.__name] = {instance:scriptInstance, onSwap:function() {
          self.swap(scriptType.__name);
        }};
        this[scriptType.__name] = scriptInstance;
        if (!args.preloading) {
          scriptInstance.__initializeAttributes();
        }
        this.fire("create", scriptType.__name, scriptInstance);
        this.fire("create:" + scriptType.__name, scriptInstance);
        this.system.app.scripts.on("swap:" + scriptType.__name, this._scriptsIndex[scriptType.__name].onSwap);
        if (!args.preloading) {
          if (scriptInstance.enabled && !scriptInstance._initialized) {
            scriptInstance._initialized = true;
            if (scriptInstance.initialize) {
              this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.initialize);
            }
          }
          if (scriptInstance.enabled && !scriptInstance._postInitialized) {
            scriptInstance._postInitialized = true;
            if (scriptInstance.postInitialize) {
              this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.postInitialize);
            }
          }
        }
        return scriptInstance;
      }
      console.warn("script '" + scriptName + "' is already added to entity '" + this.entity.name + "'");
    } else {
      this._scriptsIndex[scriptName] = {awaiting:true, ind:this._scripts.length};
      console.warn("script '" + scriptName + "' is not found, awaiting it to be added to registry");
    }
    return null;
  }, destroy:function(name) {
    var scriptName = name;
    var scriptType = name;
    if (typeof scriptType === "string") {
      scriptType = this.system.app.scripts.get(scriptType);
      if (scriptType) {
        scriptName = scriptType.__name;
      }
    }
    var scriptData = this._scriptsIndex[scriptName];
    delete this._scriptsIndex[scriptName];
    if (!scriptData) {
      return false;
    }
    if (scriptData.instance && !scriptData.instance._destroyed) {
      scriptData.instance.enabled = false;
      scriptData.instance._destroyed = true;
      if (!this._isLoopingThroughScripts) {
        var ind = this._removeScriptInstance(scriptData.instance);
        if (ind >= 0) {
          this._resetExecutionOrder(ind, this._scripts.length);
        }
      } else {
        this._destroyedScripts.push(scriptData.instance);
      }
    }
    this.system.app.scripts.off("swap:" + scriptName, scriptData.onSwap);
    delete this[scriptName];
    this.fire("destroy", scriptName, scriptData.instance || null);
    this.fire("destroy:" + scriptName, scriptData.instance || null);
    if (scriptData.instance) {
      scriptData.instance.fire("destroy");
    }
    return true;
  }, swap:function(script) {
    var scriptType = script;
    if (typeof scriptType === "string") {
      scriptType = this.system.app.scripts.get(scriptType);
    }
    var old = this._scriptsIndex[scriptType.__name];
    if (!old || !old.instance) {
      return false;
    }
    var scriptInstanceOld = old.instance;
    var ind = this._scripts.indexOf(scriptInstanceOld);
    var scriptInstance = new scriptType({app:this.system.app, entity:this.entity, enabled:scriptInstanceOld.enabled, attributes:scriptInstanceOld.__attributes});
    if (!scriptInstance.swap) {
      return false;
    }
    scriptInstance.__initializeAttributes();
    this._scripts[ind] = scriptInstance;
    this._scriptsIndex[scriptType.__name].instance = scriptInstance;
    this[scriptType.__name] = scriptInstance;
    scriptInstance.__executionOrder = ind;
    if (scriptInstanceOld.update) {
      this._updateList.remove(scriptInstanceOld);
    }
    if (scriptInstanceOld.postUpdate) {
      this._postUpdateList.remove(scriptInstanceOld);
    }
    if (scriptInstance.update) {
      this._updateList.insert(scriptInstance);
    }
    if (scriptInstance.postUpdate) {
      this._postUpdateList.insert(scriptInstance);
    }
    this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.swap, scriptInstanceOld);
    this.fire("swap", scriptType.__name, scriptInstance);
    this.fire("swap:" + scriptType.__name, scriptInstance);
    return true;
  }, resolveDuplicatedEntityReferenceProperties:function(oldScriptComponent, duplicatedIdsMap) {
    var newScriptComponent = this.entity.script;
    for (var scriptName in oldScriptComponent._scriptsIndex) {
      var scriptType = this.system.app.scripts.get(scriptName);
      if (!scriptType) {
        continue;
      }
      var script = oldScriptComponent._scriptsIndex[scriptName];
      if (!script || !script.instance) {
        continue;
      }
      var newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;
      var newAttributes = newScriptComponent[scriptName].__attributes;
      if (!newAttributesRaw && !newAttributes) {
        continue;
      }
      var oldAttributes = script.instance.__attributes;
      for (var attributeName in oldAttributes) {
        if (!oldAttributes[attributeName]) {
          continue;
        }
        var attribute = scriptType.attributes.get(attributeName);
        if (!attribute || attribute.type !== "entity") {
          continue;
        }
        if (attribute.array) {
          var oldGuidArray = oldAttributes[attributeName];
          var len = oldGuidArray.length;
          if (!len) {
            continue;
          }
          var newGuidArray = oldGuidArray.slice();
          for (var i = 0; i < len; i++) {
            var guid = newGuidArray[i] instanceof pc.Entity ? newGuidArray[i].getGuid() : newGuidArray[i];
            if (duplicatedIdsMap[guid]) {
              newGuidArray[i] = newAttributesRaw ? duplicatedIdsMap[guid].getGuid() : duplicatedIdsMap[guid];
            }
          }
          if (newAttributesRaw) {
            newAttributesRaw[attributeName] = newGuidArray;
          } else {
            newAttributes[attributeName] = newGuidArray;
          }
        } else {
          var oldGuid = oldAttributes[attributeName];
          if (oldGuid instanceof pc.Entity) {
            oldGuid = oldGuid.getGuid();
          } else {
            if (typeof oldGuid !== "string") {
              continue;
            }
          }
          if (duplicatedIdsMap[oldGuid]) {
            if (newAttributesRaw) {
              newAttributesRaw[attributeName] = duplicatedIdsMap[oldGuid].getGuid();
            } else {
              newAttributes[attributeName] = duplicatedIdsMap[oldGuid];
            }
          }
        }
      }
    }
  }, move:function(name, ind) {
    var len = this._scripts.length;
    if (ind >= len || ind < 0) {
      return false;
    }
    var scriptName = name;
    if (typeof scriptName !== "string") {
      scriptName = name.__name;
    }
    var scriptData = this._scriptsIndex[scriptName];
    if (!scriptData || !scriptData.instance) {
      return false;
    }
    var indOld = this._scripts.indexOf(scriptData.instance);
    if (indOld === -1 || indOld === ind) {
      return false;
    }
    this._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);
    this._resetExecutionOrder(0, len);
    this._updateList.sort();
    this._postUpdateList.sort();
    this.fire("move", scriptName, scriptData.instance, ind, indOld);
    this.fire("move:" + scriptName, scriptData.instance, ind, indOld);
    return true;
  }});
  Object.defineProperty(ScriptComponent.prototype, "enabled", {get:function() {
    return this._enabled;
  }, set:function(value) {
    var oldValue = this._enabled;
    this._enabled = value;
    this.fire("set", "enabled", oldValue, value);
  }});
  Object.defineProperty(ScriptComponent.prototype, "scripts", {get:function() {
    return this._scripts;
  }, set:function(value) {
    this._scriptsData = value;
    for (var key in value) {
      if (!value.hasOwnProperty(key)) {
        continue;
      }
      var script = this._scriptsIndex[key];
      if (script) {
        if (typeof value[key].enabled === "boolean") {
          script.enabled = !!value[key].enabled;
        }
        if (typeof value[key].attributes === "object") {
          for (var attr in value[key].attributes) {
            if (pc.createScript.reservedAttributes[attr]) {
              continue;
            }
            if (!script.__attributes.hasOwnProperty(attr)) {
              var scriptType = this.system.app.scripts.get(key);
              if (scriptType) {
                scriptType.attributes.add(attr, {});
              }
            }
            script[attr] = value[key].attributes[attr];
          }
        }
      } else {
        console.log(this.order);
      }
    }
  }});
  return {ScriptComponent:ScriptComponent};
}());
Object.assign(pc, function() {
  var METHOD_INITIALIZE_ATTRIBUTES = "_onInitializeAttributes";
  var METHOD_INITIALIZE = "_onInitialize";
  var METHOD_POST_INITIALIZE = "_onPostInitialize";
  var METHOD_UPDATE = "_onUpdate";
  var METHOD_POST_UPDATE = "_onPostUpdate";
  var executionOrderCounter = 0;
  var ScriptComponentSystem = function ScriptComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "script";
    this.app = app;
    this.ComponentType = pc.ScriptComponent;
    this.DataType = pc.ScriptComponentData;
    this._components = new pc.SortedLoopArray({sortBy:"_executionOrder"});
    this._enabledComponents = new pc.SortedLoopArray({sortBy:"_executionOrder"});
    this.preloading = true;
    this.on("beforeremove", this._onBeforeRemove, this);
    pc.ComponentSystem.bind("initialize", this._onInitialize, this);
    pc.ComponentSystem.bind("postInitialize", this._onPostInitialize, this);
    pc.ComponentSystem.bind("update", this._onUpdate, this);
    pc.ComponentSystem.bind("postUpdate", this._onPostUpdate, this);
  };
  ScriptComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  ScriptComponentSystem.prototype.constructor = ScriptComponentSystem;
  Object.assign(ScriptComponentSystem.prototype, {initializeComponentData:function(component, data) {
    component._executionOrder = executionOrderCounter++;
    this._components.append(component);
    if (executionOrderCounter > Number.MAX_SAFE_INTEGER) {
      this._resetExecutionOrder();
    }
    component.enabled = data.hasOwnProperty("enabled") ? !!data.enabled : true;
    if (component.enabled && component.entity.enabled) {
      this._enabledComponents.append(component);
    }
    if (data.hasOwnProperty("order") && data.hasOwnProperty("scripts")) {
      component._scriptsData = data.scripts;
      for (var i = 0; i < data.order.length; i++) {
        component.create(data.order[i], {enabled:data.scripts[data.order[i]].enabled, attributes:data.scripts[data.order[i]].attributes, preloading:this.preloading});
      }
    }
  }, cloneComponent:function(entity, clone) {
    var i, key;
    var order = [];
    var scripts = {};
    for (i = 0; i < entity.script._scripts.length; i++) {
      var scriptInstance = entity.script._scripts[i];
      var scriptName = scriptInstance.__scriptType.__name;
      order.push(scriptName);
      var attributes = {};
      for (key in scriptInstance.__attributes) {
        attributes[key] = scriptInstance.__attributes[key];
      }
      scripts[scriptName] = {enabled:scriptInstance._enabled, attributes:attributes};
    }
    for (key in entity.script._scriptsIndex) {
      if (key.awaiting) {
        order.splice(key.ind, 0, key);
      }
    }
    var data = {enabled:entity.script.enabled, order:order, scripts:scripts};
    return this.addComponent(clone, data);
  }, _resetExecutionOrder:function() {
    executionOrderCounter = 0;
    for (var i = 0, len = this._components.length; i < len; i++) {
      this._components.items[i]._executionOrder = executionOrderCounter++;
    }
  }, _callComponentMethod:function(components, name, dt) {
    for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
      components.items[components.loopIndex][name](dt);
    }
  }, _onInitialize:function() {
    this.preloading = false;
    this._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);
    this._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);
  }, _onPostInitialize:function() {
    this._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);
  }, _onUpdate:function(dt) {
    this._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);
  }, _onPostUpdate:function(dt) {
    this._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);
  }, _addComponentToEnabled:function(component) {
    this._enabledComponents.insert(component);
  }, _removeComponentFromEnabled:function(component) {
    this._enabledComponents.remove(component);
  }, _onBeforeRemove:function(entity, component) {
    var ind = this._components.items.indexOf(component);
    if (ind >= 0) {
      component._onBeforeRemove();
    }
    this._removeComponentFromEnabled(component);
    this._components.remove(component);
  }});
  return {ScriptComponentSystem:ScriptComponentSystem};
}());
Object.assign(pc, function() {
  var ScriptComponentData = function() {
    this.enabled = true;
  };
  return {ScriptComponentData:ScriptComponentData};
}());
Object.assign(pc, function() {
  var SIMPLE_PROPERTIES = ["emitterExtents", "emitterRadius", "loop", "initialVelocity", "animSpeed", "normalMap"];
  var COMPLEX_PROPERTIES = ["numParticles", "lifetime", "rate", "rate2", "startAngle", "startAngle2", "lighting", "halfLambert", "intensity", "wrap", "wrapBounds", "depthWrite", "noFog", "sort", "stretch", "alignToMotion", "preWarm", "emitterShape", "animTilesX", "animTilesY", "animNumFrames", "animLoop", "colorMap", "localSpace"];
  var GRAPH_PROPERTIES = ["scaleGraph", "scaleGraph2", "colorGraph", "colorGraph2", "alphaGraph", "alphaGraph2", "velocityGraph", "velocityGraph2", "localVelocityGraph", "localVelocityGraph2", "rotationSpeedGraph", "rotationSpeedGraph2"];
  var ASSET_PROPERTIES = ["colorMapAsset", "normalMapAsset", "meshAsset"];
  var depthLayer;
  var ParticleSystemComponent = function ParticleSystemComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this.on("set_colorMapAsset", this.onSetColorMapAsset, this);
    this.on("set_normalMapAsset", this.onSetNormalMapAsset, this);
    this.on("set_meshAsset", this.onSetMeshAsset, this);
    this.on("set_mesh", this.onSetMesh, this);
    this.on("set_loop", this.onSetLoop, this);
    this.on("set_blendType", this.onSetBlendType, this);
    this.on("set_depthSoftening", this.onSetDepthSoftening, this);
    this.on("set_layers", this.onSetLayers, this);
    SIMPLE_PROPERTIES.forEach(function(prop) {
      this.on("set_" + prop, this.onSetSimpleProperty, this);
    }.bind(this));
    COMPLEX_PROPERTIES.forEach(function(prop) {
      this.on("set_" + prop, this.onSetComplexProperty, this);
    }.bind(this));
    GRAPH_PROPERTIES.forEach(function(prop) {
      this.on("set_" + prop, this.onSetGraphProperty, this);
    }.bind(this));
    this._requestedDepth = false;
  };
  ParticleSystemComponent.prototype = Object.create(pc.Component.prototype);
  ParticleSystemComponent.prototype.constructor = ParticleSystemComponent;
  Object.assign(ParticleSystemComponent.prototype, {addModelToLayers:function() {
    if (!this.data.model) {
      return;
    }
    var layer;
    for (var i = 0; i < this.layers.length; i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.addMeshInstances(this.data.model.meshInstances);
      this.emitter._layer = layer;
    }
  }, removeModelFromLayers:function(model) {
    if (!this.data.model) {
      return;
    }
    var layer;
    for (var i = 0; i < this.layers.length; i++) {
      layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.removeMeshInstances(this.data.model.meshInstances);
    }
  }, onSetLayers:function(name, oldValue, newValue) {
    if (!this.data.model) {
      return;
    }
    var i, layer;
    for (i = 0; i < oldValue.length; i++) {
      layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
      if (!layer) {
        continue;
      }
      layer.removeMeshInstances(this.data.model.meshInstances);
    }
    if (!this.enabled || !this.entity.enabled) {
      return;
    }
    for (i = 0; i < newValue.length; i++) {
      layer = this.system.app.scene.layers.getLayerById(newValue[i]);
      if (!layer) {
        continue;
      }
      layer.addMeshInstances(this.data.model.meshInstances);
    }
  }, onLayersChanged:function(oldComp, newComp) {
    this.addModelToLayers();
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
  }, onLayerAdded:function(layer) {
    if (!this.data.model) {
      return;
    }
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    layer.addMeshInstances(this.data.model.meshInstances);
  }, onLayerRemoved:function(layer) {
    if (!this.data.model) {
      return;
    }
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    layer.removeMeshInstances(this.data.model.meshInstances);
  }, _bindColorMapAsset:function(asset) {
    asset.once("remove", this._onColorMapRemoved, this);
    if (asset.resource) {
      this.colorMap = asset.resource;
    } else {
      asset.once("load", this._onColorMapLoad, this);
      if (this.enabled && this.entity.enabled) {
        this.system.app.assets.load(asset);
      }
    }
  }, _unbindColorMapAsset:function(asset) {
    asset.off("remove", this._onColorMapRemoved, this);
    asset.off("load", this._onColorMapLoad, this);
  }, _onColorMapLoad:function(asset) {
    this.colorMap = asset.resource;
  }, _onColorMapRemoved:function(asset) {
    this.colorMapAsset = null;
  }, onSetColorMapAsset:function(name, oldValue, newValue) {
    var self = this;
    var asset;
    var assets = this.system.app.assets;
    if (oldValue) {
      asset = assets.get(oldValue);
      if (asset) {
        this._unbindColorMapAsset(asset);
      }
    }
    if (newValue) {
      if (newValue instanceof pc.Asset) {
        this.data.colorMapAsset = newValue.id;
        newValue = newValue.id;
      }
      asset = assets.get(newValue);
      if (asset) {
        self._bindColorMapAsset(asset);
      } else {
        assets.once("add:" + newValue, function(asset) {
          self._bindColorMapAsset(asset);
        });
      }
    } else {
      this.colorMap = null;
    }
  }, _bindNormalMapAsset:function(asset) {
    asset.once("remove", this._onNormalMapRemoved, this);
    if (asset.resource) {
      this.normalMap = asset.resource;
    } else {
      asset.once("load", this._onNormalMapLoad, this);
      if (this.enabled && this.entity.enabled) {
        this.system.app.assets.load(asset);
      }
    }
  }, _unbindNormalMapAsset:function(asset) {
    asset.off("remove", this._onNormalMapRemoved, this);
    asset.off("load", this._onNormalMapLoad, this);
  }, _onNormalMapLoad:function(asset) {
    this.normalMap = asset.resource;
  }, _onNormalMapRemoved:function(asset) {
    this.normalMapAsset = null;
  }, onSetNormalMapAsset:function(name, oldValue, newValue) {
    var self = this;
    var asset;
    var assets = this.system.app.assets;
    if (oldValue) {
      asset = assets.get(oldValue);
      if (asset) {
        this._unbindNormalMapAsset(asset);
      }
    }
    if (newValue) {
      if (newValue instanceof pc.Asset) {
        this.data.normalMapAsset = newValue.id;
        newValue = newValue.id;
      }
      asset = assets.get(newValue);
      if (asset) {
        self._bindNormalMapAsset(asset);
      } else {
        assets.once("add:" + newValue, function(asset) {
          self._bindNormalMapAsset(asset);
        });
      }
    } else {
      this.normalMap = null;
    }
  }, _bindMeshAsset:function(asset) {
    asset.on("remove", this._onMeshAssetRemoved, this);
    asset.on("load", this._onMeshAssetLoad, this);
  }, _unbindMeshAsset:function(asset) {
    asset.off("remove", this._onMeshAssetRemoved, this);
    asset.off("load", this._onMeshAssetLoad, this);
  }, _onMeshAssetLoad:function(asset) {
    this._onMeshChanged(asset.resource);
  }, onSetMeshAsset:function(name, oldValue, newValue) {
    var asset;
    var assets = this.system.app.assets;
    if (oldValue) {
      asset = assets.get(oldValue);
      if (asset) {
        this._unbindMeshAsset(asset);
      }
    }
    if (newValue) {
      if (newValue instanceof pc.Asset) {
        this.data.meshAsset = newValue.id;
        newValue = newValue.id;
      }
      asset = assets.get(newValue);
      if (asset) {
        this._bindMeshAsset(asset);
        if (asset.resource) {
          this._onMeshChanged(asset.resource);
        } else {
          assets.load(asset);
        }
      }
    } else {
      this._onMeshChanged(null);
    }
  }, onSetMesh:function(name, oldValue, newValue) {
    if (!newValue || newValue instanceof pc.Asset || typeof newValue === "number") {
      this.meshAsset = newValue;
    } else {
      this._onMeshChanged(newValue);
    }
  }, _onMeshChanged:function(mesh) {
    if (mesh && !(mesh instanceof pc.Mesh)) {
      if (mesh.meshInstances[0]) {
        mesh = mesh.meshInstances[0].mesh;
      } else {
        mesh = null;
      }
    }
    this.data.mesh = mesh;
    if (this.emitter) {
      this.emitter.mesh = mesh;
      this.emitter.resetMaterial();
      this.rebuild();
    }
  }, onMeshAssetRemoved:function(asset) {
    asset.off("remove", this.onMeshAssetRemoved, this);
    this.mesh = null;
  }, onSetLoop:function(name, oldValue, newValue) {
    if (this.emitter) {
      this.emitter[name] = newValue;
      this.emitter.resetTime();
    }
  }, onSetBlendType:function(name, oldValue, newValue) {
    if (this.emitter) {
      this.emitter[name] = newValue;
      this.emitter.material.blendType = newValue;
      this.emitter.resetMaterial();
      this.rebuild();
    }
  }, _requestDepth:function() {
    if (this._requestedDepth) {
      return;
    }
    if (!depthLayer) {
      depthLayer = this.system.app.scene.layers.getLayerById(pc.LAYERID_DEPTH);
    }
    if (depthLayer) {
      depthLayer.incrementCounter();
      this._requestedDepth = true;
    }
  }, _releaseDepth:function() {
    if (!this._requestedDepth) {
      return;
    }
    if (depthLayer) {
      depthLayer.decrementCounter();
      this._requestedDepth = false;
    }
  }, onSetDepthSoftening:function(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      if (newValue) {
        if (this.enabled && this.entity.enabled) {
          this._requestDepth();
        }
        if (this.emitter) {
          this.emitter[name] = newValue;
        }
      } else {
        if (this.enabled && this.entity.enabled) {
          this._releaseDepth();
        }
        if (this.emitter) {
          this.emitter[name] = newValue;
        }
      }
      if (this.emitter) {
        this.reset();
        this.emitter.resetMaterial();
        this.rebuild();
      }
    }
  }, onSetSimpleProperty:function(name, oldValue, newValue) {
    if (this.emitter) {
      this.emitter[name] = newValue;
      this.emitter.resetMaterial();
    }
  }, onSetComplexProperty:function(name, oldValue, newValue) {
    if (this.emitter) {
      this.emitter[name] = newValue;
      this.reset();
      this.emitter.resetMaterial();
      this.rebuild();
    }
  }, onSetGraphProperty:function(name, oldValue, newValue) {
    if (this.emitter) {
      this.emitter[name] = newValue;
      this.emitter.rebuildGraphs();
      this.emitter.resetMaterial();
    }
  }, onEnable:function() {
    var data = this.data;
    for (var i = 0, len = ASSET_PROPERTIES.length; i < len; i++) {
      var asset = data[ASSET_PROPERTIES[i]];
      if (asset) {
        if (!(asset instanceof pc.Asset)) {
          var id = parseInt(asset, 10);
          if (id >= 0) {
            asset = this.system.app.assets.get(asset);
          } else {
            continue;
          }
        }
        if (asset && !asset.resource) {
          this.system.app.assets.load(asset);
        }
      }
    }
    if (!this.emitter) {
      var mesh = data.mesh;
      if (!(mesh instanceof pc.Mesh)) {
        mesh = null;
      }
      this.emitter = new pc.ParticleEmitter(this.system.app.graphicsDevice, {numParticles:data.numParticles, emitterExtents:data.emitterExtents, emitterRadius:data.emitterRadius, emitterShape:data.emitterShape, initialVelocity:data.initialVelocity, wrap:data.wrap, localSpace:data.localSpace, wrapBounds:data.wrapBounds, lifetime:data.lifetime, rate:data.rate, rate2:data.rate2, animTilesX:data.animTilesX, animTilesY:data.animTilesY, animNumFrames:data.animNumFrames, animSpeed:data.animSpeed, animLoop:data.animLoop, 
      startAngle:data.startAngle, startAngle2:data.startAngle2, scaleGraph:data.scaleGraph, scaleGraph2:data.scaleGraph2, colorGraph:data.colorGraph, colorGraph2:data.colorGraph2, alphaGraph:data.alphaGraph, alphaGraph2:data.alphaGraph2, localVelocityGraph:data.localVelocityGraph, localVelocityGraph2:data.localVelocityGraph2, velocityGraph:data.velocityGraph, velocityGraph2:data.velocityGraph2, rotationSpeedGraph:data.rotationSpeedGraph, rotationSpeedGraph2:data.rotationSpeedGraph2, colorMap:data.colorMap, 
      normalMap:data.normalMap, loop:data.loop, preWarm:data.preWarm, sort:data.sort, stretch:data.stretch, alignToMotion:data.alignToMotion, lighting:data.lighting, halfLambert:data.halfLambert, intensity:data.intensity, depthSoftening:data.depthSoftening, scene:this.system.app.scene, mesh:mesh, depthWrite:data.depthWrite, noFog:data.noFog, node:this.entity, blendType:data.blendType});
      this.emitter.meshInstance.node = this.entity;
      this.psys = new pc.Model;
      this.psys.graph = this.entity;
      this.psys.emitter = this.emitter;
      this.psys.meshInstances = [this.emitter.meshInstance];
      data.model = this.psys;
      this.emitter.psys = this.psys;
      if (!data.autoPlay) {
        this.pause();
        this.emitter.meshInstance.visible = false;
      }
    }
    if (data.model && this.emitter.colorMap) {
      this.addModelToLayers();
    }
    this.system.app.scene.on("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.on("add", this.onLayerAdded, this);
      this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
    }
    if (this.enabled && this.entity.enabled && data.depthSoftening) {
      this._requestDepth();
    }
  }, onDisable:function() {
    this.system.app.scene.off("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.off("add", this.onLayerAdded, this);
      this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
    }
    if (this.data.model) {
      this.removeModelFromLayers();
      if (this.data.depthSoftening) {
        this._releaseDepth();
      }
    }
    if (this.emitter) {
      this.emitter.camera = null;
    }
  }, reset:function() {
    if (this.emitter) {
      this.emitter.reset();
    }
  }, stop:function() {
    if (this.emitter) {
      this.emitter.loop = false;
      this.emitter.resetTime();
      this.emitter.addTime(0, true);
    }
  }, pause:function() {
    this.data.paused = true;
  }, unpause:function() {
    this.data.paused = false;
  }, play:function() {
    this.data.paused = false;
    if (this.emitter) {
      this.emitter.meshInstance.visible = true;
      this.emitter.loop = this.data.loop;
      this.emitter.resetTime();
    }
  }, isPlaying:function() {
    if (this.data.paused) {
      return false;
    }
    if (this.emitter && this.emitter.loop) {
      return true;
    }
    return Date.now() <= this.emitter.endTime;
  }, rebuild:function() {
    var enabled = this.enabled;
    this.enabled = false;
    if (this.emitter) {
      this.emitter.rebuild();
      this.emitter.meshInstance.node = this.entity;
      this.data.model.meshInstances = [this.emitter.meshInstance];
    }
    this.enabled = enabled;
  }, onRemove:function() {
    var data = this.data;
    if (data.model) {
      this.entity.removeChild(data.model.getGraph());
      data.model.destroy();
      data.model = null;
    }
    if (this.emitter) {
      this.emitter.destroy();
      this.emitter = null;
    }
    for (var i = 0; i < ASSET_PROPERTIES.length; i++) {
      var prop = ASSET_PROPERTIES[i];
      if (data[prop]) {
        this[prop] = null;
      }
    }
    this.off();
  }});
  return {ParticleSystemComponent:ParticleSystemComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled", "autoPlay", "numParticles", "lifetime", "rate", "rate2", "startAngle", "startAngle2", "loop", "preWarm", "lighting", "halfLambert", "intensity", "depthWrite", "noFog", "depthSoftening", "sort", "blendType", "stretch", "alignToMotion", "emitterShape", "emitterExtents", "emitterRadius", "initialVelocity", "wrap", "wrapBounds", "localSpace", "colorMapAsset", "normalMapAsset", "mesh", "meshAsset", "localVelocityGraph", "localVelocityGraph2", "velocityGraph", "velocityGraph2", 
  "rotationSpeedGraph", "rotationSpeedGraph2", "scaleGraph", "scaleGraph2", "colorGraph", "colorGraph2", "alphaGraph", "alphaGraph2", "colorMap", "normalMap", "animTilesX", "animTilesY", "animNumFrames", "animSpeed", "animLoop", "layers"];
  var ParticleSystemComponentSystem = function ParticleSystemComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "particlesystem";
    this.description = "Updates and renders particle system in the scene.";
    this.ComponentType = pc.ParticleSystemComponent;
    this.DataType = pc.ParticleSystemComponentData;
    this.schema = _schema;
    this.propertyTypes = {emitterExtents:"vec3", wrapBounds:"vec3", localVelocityGraph:"curveset", localVelocityGraph2:"curveset", velocityGraph:"curveset", velocityGraph2:"curveset", colorGraph:"curveset", colorGraph2:"curveset", alphaGraph:"curve", alphaGraph2:"curve", rotationSpeedGraph:"curve", rotationSpeedGraph2:"curve", scaleGraph:"curve", scaleGraph2:"curve"};
    this.on("beforeremove", this.onRemove, this);
    pc.ComponentSystem.bind("update", this.onUpdate, this);
  };
  ParticleSystemComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  ParticleSystemComponentSystem.prototype.constructor = ParticleSystemComponentSystem;
  pc.Component._buildAccessors(pc.ParticleSystemComponent.prototype, _schema);
  Object.assign(ParticleSystemComponentSystem.prototype, {initializeComponentData:function(component, _data, properties) {
    var data = {};
    properties = [];
    var types = this.propertyTypes;
    var type;
    if (_data.mesh instanceof pc.Asset || typeof _data.mesh === "number") {
      _data.meshAsset = _data.mesh;
      delete _data.mesh;
    }
    for (var prop in _data) {
      if (_data.hasOwnProperty(prop)) {
        properties.push(prop);
        data[prop] = _data[prop];
      }
      if (types[prop] === "vec3") {
        if (pc.type(data[prop]) === "array") {
          data[prop] = new pc.Vec3(data[prop][0], data[prop][1], data[prop][2]);
        }
      } else {
        if (types[prop] === "curve") {
          if (!(data[prop] instanceof pc.Curve)) {
            type = data[prop].type;
            data[prop] = new pc.Curve(data[prop].keys);
            data[prop].type = type;
          }
        } else {
          if (types[prop] === "curveset") {
            if (!(data[prop] instanceof pc.CurveSet)) {
              type = data[prop].type;
              data[prop] = new pc.CurveSet(data[prop].keys);
              data[prop].type = type;
            }
          }
        }
      }
      if (data.layers && pc.type(data.layers) === "array") {
        data.layers = data.layers.slice(0);
      }
    }
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, cloneComponent:function(entity, clone) {
    var source = entity.particlesystem.data;
    var schema = this.schema;
    var data = {};
    for (var i = 0, len = schema.length; i < len; i++) {
      var prop = schema[i];
      var sourceProp = source[prop];
      if (sourceProp instanceof pc.Vec3 || sourceProp instanceof pc.Curve || sourceProp instanceof pc.CurveSet) {
        sourceProp = sourceProp.clone();
        data[prop] = sourceProp;
      } else {
        if (prop === "layers") {
          data.layers = source.layers.slice(0);
        } else {
          if (sourceProp !== null && sourceProp !== undefined) {
            data[prop] = sourceProp;
          }
        }
      }
    }
    return this.addComponent(clone, data);
  }, onUpdate:function(dt) {
    var components = this.store;
    var numSteps, i, j, c;
    var stats = this.app.stats.particles;
    for (var id in components) {
      if (components.hasOwnProperty(id)) {
        c = components[id];
        var entity = c.entity;
        var data = c.data;
        if (data.enabled && entity.enabled) {
          var emitter = data.model.emitter;
          if (!emitter.meshInstance.visible) {
            continue;
          }
          if (emitter.lighting) {
            var layer, lightCube;
            var layers = data.layers;
            for (i = 0; i < layers.length; i++) {
              layer = this.app.scene.layers.getLayerById(layers[i]);
              if (!layer) {
                continue;
              }
              if (!layer._lightCube) {
                layer._lightCube = new Float32Array(6 * 3);
              }
              lightCube = layer._lightCube;
              for (i = 0; i < 6; i++) {
                lightCube[i * 3] = this.app.scene.ambientLight.r;
                lightCube[i * 3 + 1] = this.app.scene.ambientLight.g;
                lightCube[i * 3 + 2] = this.app.scene.ambientLight.b;
              }
              var dirs = layer._sortedLights[pc.LIGHTTYPE_DIRECTIONAL];
              for (j = 0; j < dirs.length; j++) {
                for (c = 0; c < 6; c++) {
                  var weight = Math.max(emitter.lightCubeDir[c].dot(dirs[j]._direction), 0) * dirs[j]._intensity;
                  lightCube[c * 3] += dirs[j]._color.r * weight;
                  lightCube[c * 3 + 1] += dirs[j]._color.g * weight;
                  lightCube[c * 3 + 2] += dirs[j]._color.b * weight;
                }
              }
            }
            emitter.constantLightCube.setValue(lightCube);
          }
          if (!data.paused) {
            emitter.simTime += dt;
            if (emitter.simTime > emitter.fixedTimeStep) {
              numSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);
              emitter.simTime -= numSteps * emitter.fixedTimeStep;
            }
            if (numSteps) {
              numSteps = Math.min(numSteps, emitter.maxSubSteps);
              for (i = 0; i < numSteps; i++) {
                emitter.addTime(emitter.fixedTimeStep, false);
              }
              stats._updatesPerFrame += numSteps;
              stats._frameTime += emitter._addTimeTime;
              emitter._addTimeTime = 0;
            }
            emitter.finishFrame();
          }
        }
      }
    }
  }, onRemove:function(entity, component) {
    component.onRemove();
  }});
  return {ParticleSystemComponentSystem:ParticleSystemComponentSystem};
}());
Object.assign(pc, function() {
  var ParticleSystemComponentData = function() {
    this.numParticles = 1;
    this.rate = 1;
    this.rate2 = null;
    this.startAngle = 0;
    this.startAngle2 = null;
    this.lifetime = 50;
    this.emitterExtents = new pc.Vec3;
    this.emitterRadius = 0;
    this.emitterShape = pc.EMITTERSHAPE_BOX;
    this.initialVelocity = 0;
    this.wrapBounds = new pc.Vec3;
    this.localSpace = false;
    this.colorMap = null;
    this.colorMapAsset = null;
    this.normalMap = null;
    this.normalMapAsset = null;
    this.loop = true;
    this.preWarm = false;
    this.sort = 0;
    this.mode = pc.PARTICLEMODE_GPU;
    this.scene = null;
    this.lighting = false;
    this.halfLambert = false;
    this.intensity = 1;
    this.stretch = 0.0;
    this.alignToMotion = false;
    this.depthSoftening = 0;
    this.meshAsset = null;
    this.mesh = null;
    this.depthWrite = false;
    this.noFog = false;
    this.animTilesX = 1;
    this.animTilesY = 1;
    this.animNumFrames = 1;
    this.animSpeed = 1;
    this.animLoop = true;
    this.scaleGraph = null;
    this.scaleGraph2 = null;
    this.colorGraph = null;
    this.colorGraph2 = null;
    this.alphaGraph = null;
    this.alphaGraph2 = null;
    this.localVelocityGraph = null;
    this.localVelocityGraph2 = null;
    this.velocityGraph = null;
    this.velocityGraph2 = null;
    this.rotationSpeedGraph = null;
    this.rotationSpeedGraph2 = null;
    this.blendType = pc.BLEND_NORMAL;
    this.model = null;
    this.enabled = true;
    this.paused = false;
    this.autoPlay = true;
    this.layers = [pc.LAYERID_WORLD];
  };
  return {ParticleSystemComponentData:ParticleSystemComponentData};
}());
Object.assign(pc, function() {
  var SpriteAnimationClip = function(component, data) {
    this._component = component;
    this._frame = 0;
    this._sprite = null;
    this._spriteAsset = null;
    this.spriteAsset = data.spriteAsset;
    this.name = data.name;
    this.fps = data.fps || 0;
    this.loop = data.loop || false;
    this._playing = false;
    this._paused = false;
    this._time = 0;
    pc.events.attach(this);
  };
  Object.assign(SpriteAnimationClip.prototype, {_onSpriteAssetAdded:function(asset) {
    this._component.system.app.assets.off("add:" + asset.id, this._onSpriteAssetAdded, this);
    if (this._spriteAsset === asset.id) {
      this._bindSpriteAsset(asset);
    }
  }, _bindSpriteAsset:function(asset) {
    asset.on("load", this._onSpriteAssetLoad, this);
    asset.on("remove", this._onSpriteAssetRemove, this);
    if (asset.resource) {
      this._onSpriteAssetLoad(asset);
    } else {
      this._component.system.app.assets.load(asset);
    }
  }, _unbindSpriteAsset:function(asset) {
    asset.off("load", this._onSpriteAssetLoad, this);
    asset.off("remove", this._onSpriteAssetRemove, this);
    if (asset.resource && asset.resource.atlas) {
      this._component.system.app.assets.off("load:" + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
    }
  }, _onSpriteAssetLoad:function(asset) {
    if (!asset.resource) {
      this.sprite = null;
    } else {
      if (!asset.resource.atlas) {
        var atlasAssetId = asset.data.textureAtlasAsset;
        var assets = this._component.system.app.assets;
        assets.off("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
        assets.once("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
      } else {
        this.sprite = asset.resource;
      }
    }
  }, _onTextureAtlasLoad:function(atlasAsset) {
    var spriteAsset = this._spriteAsset;
    if (spriteAsset instanceof pc.Asset) {
      this._onSpriteAssetLoad(spriteAsset);
    } else {
      this._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));
    }
  }, _onSpriteAssetRemove:function(asset) {
    this.sprite = null;
  }, _onSpriteMeshesChange:function() {
    if (this._component.currentClip === this) {
      this._component._showFrame(this.frame);
    }
  }, _onSpritePpuChanged:function() {
    if (this._component.currentClip === this) {
      if (this.sprite.renderMode !== pc.SPRITE_RENDERMODE_SIMPLE) {
        this._component._showFrame(this.frame);
      }
    }
  }, _update:function(dt) {
    if (this.fps === 0) {
      return;
    }
    if (!this._playing || this._paused || !this._sprite) {
      return;
    }
    var dir = this.fps < 0 ? -1 : 1;
    var time = this._time + dt * this._component.speed * dir;
    var duration = this.duration;
    var end = time > duration || time < 0;
    this._setTime(time);
    var frame = this.frame;
    if (this._sprite) {
      frame = Math.floor(this._sprite.frameKeys.length * this._time / duration);
    } else {
      frame = 0;
    }
    if (frame !== this._frame) {
      this._setFrame(frame);
    }
    if (end) {
      if (this.loop) {
        this.fire("loop");
        this._component.fire("loop", this);
      } else {
        this._playing = false;
        this._paused = false;
        this.fire("end");
        this._component.fire("end", this);
      }
    }
  }, _setTime:function(value) {
    this._time = value;
    var duration = this.duration;
    if (this._time < 0) {
      if (this.loop) {
        this._time = this._time % duration + duration;
      } else {
        this._time = 0;
      }
    } else {
      if (this._time > duration) {
        if (this.loop) {
          this._time = this._time % duration;
        } else {
          this._time = duration;
        }
      }
    }
  }, _setFrame:function(value) {
    if (this._sprite) {
      this._frame = pc.math.clamp(value, 0, this._sprite.frameKeys.length - 1);
    } else {
      this._frame = value;
    }
    if (this._component.currentClip === this) {
      this._component._showFrame(this._frame);
    }
  }, _destroy:function() {
    if (this._sprite) {
      this.sprite = null;
    }
    if (this._spriteAsset) {
      this.spriteAsset = null;
    }
  }, play:function() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    this._paused = false;
    this.frame = 0;
    this.fire("play");
    this._component.fire("play", this);
  }, pause:function() {
    if (!this._playing || this._paused) {
      return;
    }
    this._paused = true;
    this.fire("pause");
    this._component.fire("pause", this);
  }, resume:function() {
    if (!this._paused) {
      return;
    }
    this._paused = false;
    this.fire("resume");
    this._component.fire("resume", this);
  }, stop:function() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    this._paused = false;
    this._time = 0;
    this.frame = 0;
    this.fire("stop");
    this._component.fire("stop", this);
  }});
  Object.defineProperty(SpriteAnimationClip.prototype, "spriteAsset", {get:function() {
    return this._spriteAsset;
  }, set:function(value) {
    var assets = this._component.system.app.assets;
    var id = value;
    if (value instanceof pc.Asset) {
      id = value.id;
    }
    if (this._spriteAsset !== id) {
      if (this._spriteAsset) {
        var prev = assets.get(this._spriteAsset);
        if (prev) {
          this._unbindSpriteAsset(prev);
        }
      }
      this._spriteAsset = id;
      if (this._spriteAsset) {
        var asset = assets.get(this._spriteAsset);
        if (!asset) {
          this.sprite = null;
          assets.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this);
        } else {
          this._bindSpriteAsset(asset);
        }
      } else {
        this.sprite = null;
      }
    }
  }});
  Object.defineProperty(SpriteAnimationClip.prototype, "sprite", {get:function() {
    return this._sprite;
  }, set:function(value) {
    if (this._sprite) {
      this._sprite.off("set:meshes", this._onSpriteMeshesChange, this);
      this._sprite.off("set:pixelsPerUnit", this._onSpritePpuChanged, this);
      this._sprite.off("set:atlas", this._onSpriteMeshesChange, this);
      if (this._sprite.atlas) {
        this._sprite.atlas.off("set:texture", this._onSpriteMeshesChange, this);
      }
    }
    this._sprite = value;
    if (this._sprite) {
      this._sprite.on("set:meshes", this._onSpriteMeshesChange, this);
      this._sprite.on("set:pixelsPerUnit", this._onSpritePpuChanged, this);
      this._sprite.on("set:atlas", this._onSpriteMeshesChange, this);
      if (this._sprite.atlas) {
        this._sprite.atlas.on("set:texture", this._onSpriteMeshesChange, this);
      }
    }
    if (this._component.currentClip === this) {
      var mi;
      if (!value || !value.atlas) {
        mi = this._component._meshInstance;
        if (mi) {
          mi.deleteParameter("texture_emissiveMap");
          mi.deleteParameter("texture_opacityMap");
        }
        this._component._hideModel();
      } else {
        if (value.atlas.texture) {
          mi = this._component._meshInstance;
          if (mi) {
            mi.setParameter("texture_emissiveMap", value.atlas.texture);
            mi.setParameter("texture_opacityMap", value.atlas.texture);
          }
          if (this._component.enabled && this._component.entity.enabled) {
            this._component._showModel();
          }
        }
        if (this.time && this.fps) {
          this.time = this.time;
        } else {
          this.frame = this.frame;
        }
      }
    }
  }});
  Object.defineProperty(SpriteAnimationClip.prototype, "frame", {get:function() {
    return this._frame;
  }, set:function(value) {
    this._setFrame(value);
    var fps = this.fps || Number.MIN_VALUE;
    this._setTime(this._frame / fps);
  }});
  Object.defineProperty(SpriteAnimationClip.prototype, "isPlaying", {get:function() {
    return this._playing;
  }});
  Object.defineProperty(SpriteAnimationClip.prototype, "isPaused", {get:function() {
    return this._paused;
  }});
  Object.defineProperty(SpriteAnimationClip.prototype, "duration", {get:function() {
    if (this._sprite) {
      var fps = this.fps || Number.MIN_VALUE;
      return this._sprite.frameKeys.length / Math.abs(fps);
    }
    return 0;
  }});
  Object.defineProperty(SpriteAnimationClip.prototype, "time", {get:function() {
    return this._time;
  }, set:function(value) {
    this._setTime(value);
    if (this._sprite) {
      this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));
    } else {
      this.frame = 0;
    }
  }});
  return {SpriteAnimationClip:SpriteAnimationClip};
}());
Object.assign(pc, function() {
  pc.SPRITETYPE_SIMPLE = "simple";
  pc.SPRITETYPE_ANIMATED = "animated";
  var PARAM_EMISSIVE_MAP = "texture_emissiveMap";
  var PARAM_OPACITY_MAP = "texture_opacityMap";
  var PARAM_EMISSIVE = "material_emissive";
  var PARAM_OPACITY = "material_opacity";
  var PARAM_INNER_OFFSET = "innerOffset";
  var PARAM_OUTER_SCALE = "outerScale";
  var PARAM_ATLAS_RECT = "atlasRect";
  var SpriteComponent = function SpriteComponent(system, entity) {
    pc.Component.call(this, system, entity);
    this._type = pc.SPRITETYPE_SIMPLE;
    this._material = system.defaultMaterial;
    this._color = new pc.Color(1, 1, 1, 1);
    this._colorUniform = new Float32Array(3);
    this._speed = 1;
    this._flipX = false;
    this._flipY = false;
    this._width = 1;
    this._height = 1;
    this._drawOrder = 0;
    this._layers = [pc.LAYERID_WORLD];
    this._outerScale = new pc.Vec2(1, 1);
    this._outerScaleUniform = new Float32Array(2);
    this._innerOffset = new pc.Vec4;
    this._innerOffsetUniform = new Float32Array(4);
    this._atlasRect = new pc.Vec4;
    this._atlasRectUniform = new Float32Array(4);
    this._batchGroupId = -1;
    this._batchGroup = null;
    this._node = new pc.GraphNode;
    this._model = new pc.Model;
    this._model.graph = this._node;
    this._meshInstance = null;
    entity.addChild(this._model.graph);
    this._model._entity = entity;
    this._updateAabbFunc = this._updateAabb.bind(this);
    this._addedModel = false;
    this._autoPlayClip = null;
    this._clips = {};
    this._defaultClip = new pc.SpriteAnimationClip(this, {name:this.entity.name, fps:0, loop:false, spriteAsset:null});
    this._currentClip = this._defaultClip;
  };
  SpriteComponent.prototype = Object.create(pc.Component.prototype);
  SpriteComponent.prototype.constructor = SpriteComponent;
  Object.assign(SpriteComponent.prototype, {onEnable:function() {
    var app = this.system.app;
    var scene = app.scene;
    scene.on("set:layers", this._onLayersChanged, this);
    if (scene.layers) {
      scene.layers.on("add", this._onLayerAdded, this);
      scene.layers.on("remove", this._onLayerRemoved, this);
    }
    this._showModel();
    if (this._autoPlayClip) {
      this._tryAutoPlay();
    }
    if (this._batchGroupId >= 0) {
      app.batcher.insert(pc.BatchGroup.SPRITE, this._batchGroupId, this.entity);
    }
  }, onDisable:function() {
    var app = this.system.app;
    var scene = app.scene;
    scene.off("set:layers", this._onLayersChanged, this);
    if (scene.layers) {
      scene.layers.off("add", this._onLayerAdded, this);
      scene.layers.off("remove", this._onLayerRemoved, this);
    }
    this.stop();
    this._hideModel();
    if (this._batchGroupId >= 0) {
      app.batcher.remove(pc.BatchGroup.SPRITE, this._batchGroupId, this.entity);
    }
  }, onDestroy:function() {
    this._currentClip = null;
    if (this._defaultClip) {
      this._defaultClip._destroy();
      this._defaultClip = null;
    }
    for (var key in this._clips) {
      this._clips[key]._destroy();
    }
    this._clips = null;
    this._hideModel();
    this._model = null;
    if (this._node) {
      if (this._node.parent) {
        this._node.parent.removeChild(this._node);
      }
      this._node = null;
    }
    if (this._meshInstance) {
      this._meshInstance.material = null;
      this._meshInstance.mesh = null;
      this._meshInstance = null;
    }
  }, _showModel:function() {
    if (this._addedModel) {
      return;
    }
    if (!this._meshInstance) {
      return;
    }
    var i;
    var len;
    var meshInstances = [this._meshInstance];
    for (i = 0, len = this._layers.length; i < len; i++) {
      var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
      if (layer) {
        layer.addMeshInstances(meshInstances);
      }
    }
    this._addedModel = true;
  }, _hideModel:function() {
    if (!this._addedModel || !this._meshInstance) {
      return;
    }
    var i;
    var len;
    var meshInstances = [this._meshInstance];
    for (i = 0, len = this._layers.length; i < len; i++) {
      var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
      if (layer) {
        layer.removeMeshInstances(meshInstances);
      }
    }
    this._addedModel = false;
  }, _showFrame:function(frame) {
    if (!this.sprite) {
      return;
    }
    var mesh = this.sprite.meshes[frame];
    if (!mesh) {
      if (this._meshInstance) {
        this._meshInstance.mesh = null;
        this._meshInstance.visible = false;
      }
      return;
    }
    var material = this.system.defaultMaterial;
    if (this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED) {
      material = this.system.default9SlicedMaterialSlicedMode;
    } else {
      if (this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED) {
        material = this.system.default9SlicedMaterialTiledMode;
      }
    }
    if (!this._meshInstance) {
      this._meshInstance = new pc.MeshInstance(this._node, mesh, this._material);
      this._meshInstance.castShadow = false;
      this._meshInstance.receiveShadow = false;
      this._meshInstance.drawOrder = this._drawOrder;
      this._model.meshInstances.push(this._meshInstance);
      this._colorUniform[0] = this._color.r;
      this._colorUniform[1] = this._color.g;
      this._colorUniform[2] = this._color.b;
      this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
      this._meshInstance.setParameter(PARAM_OPACITY, this._color.a);
      if (this.enabled && this.entity.enabled) {
        this._showModel();
      }
    }
    if (this._meshInstance.material !== material) {
      this._meshInstance.material = material;
    }
    if (this._meshInstance.mesh !== mesh) {
      this._meshInstance.mesh = mesh;
      this._meshInstance.visible = true;
      this._meshInstance._aabbVer = -1;
    }
    if (this.sprite.atlas && this.sprite.atlas.texture) {
      this._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);
      this._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);
    } else {
      this._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);
      this._meshInstance.deleteParameter(PARAM_OPACITY_MAP);
    }
    if (this.sprite.atlas && (this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED)) {
      this._meshInstance._updateAabbFunc = this._updateAabbFunc;
      var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];
      if (frameData) {
        var borderWidthScale = 2 / frameData.rect.z;
        var borderHeightScale = 2 / frameData.rect.w;
        this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);
        var tex = this.sprite.atlas.texture;
        this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
      } else {
        this._innerOffset.set(0, 0, 0, 0);
      }
      this._innerOffsetUniform[0] = this._innerOffset.x;
      this._innerOffsetUniform[1] = this._innerOffset.y;
      this._innerOffsetUniform[2] = this._innerOffset.z;
      this._innerOffsetUniform[3] = this._innerOffset.w;
      this._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);
      this._atlasRectUniform[0] = this._atlasRect.x;
      this._atlasRectUniform[1] = this._atlasRect.y;
      this._atlasRectUniform[2] = this._atlasRect.z;
      this._atlasRectUniform[3] = this._atlasRect.w;
      this._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);
    } else {
      this._meshInstance._updateAabbFunc = null;
    }
    this._updateTransform();
  }, _updateTransform:function() {
    var scaleX = this.flipX ? -1 : 1;
    var scaleY = this.flipY ? -1 : 1;
    var posX = 0;
    var posY = 0;
    if (this.sprite && (this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED)) {
      var w = 1;
      var h = 1;
      if (this.sprite.atlas) {
        var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];
        if (frameData) {
          w = frameData.rect.z;
          h = frameData.rect.w;
          posX = (0.5 - frameData.pivot.x) * this._width;
          posY = (0.5 - frameData.pivot.y) * this._height;
        }
      }
      var scaleMulX = w / this.sprite.pixelsPerUnit;
      var scaleMulY = h / this.sprite.pixelsPerUnit;
      this._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));
      scaleX *= scaleMulX;
      scaleY *= scaleMulY;
      this._outerScale.x /= scaleMulX;
      this._outerScale.y /= scaleMulY;
      scaleX *= pc.math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);
      scaleY *= pc.math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);
      if (this._meshInstance) {
        this._outerScaleUniform[0] = this._outerScale.x;
        this._outerScaleUniform[1] = this._outerScale.y;
        this._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform, 4294967295);
      }
    }
    this._node.setLocalScale(scaleX, scaleY, 1);
    this._node.setLocalPosition(posX, posY, 0);
  }, _updateAabb:function(aabb) {
    aabb.center.set(0, 0, 0);
    aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
    aabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());
    return aabb;
  }, _tryAutoPlay:function() {
    if (!this._autoPlayClip) {
      return;
    }
    if (this.type !== pc.SPRITETYPE_ANIMATED) {
      return;
    }
    var clip = this._clips[this._autoPlayClip];
    if (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {
      if (this.enabled && this.entity.enabled) {
        this.play(clip.name);
      }
    }
  }, _onLayersChanged:function(oldComp, newComp) {
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
    if (this.enabled && this.entity.enabled) {
      this._showModel();
    }
  }, _onLayerAdded:function(layer) {
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    if (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {
      layer.addMeshInstances([this._meshInstance]);
    }
  }, _onLayerRemoved:function(layer) {
    if (!this._meshInstance) {
      return;
    }
    var index = this.layers.indexOf(layer.id);
    if (index < 0) {
      return;
    }
    layer.removeMeshInstances([this._meshInstance]);
  }, addClip:function(data) {
    var clip = new pc.SpriteAnimationClip(this, {name:data.name, fps:data.fps, loop:data.loop, spriteAsset:data.spriteAsset});
    this._clips[data.name] = clip;
    if (clip.name && clip.name === this._autoPlayClip) {
      this._tryAutoPlay();
    }
    return clip;
  }, removeClip:function(name) {
    delete this._clips[name];
  }, clip:function(name) {
    return this._clips[name];
  }, play:function(name) {
    var clip = this._clips[name];
    var current = this._currentClip;
    if (current && current !== clip) {
      current._playing = false;
    }
    this._currentClip = clip;
    if (this._currentClip) {
      this._currentClip = clip;
      this._currentClip.play();
    } else {
      logWARNING("Trying to play sprite animation " + name + " which does not exist.");
    }
    return clip;
  }, pause:function() {
    if (this._currentClip === this._defaultClip) {
      return;
    }
    if (this._currentClip.isPlaying) {
      this._currentClip.pause();
    }
  }, resume:function() {
    if (this._currentClip === this._defaultClip) {
      return;
    }
    if (this._currentClip.isPaused) {
      this._currentClip.resume();
    }
  }, stop:function() {
    if (this._currentClip === this._defaultClip) {
      return;
    }
    this._currentClip.stop();
  }});
  Object.defineProperty(SpriteComponent.prototype, "type", {get:function() {
    return this._type;
  }, set:function(value) {
    if (this._type === value) {
      return;
    }
    this._type = value;
    if (this._type === pc.SPRITETYPE_SIMPLE) {
      this.stop();
      this._currentClip = this._defaultClip;
      if (this.enabled && this.entity.enabled) {
        this._currentClip.frame = this.frame;
        if (this._currentClip.sprite) {
          this._showModel();
        } else {
          this._hideModel();
        }
      }
    } else {
      if (this._type === pc.SPRITETYPE_ANIMATED) {
        this.stop();
        if (this._autoPlayClip) {
          this._tryAutoPlay();
        }
        if (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {
          this._showModel();
        } else {
          this._hideModel();
        }
      }
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "frame", {get:function() {
    return this._currentClip.frame;
  }, set:function(value) {
    this._currentClip.frame = value;
  }});
  Object.defineProperty(SpriteComponent.prototype, "spriteAsset", {get:function() {
    return this._defaultClip._spriteAsset;
  }, set:function(value) {
    this._defaultClip.spriteAsset = value;
  }});
  Object.defineProperty(SpriteComponent.prototype, "sprite", {get:function() {
    return this._currentClip.sprite;
  }, set:function(value) {
    this._currentClip.sprite = value;
  }});
  Object.defineProperty(SpriteComponent.prototype, "material", {get:function() {
    return this._material;
  }, set:function(value) {
    this._material = value;
    if (this._meshInstance) {
      this._meshInstance.material = value;
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "color", {get:function() {
    return this._color;
  }, set:function(value) {
    this._color.r = value.r;
    this._color.g = value.g;
    this._color.b = value.b;
    if (this._meshInstance) {
      this._colorUniform[0] = this._color.r;
      this._colorUniform[1] = this._color.g;
      this._colorUniform[2] = this._color.b;
      this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "opacity", {get:function() {
    return this._color.a;
  }, set:function(value) {
    this._color.a = value;
    if (this._meshInstance) {
      this._meshInstance.setParameter(PARAM_OPACITY, value);
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "clips", {get:function() {
    return this._clips;
  }, set:function(value) {
    var name, key;
    if (!value) {
      for (name in this._clips) {
        this.removeClip(name);
      }
      return;
    }
    for (name in this._clips) {
      var found = false;
      for (key in value) {
        if (value[key].name === name) {
          found = true;
          this._clips[name].fps = value[key].fps;
          this._clips[name].loop = value[key].loop;
          if (value[key].hasOwnProperty("sprite")) {
            this._clips[name].sprite = value[key].sprite;
          } else {
            if (value[key].hasOwnProperty("spriteAsset")) {
              this._clips[name].spriteAsset = value[key].spriteAsset;
            }
          }
          break;
        }
      }
      if (!found) {
        this.removeClip(name);
      }
    }
    for (key in value) {
      if (this._clips[value[key].name]) {
        continue;
      }
      this.addClip(value[key]);
    }
    if (this._autoPlayClip) {
      this._tryAutoPlay();
    }
    if (!this._currentClip || !this._currentClip.sprite) {
      this._hideModel();
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "currentClip", {get:function() {
    return this._currentClip;
  }});
  Object.defineProperty(SpriteComponent.prototype, "speed", {get:function() {
    return this._speed;
  }, set:function(value) {
    this._speed = value;
  }});
  Object.defineProperty(SpriteComponent.prototype, "flipX", {get:function() {
    return this._flipX;
  }, set:function(value) {
    if (this._flipX === value) {
      return;
    }
    this._flipX = value;
    this._updateTransform();
  }});
  Object.defineProperty(SpriteComponent.prototype, "flipY", {get:function() {
    return this._flipY;
  }, set:function(value) {
    if (this._flipY === value) {
      return;
    }
    this._flipY = value;
    this._updateTransform();
  }});
  Object.defineProperty(SpriteComponent.prototype, "width", {get:function() {
    return this._width;
  }, set:function(value) {
    if (value === this._width) {
      return;
    }
    this._width = value;
    this._outerScale.x = this._width;
    if (this.sprite && (this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED || this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED)) {
      this._updateTransform();
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "height", {get:function() {
    return this._height;
  }, set:function(value) {
    if (value === this._height) {
      return;
    }
    this._height = value;
    this._outerScale.y = this.height;
    if (this.sprite && (this.sprite.renderMode === pc.SPRITE_RENDERMODE_TILED || this.sprite.renderMode === pc.SPRITE_RENDERMODE_SLICED)) {
      this._updateTransform();
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "batchGroupId", {get:function() {
    return this._batchGroupId;
  }, set:function(value) {
    if (this._batchGroupId === value) {
      return;
    }
    var prev = this._batchGroupId;
    this._batchGroupId = value;
    if (this.entity.enabled && prev >= 0) {
      this.system.app.batcher.remove(pc.BatchGroup.SPRITE, prev, this.entity);
    }
    if (this.entity.enabled && value >= 0) {
      this.system.app.batcher.insert(pc.BatchGroup.SPRITE, value, this.entity);
    } else {
      if (prev >= 0) {
        if (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {
          this._showModel();
        }
      }
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "autoPlayClip", {get:function() {
    return this._autoPlayClip;
  }, set:function(value) {
    this._autoPlayClip = value instanceof pc.SpriteAnimationClip ? value.name : value;
    this._tryAutoPlay();
  }});
  Object.defineProperty(SpriteComponent.prototype, "drawOrder", {get:function() {
    return this._drawOrder;
  }, set:function(value) {
    this._drawOrder = value;
    if (this._meshInstance) {
      this._meshInstance.drawOrder = value;
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "layers", {get:function() {
    return this._layers;
  }, set:function(value) {
    if (this._addedModel) {
      this._hideModel();
    }
    this._layers = value;
    if (!this._meshInstance) {
      return;
    }
    if (this.enabled && this.entity.enabled) {
      this._showModel();
    }
  }});
  Object.defineProperty(SpriteComponent.prototype, "aabb", {get:function() {
    if (this._meshInstance) {
      return this._meshInstance.aabb;
    }
    return null;
  }});
  return {SpriteComponent:SpriteComponent};
}());
Object.assign(pc, function() {
  var _schema = ["enabled"];
  var SpriteComponentSystem = function SpriteComponentSystem(app) {
    pc.ComponentSystem.call(this, app);
    this.id = "sprite";
    this.app = app;
    this.ComponentType = pc.SpriteComponent;
    this.DataType = pc.SpriteComponentData;
    this.schema = _schema;
    this._defaultTexture = new pc.Texture(app.graphicsDevice, {width:1, height:1, format:pc.PIXELFORMAT_R8_G8_B8_A8});
    var pixels = this._defaultTexture.lock();
    var pixelData = new Uint8Array(4);
    pixelData[0] = 255.0;
    pixelData[1] = 255.0;
    pixelData[2] = 255.0;
    pixelData[3] = 255.0;
    pixels.set(pixelData);
    this._defaultTexture.name = "sprite";
    this._defaultTexture.unlock();
    this.defaultMaterial = new pc.StandardMaterial;
    this.defaultMaterial.diffuse = new pc.Color(0, 0, 0, 1);
    this.defaultMaterial.emissive = new pc.Color(0.5, 0.5, 0.5, 1);
    this.defaultMaterial.emissiveMap = this._defaultTexture;
    this.defaultMaterial.emissiveMapTint = true;
    this.defaultMaterial.opacityMap = this._defaultTexture;
    this.defaultMaterial.opacityMapChannel = "a";
    this.defaultMaterial.opacityTint = true;
    this.defaultMaterial.opacity = 0;
    this.defaultMaterial.useLighting = false;
    this.defaultMaterial.useGammaTonemap = false;
    this.defaultMaterial.useFog = false;
    this.defaultMaterial.useSkybox = false;
    this.defaultMaterial.blendType = pc.BLEND_PREMULTIPLIED;
    this.defaultMaterial.depthWrite = false;
    this.defaultMaterial.pixelSnap = false;
    this.defaultMaterial.cull = pc.CULLFACE_NONE;
    this.defaultMaterial.update();
    this.default9SlicedMaterialSlicedMode = this.defaultMaterial.clone();
    this.default9SlicedMaterialSlicedMode.nineSlicedMode = pc.SPRITE_RENDERMODE_SLICED;
    this.default9SlicedMaterialSlicedMode.update();
    this.default9SlicedMaterialTiledMode = this.defaultMaterial.clone();
    this.default9SlicedMaterialTiledMode.nineSlicedMode = pc.SPRITE_RENDERMODE_TILED;
    this.default9SlicedMaterialTiledMode.update();
    pc.ComponentSystem.bind("update", this.onUpdate, this);
    this.on("beforeremove", this.onBeforeRemove, this);
  };
  SpriteComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
  SpriteComponentSystem.prototype.constructor = SpriteComponentSystem;
  pc.Component._buildAccessors(pc.SpriteComponent.prototype, _schema);
  Object.assign(SpriteComponentSystem.prototype, {destroy:function() {
    this._defaultTexture.destroy();
    this._defaultTexture = null;
  }, initializeComponentData:function(component, data, properties) {
    if (data.enabled !== undefined) {
      component.enabled = data.enabled;
    }
    component.type = data.type;
    if (data.layers && pc.type(data.layers) === "array") {
      component.layers = data.layers.slice(0);
    }
    if (data.drawOrder !== undefined) {
      component.drawOrder = data.drawOrder;
    }
    if (data.color !== undefined) {
      if (data.color instanceof pc.Color) {
        component.color.set(data.color.r, data.color.g, data.color.b, data.opacity !== undefined ? data.opacity : 1);
      } else {
        component.color.set(data.color[0], data.color[1], data.color[2], data.opacity !== undefined ? data.opacity : 1);
      }
      component.color = component.color;
    }
    if (data.opacity !== undefined) {
      component.opacity = data.opacity;
    }
    if (data.flipX !== undefined) {
      component.flipX = data.flipX;
    }
    if (data.flipY !== undefined) {
      component.flipY = data.flipY;
    }
    if (data.width !== undefined) {
      component.width = data.width;
    }
    if (data.height !== undefined) {
      component.height = data.height;
    }
    if (data.spriteAsset !== undefined) {
      component.spriteAsset = data.spriteAsset;
    }
    if (data.sprite) {
      component.sprite = data.sprite;
    }
    if (data.frame !== undefined) {
      component.frame = data.frame;
    }
    if (data.clips) {
      for (var name in data.clips) {
        component.addClip(data.clips[name]);
      }
    }
    if (data.speed !== undefined) {
      component.speed = data.speed;
    }
    if (data.autoPlayClip) {
      component.autoPlayClip = data.autoPlayClip;
    }
    component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;
    pc.ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
  }, cloneComponent:function(entity, clone) {
    var source = entity.sprite;
    return this.addComponent(clone, {enabled:source.enabled, type:source.type, spriteAsset:source.spriteAsset, sprite:source.sprite, frame:source.frame, color:source.color.clone(), opacity:source.opacity, flipX:source.flipX, flipY:source.flipY, speed:source.speed, clips:source.clips, autoPlayClip:source.autoPlayClip, batchGroupId:source.batchGroupId, drawOrder:source.drawOrder, layers:source.layers.slice(0)});
  }, onUpdate:function(dt) {
    var components = this.store;
    for (var id in components) {
      if (components.hasOwnProperty(id)) {
        var component = components[id];
        if (component.data.enabled && component.entity.enabled) {
          var sprite = component.entity.sprite;
          if (sprite._currentClip) {
            sprite._currentClip._update(dt);
          }
        }
      }
    }
  }, onBeforeRemove:function(entity, component) {
    component.onDestroy();
  }});
  return {SpriteComponentSystem:SpriteComponentSystem};
}());
Object.assign(pc, function() {
  var SpriteComponentData = function() {
    this.enabled = true;
  };
  return {SpriteComponentData:SpriteComponentData};
}());
Object.assign(pc, function() {
  pc.FONT_MSDF = "msdf";
  pc.FONT_BITMAP = "bitmap";
  var Font = function(textures, data) {
    this.type = data ? data.type || pc.FONT_MSDF : pc.FONT_MSDF;
    this.em = 1;
    this.textures = textures;
    this.intensity = 0.0;
    this._data = null;
    this.data = data;
  };
  Object.defineProperty(Font.prototype, "data", {get:function() {
    return this._data;
  }, set:function(value) {
    this._data = value;
    if (!value) {
      return;
    }
    if (this._data.intensity !== undefined) {
      this.intensity = this._data.intensity;
    }
    if (!this._data.info) {
      this._data.info = {};
    }
    if (!this._data.version || this._data.version < 2) {
      this._data.info.maps = [{width:this._data.info.width, height:this._data.info.height}];
      if (this._data.chars) {
        for (var key in this._data.chars) {
          this._data.chars[key].map = 0;
        }
      }
    }
  }});
  return {FONT_MSDF:pc.FONT_MSDF, Font:Font};
}());
Object.assign(pc, function() {
  var MAX_TEXTURE_SIZE = 4096;
  var DEFAULT_TEXTURE_SIZE = 512;
  var CanvasFont = function(app, options) {
    this.type = "bitmap";
    this.app = app;
    this.intensity = 0;
    options = options || {};
    this.fontWeight = options.fontWeight || "normal";
    this.fontSize = parseInt(options.fontSize, 10);
    this.glyphSize = this.fontSize;
    this.fontName = options.fontName || "Arial";
    this.color = options.color || new pc.Color(1, 1, 1);
    var w = options.width > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : options.width || DEFAULT_TEXTURE_SIZE;
    var h = options.height > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : options.height || DEFAULT_TEXTURE_SIZE;
    var canvas = document.createElement("canvas");
    canvas.height = h;
    canvas.width = w;
    var texture = new pc.Texture(this.app.graphicsDevice, {format:pc.PIXELFORMAT_R8_G8_B8_A8, autoMipmap:true});
    texture.name = "font";
    texture.setSource(canvas);
    texture.minFilter = pc.FILTER_LINEAR_MIPMAP_LINEAR;
    texture.magFilter = pc.FILTER_LINEAR;
    texture.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
    texture.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
    this.textures = [texture];
    this.chars = "";
    this.data = {};
    pc.events.attach(this);
  };
  CanvasFont.prototype.createTextures = function(text) {
    var _chars = this._normalizeCharsSet(text);
    if (_chars.length !== this.chars.length) {
      this._renderAtlas(_chars);
      return;
    }
    for (var i = 0; i < _chars.length; i++) {
      if (_chars[i] !== this.chars[i]) {
        this._renderAtlas(_chars);
        return;
      }
    }
  };
  CanvasFont.prototype.updateTextures = function(text) {
    var _chars = this._normalizeCharsSet(text);
    var newCharsSet = [];
    for (var i = 0; i < _chars.length; i++) {
      var char = _chars[i];
      if (!this.data.chars[char]) {
        newCharsSet.push(char);
      }
    }
    if (newCharsSet.length > 0) {
      this._renderAtlas(this.chars.concat(newCharsSet));
    }
  };
  CanvasFont.prototype.destroy = function() {
    for (var i = 0; i < this.textures.length; i++) {
      this.textures[i].destroy();
    }
    this.chars = null;
    this.color = null;
    this.data = null;
    this.fontName = null;
    this.fontSize = null;
    this.glyphSize = null;
    this.intensity = null;
    this.textures = null;
    this.type = null;
    this.fontWeight = null;
  };
  CanvasFont.prototype._getAndClearContext = function(canvas, clearColor) {
    var w = canvas.width;
    var h = canvas.height;
    var ctx = canvas.getContext("2d", {alpha:true});
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = clearColor;
    ctx.fillRect(0, 0, w, h);
    return ctx;
  };
  CanvasFont.prototype._colorToRgbString = function(color, alpha) {
    var str;
    var r = Math.round(255 * color.r);
    var g = Math.round(255 * color.g);
    var b = Math.round(255 * color.b);
    if (alpha) {
      str = "rgba(" + r + ", " + g + ", " + b + ", " + color.a + ")";
    } else {
      str = "rgb(" + r + ", " + g + ", " + b + ")";
    }
    return str;
  };
  CanvasFont.prototype.renderCharacter = function(context, char, x, y, color) {
    context.fillStyle = color;
    context.fillText(char, x, y);
  };
  CanvasFont.prototype._renderAtlas = function(charsArray) {
    this.chars = charsArray;
    var numTextures = 1;
    var canvas = this.textures[numTextures - 1].getSource();
    var w = canvas.width;
    var h = canvas.height;
    var color = this._colorToRgbString(this.color, false);
    var a = this.color.a;
    this.color.a = 1 / 255;
    var transparent = this._colorToRgbString(this.color, true);
    this.color.a = a;
    var TEXT_ALIGN = "center";
    var TEXT_BASELINE = "bottom";
    var ctx = this._getAndClearContext(canvas, transparent);
    ctx.font = this.fontWeight + " " + this.fontSize.toString() + "px " + this.fontName;
    ctx.textAlign = TEXT_ALIGN;
    ctx.textBaseline = TEXT_BASELINE;
    this.data = this._createJson(this.chars, this.fontName, w, h);
    var symbols = pc.string.getSymbols(this.chars.join(""));
    var prevNumTextures = this.textures.length;
    var maxHeight = 0;
    var maxDescent = 0;
    var metrics = {};
    var i, ch;
    for (i = 0; i < symbols.length; i++) {
      ch = symbols[i];
      metrics[ch] = this._getTextMetrics(ch);
      maxHeight = Math.max(maxHeight, metrics[ch].height);
      maxDescent = Math.max(maxDescent, metrics[ch].descent);
    }
    this.glyphSize = Math.max(this.glyphSize, maxHeight);
    var sx = this.glyphSize;
    var sy = this.glyphSize;
    var halfWidth = sx / 2;
    var _x = halfWidth;
    var _y = sy;
    for (i = 0; i < symbols.length; i++) {
      ch = symbols[i];
      var code = pc.string.getCodePoint(symbols[i]);
      var fs = this.fontSize;
      ctx.font = this.fontWeight + " " + fs.toString() + "px " + this.fontName;
      ctx.textAlign = TEXT_ALIGN;
      ctx.textBaseline = TEXT_BASELINE;
      var width = ctx.measureText(ch).width;
      if (width > fs) {
        fs = this.fontSize * this.fontSize / width;
        ctx.font = this.fontWeight + " " + fs.toString() + "px " + this.fontName;
        width = this.fontSize;
      }
      this.renderCharacter(ctx, ch, _x, _y, color);
      var xoffset = (sx - width) / 2;
      var yoffset = metrics[ch].descent - maxDescent;
      var xadvance = width;
      this._addChar(this.data, ch, code, _x - halfWidth, _y - sy, sx, sy, xoffset, yoffset, xadvance, numTextures - 1, w, h);
      _x += sx;
      if (_x + halfWidth > w) {
        _x = halfWidth;
        _y += sy;
        if (_y > h) {
          this.textures[numTextures - 1].upload();
          numTextures++;
          _y = sy;
          if (numTextures > prevNumTextures) {
            canvas = document.createElement("canvas");
            canvas.height = h;
            canvas.width = w;
            ctx = this._getAndClearContext(canvas, transparent);
            var texture = new pc.Texture(this.app.graphicsDevice, {format:pc.PIXELFORMAT_R8_G8_B8_A8, autoMipmap:true});
            texture.name = "font-atlas";
            texture.setSource(canvas);
            texture.minFilter = pc.FILTER_LINEAR_MIPMAP_LINEAR;
            texture.magFilter = pc.FILTER_LINEAR;
            texture.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
            texture.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
            this.textures.push(texture);
          } else {
            canvas = this.textures[numTextures - 1].getSource();
            ctx = this._getAndClearContext(canvas, transparent);
          }
        }
      }
    }
    this.textures[numTextures - 1].upload();
    if (numTextures < prevNumTextures) {
      for (i = numTextures; i < prevNumTextures; i++) {
        this.textures[i].destroy();
      }
      this.textures.splice(numTextures);
    }
    this.fire("render");
  };
  CanvasFont.prototype._createJson = function(chars, fontName, width, height) {
    var base = {"version":3, "intensity":this.intensity, "info":{"face":fontName, "width":width, "height":height, "maps":[{"width":width, "height":height}]}, "chars":{}};
    return base;
  };
  CanvasFont.prototype._addChar = function(json, char, charCode, x, y, w, h, xoffset, yoffset, xadvance, mapNum, mapW, mapH) {
    if (json.info.maps.length < mapNum + 1) {
      json.info.maps.push({"width":mapW, "height":mapH});
    }
    var scale = this.fontSize / 32;
    json.chars[char] = {"id":charCode, "letter":char, "x":x, "y":y, "width":w, "height":h, "xadvance":xadvance / scale, "xoffset":xoffset / scale, "yoffset":yoffset / scale, "scale":scale, "range":1, "map":mapNum, "bounds":[0, 0, w / scale, h / scale]};
  };
  CanvasFont.prototype._normalizeCharsSet = function(text) {
    var unicodeConverterFunc = this.app.systems.element.getUnicodeConverter();
    if (unicodeConverterFunc) {
      text = unicodeConverterFunc(text);
    }
    var set = {};
    var symbols = pc.string.getSymbols(text);
    var i;
    for (i = 0; i < symbols.length; i++) {
      var ch = symbols[i];
      if (set[ch]) {
        continue;
      }
      set[ch] = ch;
    }
    var chars = Object.keys(set);
    return chars.sort();
  };
  CanvasFont.prototype._getTextMetrics = function(text) {
    var textSpan = document.createElement("span");
    textSpan.id = "content-span";
      console.log(">>>> INNER HTML 2");
      textSpan.innerHTML = text;

      console.log("<<<<< INNER HTML 2");
    var block = document.createElement("div");
    block.id = "content-block";
    block.style.display = "inline-block";
    block.style.width = "1px";
    block.style.height = "0px";
    var div = document.createElement("div");
    div.appendChild(textSpan);
    div.appendChild(block);
    div.style.font = this.fontName;
    div.style.fontSize = this.fontSize + "px";
    var body = document.body;
    body.appendChild(div);
    var ascent = -1;
    var descent = -1;
    var height = -1;
    try {
      block.style["vertical-align"] = "baseline";
      ascent = block.offsetTop - textSpan.offsetTop;
      block.style["vertical-align"] = "bottom";
      height = block.offsetTop - textSpan.offsetTop;
      descent = height - ascent;
    } finally {
      document.body.removeChild(div);
    }
    return {ascent:ascent, descent:descent, height:height};
  };
  return {CanvasFont:CanvasFont};
}());
Object.assign(pc, function() {
  var Entity = function(name, app) {
    pc.GraphNode.call(this, name);
    if (name instanceof pc.Application) {
      app = name;
    }
    this._batchHandle = null;
    this.c = {};
    this._app = app;
    if (!app) {
      this._app = pc.Application.getApplication();
      if (!this._app) {
        throw new Error("Couldn't find current application");
      }
    }
    this._guid = null;
    this._destroying = false;
    pc.events.attach(this);
  };
  Entity.prototype = Object.create(pc.GraphNode.prototype);
  Entity.prototype.constructor = Entity;
  Entity.prototype.addComponent = function(type, data) {
    var system = this._app.systems[type];
    if (!system) {
      return null;
    }
    if (this.c[type]) {
      return null;
    }
    return system.addComponent(this, data);
  };
  Entity.prototype.removeComponent = function(type) {
    var system = this._app.systems[type];
    if (!system) {
      return;
    }
    if (!this.c[type]) {
      return;
    }
    system.removeComponent(this);
  };
  Entity.prototype.getGuid = function() {
    if (!this._guid) {
      this.setGuid(pc.guid.create());
    }
    return this._guid;
  };
  Entity.prototype.setGuid = function(guid) {
    var index = this._app._entityIndex;
    if (this._guid) {
      delete index[this._guid];
    }
    this._guid = guid;
    index[this._guid] = this;
  };
  Entity.prototype._notifyHierarchyStateChanged = function(node, enabled) {
    var enableFirst = false;
    if (node === this && this._app._enableList.length === 0) {
      enableFirst = true;
    }
    node._beingEnabled = true;
    node._onHierarchyStateChanged(enabled);
    if (node._onHierarchyStatePostChanged) {
      this._app._enableList.push(node);
    }
    var i, len;
    var c = node._children;
    for (i = 0, len = c.length; i < len; i++) {
      if (c[i]._enabled) {
        this._notifyHierarchyStateChanged(c[i], enabled);
      }
    }
    node._beingEnabled = false;
    if (enableFirst) {
      for (i = 0, len = this._app._enableList.length; i < len; i++) {
        this._app._enableList[i]._onHierarchyStatePostChanged();
      }
      this._app._enableList.length = 0;
    }
  };
  Entity.prototype._onHierarchyStateChanged = function(enabled) {
    pc.GraphNode.prototype._onHierarchyStateChanged.call(this, enabled);
    var component;
    var components = this.c;
    for (var type in components) {
      if (components.hasOwnProperty(type)) {
        component = components[type];
        if (component.enabled) {
          if (enabled) {
            component.onEnable();
          } else {
            component.onDisable();
          }
        }
      }
    }
  };
  Entity.prototype._onHierarchyStatePostChanged = function() {
    var components = this.c;
    for (var type in components) {
      if (components.hasOwnProperty(type)) {
        components[type].onPostStateChange();
      }
    }
  };
  Entity.prototype.setRequest = function(request) {
    this._request = request;
  };
  Entity.prototype.getRequest = function() {
    return this._request;
  };
  Entity.prototype.findByGuid = function(guid) {
    if (this._guid === guid) {
      return this;
    }
    var e = this._app._entityIndex[guid];
    if (e && (e === this || e.isDescendantOf(this))) {
      return e;
    }
    return null;
  };
  Entity.prototype.destroy = function() {
    var name;
    this._destroying = true;
    for (name in this.c) {
      this.c[name].enabled = false;
    }
    for (name in this.c) {
      this.c[name].system.removeComponent(this);
    }
    if (this._parent) {
      this._parent.removeChild(this);
    }
    var children = this._children;
    var child = children.shift();
    while (child) {
      if (child instanceof pc.Entity) {
        child.destroy();
      }
      child._parent = null;
      child = children.shift();
    }
    this.fire("destroy", this);
    this.off();
    if (this._guid) {
      delete this._app._entityIndex[this._guid];
    }
    this._destroying = false;
  };
  Entity.prototype.clone = function() {
    var duplicatedIdsMap = {};
    var clone = this._cloneRecursively(duplicatedIdsMap);
    duplicatedIdsMap[this.getGuid()] = clone;
    resolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);
    return clone;
  };
  Entity.prototype._cloneRecursively = function(duplicatedIdsMap) {
    var clone = new pc.Entity(this._app);
    pc.GraphNode.prototype._cloneInternal.call(this, clone);
    for (var type in this.c) {
      var component = this.c[type];
      component.system.cloneComponent(this, clone);
    }
    var i;
    for (i = 0; i < this._children.length; i++) {
      var oldChild = this._children[i];
      if (oldChild instanceof pc.Entity) {
        var newChild = oldChild._cloneRecursively(duplicatedIdsMap);
        clone.addChild(newChild);
        duplicatedIdsMap[oldChild.getGuid()] = newChild;
      }
    }
    return clone;
  };
  function resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {
    var i, len;
    if (oldEntity instanceof pc.Entity) {
      var components = oldEntity.c;
      for (var componentName in components) {
        var component = components[componentName];
        var entityProperties = component.system.getPropertiesOfType("entity");
        for (i = 0, len = entityProperties.length; i < len; i++) {
          var propertyDescriptor = entityProperties[i];
          var propertyName = propertyDescriptor.name;
          var oldEntityReferenceId = component[propertyName];
          var entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);
          if (entityIsWithinOldSubtree) {
            var newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();
            if (newEntityReferenceId) {
              newEntity.c[componentName][propertyName] = newEntityReferenceId;
            } else {
              console.warn("Could not find corresponding entity id when resolving duplicated entity references");
            }
          }
        }
      }
      if (components.script && !newEntity._app.useLegacyScriptAttributeCloning) {
        newEntity.script.resolveDuplicatedEntityReferenceProperties(components.script, duplicatedIdsMap);
      }
      var _old = oldEntity.children.filter(function(e) {
        return e instanceof pc.Entity;
      });
      var _new = newEntity.children.filter(function(e) {
        return e instanceof pc.Entity;
      });
      for (i = 0, len = _old.length; i < len; i++) {
        resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[i], _new[i], duplicatedIdsMap);
      }
    }
  }
  return {Entity:Entity};
}());
Object.assign(pc, function() {
  function EntityReference(parentComponent, entityPropertyName, eventConfig) {
    if (!parentComponent || !(parentComponent instanceof pc.Component)) {
      throw new Error("The parentComponent argument is required and must be a Component");
    } else {
      if (!entityPropertyName || typeof entityPropertyName !== "string") {
        throw new Error("The propertyName argument is required and must be a string");
      } else {
        if (eventConfig && typeof eventConfig !== "object") {
          throw new Error("If provided, the eventConfig argument must be an object");
        }
      }
    }
    this._parentComponent = parentComponent;
    this._entityPropertyName = entityPropertyName;
    this._entity = null;
    this._app = parentComponent.system.app;
    this._configureEventListeners(eventConfig || {}, {"entity#destroy":this._onEntityDestroy});
    this._toggleLifecycleListeners("on");
  }
  Object.assign(EntityReference.prototype, {_configureEventListeners:function(externalEventConfig, internalEventConfig) {
    var externalEventListenerConfigs = this._parseEventListenerConfig(externalEventConfig, "external", this._parentComponent);
    var internalEventListenerConfigs = this._parseEventListenerConfig(internalEventConfig, "internal", this);
    this._eventListenerConfigs = externalEventListenerConfigs.concat(internalEventListenerConfigs);
    this._listenerStatusFlags = {};
    this._gainListeners = {};
    this._loseListeners = {};
  }, _parseEventListenerConfig:function(eventConfig, prefix, scope) {
    return Object.keys(eventConfig).map(function(listenerDescription, index) {
      var listenerDescriptionParts = listenerDescription.split("#");
      var sourceName = listenerDescriptionParts[0];
      var eventName = listenerDescriptionParts[1];
      var callback = eventConfig[listenerDescription];
      if (listenerDescriptionParts.length !== 2 || typeof sourceName !== "string" || sourceName.length === 0 || typeof eventName !== "string" || eventName.length === 0) {
        throw new Error("Invalid event listener description: `" + listenerDescription + "`");
      }
      if (typeof callback !== "function") {
        throw new Error("Invalid or missing callback for event listener `" + listenerDescription + "`");
      }
      return {id:prefix + "_" + index + "_" + listenerDescription, sourceName:sourceName, eventName:eventName, callback:callback, scope:scope};
    }, this);
  }, _toggleLifecycleListeners:function(onOrOff) {
    this._parentComponent[onOrOff]("set_" + this._entityPropertyName, this._onSetEntity, this);
    this._parentComponent.system[onOrOff]("beforeremove", this._onParentComponentRemove, this);
    pc.ComponentSystem[onOrOff]("postinitialize", this._onPostInitialize, this);
    this._app[onOrOff]("tools:sceneloaded", this._onSceneLoaded, this);
    var allComponentSystems = [];
    for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
      var config = this._eventListenerConfigs[i];
      var componentSystem = this._app.systems[config.sourceName];
      if (componentSystem) {
        if (allComponentSystems.indexOf(componentSystem) === -1) {
          allComponentSystems.push(componentSystem);
        }
        if (componentSystem && config.eventName === "gain") {
          this._gainListeners[config.sourceName] = config;
        }
        if (componentSystem && config.eventName === "lose") {
          this._loseListeners[config.sourceName] = config;
        }
      }
    }
    for (var j = 0; j < allComponentSystems.length; ++j) {
      allComponentSystems[j][onOrOff]("add", this._onComponentAdd, this);
      allComponentSystems[j][onOrOff]("beforeremove", this._onComponentRemove, this);
    }
  }, _onSetEntity:function(name, oldValue, newValue) {
    if (newValue instanceof pc.Entity) {
      this._updateEntityReference();
    } else {
      if (newValue !== null && newValue !== undefined && typeof newValue !== "string") {
        console.warn("Entity field `" + this._entityPropertyName + "` was set to unexpected type '" + typeof newValue + "'");
        return;
      }
      if (oldValue !== newValue) {
        this._updateEntityReference();
      }
    }
  }, _onPostInitialize:function() {
    this._updateEntityReference();
  }, onParentComponentEnable:function() {
    if (!this._entity) {
      this._updateEntityReference();
    }
  }, _onSceneLoaded:function() {
    this._updateEntityReference();
  }, _updateEntityReference:function() {
    var nextEntityGuid = this._parentComponent.data[this._entityPropertyName];
    var nextEntity;
    if (nextEntityGuid instanceof pc.Entity) {
      nextEntity = nextEntityGuid;
      nextEntityGuid = nextEntity.getGuid();
      this._parentComponent.data[this._entityPropertyName] = nextEntityGuid;
    } else {
      var root = this._parentComponent.system.app.root;
      var isOnSceneGraph = this._parentComponent.entity.isDescendantOf(root);
      nextEntity = isOnSceneGraph && nextEntityGuid ? root.findByGuid(nextEntityGuid) : null;
    }
    var hasChanged = this._entity !== nextEntity;
    if (hasChanged) {
      if (this._entity) {
        this._onBeforeEntityChange();
      }
      this._entity = nextEntity;
      if (this._entity) {
        this._onAfterEntityChange();
      }
    }
  }, _onBeforeEntityChange:function() {
    this._toggleEntityListeners("off");
    this._callAllGainOrLoseListeners(this._loseListeners);
  }, _onAfterEntityChange:function() {
    this._toggleEntityListeners("on");
    this._callAllGainOrLoseListeners(this._gainListeners);
  }, _onComponentAdd:function(entity, component) {
    var componentName = component.system.id;
    if (entity === this._entity) {
      this._callGainOrLoseListener(componentName, this._gainListeners);
      this._toggleComponentListeners("on", componentName);
    }
  }, _onComponentRemove:function(entity, component) {
    var componentName = component.system.id;
    if (entity === this._entity) {
      this._callGainOrLoseListener(componentName, this._loseListeners);
      this._toggleComponentListeners("off", componentName, true);
    }
  }, _callAllGainOrLoseListeners:function(listenerMap) {
    for (var componentName in this._entity.c) {
      this._callGainOrLoseListener(componentName, listenerMap);
    }
  }, _callGainOrLoseListener:function(componentName, listenerMap) {
    if (this._entity.c.hasOwnProperty(componentName) && listenerMap[componentName]) {
      var config = listenerMap[componentName];
      config.callback.call(config.scope);
    }
  }, _toggleEntityListeners:function(onOrOff, isDestroying) {
    if (this._entity) {
      for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
        this._safeToggleListener(onOrOff, this._eventListenerConfigs[i], isDestroying);
      }
    }
  }, _toggleComponentListeners:function(onOrOff, componentName, isDestroying) {
    for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
      var config = this._eventListenerConfigs[i];
      if (config.sourceName === componentName) {
        this._safeToggleListener(onOrOff, config, isDestroying);
      }
    }
  }, _safeToggleListener:function(onOrOff, config, isDestroying) {
    var isAdding = onOrOff === "on";
    if (isAdding && this._listenerStatusFlags[config.id]) {
      return;
    }
    var source = this._getEventSource(config.sourceName, isDestroying);
    if (source) {
      source[onOrOff](config.eventName, config.callback, config.scope);
      this._listenerStatusFlags[config.id] = isAdding;
    }
  }, _getEventSource:function(sourceName, isDestroying) {
    if (sourceName === "entity") {
      return this._entity;
    }
    var component = this._entity[sourceName];
    if (component) {
      return component;
    }
    if (!isDestroying) {
      console.warn("Entity has no component with name " + sourceName);
    }
    return null;
  }, _onEntityDestroy:function(entity) {
    if (this._entity === entity) {
      this._toggleEntityListeners("off", true);
      this._entity = null;
    }
  }, _onParentComponentRemove:function(entity, component) {
    if (component === this._parentComponent) {
      this._toggleLifecycleListeners("off");
      this._toggleEntityListeners("off", true);
    }
  }, hasComponent:function(componentName) {
    return this._entity && this._entity.c ? !!this._entity.c[componentName] : false;
  }});
  Object.defineProperty(EntityReference.prototype, "entity", {get:function() {
    return this._entity;
  }});
  return {EntityReference:EntityReference};
}());
Object.assign(pc, function() {
  var SortedLoopArray = function(args) {
    this._sortBy = args.sortBy;
    this.items = [];
    this.length = 0;
    this.loopIndex = -1;
    this._sortHandler = this._doSort.bind(this);
  };
  SortedLoopArray.prototype._binarySearch = function(item) {
    var left = 0;
    var right = this.items.length - 1;
    var search = item[this._sortBy];
    var middle;
    var current;
    while (left <= right) {
      middle = Math.floor((left + right) / 2);
      current = this.items[middle][this._sortBy];
      if (current <= search) {
        left = middle + 1;
      } else {
        if (current > search) {
          right = middle - 1;
        }
      }
    }
    return left;
  };
  SortedLoopArray.prototype._doSort = function(a, b) {
    var sortBy = this._sortBy;
    return a[sortBy] - b[sortBy];
  };
  SortedLoopArray.prototype.insert = function(item) {
    var index = this._binarySearch(item);
    this.items.splice(index, 0, item);
    this.length++;
    if (this.loopIndex >= index) {
      this.loopIndex++;
    }
  };
  SortedLoopArray.prototype.append = function(item) {
    this.items.push(item);
    this.length++;
  };
  SortedLoopArray.prototype.remove = function(item) {
    var idx = this.items.indexOf(item);
    if (idx < 0) {
      return;
    }
    this.items.splice(idx, 1);
    this.length--;
    if (this.loopIndex >= idx) {
      this.loopIndex--;
    }
  };
  SortedLoopArray.prototype.sort = function() {
    var current = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;
    this.items.sort(this._sortHandler);
    if (current !== null) {
      this.loopIndex = this.items.indexOf(current);
    }
  };
  return {SortedLoopArray:SortedLoopArray};
}());
Object.assign(pc, function() {
  var ResourceLoader = function(app) {
    this._handlers = {};
    this._requests = {};
    this._cache = {};
    this._app = app;
  };
  Object.assign(ResourceLoader.prototype, {addHandler:function(type, handler) {
    this._handlers[type] = handler;
    handler._loader = this;
  }, removeHandler:function(type) {
    delete this._handlers[type];
  }, getHandler:function(type) {
    return this._handlers[type];
  }, load:function(url, type, callback, asset) {
    var handler = this._handlers[type];
    if (!handler) {
      var err = "No handler for asset type: " + type;
      callback(err);
      return;
    }
    var key = url + type;
    if (this._cache[key] !== undefined) {
      callback(null, this._cache[key]);
    } else {
      if (this._requests[key]) {
        this._requests[key].push(callback);
      } else {
        this._requests[key] = [callback];
        var handleLoad = function(err, urlObj) {
          if (err) {
            console.error(err);
            if (this._requests[key]) {
              for (var i = 0, len = this._requests[key].length; i < len; i++) {
                this._requests[key][i](err);
              }
            }
            delete this._requests[key];
            return;
          }
          handler.load(urlObj, function(err, data, extra) {
            if (!this._requests[key]) {
              return;
            }
            var i, len = this._requests[key].length;
            var resource;
            if (!err) {
              try {
                resource = handler.open(urlObj.original, data, asset);
              } catch (ex) {
                err = ex;
              }
            }
            if (!err) {
              this._cache[key] = resource;
              for (i = 0; i < len; i++) {
                this._requests[key][i](null, resource, extra);
              }
            } else {
              console.error(err);
              for (i = 0; i < len; i++) {
                this._requests[key][i](err);
              }
            }
            delete this._requests[key];
          }.bind(this), asset);
        }.bind(this);
        var normalizedUrl = url.split("?")[0];
        if (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl)) {
          if (!this._app.bundles.canLoadUrl(normalizedUrl)) {
            handleLoad("Bundle for " + url + " not loaded yet");
            return;
          }
          this._app.bundles.loadUrl(normalizedUrl, function(err, fileUrlFromBundle) {
            handleLoad(err, {load:fileUrlFromBundle, original:url});
          });
        } else {
          handleLoad(null, {load:url, original:url});
        }
      }
    }
  }, open:function(type, data) {
    var handler = this._handlers[type];
    if (!handler) {
      console.warn("No resource handler found for: " + type);
      return data;
    }
    return handler.open(null, data);
  }, patch:function(asset, assets) {
    var handler = this._handlers[asset.type];
    if (!handler) {
      console.warn("No resource handler found for: " + asset.type);
      return;
    }
    if (handler.patch) {
      handler.patch(asset, assets);
    }
  }, clearCache:function(url, type) {
    delete this._cache[url + type];
  }, getFromCache:function(url, type) {
    if (this._cache[url + type]) {
      return this._cache[url + type];
    }
  }, destroy:function() {
    this._handlers = {};
    this._requests = {};
    this._cache = {};
  }});
  return {ResourceLoader:ResourceLoader};
}());
Object.assign(pc, function() {
  var Untar;
  function UntarScope(isWorker) {
    var utfDecoder;
    var asciiDecoder;
    if (typeof TextDecoder !== "undefined") {
      utfDecoder = new TextDecoder("utf-8");
      asciiDecoder = new TextDecoder("windows-1252");
    } else {
      console.warn("TextDecoder not supported - pc.Untar module will not work");
    }
    function PaxHeader(fields) {
      this._fields = fields;
    }
    PaxHeader.parse = function(buffer, start, length) {
      var paxArray = new Uint8Array(buffer, start, length);
      var bytesRead = 0;
      var fields = [];
      while (bytesRead < length) {
        var spaceIndex;
        for (spaceIndex = bytesRead; spaceIndex < length; spaceIndex++) {
          if (paxArray[spaceIndex] == 32) {
            break;
          }
        }
        if (spaceIndex >= length) {
          throw new Error("Invalid PAX header data format.");
        }
        var fieldLength = parseInt(utfDecoder.decode(new Uint8Array(buffer, start + bytesRead, spaceIndex - bytesRead)), 10);
        var fieldText = utfDecoder.decode(new Uint8Array(buffer, start + spaceIndex + 1, fieldLength - (spaceIndex - bytesRead) - 2));
        var field = fieldText.split("=");
        if (field.length !== 2) {
          throw new Error("Invalid PAX header data format.");
        }
        if (field[1].length === 0) {
          field[1] = null;
        }
        fields.push({name:field[0], value:field[1]});
        bytesRead += fieldLength;
      }
      return new PaxHeader(fields);
    };
    PaxHeader.prototype.applyHeader = function(file) {
      for (var i = 0; i < this._fields.length; i++) {
        var fieldName = this._fields[i].name;
        var fieldValue = this._fields[i].value;
        if (fieldName === "path") {
          fieldName = "name";
        }
        if (fieldValue === null) {
          delete file[fieldName];
        } else {
          file[fieldName] = fieldValue;
        }
      }
    };
    var UntarInternal = function(arrayBuffer) {
      this._arrayBuffer = arrayBuffer || new ArrayBuffer(0);
      this._bufferView = new DataView(this._arrayBuffer);
      this._globalPaxHeader = null;
      this._bytesRead = 0;
    };
    if (!isWorker) {
      Untar = UntarInternal;
    }
    UntarInternal.prototype._hasNext = function() {
      return this._bytesRead + 4 < this._arrayBuffer.byteLength && this._bufferView.getUint32(this._bytesRead) !== 0;
    };
    UntarInternal.prototype._readNextFile = function() {
      var headersDataView = new DataView(this._arrayBuffer, this._bytesRead, 512);
      var headers = asciiDecoder.decode(headersDataView);
      this._bytesRead += 512;
      var name = headers.substr(0, 100).replace(/\0/g, "");
      var ustarFormat = headers.substr(257, 6);
      var size = parseInt(headers.substr(124, 12), 8);
      var type = headers.substr(156, 1);
      var start = this._bytesRead;
      var url = null;
      var paxHeader;
      var normalFile = false;
      switch(type) {
        case "0":
        case "":
          normalFile = true;
          if (!isWorker) {
            var blob = new Blob([this._arrayBuffer.slice(this._bytesRead, this._bytesRead + size)]);
            url = URL.createObjectURL(blob);
          }
          break;
        case "g":
          this._globalPaxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
          break;
        case "x":
          paxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
          break;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        default:
      }
      this._bytesRead += size;
      var remainder = size % 512;
      if (remainder !== 0) {
        this._bytesRead += 512 - remainder;
      }
      if (!normalFile) {
        return null;
      }
      if (ustarFormat.indexOf("ustar") !== -1) {
        var namePrefix = headers.substr(345, 155).replace(/\0/g, "");
        if (namePrefix.length > 0) {
          name = namePrefix.trim() + name.trim();
        }
      }
      var file = {name:name, start:start, size:size, url:url};
      if (this._globalPaxHeader) {
        this._globalPaxHeader.applyHeader(file);
      }
      if (paxHeader) {
        paxHeader.applyHeader(file);
      }
      return file;
    };
    UntarInternal.prototype.untar = function(filenamePrefix) {
      if (!utfDecoder) {
        console.error("Cannot untar because TextDecoder interface is not available for this platform.");
        return [];
      }
      var files = [];
      while (this._hasNext()) {
        var file = this._readNextFile();
        if (!file) {
          continue;
        }
        if (filenamePrefix && file.name) {
          file.name = filenamePrefix + file.name;
        }
        files.push(file);
      }
      return files;
    };
    if (isWorker) {
      self.onmessage = function(e) {
        var id = e.data.id;
        try {
          var archive = new UntarInternal(e.data.arrayBuffer);
          var files = archive.untar(e.data.prefix);
          postMessage({id:id, files:files, arrayBuffer:e.data.arrayBuffer}, [e.data.arrayBuffer]);
        } catch (err) {
          postMessage({id:id, error:err.toString()});
        }
      };
    }
  }
  var scopeToUrl = function() {
    var code = "(" + UntarScope.toString() + ")(true)\n\n";
    var blob = new Blob([code], {type:"application/javascript"});
    return URL.createObjectURL(blob);
  };
  var WORKER_URL = scopeToUrl();
  var UntarWorker = function(filenamePrefix) {
    this._requestId = 0;
    this._pendingRequests = {};
    this._filenamePrefix = filenamePrefix;
    this._worker = new Worker(WORKER_URL);
    this._worker.addEventListener("message", this._onMessage.bind(this));
  };
  UntarWorker.prototype._onMessage = function(e) {
    var id = e.data.id;
    if (!this._pendingRequests[id]) {
      return;
    }
    var callback = this._pendingRequests[id];
    delete this._pendingRequests[id];
    if (e.data.error) {
      callback(e.data.error);
    } else {
      var arrayBuffer = e.data.arrayBuffer;
      for (var i = 0, len = e.data.files.length; i < len; i++) {
        var file = e.data.files[i];
        var blob = new Blob([arrayBuffer.slice(file.start, file.start + file.size)]);
        file.url = URL.createObjectURL(blob);
      }
      callback(null, e.data.files);
    }
  };
  UntarWorker.prototype.untar = function(arrayBuffer, callback) {
    var id = this._requestId++;
    this._pendingRequests[id] = callback;
    this._worker.postMessage({id:id, prefix:this._filenamePrefix, arrayBuffer:arrayBuffer}, [arrayBuffer]);
  };
  UntarWorker.prototype.hasPendingRequests = function() {
    for (var key in this._pendingRequests) {
      return true;
    }
    return false;
  };
  UntarWorker.prototype.destroy = function() {
    if (this._worker) {
      this._worker.terminate();
      this._worker = null;
      this._pendingRequests = null;
    }
  };
  UntarScope();
  return {Untar:Untar, UntarWorker:UntarWorker};
}());
Object.assign(pc, function() {
  var JsonHandler = function() {
  };
  Object.assign(JsonHandler.prototype, {load:function(url, callback) {
    if (typeof url === "string") {
      url = {load:url, original:url};
    }
    callback(null, JSON.parse(getJSONSrcByKey(url.load.split("?")[0])));
  }, open:function(url, data) {
    return data;
  }, patch:function(asset, assets) {
  }});
  return {JsonHandler:JsonHandler};
}());
Object.assign(pc, function() {
  var ScriptHandler = function(app) {
    this._app = app;
    this._scripts = {};
    this._cache = {};
  };
  ScriptHandler._types = [];
  ScriptHandler._push = function(Type) {
    if (pc.script.legacy && ScriptHandler._types.length > 0) {
      console.assert("Script Ordering Error. Contact support@playcanvas.com");
    } else {
      ScriptHandler._types.push(Type);
    }
  };
  Object.assign(ScriptHandler.prototype, {load:function(url, callback) {
    if (typeof url === "string") {
      url = {load:url, original:url};
    }
    var self = this;
    pc.script.app = this._app;
    this._loadScript(url.original, function(err, url, extra) {
      if (!err) {
        var obj = {};
        for (var i = 0; i < ScriptHandler._types.length; i++) {
          obj[ScriptHandler._types[i].name] = ScriptHandler._types[i];
        }
        ScriptHandler._types.length = 0;
        callback(null, obj, extra);
        delete self._loader._cache[url + "script"];
      } else {
        callback(err);
      }
    });
  }, open:function(url, data) {
    return data;
  }, patch:function(asset, assets) {
  }, _loadScript:function(url, callback) {
    var head = document.head;
    var element = document.createElement("script");
    this._cache[url] = element;
    element.async = false;
    element.addEventListener("error", function(e) {
      callback(pc.string.format("Script: {0} failed to load", e.target.src));
    }, false);
    var done = false;
    var wrappedScriptContent = getScriptSrcByKey(url);
    var scriptBlob = new Blob([wrappedScriptContent], {type:"text/javascript"});
    element.onload = element.onreadystatechange = function() {
      if (!done && (!this.readyState || (this.readyState == "loaded" || this.readyState == "complete"))) {
        done = true;
        callback(null, url, element);
      }
    };
    element.src = URL.createObjectURL(scriptBlob);
    head.appendChild(element);
  }});
  return {ScriptHandler:ScriptHandler};
}());
Object.assign(pc, function() {
  var TextHandler = function() {
  };
  Object.assign(TextHandler.prototype, {load:function(url, callback) {
    if (typeof url === "string") {
      url = {load:url, original:url};
    }
    callback(null, getTxtSrcByKey(url.load.split("?")[0]));
  }, open:function(url, data) {
    return data;
  }, patch:function(asset, assets) {
  }});
  return {TextHandler:TextHandler};
}());
Object.assign(pc, function() {
  var DDSD_CAPS = 1;
  var DDSD_HEIGHT = 2;
  var DDSD_WIDTH = 4;
  var DDSD_PITCH = 8;
  var DDSD_PIXELFORMAT = 4096;
  var DDSD_MIPMAPCOUNT = 131072;
  var DDSD_LINEARSIZE = 524288;
  var DDSD_DEPTH = 8388608;
  var DDSCAPS2_CUBEMAP = 512;
  var DDSCAPS2_CUBEMAP_POSITIVEX = 1024;
  var DDSCAPS2_CUBEMAP_NEGATIVEX = 2048;
  var DDSCAPS2_CUBEMAP_POSITIVEY = 4096;
  var DDSCAPS2_CUBEMAP_NEGATIVEY = 8192;
  var DDSCAPS2_CUBEMAP_POSITIVEZ = 16384;
  var DDSCAPS2_CUBEMAP_NEGATIVEZ = 32768;
  var DDS_CUBEMAP_ALLFACES = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX | DDSCAPS2_CUBEMAP_NEGATIVEX | DDSCAPS2_CUBEMAP_POSITIVEY | DDSCAPS2_CUBEMAP_NEGATIVEY | DDSCAPS2_CUBEMAP_POSITIVEZ | DDSCAPS2_CUBEMAP_NEGATIVEZ;
  var DDPF_ALPHAPIXELS = 1;
  var DDPF_ALPHA = 2;
  var DDPF_FOURCC = 4;
  var DDPF_RGB = 64;
  var DDPF_YUV = 512;
  var DDPF_LUMINANCE = 131072;
  var makeFourCC = function(str) {
    return str.charCodeAt(0) + (str.charCodeAt(1) << 8) + (str.charCodeAt(2) << 16) + (str.charCodeAt(3) << 24);
  };
  var DDS_MAGIC = makeFourCC("DDS ");
  var FCC_DXT1 = makeFourCC("DXT1");
  var FCC_DXT5 = makeFourCC("DXT5");
  var FCC_DX10 = makeFourCC("DX10");
  var FCC_FP32 = 116;
  var FCC_ETC1 = makeFourCC("ETC1");
  var FCC_PVRTC_2BPP_RGB_1 = makeFourCC("P231");
  var FCC_PVRTC_2BPP_RGBA_1 = makeFourCC("P241");
  var FCC_PVRTC_4BPP_RGB_1 = makeFourCC("P431");
  var FCC_PVRTC_4BPP_RGBA_1 = makeFourCC("P441");
  var fccToFormat = {};
  fccToFormat[FCC_FP32] = pc.PIXELFORMAT_RGBA32F;
  fccToFormat[FCC_DXT1] = pc.PIXELFORMAT_DXT1;
  fccToFormat[FCC_DXT5] = pc.PIXELFORMAT_DXT5;
  fccToFormat[FCC_ETC1] = pc.PIXELFORMAT_ETC1;
  fccToFormat[FCC_PVRTC_2BPP_RGB_1] = pc.PIXELFORMAT_PVRTC_2BPP_RGB_1;
  fccToFormat[FCC_PVRTC_2BPP_RGBA_1] = pc.PIXELFORMAT_PVRTC_2BPP_RGBA_1;
  fccToFormat[FCC_PVRTC_4BPP_RGB_1] = pc.PIXELFORMAT_PVRTC_4BPP_RGB_1;
  fccToFormat[FCC_PVRTC_4BPP_RGBA_1] = pc.PIXELFORMAT_PVRTC_4BPP_RGBA_1;
  var DdsParser = function(arrayBuffer) {
    var headerU32 = new Uint32Array(arrayBuffer, 0, 32);
    var magic = headerU32[0];
    if (magic !== DDS_MAGIC) {
      return null;
    }
    var header = {size:headerU32[1], flags:headerU32[2], height:headerU32[3], width:headerU32[4], pitchOrLinearSize:headerU32[5], depth:headerU32[6], mipMapCount:Math.max(headerU32[7], 1), ddspf:{size:headerU32[19], flags:headerU32[20], fourCc:headerU32[21], rgbBitCount:headerU32[22], rBitMask:headerU32[23], gBitMask:headerU32[24], bBitMask:headerU32[25], aBitMask:headerU32[26]}, caps:headerU32[27], caps2:headerU32[28], caps3:headerU32[29], caps4:headerU32[30]};
    if (header.size !== 124) {
      return null;
    }
    var offset = 4 + header.size;
    var isFcc = header.ddspf.flags & DDPF_FOURCC;
    var fcc = header.ddspf.fourCc;
    if (isFcc && fcc === FCC_DX10) {
      headerU32 = new Uint32Array(arrayBuffer, 128, 5);
      offset += 20;
    }
    var isCubeMap = header.caps2 === DDS_CUBEMAP_ALLFACES;
    var numFaces = isCubeMap ? 6 : 1;
    var numMips = header.flags & DDSD_MIPMAPCOUNT ? header.mipMapCount : 1;
    var levels = [];
    if (isCubeMap) {
      for (var mipCnt = 0; mipCnt < numMips; mipCnt++) {
        levels.push([]);
      }
    }
    for (var face = 0; face < numFaces; face++) {
      var mipWidth = header.width;
      var mipHeight = header.height;
      for (var mip = 0; mip < numMips; mip++) {
        var mipSize;
        if (fcc === FCC_DXT1 || fcc === FCC_DXT5 || fcc === FCC_ETC1) {
          var bytesPerBlock = fcc === FCC_DXT5 ? 16 : 8;
          mipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * bytesPerBlock;
        } else {
          if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {
            mipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;
          } else {
            if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {
              mipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;
            } else {
              if (header.ddspf.rgbBitCount === 32) {
                mipSize = mipWidth * mipHeight * 4;
              } else {
                return null;
              }
            }
          }
        }
        var mipData = fcc === FCC_FP32 ? new Float32Array(arrayBuffer, offset, mipSize) : new Uint8Array(arrayBuffer, offset, mipSize);
        if (isCubeMap) {
          levels[mip][face] = mipData;
        } else {
          levels.push(mipData);
        }
        offset += fcc === FCC_FP32 ? mipSize * 4 : mipSize;
        mipWidth = Math.max(mipWidth * 0.5, 1);
        mipHeight = Math.max(mipHeight * 0.5, 1);
      }
    }
    this.format = fccToFormat[fcc] || pc.PIXELFORMAT_R8_G8_B8_A8;
    this.width = header.width;
    this.height = header.height;
    this.levels = levels;
    this.cubemap = isCubeMap;
  };
  return {DdsParser:DdsParser};
}());
Object.assign(pc, function() {
  var IDENTIFIER = [1481919403, 3140563232, 169478669];
  var KNOWN_FORMATS = {33776:pc.PIXELFORMAT_DXT1, 33778:pc.PIXELFORMAT_DXT3, 33779:pc.PIXELFORMAT_DXT5, 36196:pc.PIXELFORMAT_ETC1, 37492:pc.PIXELFORMAT_ETC2_RGB, 37496:pc.PIXELFORMAT_ETC2_RGBA, 35840:pc.PIXELFORMAT_PVRTC_4BPP_RGB_1, 35841:pc.PIXELFORMAT_PVRTC_2BPP_RGB_1, 35842:pc.PIXELFORMAT_PVRTC_4BPP_RGBA_1, 35843:pc.PIXELFORMAT_PVRTC_2BPP_RGBA_1};
  var KtxParser = function(arrayBuffer) {
    var headerU32 = new Uint32Array(arrayBuffer, 0, 16);
    if (IDENTIFIER[0] !== headerU32[0] || IDENTIFIER[1] !== headerU32[1] || IDENTIFIER[2] !== headerU32[2]) {
      return null;
    }
    var header = {endianness:headerU32[3], glType:headerU32[4], glTypeSize:headerU32[5], glFormat:headerU32[6], glInternalFormat:headerU32[7], glBaseInternalFormat:headerU32[8], pixelWidth:headerU32[9], pixelHeight:headerU32[10], pixelDepth:headerU32[11], numberOfArrayElements:headerU32[12], numberOfFaces:headerU32[13], numberOfMipmapLevels:headerU32[14], bytesOfKeyValueData:headerU32[15]};
    if (header.pixelDepth > 1) {
      return null;
    }
    if (header.numberOfArrayElements > 1) {
      return null;
    }
    if (header.glFormat !== 0) {
      return null;
    }
    if (!KNOWN_FORMATS[header.glInternalFormat]) {
      return null;
    }
    var offset = 16 * 4 + header.bytesOfKeyValueData;
    var levels = [];
    var isCubeMap = false;
    for (var mipmapLevel = 0; mipmapLevel < (header.numberOfMipmapLevels || 1); mipmapLevel++) {
      var imageSizeInBytes = (new Uint32Array(arrayBuffer.slice(offset, offset + 4)))[0];
      offset += 4;
      var faceSizeInBytes = imageSizeInBytes / (header.numberOfFaces || 1);
      if (header.numberOfFaces > 1) {
        isCubeMap = true;
        levels.push([]);
      }
      for (var face = 0; face < header.numberOfFaces; face++) {
        var mipData = new Uint8Array(arrayBuffer, offset, faceSizeInBytes);
        if (header.numberOfFaces > 1) {
          levels[mipmapLevel].push(mipData);
        } else {
          levels.push(mipData);
        }
        offset += faceSizeInBytes;
      }
      offset += 3 - (offset + 3) % 4;
    }
    this.format = KNOWN_FORMATS[header.glInternalFormat];
    this.width = header.pixelWidth;
    this.height = header.pixelHeight;
    this.levels = levels;
    this.cubemap = isCubeMap;
  };
  return {KtxParser:KtxParser};
}());
Object.assign(pc, function() {
  var JSON_ADDRESS_MODE = {"repeat":pc.ADDRESS_REPEAT, "clamp":pc.ADDRESS_CLAMP_TO_EDGE, "mirror":pc.ADDRESS_MIRRORED_REPEAT};
  var JSON_FILTER_MODE = {"nearest":pc.FILTER_NEAREST, "linear":pc.FILTER_LINEAR, "nearest_mip_nearest":pc.FILTER_NEAREST_MIPMAP_NEAREST, "linear_mip_nearest":pc.FILTER_LINEAR_MIPMAP_NEAREST, "nearest_mip_linear":pc.FILTER_NEAREST_MIPMAP_LINEAR, "linear_mip_linear":pc.FILTER_LINEAR_MIPMAP_LINEAR};
  function arrayBufferCopy(src, dst, dstByteOffset, numBytes) {
    var i;
    var dst32Offset = dstByteOffset / 4;
    var tail = numBytes % 4;
    var src32 = new Uint32Array(src.buffer, 0, (numBytes - tail) / 4);
    var dst32 = new Uint32Array(dst.buffer);
    for (i = 0; i < src32.length; i++) {
      dst32[dst32Offset + i] = src32[i];
    }
    for (i = numBytes - tail; i < numBytes; i++) {
      dst[dstByteOffset + i] = src[i];
    }
  }
  var _legacyDdsLoader = function(url, data, graphicsDevice) {
    var ext = pc.path.getExtension(url).toLowerCase();
    if (ext === ".crn") {
      var srcSize = data.byteLength;
      var bytes = new Uint8Array(data);
      var src = Module._malloc(srcSize);
      arrayBufferCopy(bytes, Module.HEAPU8, src, srcSize);
      var dst = Module._crn_decompress_get_data(src, srcSize);
      var dstSize = Module._crn_decompress_get_size(src, srcSize);
      data = Module.HEAPU8.buffer.slice(dst, dst + dstSize);
    }
    var header = new Uint32Array(data, 0, 128 / 4);
    var width = header[4];
    var height = header[3];
    var mips = Math.max(header[7], 1);
    var isFourCc = header[20] === 4;
    var fcc = header[21];
    var bpp = header[22];
    var isCubemap = header[28] === 65024;
    var FCC_DXT1 = 827611204;
    var FCC_DXT5 = 894720068;
    var FCC_FP32 = 116;
    var FCC_ETC1 = 826496069;
    var FCC_PVRTC_2BPP_RGB_1 = 825438800;
    var FCC_PVRTC_2BPP_RGBA_1 = 825504336;
    var FCC_PVRTC_4BPP_RGB_1 = 825439312;
    var FCC_PVRTC_4BPP_RGBA_1 = 825504848;
    var compressed = false;
    var floating = false;
    var etc1 = false;
    var pvrtc2 = false;
    var pvrtc4 = false;
    var format = null;
    var texture;
    if (isFourCc) {
      if (fcc === FCC_DXT1) {
        format = pc.PIXELFORMAT_DXT1;
        compressed = true;
      } else {
        if (fcc === FCC_DXT5) {
          format = pc.PIXELFORMAT_DXT5;
          compressed = true;
        } else {
          if (fcc === FCC_FP32) {
            format = pc.PIXELFORMAT_RGBA32F;
            floating = true;
          } else {
            if (fcc === FCC_ETC1) {
              format = pc.PIXELFORMAT_ETC1;
              compressed = true;
              etc1 = true;
            } else {
              if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {
                format = fcc === FCC_PVRTC_2BPP_RGB_1 ? pc.PIXELFORMAT_PVRTC_2BPP_RGB_1 : pc.PIXELFORMAT_PVRTC_2BPP_RGBA_1;
                compressed = true;
                pvrtc2 = true;
              } else {
                if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {
                  format = fcc === FCC_PVRTC_4BPP_RGB_1 ? pc.PIXELFORMAT_PVRTC_4BPP_RGB_1 : pc.PIXELFORMAT_PVRTC_4BPP_RGBA_1;
                  compressed = true;
                  pvrtc4 = true;
                }
              }
            }
          }
        }
      }
    } else {
      if (bpp === 32) {
        format = pc.PIXELFORMAT_R8_G8_B8_A8;
      }
    }
    if (!format) {
      texture = new pc.Texture(graphicsDevice, {width:4, height:4, format:pc.PIXELFORMAT_R8_G8_B8});
      texture.name = "dds-legacy-empty";
      return texture;
    }
    var texOptions = {width:width, height:height, format:format, cubemap:isCubemap};
    texture = new pc.Texture(graphicsDevice, texOptions);
    if (isCubemap) {
      texture.addressU = pc.ADDRESS_CLAMP_TO_EDGE;
      texture.addressV = pc.ADDRESS_CLAMP_TO_EDGE;
    }
    var offset = 128;
    var faces = isCubemap ? 6 : 1;
    var mipSize;
    var DXT_BLOCK_WIDTH = 4;
    var DXT_BLOCK_HEIGHT = 4;
    var blockSize = fcc === FCC_DXT1 ? 8 : 16;
    var numBlocksAcross, numBlocksDown, numBlocks;
    for (var face = 0; face < faces; face++) {
      var mipWidth = width;
      var mipHeight = height;
      for (var i = 0; i < mips; i++) {
        if (compressed) {
          if (etc1) {
            mipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;
          } else {
            if (pvrtc2) {
              mipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;
            } else {
              if (pvrtc4) {
                mipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;
              } else {
                numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);
                numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);
                numBlocks = numBlocksAcross * numBlocksDown;
                mipSize = numBlocks * blockSize;
              }
            }
          }
        } else {
          mipSize = mipWidth * mipHeight * 4;
        }
        var mipBuff = floating ? new Float32Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);
        if (!isCubemap) {
          texture._levels[i] = mipBuff;
        } else {
          if (!texture._levels[i]) {
            texture._levels[i] = [];
          }
          texture._levels[i][face] = mipBuff;
        }
        offset += floating ? mipSize * 4 : mipSize;
        mipWidth = Math.max(mipWidth * 0.5, 1);
        mipHeight = Math.max(mipHeight * 0.5, 1);
      }
    }
    texture.name = url;
    texture.upload();
    return texture;
  };
  var TextureHandler = function(device, assets, loader) {
    this._device = device;
    this._assets = assets;
    this._loader = loader;
    this.crossOrigin = undefined;
    if (assets.prefix) {
      this.crossOrigin = "anonymous";
    }
  };
  Object.assign(TextureHandler.prototype, {load:function(url, callback) {
    if (typeof url === "string") {
      url = {load:url, original:url};
    }
    var self = this;
    var image;
    var urlWithoutParams = url.original.indexOf("?") >= 0 ? url.original.split("?")[0] : url.original;
    var ext = pc.path.getExtension(urlWithoutParams).toLowerCase();
    if (ext === ".dds" || ext === ".ktx") {
      var options = {cache:true, responseType:"arraybuffer"};
      pc.http.get(url.load, options, function(err, response) {
        if (!err) {
          callback(null, response);
        } else {
          callback(err);
        }
      });
    } else {
      if (ext === ".jpg" || ext === ".jpeg" || ext === ".gif" || ext === ".png") {
        image = new Image;
        if (self.crossOrigin !== undefined && pc.ABSOLUTE_URL.test(url.original)) {
          image.crossOrigin = self.crossOrigin;
        }
        image.onload = function() {
          callback(null, image);
        };
        image.onerror = function(event) {
          callback(pc.string.format("Error loading Texture from: '{0}'", url.original));
        };
        image.src = getImageSrcByKey(urlWithoutParams);
      } else {
        var blobStart = urlWithoutParams.indexOf("blob:");
        if (blobStart >= 0) {
          urlWithoutParams = urlWithoutParams.substr(blobStart);
          url = urlWithoutParams;
          image = new Image;
          image.onload = function() {
            callback(null, image);
          };
          image.onerror = function(event) {
            callback(pc.string.format("Error loading Texture from: '{0}'", url));
          };
          image.src = url;
        } else {
          setTimeout(function() {
            callback(pc.string.format("Error loading Texture: format not supported: '{0}'", ext));
          }, 0);
        }
      }
    }
  }, open:function(url, data) {
    if (!url) {
      return;
    }
    var texture;
    var ext = pc.path.getExtension(url).toLowerCase();
    var format = null;
    if (data instanceof Image || data instanceof HTMLImageElement) {
      var img = data;
      format = ext === ".jpg" || ext === ".jpeg" ? pc.PIXELFORMAT_R8_G8_B8 : pc.PIXELFORMAT_R8_G8_B8_A8;
      texture = new pc.Texture(this._device, {width:img.width, height:img.height, format:format});
      texture.name = url;
      texture.setSource(img);
    } else {
      if (data instanceof ArrayBuffer) {
        var LEGACY = true;
        if (LEGACY && ext === ".dds") {
          texture = _legacyDdsLoader(url, data, this._device);
        } else {
          var textureData;
          switch(ext) {
            case ".dds":
              textureData = new pc.DdsParser(data);
              break;
            case ".ktx":
              textureData = new pc.KtxParser(data);
              break;
            case ".pvr":
              console.warn("PVR container not supported.");
              break;
          }
          if (!textureData) {
            texture = new pc.Texture(this._device, {width:4, height:4, format:pc.PIXELFORMAT_R8_G8_B8});
            texture.name = "unsupported-empty";
            return texture;
          }
          texture = new pc.Texture(this._device, {addressU:textureData.cubemap ? pc.ADDRESS_CLAMP_TO_EDGE : pc.ADDRESS_REPEAT, addressV:textureData.cubemap ? pc.ADDRESS_CLAMP_TO_EDGE : pc.ADDRESS_REPEAT, width:textureData.width, height:textureData.height, format:textureData.format, cubemap:textureData.cubemap, levels:textureData.levels});
          texture.name = url;
          texture.upload();
        }
      }
    }
    return texture;
  }, patch:function(asset, assets) {
    var texture = asset.resource;
    if (!texture) {
      return;
    }
    if (texture.name !== asset.name) {
      texture.name = asset.name;
    }
    if (asset.data.hasOwnProperty("minfilter") && texture.minFilter !== JSON_FILTER_MODE[asset.data.minfilter]) {
      texture.minFilter = JSON_FILTER_MODE[asset.data.minfilter];
    }
    if (asset.data.hasOwnProperty("magfilter") && texture.magFilter !== JSON_FILTER_MODE[asset.data.magfilter]) {
      texture.magFilter = JSON_FILTER_MODE[asset.data.magfilter];
    }
    if (asset.data.hasOwnProperty("addressu") && texture.addressU !== JSON_ADDRESS_MODE[asset.data.addressu]) {
      texture.addressU = JSON_ADDRESS_MODE[asset.data.addressu];
    }
    if (asset.data.hasOwnProperty("addressv") && texture.addressV !== JSON_ADDRESS_MODE[asset.data.addressv]) {
      texture.addressV = JSON_ADDRESS_MODE[asset.data.addressv];
    }
    if (asset.data.hasOwnProperty("mipmaps") && texture.mipmaps !== asset.data.mipmaps) {
      texture.mipmaps = asset.data.mipmaps;
    }
    if (asset.data.hasOwnProperty("anisotropy") && texture.anisotropy !== asset.data.anisotropy) {
      texture.anisotropy = asset.data.anisotropy;
    }
    var rgbm = !!asset.data.rgbm;
    if (asset.data.hasOwnProperty("rgbm") && texture.rgbm !== rgbm) {
      texture.rgbm = rgbm;
    }
  }});
  return {TextureHandler:TextureHandler};
}());
Object.assign(pc, function() {
  var HtmlHandler = function() {
  };
  Object.assign(HtmlHandler.prototype, {load:function(url, callback) {
    if (typeof url === "string") {
      url = {load:url, original:url};
    }
    pc.http.get(url.load, function(err, response) {
      if (!err) {
        callback(null, response);
      } else {
        callback(pc.string.format("Error loading html resource: {0} [{1}]", url.original, err));
      }
    });
  }, open:function(url, data) {
    return data;
  }, patch:function(asset, assets) {
  }});
  return {HtmlHandler:HtmlHandler};
}());
Object.assign(pc, function() {
  var CssHandler = function() {
  };
  Object.assign(CssHandler.prototype, {load:function(url, callback) {
    if (typeof url === "string") {
      url = {load:url, original:url};
    }
    pc.http.get(url.load, function(err, response) {
      if (!err) {
        callback(null, response);
      } else {
        callback(pc.string.format("Error loading css resource: {0} [{1}]", url.original, err));
      }
    });
  }, open:function(url, data) {
    return data;
  }, patch:function(asset, assets) {
  }});
  var createStyle = function(cssString) {
    var result = document.createElement("style");
    result.type = "text/css";
    if (result.styleSheet) {
      result.styleSheet.cssText = cssString;
    } else {
      result.appendChild(document.createTextNode(cssString));
    }
    return result;
  };
  return {CssHandler:CssHandler, createStyle:createStyle};
}());
Object.assign(pc, function() {
  var SceneHandler = function(app) {
    this._app = app;
  };
  Object.assign(SceneHandler.prototype, {load:function(url, callback) {
    if (typeof url === "string") {
      url = {load:url, original:url};
    }
    pc.http.get(url.load, function(err, response) {
      if (!err) {
        callback(null, response);
      } else {
        callback("Error requesting scene: " + url.original);
      }
    });
  }, open:function(url, data) {
    this._app.systems.script.preloading = true;
    var parser = new pc.SceneParser(this._app);
    var parent = parser.parse(data);
    var scene = this._app.scene;
    scene.root = parent;
    this._app.applySceneSettings(data.settings);
    this._app.systems.script.preloading = false;
    return scene;
  }, patch:function(asset, assets) {
  }});
  return {SceneHandler:SceneHandler};
}());
Object.assign(pc, function() {
  var HierarchyHandler = function(app) {
    this._app = app;
  };
  Object.assign(HierarchyHandler.prototype, {load:function(url, callback) {
    if (typeof url === "string") {
      url = {load:url, original:url};
    }
    pc.http.get(url.load, function(err, response) {
      if (!err) {
        callback(null, response);
      } else {
        callback("Error requesting scene: " + url.original);
      }
    });
  }, open:function(url, data) {
    this._app.systems.script.preloading = true;
    var parser = new pc.SceneParser(this._app);
    var parent = parser.parse(data);
    this._app.systems.script.preloading = false;
    return parent;
  }});
  return {HierarchyHandler:HierarchyHandler};
}());
Object.assign(pc, function() {
  var SceneSettingsHandler = function(app) {
    this._app = app;
  };
  Object.assign(SceneSettingsHandler.prototype, {load:function(url, callback) {
    if (typeof url === "string") {
      url = {load:url, original:url};
    }
    pc.http.get(url.load, function(err, response) {
      if (!err) {
        callback(null, response);
      } else {
        callback("Error requesting scene: " + url.original);
      }
    });
  }, open:function(url, data) {
    return data.settings;
  }});
  return {SceneSettingsHandler:SceneSettingsHandler};
}());
Object.assign(pc, function() {
  var FolderHandler = function() {
  };
  Object.assign(FolderHandler.prototype, {load:function(url, callback) {
    callback(null, null);
  }, open:function(url, data) {
    return data;
  }});
  return {FolderHandler:FolderHandler};
}());
Object.assign(pc, function() {
  var JSON_ADDRESS_MODE = {"repeat":pc.ADDRESS_REPEAT, "clamp":pc.ADDRESS_CLAMP_TO_EDGE, "mirror":pc.ADDRESS_MIRRORED_REPEAT};
  var JSON_FILTER_MODE = {"nearest":pc.FILTER_NEAREST, "linear":pc.FILTER_LINEAR, "nearest_mip_nearest":pc.FILTER_NEAREST_MIPMAP_NEAREST, "linear_mip_nearest":pc.FILTER_LINEAR_MIPMAP_NEAREST, "nearest_mip_linear":pc.FILTER_NEAREST_MIPMAP_LINEAR, "linear_mip_linear":pc.FILTER_LINEAR_MIPMAP_LINEAR};
  var regexFrame = /^data\.frames\.(\d+)$/;
  var TextureAtlasHandler = function(loader) {
    this._loader = loader;
  };
  Object.assign(TextureAtlasHandler.prototype, {load:function(url, callback) {
    if (typeof url === "string") {
      url = {load:url, original:url};
    }
    var self = this;
    var handler = this._loader.getHandler("texture");
    if (pc.path.getExtension(url.original) === ".json") {
      pc.http.get(url.load, function(err, response) {
        if (!err) {
          var textureUrl = url.original.replace(".json", ".png");
          self._loader.load(textureUrl, "texture", function(err, texture) {
            if (err) {
              callback(err);
            } else {
              callback(null, {data:response, texture:texture});
            }
          });
        } else {
          callback(err);
        }
      });
    } else {
      return handler.load(url, callback);
    }
  }, open:function(url, data) {
    var resource = new pc.TextureAtlas;
    if (data.texture && data.data) {
      resource.texture = data.texture;
      resource.__data = data.data;
    } else {
      var handler = this._loader.getHandler("texture");
      var texture = handler.open(url, data);
      if (!texture) {
        return null;
      }
      resource.texture = texture;
    }
    return resource;
  }, patch:function(asset, assets) {
    if (asset.resource.__data) {
      if (asset.resource.__data.minfilter !== undefined) {
        asset.data.minfilter = asset.resource.__data.minfilter;
      }
      if (asset.resource.__data.magfilter !== undefined) {
        asset.data.magfilter = asset.resource.__data.magfilter;
      }
      if (asset.resource.__data.addressu !== undefined) {
        asset.data.addressu = asset.resource.__data.addressu;
      }
      if (asset.resource.__data.addressv !== undefined) {
        asset.data.addressv = asset.resource.__data.addressv;
      }
      if (asset.resource.__data.mipmaps !== undefined) {
        asset.data.mipmaps = asset.resource.__data.mipmaps;
      }
      if (asset.resource.__data.anisotropy !== undefined) {
        asset.data.anisotropy = asset.resource.__data.anisotropy;
      }
      if (asset.resource.__data.rgbm !== undefined) {
        asset.data.rgbm = !!asset.resource.__data.rgbm;
      }
      asset.data.frames = asset.resource.__data.frames;
      delete asset.resource.__data;
    }
    var texture = asset.resource.texture;
    if (texture) {
      texture.name = asset.name;
      if (asset.data.hasOwnProperty("minfilter") && texture.minFilter !== JSON_FILTER_MODE[asset.data.minfilter]) {
        texture.minFilter = JSON_FILTER_MODE[asset.data.minfilter];
      }
      if (asset.data.hasOwnProperty("magfilter") && texture.magFilter !== JSON_FILTER_MODE[asset.data.magfilter]) {
        texture.magFilter = JSON_FILTER_MODE[asset.data.magfilter];
      }
      if (asset.data.hasOwnProperty("addressu") && texture.addressU !== JSON_ADDRESS_MODE[asset.data.addressu]) {
        texture.addressU = JSON_ADDRESS_MODE[asset.data.addressu];
      }
      if (asset.data.hasOwnProperty("addressv") && texture.addressV !== JSON_ADDRESS_MODE[asset.data.addressv]) {
        texture.addressV = JSON_ADDRESS_MODE[asset.data.addressv];
      }
      if (asset.data.hasOwnProperty("mipmaps") && texture.mipmaps !== asset.data.mipmaps) {
        texture.mipmaps = asset.data.mipmaps;
      }
      if (asset.data.hasOwnProperty("anisotropy") && texture.anisotropy !== asset.data.anisotropy) {
        texture.anisotropy = asset.data.anisotropy;
      }
      var rgbm = !!asset.data.rgbm;
      if (asset.data.hasOwnProperty("rgbm") && texture.rgbm !== rgbm) {
        texture.rgbm = rgbm;
      }
    }
    asset.resource.texture = texture;
    var frames = {};
    for (var key in asset.data.frames) {
      var frame = asset.data.frames[key];
      frames[key] = {rect:new pc.Vec4(frame.rect), pivot:new pc.Vec2(frame.pivot), border:new pc.Vec4(frame.border)};
    }
    asset.resource.frames = frames;
    asset.off("change", this._onAssetChange, this);
    asset.on("change", this._onAssetChange, this);
  }, _onAssetChange:function(asset, attribute, value) {
    var frame;
    if (attribute === "data" || attribute === "data.frames") {
      var frames = {};
      for (var key in value.frames) {
        frame = value.frames[key];
        frames[key] = {rect:new pc.Vec4(frame.rect), pivot:new pc.Vec2(frame.pivot), border:new pc.Vec4(frame.border)};
      }
      asset.resource.frames = frames;
    } else {
      var match = attribute.match(regexFrame);
      if (match) {
        var frameKey = match[1];
        if (value) {
          if (!asset.resource.frames[frameKey]) {
            asset.resource.frames[frameKey] = {rect:new pc.Vec4(value.rect), pivot:new pc.Vec2(value.pivot), border:new pc.Vec4(value.border)};
          } else {
            frame = asset.resource.frames[frameKey];
            frame.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);
            frame.pivot.set(value.pivot[0], value.pivot[1]);
            frame.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);
          }
          asset.resource.fire("set:frame", frameKey, asset.resource.frames[frameKey]);
        } else {
          if (asset.resource.frames[frameKey]) {
            delete asset.resource.frames[frameKey];
            asset.resource.fire("remove:frame", frameKey);
          }
        }
      }
    }
  }});
  return {TextureAtlasHandler:TextureAtlasHandler};
}());
Object.assign(pc, function() {
  var SpriteHandler = function(assets, device) {
    this._assets = assets;
    this._device = device;
  };
  var onTextureAtlasLoaded = function(atlasAsset) {
    var spriteAsset = this;
    if (spriteAsset.resource) {
      spriteAsset.resource.atlas = atlasAsset.resource;
    }
  };
  var onTextureAtlasAdded = function(atlasAsset) {
    var spriteAsset = this;
    spriteAsset.registry.load(atlasAsset);
  };
  Object.assign(SpriteHandler.prototype, {load:function(url, callback) {
    if (typeof url === "string") {
      url = {load:url, original:url};
    }
    if (pc.path.getExtension(url.original) === ".json") {
      pc.http.get(url.load, function(err, response) {
        if (!err) {
          callback(null, response);
        } else {
          callback(err);
        }
      });
    }
  }, open:function(url, data) {
    var sprite = new pc.Sprite(this._device);
    if (url) {
      sprite.__data = data;
    }
    return sprite;
  }, patch:function(asset, assets) {
    var sprite = asset.resource;
    if (sprite.__data) {
      asset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;
      asset.data.renderMode = sprite.__data.renderMode;
      asset.data.frameKeys = sprite.__data.frameKeys;
      if (sprite.__data.textureAtlasAsset) {
        var atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);
        if (atlas) {
          asset.data.textureAtlasAsset = atlas.id;
        } else {
          console.warn("Could not find textureatlas with url: " + sprite.__data.textureAtlasAsset);
        }
      }
    }
    sprite.startUpdate();
    sprite.renderMode = asset.data.renderMode;
    sprite.pixelsPerUnit = asset.data.pixelsPerUnit;
    sprite.frameKeys = asset.data.frameKeys;
    this._updateAtlas(asset);
    sprite.endUpdate();
    asset.off("change", this._onAssetChange, this);
    asset.on("change", this._onAssetChange, this);
  }, _updateAtlas:function(asset) {
    var sprite = asset.resource;
    if (!asset.data.textureAtlasAsset) {
      sprite.atlas = null;
      return;
    }
    this._assets.off("load:" + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);
    this._assets.on("load:" + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);
    var atlasAsset = this._assets.get(asset.data.textureAtlasAsset);
    if (atlasAsset && atlasAsset.resource) {
      sprite.atlas = atlasAsset.resource;
    } else {
      if (!atlasAsset) {
        this._assets.off("add:" + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
        this._assets.on("add:" + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
      } else {
        this._assets.load(atlasAsset);
      }
    }
  }, _onAssetChange:function(asset, attribute, value, oldValue) {
    if (attribute === "data") {
      if (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {
        this._assets.off("load:" + oldValue.textureAtlasAsset, onTextureAtlasLoaded, asset);
        this._assets.off("add:" + oldValue.textureAtlasAsset, onTextureAtlasAdded, asset);
      }
    }
  }});
  return {SpriteHandler:SpriteHandler};
}());
Object.assign(pc, function() {
  var SceneParser = function(app) {
    this._app = app;
  };
  Object.assign(SceneParser.prototype, {parse:function(data) {
    var entities = {};
    var id, i;
    var parent = null;
    for (id in data.entities) {
      entities[id] = this._createEntity(data.entities[id]);
      if (data.entities[id].parent === null) {
        parent = entities[id];
      }
    }
    for (id in data.entities) {
      var l = data.entities[id].children.length;
      for (i = 0; i < l; i++) {
        var resource_id = data.entities[id].children[i];
        if (entities[resource_id]) {
          entities[id].addChild(entities[resource_id]);
        }
      }
    }
    this._openComponentData(parent, data.entities);
    return parent;
  }, _createEntity:function(data) {
    var entity = new pc.Entity;
    var p = data.position;
    var r = data.rotation;
    var s = data.scale;
    entity.name = data.name;
    entity.setGuid(data.resource_id);
    entity.setLocalPosition(p[0], p[1], p[2]);
    entity.setLocalEulerAngles(r[0], r[1], r[2]);
    entity.setLocalScale(s[0], s[1], s[2]);
    entity._enabled = data.enabled !== undefined ? data.enabled : true;
    entity._enabledInHierarchy = entity._enabled;
    entity.template = data.template;
    if (data.tags) {
      for (var i = 0; i < data.tags.length; i++) {
        entity.tags.add(data.tags[i]);
      }
    }
    if (data.labels) {
      data.labels.forEach(function(label) {
        entity.addLabel(label);
      });
    }
    return entity;
  }, _openComponentData:function(entity, entities) {
    var systemsList = this._app.systems.list;
    var i, len = systemsList.length;
    var entityData = entities[entity.getGuid()];
    for (i = 0; i < len; i++) {
      var system = systemsList[i];
      var componentData = entityData.components[system.id];
      if (componentData) {
        system.addComponent(entity, componentData);
      }
    }
    len = entityData.children.length;
    var children = entity._children;
    for (i = 0; i < len; i++) {
      children[i] = this._openComponentData(children[i], entities);
    }
    return entity;
  }});
  return {SceneParser:SceneParser};
}());
Object.assign(pc, function() {
  var JsonStandardMaterialParser = function() {
    this._validator = null;
  };
  JsonStandardMaterialParser.prototype.parse = function(input) {
    var migrated = this.migrate(input);
    var validated = this._validate(migrated);
    var material = new pc.StandardMaterial;
    this.initialize(material, validated);
    return material;
  };
  JsonStandardMaterialParser.prototype.initialize = function(material, data) {
    if (!data.validated) {
      if (!this._validator) {
        this._validator = new pc.StandardMaterialValidator;
      }
      this._validator.validate(data);
    }
    if (data.chunks) {
      material.chunks.copy(data.chunks);
    }
    for (var key in data) {
      var type = pc.StandardMaterial.PARAMETER_TYPES[key];
      var value = data[key];
      if (type === "vec2") {
        material[key] = new pc.Vec2(value[0], value[1]);
      } else {
        if (type === "rgb") {
          material[key] = new pc.Color(value[0], value[1], value[2]);
        } else {
          if (type === "texture") {
            if (value instanceof pc.Texture) {
              material[key] = value;
            } else {
              if (material[key] instanceof pc.Texture && typeof value === "number" && value > 0) {
              } else {
                material[key] = null;
              }
            }
          } else {
            if (type === "cubemap") {
              if (value instanceof pc.Texture) {
                material[key] = value;
              } else {
                if (material[key] instanceof pc.Texture && typeof value === "number" && value > 0) {
                } else {
                  material[key] = null;
                }
              }
            } else {
              if (type === "boundingbox") {
                var center = new pc.Vec3(value.center[0], value.center[1], value.center[2]);
                var halfExtents = new pc.Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);
                material[key] = new pc.BoundingBox(center, halfExtents);
              } else {
                material[key] = data[key];
              }
            }
          }
        }
      }
    }
    material.update();
  };
  JsonStandardMaterialParser.prototype.migrate = function(data) {
    if (data.shadingModel === undefined) {
      if (data.shader === "blinn") {
        data.shadingModel = pc.SPECULAR_BLINN;
      } else {
        data.shadingModel = pc.SPECULAR_PHONG;
      }
    }
    if (data.shader) {
      delete data.shader;
    }
    if (data.mapping_format) {
      data.mappingFormat = data.mapping_format;
      delete data.mapping_format;
    }
    var i;
    var RENAMED_PROPERTIES = [["bumpMapFactor", "bumpiness"], ["aoUvSet", "aoMapUv"], ["aoMapVertexColor", "aoVertexColor"], ["diffuseMapVertexColor", "diffuseVertexColor"], ["emissiveMapVertexColor", "emissiveVertexColor"], ["specularMapVertexColor", "specularVertexColor"], ["metalnessMapVertexColor", "metalnessVertexColor"], ["opacityMapVertexColor", "opacityVertexColor"], ["glossMapVertexColor", "glossVertexColor"], ["lightMapVertexColor", "lightVertexColor"], ["diffuseMapTint", "diffuseTint"], 
    ["specularMapTint", "specularTint"], ["emissiveMapTint", "emissiveTint"], ["metalnessMapTint", "metalnessTint"]];
    for (i = 0; i < RENAMED_PROPERTIES.length; i++) {
      var _old = RENAMED_PROPERTIES[i][0];
      var _new = RENAMED_PROPERTIES[i][1];
      if (data[_old] !== undefined && !(data[_new] !== undefined)) {
        data[_new] = data[_old];
        delete data[_old];
      }
    }
    var DEPRECATED_PROPERTIES = ["fresnelFactor", "shadowSampleType"];
    for (i = 0; i < DEPRECATED_PROPERTIES.length; i++) {
      var name = DEPRECATED_PROPERTIES[i];
      if (data.hasOwnProperty(name)) {
        delete data[name];
      }
    }
    return data;
  };
  JsonStandardMaterialParser.prototype._validate = function(data) {
    if (!this._validator) {
      this._validator = new pc.StandardMaterialValidator;
    }
    this._validator.validate(data);
    return data;
  };
  return {JsonStandardMaterialParser:JsonStandardMaterialParser};
}());
Object.assign(pc, function() {
  var assetIdCounter = 0;
  var ABSOLUTE_URL = new RegExp("^" + "\\s*" + "(?:" + "[a-z]+[a-z0-9\\-\\+\\.]*" + ":" + ")?" + "//", "i");
  var VARIANT_SUPPORT = {pvr:"extCompressedTexturePVRTC", dxt:"extCompressedTextureS3TC", etc2:"extCompressedTextureETC", etc1:"extCompressedTextureETC1"};
  var VARIANT_DEFAULT_PRIORITY = ["pvr", "dxt", "etc2", "etc1"];
  var Asset = function(name, type, file, data) {
    this._id = ++assetIdCounter;
    this.name = name || "";
    this.type = type;
    this.tags = new pc.Tags(this);
    this._preload = false;
    this.variants = new pc.AssetVariants(this);
    this._file = null;
    this._data = data || {};
    this._resources = [];
    this.loaded = false;
    this.loading = false;
    this.registry = null;
    pc.events.attach(this);
    if (file) {
      this.file = file;
    }
  };
  Object.assign(Asset.prototype, {getFileUrl:function() {
    var file = this.getPreferredFile();
    if (!file || !file.url) {
      return null;
    }
    var url = file.url;
    if (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url)) {
      url = this.registry.prefix + url;
    }
    if (this.type !== "script" && file.hash) {
      var separator = url.indexOf("?") !== -1 ? "&" : "?";
      url += separator + "t=" + file.hash;
    }
    return url;
  }, getPreferredFile:function() {
    if (!this.file) {
      return null;
    }
    if (this.type === "texture" || this.type === "textureatlas" || this.type === "bundle") {
      var app = this.registry._loader._app;
      var device = app.graphicsDevice;
      for (var i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++) {
        var variant = VARIANT_DEFAULT_PRIORITY[i];
        if (!device[VARIANT_SUPPORT[variant]]) {
          continue;
        }
        if (this.file.variants[variant]) {
          return this.file.variants[variant];
        }
        if (app.enableBundles) {
          var bundles = app.bundles.listBundlesForAsset(this);
          if (!bundles) {
            continue;
          }
          for (var j = 0, len2 = bundles.length; j < len2; j++) {
            if (bundles[j].file && bundles[j].file.variants && bundles[j].file.variants[variant]) {
              return this.file;
            }
          }
        }
      }
    }
    return this.file;
  }, ready:function(callback, scope) {
    scope = scope || this;
    if (this.resource) {
      callback.call(scope, this);
    } else {
      this.once("load", function(asset) {
        callback.call(scope, asset);
      });
    }
  }, reload:function() {
    if (!this.loaded) {
      return;
    }
    if (this.type === "cubemap") {
      this.registry._loader.patch(this, this.registry);
    } else {
      this.loaded = false;
      this.registry.load(this);
    }
  }, unload:function() {
    if (!this.loaded && !this.resource) {
      return;
    }
    this.fire("unload", this);
    this.registry.fire("unload:" + this.id, this);
    if (this.resource && this.resource.destroy) {
      this.resource.destroy();
    }
    this.resource = null;
    this.loaded = false;
    if (this.file) {
      this.registry._loader.clearCache(this.getFileUrl(), this.type);
    }
  }});
  Object.defineProperty(Asset.prototype, "id", {get:function() {
    return this._id;
  }, set:function(value) {
    this._id = value;
    if (value > assetIdCounter) {
      assetIdCounter = value;
    }
  }});
  Object.defineProperty(Asset.prototype, "file", {get:function() {
    return this._file;
  }, set:function(value) {
    var key;
    var valueAsBool = !!value;
    var fileAsBool = !!this._file;
    if (valueAsBool !== fileAsBool || value && this._file && value.hash !== this._file) {
      if (value) {
        if (!this._file) {
          this._file = {};
        }
        this._file.url = value.url;
        this._file.filename = value.filename;
        this._file.hash = value.hash;
        this._file.size = value.size;
        this._file.variants = this.variants;
        if (value.hasOwnProperty("variants")) {
          this.variants.clear();
          if (value.variants) {
            for (key in value.variants) {
              if (!value.variants[key]) {
                continue;
              }
              this.variants[key] = value.variants[key];
            }
          }
        }
        this.fire("change", this, "file", this._file, this._file);
        this.reload();
      } else {
        this._file = null;
        this.variants.clear();
      }
    } else {
      if (value && this._file && value.hasOwnProperty("variants")) {
        this.variants.clear();
        if (value.variants) {
          for (key in value.variants) {
            if (!value.variants[key]) {
              continue;
            }
            this.variants[key] = value.variants[key];
          }
        }
      }
    }
  }});
  Object.defineProperty(Asset.prototype, "data", {get:function() {
    return this._data;
  }, set:function(value) {
    var old = this._data;
    this._data = value;
    if (value !== old) {
      this.fire("change", this, "data", value, old);
      if (this.loaded) {
        this.registry._loader.patch(this, this.registry);
      }
    }
  }});
  Object.defineProperty(Asset.prototype, "resource", {get:function() {
    return this._resources[0];
  }, set:function(value) {
    var _old = this._resources[0];
    this._resources[0] = value;
    this.fire("change", this, "resource", value, _old);
  }});
  Object.defineProperty(Asset.prototype, "resources", {get:function() {
    return this._resources;
  }, set:function(value) {
    var _old = this._resources;
    this._resources = value;
    this.fire("change", this, "resources", value, _old);
  }});
  Object.defineProperty(Asset.prototype, "preload", {get:function() {
    return this._preload;
  }, set:function(value) {
    value = !!value;
    if (this._preload === value) {
      return;
    }
    this._preload = value;
    if (this._preload && !this.loaded && !this.loading && this.registry) {
      this.registry.load(this);
    }
  }});
  return {Asset:Asset, ASSET_ANIMATION:"animation", ASSET_AUDIO:"audio", ASSET_IMAGE:"image", ASSET_JSON:"json", ASSET_MODEL:"model", ASSET_MATERIAL:"material", ASSET_TEXT:"text", ASSET_TEXTURE:"texture", ASSET_CUBEMAP:"cubemap", ASSET_SHADER:"shader", ASSET_CSS:"css", ASSET_HTML:"html", ASSET_SCRIPT:"script", ABSOLUTE_URL:ABSOLUTE_URL};
}());
Object.assign(pc, function() {
  var properties = [];
  var AssetVariants = function(asset) {
    this.asset = asset;
  };
  var defineVariantProperty = function(name) {
    var field = "_" + name;
    properties.push(field);
    Object.defineProperty(AssetVariants.prototype, name, {get:function() {
      return this[field] || null;
    }, set:function(value) {
      var fieldAsBool = !!this[field];
      var valueAsBool = !!value;
      if (fieldAsBool !== valueAsBool || this[field] && value && this[field].hash !== value.hash) {
        if (value) {
          this[field] = {url:value.url, filename:value.filename, size:value.size, hash:value.hash, opt:value.opt || 0};
        } else {
          this[field] = null;
        }
        if (this.asset.file) {
          this.asset.fire("change", this.asset, "file", this.asset._file, this.asset._file);
          this.asset.reload();
        }
      }
    }});
  };
  defineVariantProperty("dxt");
  defineVariantProperty("pvr");
  defineVariantProperty("etc1");
  defineVariantProperty("etc2");
  AssetVariants.prototype.clear = function() {
    for (var i = 0; i < properties.length; i++) {
      this[properties[i]] = null;
    }
  };
  return {AssetVariants:AssetVariants};
}());
Object.assign(pc, function() {
  var AssetRegistry = function(loader) {
    this._loader = loader;
    this._assets = [];
    this._cache = {};
    this._names = {};
    this._tags = new pc.TagsCache("_id");
    this._urls = {};
    this.prefix = null;
    Object.assign(this, pc.events);
  };
  Object.assign(AssetRegistry.prototype, {list:function(filters) {
    filters = filters || {};
    return this._assets.filter(function(asset) {
      var include = true;
      if (filters.preload !== undefined) {
        include = asset.preload === filters.preload;
      }
      return include;
    });
  }, add:function(asset) {
    var index = this._assets.push(asset) - 1;
    var url;
    this._cache[asset.id] = index;
    if (!this._names[asset.name]) {
      this._names[asset.name] = [];
    }
    this._names[asset.name].push(index);
    if (asset.file) {
      url = asset.file.url;
      this._urls[url] = index;
    }
    asset.registry = this;
    this._tags.addItem(asset);
    asset.tags.on("add", this._onTagAdd, this);
    asset.tags.on("remove", this._onTagRemove, this);
    this.fire("add", asset);
    this.fire("add:" + asset.id, asset);
    if (url) {
      this.fire("add:url:" + url, asset);
    }
    if (asset.preload) {
      this.load(asset);
    }
  }, remove:function(asset) {
    var idx = this._cache[asset.id];
    var url = asset.file ? asset.file.url : null;
    if (idx !== undefined) {
      this._assets.splice(idx, 1);
      delete this._cache[asset.id];
      this._names = {};
      this._urls = [];
      for (var i = 0, l = this._assets.length; i < l; i++) {
        var a = this._assets[i];
        this._cache[a.id] = i;
        if (!this._names[a.name]) {
          this._names[a.name] = [];
        }
        this._names[a.name].push(i);
        if (a.file) {
          this._urls[a.file.url] = i;
        }
      }
      this._tags.removeItem(asset);
      asset.tags.off("add", this._onTagAdd, this);
      asset.tags.off("remove", this._onTagRemove, this);
      asset.fire("remove", asset);
      this.fire("remove", asset);
      this.fire("remove:" + asset.id, asset);
      if (url) {
        this.fire("remove:url:" + url, asset);
      }
      return true;
    }
    return false;
  }, get:function(id) {
    var idx = this._cache[id];
    return this._assets[idx];
  }, getByUrl:function(url) {
    var idx = this._urls[url];
    return this._assets[idx];
  }, load:function(asset) {
    if (asset.loading) {
      return;
    }
    var self = this;
    if (asset.loaded) {
      if (asset.type === "cubemap") {
        self._loader.patch(asset, this);
      }
      return;
    }
    var load = !!asset.file;
    var file = asset.getPreferredFile();
    var _load = function() {
      var url = asset.getFileUrl();
      asset.loading = true;
      self._loader.load(url, asset.type, function(err, resource, extra) {
        asset.loaded = true;
        asset.loading = false;
        if (err) {
          self.fire("error", err, asset);
          self.fire("error:" + asset.id, err, asset);
          asset.fire("error", err, asset);
          return;
        }
        if (resource instanceof Array) {
          asset.resources = resource;
        } else {
          asset.resource = resource;
        }
        if (!pc.script.legacy && asset.type === "script") {
          var loader = self._loader.getHandler("script");
          if (loader._cache[asset.id] && loader._cache[asset.id].parentNode === document.head) {
            document.head.removeChild(loader._cache[asset.id]);
          }
          loader._cache[asset.id] = extra;
        }
        self._loader.patch(asset, self);
        self.fire("load", asset);
        self.fire("load:" + asset.id, asset);
        if (file && file.url) {
          self.fire("load:url:" + file.url, asset);
        }
        asset.fire("load", asset);
      }, asset);
    };
    var _open = function() {
      var resource = self._loader.open(asset.type, asset.data);
      if (resource instanceof Array) {
        asset.resources = resource;
      } else {
        asset.resource = resource;
      }
      asset.loaded = true;
      self._loader.patch(asset, self);
      self.fire("load", asset);
      self.fire("load:" + asset.id, asset);
      if (file && file.url) {
        self.fire("load:url:" + file.url, asset);
      }
      asset.fire("load", asset);
    };
    if (file && asset.type === "cubemap") {
      load = false;
      var url = asset.getFileUrl();
      this._loader.load(url, "texture", function(err, texture) {
        if (!err) {
          self._loader.patch({resource:texture, type:"texture", data:asset.data}, self);
          asset._dds = texture;
          _open();
        } else {
          self.fire("error", err, asset);
          self.fire("error:" + asset.id, err, asset);
          asset.fire("error", err, asset);
        }
      });
    }
    if (!file) {
      _open();
    } else {
      if (load) {
        this.fire("load:start", asset);
        this.fire("load:" + asset.id + ":start", asset);
        _load();
      }
    }
  }, loadFromUrl:function(url, type, callback) {
    var self = this;
    var name = pc.path.getBasename(url);
    var file = {url:url};
    var data = {};
    var asset = self.getByUrl(url);
    if (!asset) {
      asset = new pc.Asset(name, type, file, data);
      self.add(asset);
    }
    if (type === "model") {
      self._loadModel(asset, callback);
      return;
    }
    asset.once("load", function(loadedAsset) {
      callback(null, loadedAsset);
    });
    asset.once("error", function(err) {
      callback(err);
    });
    self.load(asset);
  }, _loadModel:function(asset, callback) {
    var self = this;
    var url = asset.getFileUrl();
    var dir = pc.path.getDirectory(url);
    var basename = pc.path.getBasename(url);
    var ext = pc.path.getExtension(url);
    var _loadAsset = function(assetToLoad) {
      asset.once("load", function(loadedAsset) {
        callback(null, loadedAsset);
      });
      asset.once("error", function(err) {
        callback(err);
      });
      self.load(assetToLoad);
    };
    if (ext === ".json") {
      var mappingUrl = pc.path.join(dir, basename.replace(".json", ".mapping.json"));
      this._loader.load(mappingUrl, "json", function(err, data) {
        if (err) {
          asset.data = {mapping:[]};
          _loadAsset(asset);
          return;
        }
        self._loadMaterials(dir, data, function(e, materials) {
          asset.data = data;
          _loadAsset(asset);
        });
      });
    } else {
      _loadAsset(asset);
    }
  }, _loadMaterials:function(dir, mapping, callback) {
    var self = this;
    var i;
    var count = mapping.mapping.length;
    var materials = [];
    var done = function(err, loadedMaterials) {
      self._loadTextures(loadedMaterials, function(e, textures) {
        callback(null, loadedMaterials);
      });
    };
    if (count === 0) {
      callback(null, materials);
    }
    var onLoadAsset = function(err, asset) {
      materials.push(asset);
      count--;
      if (count === 0) {
        done(null, materials);
      }
    };
    for (i = 0; i < mapping.mapping.length; i++) {
      var path = mapping.mapping[i].path;
      if (path) {
        path = pc.path.join(dir, path);
        self.loadFromUrl(path, "material", onLoadAsset);
      } else {
        count--;
      }
    }
  }, _loadTextures:function(materialAssets, callback) {
    var self = this;
    var i;
    var used = {};
    var urls = [];
    var textures = [];
    var count = 0;
    for (i = 0; i < materialAssets.length; i++) {
      var materialData = materialAssets[i].data;
      if (materialData.mappingFormat !== "path") {
        console.warn("Skipping: " + materialAssets[i].name + ', material files must be mappingFormat: "path" to be loaded from URL');
        continue;
      }
      var url = materialAssets[i].getFileUrl();
      var dir = pc.path.getDirectory(url);
      var textureUrl;
      for (var pi = 0; pi < pc.StandardMaterial.TEXTURE_PARAMETERS.length; pi++) {
        var paramName = pc.StandardMaterial.TEXTURE_PARAMETERS[pi];
        if (materialData[paramName]) {
          var texturePath = materialData[paramName];
          textureUrl = pc.path.join(dir, texturePath);
          if (!used[textureUrl]) {
            used[textureUrl] = true;
            urls.push(textureUrl);
            count++;
          }
        }
      }
    }
    if (!count) {
      callback(null, textures);
      return;
    }
    var onLoadAsset = function(err, texture) {
      textures.push(texture);
      count--;
      if (err) {
        console.error(err);
      }
      if (count === 0) {
        callback(null, textures);
      }
    };
    for (i = 0; i < urls.length; i++) {
      self.loadFromUrl(urls[i], "texture", onLoadAsset);
    }
  }, findAll:function(name, type) {
    var self = this;
    var idxs = this._names[name];
    if (idxs) {
      var assets = idxs.map(function(idx) {
        return self._assets[idx];
      });
      if (type) {
        return assets.filter(function(asset) {
          return asset.type === type;
        });
      }
      return assets;
    }
    return [];
  }, _onTagAdd:function(tag, asset) {
    this._tags.add(tag, asset);
  }, _onTagRemove:function(tag, asset) {
    this._tags.remove(tag, asset);
  }, findByTag:function() {
    return this._tags.find(arguments);
  }, filter:function(callback) {
    var items = [];
    for (var i = 0, len = this._assets.length; i < len; i++) {
      if (callback(this._assets[i])) {
        items.push(this._assets[i]);
      }
    }
    return items;
  }, find:function(name, type) {
    var asset = this.findAll(name, type);
    return asset ? asset[0] : null;
  }, getAssetById:function(id) {
    console.warn("DEPRECATED: getAssetById() use get() instead");
    return this.get(id);
  }});
  return {AssetRegistry:AssetRegistry};
}());
Object.assign(pc, function() {
  var AssetReference = function(propertyName, parent, registry, callbacks, scope) {
    this.propertyName = propertyName;
    this.parent = parent;
    this._scope = scope;
    this._registry = registry;
    this.id = null;
    this.url = null;
    this.asset = null;
    this._onAssetLoad = callbacks.load;
    this._onAssetAdd = callbacks.add;
    this._onAssetRemove = callbacks.remove;
  };
  AssetReference.prototype._bind = function() {
    if (this.id) {
      if (this._onAssetLoad) {
        this._registry.on("load:" + this.id, this._onLoad, this);
      }
      if (this._onAssetAdd) {
        this._registry.once("add:" + this.id, this._onAdd, this);
      }
      if (this._onAssetRemove) {
        this._registry.on("remove:" + this.id, this._onRemove, this);
      }
    }
    if (this.url) {
      if (this._onAssetLoad) {
        this._registry.on("load:url:" + this.url, this._onLoad, this);
      }
      if (this._onAssetAdd) {
        this._registry.once("add:url:" + this.url, this._onAdd, this);
      }
      if (this._onAssetRemove) {
        this._registry.on("remove:url:" + this.url, this._onRemove, this);
      }
    }
  };
  AssetReference.prototype._unbind = function() {
    if (this.id) {
      if (this._onAssetLoad) {
        this._registry.off("load:" + this.id, this._onLoad, this);
      }
      if (this._onAssetAdd) {
        this._registry.off("add:" + this.id, this._onAdd, this);
      }
      if (this._onAssetRemove) {
        this._registry.off("remove:" + this.id, this._onRemove, this);
      }
    }
    if (this.url) {
      if (this._onAssetLoad) {
        this._registry.off("load:" + this.url, this._onLoad, this);
      }
      if (this._onAssetAdd) {
        this._registry.off("add:" + this.url, this._onAdd, this);
      }
      if (this._onAssetRemove) {
        this._registry.off("remove:" + this.url, this._onRemove, this);
      }
    }
  };
  AssetReference.prototype._onLoad = function(asset) {
    this._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);
  };
  AssetReference.prototype._onAdd = function(asset) {
    this._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);
  };
  AssetReference.prototype._onRemove = function(asset) {
    this._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);
  };
  Object.defineProperty(AssetReference.prototype, "id", {get:function() {
    return this._id;
  }, set:function(value) {
    if (this.url) {
      throw Error("Can't set id and url");
    }
    this._unbind();
    this._id = value;
    this.asset = this._registry.get(this._id);
    this._bind();
  }});
  Object.defineProperty(AssetReference.prototype, "url", {get:function() {
    return this._url;
  }, set:function(value) {
    if (this.id) {
      throw Error("Can't set id and url");
    }
    this._unbind();
    this._url = value;
    this.asset = this._registry.getByUrl(this._url);
    this._bind();
  }});
  return {AssetReference:AssetReference};
}());
Object.assign(pc, function() {
  return {inherits:function(Self, Super) {
    var Temp = function() {
    };
    var Func = function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
      Super.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
      Self.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    };
    Func._super = Super.prototype;
    Temp.prototype = Super.prototype;
    Func.prototype = new Temp;
    return Func;
  }};
}());
pc.anim = {Animation:pc.Animation, Key:pc.Key, Node:pc.Node, Skeleton:pc.Skeleton};
pc.asset = {ASSET_ANIMATION:"animation", ASSET_AUDIO:"audio", ASSET_IMAGE:"image", ASSET_JSON:"json", ASSET_MODEL:"model", ASSET_MATERIAL:"material", ASSET_TEXT:"text", ASSET_TEXTURE:"texture", ASSET_CUBEMAP:"cubemap", ASSET_SCRIPT:"script"};
pc.fw = {Application:pc.Application, Component:pc.Component, ComponentData:pc.ComponentData, ComponentSystem:pc.ComponentSystem, Entity:pc.Entity, FillMode:{NONE:pc.FILLMODE_NONE, FILL_WINDOW:pc.FILLMODE_FILL_WINDOW, KEEP_ASPECT:pc.FILLMODE_KEEP_ASPECT}, ResolutionMode:{AUTO:pc.RESOLUTION_AUTO, FIXED:pc.RESOLUTION_FIXED}};
Object.assign(pc.gfx, {drawQuadWithShader:pc.drawQuadWithShader, programlib:pc.programlib, shaderChunks:pc.shaderChunks, ContextCreationError:pc.ContextCreationError, Device:pc.GraphicsDevice, IndexBuffer:pc.IndexBuffer, ProgramLibrary:pc.ProgramLibrary, RenderTarget:pc.RenderTarget, ScopeId:pc.ScopeId, Shader:pc.Shader, ShaderInput:pc.ShaderInput, Texture:pc.Texture, UnsupportedBrowserError:pc.UnsupportedBrowserError, VertexBuffer:pc.VertexBuffer, VertexFormat:pc.VertexFormat, VertexIterator:pc.VertexIterator});
(function() {
  function UnsupportedBrowserError(message) {
    this.name = "UnsupportedBrowserError";
    this.message = message || "";
  }
  UnsupportedBrowserError.prototype = Error.prototype;
  function ContextCreationError(message) {
    this.name = "ContextCreationError";
    this.message = message || "";
  }
  ContextCreationError.prototype = Error.prototype;
  pc.ContextCreationError = ContextCreationError;
  pc.UnsupportedBrowserError = UnsupportedBrowserError;
})();
Object.assign(pc.input, {getTouchTargetCoords:pc.getTouchTargetCoords, Controller:pc.Controller, GamePads:pc.GamePads, Keyboard:pc.Keyboard, KeyboardEvent:pc.KeyboardEvent, Mouse:pc.Mouse, MouseEvent:pc.MouseEvent, Touch:pc.Touch, TouchDevice:pc.TouchDevice, TouchEvent:pc.TouchEvent});
pc.math.INV_LOG2 = Math.LOG2E;
pc.math.intToBytes = pc.math.intToBytes32;
pc.math.bytesToInt = pc.math.bytesToInt32;
pc.posteffect = {createFullscreenQuad:pc.createFullscreenQuad, drawFullscreenQuad:pc.drawFullscreenQuad, PostEffect:pc.PostEffect, PostEffectQueue:pc.PostEffectQueue};
Object.assign(pc.scene, {partitionSkin:pc.partitionSkin, procedural:{calculateTangents:pc.calculateTangents, createMesh:pc.createMesh, createTorus:pc.createTorus, createCylinder:pc.createCylinder, createCapsule:pc.createCapsule, createCone:pc.createCone, createSphere:pc.createSphere, createPlane:pc.createPlane, createBox:pc.createBox}, BasicMaterial:pc.BasicMaterial, DepthMaterial:pc.DepthMaterial, ForwardRenderer:pc.ForwardRenderer, GraphNode:pc.GraphNode, Material:pc.Material, Command:pc.Command, 
Mesh:pc.Mesh, MeshInstance:pc.MeshInstance, Model:pc.Model, ParticleEmitter:pc.ParticleEmitter, PhongMaterial:pc.StandardMaterial, Picker:pc.Picker, PickMaterial:pc.PickMaterial, Projection:{ORTHOGRAPHIC:pc.PROJECTION_ORTHOGRAPHIC, PERSPECTIVE:pc.PROJECTION_PERSPECTIVE}, Scene:pc.Scene, Skin:pc.Skin, SkinInstance:pc.SkinInstance});
pc.shape = {Aabb:pc.BoundingBox, Sphere:pc.BoundingSphere, Plane:pc.Plane};
pc.time = {now:pc.now, Timer:pc.Timer};
pc.PhongMaterial = pc.StandardMaterial;
pc.BoundingSphere.prototype.intersectRay = pc.BoundingSphere.prototype.intersectsRay;
pc.ELEMENTTYPE_INT8 = pc.TYPE_INT8;
pc.ELEMENTTYPE_UINT8 = pc.TYPE_UINT8;
pc.ELEMENTTYPE_INT16 = pc.TYPE_INT16;
pc.ELEMENTTYPE_UINT16 = pc.TYPE_UINT16;
pc.ELEMENTTYPE_INT32 = pc.TYPE_INT32;
pc.ELEMENTTYPE_UINT32 = pc.TYPE_UINT32;
pc.ELEMENTTYPE_FLOAT32 = pc.TYPE_FLOAT32;
Object.defineProperty(pc.shaderChunks, "transformSkinnedVS", {get:function() {
  return "#define SKIN\n" + pc.shaderChunks.transformVS;
}});
Object.defineProperty(pc.Vec2.prototype, "data", {get:function() {
  if (!this._data) {
    this._data = new Float32Array(2);
  }
  this._data[0] = this.x;
  this._data[1] = this.y;
  return this._data;
}});
Object.defineProperty(pc.Vec3.prototype, "data", {get:function() {
  if (!this._data) {
    this._data = new Float32Array(3);
  }
  this._data[0] = this.x;
  this._data[1] = this.y;
  this._data[2] = this.z;
  return this._data;
}});
Object.defineProperty(pc.Vec4.prototype, "data", {get:function() {
  if (!this._data) {
    this._data = new Float32Array(4);
  }
  this._data[0] = this.x;
  this._data[1] = this.y;
  this._data[2] = this.z;
  this._data[3] = this.w;
  return this._data;
}});
Object.defineProperty(pc.Color.prototype, "data", {get:function() {
  if (!this._data) {
    this._data = new Float32Array(4);
  }
  this._data[0] = this.r;
  this._data[1] = this.g;
  this._data[2] = this.b;
  this._data[3] = this.a;
  return this._data;
}});
Object.defineProperty(pc.Color.prototype, "data3", {get:function() {
  if (!this._data3) {
    this._data3 = new Float32Array(3);
  }
  this._data3[0] = this.r;
  this._data3[1] = this.g;
  this._data3[2] = this.b;
  return this._data3;
}});
pc.Material.prototype.getName = function() {
  return this.name;
};
pc.Material.prototype.setName = function(name) {
  this.name = name;
};
pc.Material.prototype.getShader = function() {
  return this.shader;
};
pc.Material.prototype.setShader = function(shader) {
  this.shader = shader;
};
pc.GraphNode.prototype._dirtify = function(local) {
  if (local) {
    this._dirtifyLocal();
  } else {
    this._dirtifyWorld();
  }
};
Object.assign(pc.Application.prototype, function() {
  var tempGraphNode = new pc.GraphNode;
  var identityGraphNode = new pc.GraphNode;
  var meshInstanceArray = [];
  var _deprecationWarning = false;
  var ImmediateData = function(device) {
    this.lineVertexFormat = new pc.VertexFormat(device, [{semantic:pc.SEMANTIC_POSITION, components:3, type:pc.TYPE_FLOAT32}, {semantic:pc.SEMANTIC_COLOR, components:4, type:pc.TYPE_UINT8, normalize:true}]);
    this.lineBatches = [];
    this.layers = [];
    this.layerToBatch = {};
    this.quadMesh = null;
    this.cubeLocalPos = null;
    this.cubeWorldPos = null;
    this.identityGraphNode = new pc.GraphNode;
  };
  ImmediateData.prototype.addLayer = function(layer) {
    if (this.layers.indexOf(layer) < 0) {
      this.layers.push(layer);
    }
  };
  ImmediateData.prototype.getLayerIdx = function(layer) {
    return this.layerToBatch[layer.id];
  };
  ImmediateData.prototype.addLayerIdx = function(idx, layer) {
    this.layerToBatch[layer.id] = idx;
  };
  var LineBatch = function() {
    this.numLinesAllocated = 128;
    this.vb = null;
    this.vbRam = null;
    this.mesh = null;
    this.linesUsed = 0;
    this.material = null;
    this.meshInstance = null;
    this.layer = null;
  };
  Object.assign(LineBatch.prototype, {init:function(device, vertexFormat, layer, linesToAdd) {
    if (!this.mesh) {
      this.mesh = new pc.Mesh;
      this.mesh.primitive[0].type = pc.PRIMITIVE_LINES;
      this.mesh.primitive[0].base = 0;
      this.mesh.primitive[0].indexed = false;
      this.material = new pc.BasicMaterial;
      this.material.vertexColors = true;
      this.material.blend = true;
      this.material.blendType = pc.BLEND_NORMAL;
      this.material.update();
    }
    this.layer = layer;
    while (this.linesUsed + linesToAdd > this.numLinesAllocated) {
      if (this.vb) {
        this.vb.destroy();
        this.vb = null;
      }
      this.numLinesAllocated *= 2;
    }
    this.vertexFormat = vertexFormat;
    if (!this.vb) {
      this.vb = new pc.VertexBuffer(device, vertexFormat, this.numLinesAllocated * 2, pc.BUFFER_DYNAMIC);
      this.mesh.vertexBuffer = this.vb;
      this.vbRam = new DataView(this.vb.lock());
      if (!this.meshInstance) {
        identityGraphNode.worldTransform = pc.Mat4.IDENTITY;
        identityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;
        this.meshInstance = new pc.MeshInstance(identityGraphNode, this.mesh, this.material);
        this.meshInstance.cull = false;
      }
    }
  }, addLines:function(position, color) {
    var multiColor = !!color.length;
    var offset = this.linesUsed * 2 * this.vertexFormat.size;
    var clr;
    for (var i = 0; i < position.length; i++) {
      this.vbRam.setFloat32(offset, position[i].x, true);
      offset += 4;
      this.vbRam.setFloat32(offset, position[i].y, true);
      offset += 4;
      this.vbRam.setFloat32(offset, position[i].z, true);
      offset += 4;
      clr = multiColor ? color[i] : color;
      this.vbRam.setUint8(offset, clr.r * 255);
      offset += 1;
      this.vbRam.setUint8(offset, clr.g * 255);
      offset += 1;
      this.vbRam.setUint8(offset, clr.b * 255);
      offset += 1;
      this.vbRam.setUint8(offset, clr.a * 255);
      offset += 1;
    }
    this.linesUsed += position.length / 2;
  }, finalize:function() {
    if (this.linesUsed > 0) {
      this.vb.setData(this.vbRam.buffer);
      this.mesh.primitive[0].count = this.linesUsed * 2;
      meshInstanceArray[0] = this.meshInstance;
      this.layer.addMeshInstances(meshInstanceArray, true);
      this.linesUsed = 0;
    }
  }});
  function _initImmediate() {
    if (!this._immediateData) {
      this._immediateData = new ImmediateData(this.graphicsDevice);
      this.on("prerender", this._preRenderImmediate, this);
      this.on("postrender", this._postRenderImmediate, this);
    }
  }
  function _addLines(position, color, options) {
    if (options.layer === undefined) {
      options.layer = this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE);
    }
    if (options.depthTest === undefined) {
      options.depthTest = true;
    }
    this._initImmediate();
    var layer = options.layer;
    this._immediateData.addLayer(layer);
    var idx = this._immediateData.getLayerIdx(layer);
    if (idx === undefined) {
      var batch = new LineBatch;
      batch.init(this.graphicsDevice, this._immediateData.lineVertexFormat, layer, position.length / 2);
      batch.material.depthTest = options.depthTest;
      if (options.mask) {
        batch.meshInstance.mask = options.mask;
      }
      idx = this._immediateData.lineBatches.push(batch) - 1;
      this._immediateData.addLayerIdx(idx, layer);
    } else {
      this._immediateData.lineBatches[idx].init(this.graphicsDevice, this._immediateData.lineVertexFormat, layer, position.length / 2);
      this._immediateData.lineBatches[idx].material.depthTest = options.depthTest;
      if (options.mask) {
        this._immediateData.lineBatches[idx].meshInstance.mask = options.mask;
      }
    }
    this._immediateData.lineBatches[idx].addLines(position, color);
  }
  function renderLine(start, end, color) {
    var endColor = color;
    var options;
    var arg3 = arguments[3];
    var arg4 = arguments[4];
    if (arg3 instanceof pc.Color) {
      endColor = arg3;
      if (typeof arg4 === "number") {
        if (!_deprecationWarning) {
          console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead");
          _deprecationWarning = true;
        }
        if (arg4 === pc.LINEBATCH_OVERLAY) {
          options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:false};
        } else {
          options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:true};
        }
      } else {
        options = arg4;
      }
    } else {
      if (typeof arg3 === "number") {
        if (!_deprecationWarning) {
          console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead");
          _deprecationWarning = true;
        }
        endColor = color;
        if (arg3 === pc.LINEBATCH_OVERLAY) {
          options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:false};
        } else {
          options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:true};
        }
      } else {
        if (arg3) {
          options = arg3;
        } else {
          options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:true};
        }
      }
    }
    this._addLines([start, end], [color, endColor], options);
  }
  function renderLines(position, color, options) {
    if (!options) {
      options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:true};
    } else {
      if (typeof options === "number") {
        if (!_deprecationWarning) {
          console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead");
          _deprecationWarning = true;
        }
        if (options === pc.LINEBATCH_OVERLAY) {
          options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:false};
        } else {
          options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE), depthTest:true};
        }
      }
    }
    var multiColor = !!color.length;
    if (multiColor) {
      if (position.length !== color.length) {
        pc.log.error("renderLines: position/color arrays have different lengths");
        return;
      }
    }
    if (position.length % 2 !== 0) {
      pc.log.error("renderLines: array length is not divisible by 2");
      return;
    }
    this._addLines(position, color, options);
  }
  function renderWireCube(matrix, color, options) {
    var i;
    this._initImmediate();
    if (!this._immediateData.cubeLocalPos) {
      var x = 0.5;
      this._immediateData.cubeLocalPos = [new pc.Vec3(-x, -x, -x), new pc.Vec3(-x, x, -x), new pc.Vec3(x, x, -x), new pc.Vec3(x, -x, -x), new pc.Vec3(-x, -x, x), new pc.Vec3(-x, x, x), new pc.Vec3(x, x, x), new pc.Vec3(x, -x, x)];
      this._immediateData.cubeWorldPos = [new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3, new pc.Vec3];
    }
    var cubeLocalPos = this._immediateData.cubeLocalPos;
    var cubeWorldPos = this._immediateData.cubeWorldPos;
    for (i = 0; i < 8; i++) {
      matrix.transformPoint(cubeLocalPos[i], cubeWorldPos[i]);
    }
    this.renderLines([cubeWorldPos[0], cubeWorldPos[1], cubeWorldPos[1], cubeWorldPos[2], cubeWorldPos[2], cubeWorldPos[3], cubeWorldPos[3], cubeWorldPos[0], cubeWorldPos[4], cubeWorldPos[5], cubeWorldPos[5], cubeWorldPos[6], cubeWorldPos[6], cubeWorldPos[7], cubeWorldPos[7], cubeWorldPos[4], cubeWorldPos[0], cubeWorldPos[4], cubeWorldPos[1], cubeWorldPos[5], cubeWorldPos[2], cubeWorldPos[6], cubeWorldPos[3], cubeWorldPos[7]], color, options);
  }
  function _preRenderImmediate() {
    for (var i = 0; i < this._immediateData.lineBatches.length; i++) {
      if (this._immediateData.lineBatches[i]) {
        this._immediateData.lineBatches[i].finalize();
      }
    }
  }
  function _postRenderImmediate() {
    for (var i = 0; i < this._immediateData.layers.length; i++) {
      this._immediateData.layers[i].clearMeshInstances(true);
    }
    this._immediateData.layers.length = 0;
  }
  function renderMeshInstance(meshInstance, options) {
    if (!options) {
      options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE)};
    }
    this._initImmediate();
    this._immediateData.addLayer(options.layer);
    meshInstanceArray[0] = meshInstance;
    options.layer.addMeshInstances(meshInstanceArray, true);
  }
  function renderMesh(mesh, material, matrix, options) {
    if (!options) {
      options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE)};
    }
    this._initImmediate();
    tempGraphNode.worldTransform = matrix;
    tempGraphNode._dirtyWorld = tempGraphNode._dirtyNormal = false;
    var instance = new pc.MeshInstance(tempGraphNode, mesh, material);
    instance.cull = false;
    if (options.mask) {
      instance.mask = options.mask;
    }
    this._immediateData.addLayer(options.layer);
    meshInstanceArray[0] = instance;
    options.layer.addMeshInstances(meshInstanceArray, true);
  }
  function renderQuad(matrix, material, options) {
    if (!options) {
      options = {layer:this.scene.layers.getLayerById(pc.LAYERID_IMMEDIATE)};
    }
    this._initImmediate();
    if (!this._immediateData.quadMesh) {
      var format = new pc.VertexFormat(this.graphicsDevice, [{semantic:pc.SEMANTIC_POSITION, components:3, type:pc.TYPE_FLOAT32}]);
      var quadVb = new pc.VertexBuffer(this.graphicsDevice, format, 4);
      var iterator = new pc.VertexIterator(quadVb);
      iterator.element[pc.SEMANTIC_POSITION].set(-0.5, -0.5, 0);
      iterator.next();
      iterator.element[pc.SEMANTIC_POSITION].set(0.5, -0.5, 0);
      iterator.next();
      iterator.element[pc.SEMANTIC_POSITION].set(-0.5, 0.5, 0);
      iterator.next();
      iterator.element[pc.SEMANTIC_POSITION].set(0.5, 0.5, 0);
      iterator.end();
      this._immediateData.quadMesh = new pc.Mesh;
      this._immediateData.quadMesh.vertexBuffer = quadVb;
      this._immediateData.quadMesh.primitive[0].type = pc.PRIMITIVE_TRISTRIP;
      this._immediateData.quadMesh.primitive[0].base = 0;
      this._immediateData.quadMesh.primitive[0].count = 4;
      this._immediateData.quadMesh.primitive[0].indexed = false;
    }
    tempGraphNode.worldTransform = matrix;
    tempGraphNode._dirtyWorld = tempGraphNode._dirtyNormal = false;
    var quad = new pc.MeshInstance(tempGraphNode, this._immediateData.quadMesh, material);
    quad.cull = false;
    meshInstanceArray[0] = quad;
    this._immediateData.addLayer(options.layer);
    options.layer.addMeshInstances(meshInstanceArray, true);
  }
  return {renderMeshInstance:renderMeshInstance, renderMesh:renderMesh, renderLine:renderLine, renderLines:renderLines, renderQuad:renderQuad, renderWireCube:renderWireCube, _addLines:_addLines, _initImmediate:_initImmediate, _preRenderImmediate:_preRenderImmediate, _postRenderImmediate:_postRenderImmediate};
}());
Object.assign(pc, function() {
  var maxSize = 2048;
  var maskBaked = 2;
  var maskLightmap = 4;
  var sceneLightmaps = [];
  var sceneLightmapsNode = [];
  var lmCamera;
  var tempVec = new pc.Vec3;
  var bounds = new pc.BoundingBox;
  var lightBounds = new pc.BoundingBox;
  var tempSphere = {};
  var PASS_COLOR = 0;
  var PASS_DIR = 1;
  var passTexName = ["texture_lightMap", "texture_dirLightMap"];
  var passMaterial = [];
  function collectModels(node, nodes, nodesMeshInstances, allNodes) {
    if (!node.enabled) {
      return;
    }
    var i;
    if (node.model && node.model.model && node.model.enabled) {
      if (allNodes) {
        allNodes.push(node);
      }
      if (node.model.lightmapped) {
        if (nodes) {
          var hasUv1 = true;
          var meshInstances = node.model.model.meshInstances;
          for (i = 0; i < meshInstances.length; i++) {
            if (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {
              hasUv1 = false;
              break;
            }
          }
          if (hasUv1) {
            var j;
            var isInstance;
            var notInstancedMeshInstances = [];
            for (i = 0; i < meshInstances.length; i++) {
              isInstance = false;
              for (j = 0; j < meshInstances.length; j++) {
                if (i !== j) {
                  if (meshInstances[i].mesh === meshInstances[j].mesh) {
                    isInstance = true;
                  }
                }
              }
              if (isInstance) {
                nodes.push(node);
                nodesMeshInstances.push([meshInstances[i]]);
              } else {
                notInstancedMeshInstances.push(meshInstances[i]);
              }
            }
            if (notInstancedMeshInstances.length > 0) {
              nodes.push(node);
              nodesMeshInstances.push(notInstancedMeshInstances);
            }
          }
        }
      }
    }
    for (i = 0; i < node._children.length; i++) {
      collectModels(node._children[i], nodes, nodesMeshInstances, allNodes);
    }
  }
  var Lightmapper = function(device, root, scene, renderer, assets) {
    this.device = device;
    this.root = root;
    this.scene = scene;
    this.renderer = renderer;
    this.assets = assets;
  };
  Object.assign(Lightmapper.prototype, {destroy:function() {
    this.device = null;
    this.root = null;
    this.scene = null;
    this.renderer = null;
    this.assets = null;
  }, calculateLightmapSize:function(node) {
    var data, parent;
    var sizeMult = this.scene.lightmapSizeMultiplier || 16;
    var scale = tempVec;
    var area = {x:1, y:1, z:1, uv:1};
    if (node.model.asset) {
      data = this.assets.get(node.model.asset).data;
      if (data.area) {
        area.x = data.area.x;
        area.y = data.area.y;
        area.z = data.area.z;
        area.uv = data.area.uv;
      }
    } else {
      if (node.model._area) {
        data = node.model;
        if (data._area) {
          area.x = data._area.x;
          area.y = data._area.y;
          area.z = data._area.z;
          area.uv = data._area.uv;
        }
      }
    }
    var areaMult = node.model.lightmapSizeMultiplier || 1;
    area.x *= areaMult;
    area.y *= areaMult;
    area.z *= areaMult;
    scale.copy(node.localScale);
    parent = node._parent;
    while (parent) {
      scale.mul(parent.localScale);
      parent = parent._parent;
    }
    scale.x = Math.abs(scale.x);
    scale.y = Math.abs(scale.y);
    scale.z = Math.abs(scale.z);
    var totalArea = area.x * scale.y * scale.z + area.y * scale.x * scale.z + area.z * scale.x * scale.y;
    totalArea /= area.uv;
    totalArea = Math.sqrt(totalArea);
    return Math.min(pc.math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || maxSize);
  }, bake:function(nodes, mode) {
    var i, j;
    var device = this.device;
    var scene = this.scene;
    var passCount = 1;
    if (mode === undefined) {
      mode = pc.BAKE_COLORDIR;
    }
    if (mode === pc.BAKE_COLORDIR) {
      passCount = 2;
    }
    var pass;
    var allNodes = [];
    var nodesMeshInstances = [];
    if (!nodes) {
      for (i = 0; i < sceneLightmaps.length; i++) {
        for (j = 0; j < sceneLightmaps[i].length; j++) {
          sceneLightmaps[i][j].destroy();
        }
      }
      sceneLightmaps = [];
      sceneLightmapsNode = [];
      nodes = [];
      collectModels(this.root, nodes, nodesMeshInstances, allNodes);
    } else {
      var k;
      for (i = sceneLightmapsNode.length - 1; i >= 0; i--) {
        for (j = 0; j < nodes.length; j++) {
          if (sceneLightmapsNode[i] === nodes[j]) {
            for (k = 0; k < sceneLightmaps[i].length; k++) {
              sceneLightmaps[i][k].destroy();
            }
            sceneLightmaps.splice(i, 1);
            sceneLightmapsNode.splice(i, 1);
          }
        }
      }
      var _nodes = [];
      for (i = 0; i < nodes.length; i++) {
        collectModels(nodes[i], _nodes, nodesMeshInstances);
      }
      nodes = _nodes;
      collectModels(this.root, null, null, allNodes);
    }
    if (nodes.length === 0) {
      device.fire("lightmapper:end", {timestamp:pc.now(), target:this});
      return;
    }
    var revertStatic = false;
    if (scene._needsStaticPrepare) {
      scene._needsStaticPrepare = false;
      revertStatic = true;
    }
    var texSize = [];
    var lmaps = [[], []];
    var texPool = {};
    var size;
    var tex;
    var blackTex = new pc.Texture(this.device, {width:4, height:4, format:pc.PIXELFORMAT_R8_G8_B8_A8, rgbm:true});
    blackTex.name = "lightmap";
    for (i = 0; i < nodes.length; i++) {
      size = this.calculateLightmapSize(nodes[i]);
      texSize.push(size);
      for (pass = 0; pass < passCount; pass++) {
        tex = new pc.Texture(device, {width:size, height:size, format:pc.PIXELFORMAT_R8_G8_B8_A8, mipmaps:false, rgbm:pass === PASS_COLOR, minFilter:pc.FILTER_NEAREST, magFilter:pc.FILTER_NEAREST});
        tex.name = "lightmap";
        lmaps[pass].push(tex);
      }
      if (!texPool[size]) {
        var tex2 = new pc.Texture(device, {width:size, height:size, format:pc.PIXELFORMAT_R8_G8_B8_A8, mipmaps:false, rgbm:true, minFilter:pc.FILTER_NEAREST, magFilter:pc.FILTER_NEAREST});
        tex2.name = "lightmap";
        var targ2 = new pc.RenderTarget(device, tex2, {depth:false});
        texPool[size] = targ2;
      }
    }
    var activeComp = scene.layers;
    activeComp._update();
    var lights = [];
    var origMask = [];
    var origShadowMode = [];
    var origEnabled = [];
    var sceneLights = activeComp._lights;
    var mask;
    for (i = 0; i < sceneLights.length; i++) {
      if (sceneLights[i]._enabled) {
        mask = sceneLights[i]._mask;
        if ((mask & maskLightmap) !== 0) {
          origMask.push(mask);
          origShadowMode.push(sceneLights[i].shadowUpdateMode);
          sceneLights[i]._mask = 4294967295;
          sceneLights[i].shadowUpdateMode = sceneLights[i]._type === pc.LIGHTTYPE_DIRECTIONAL ? pc.SHADOWUPDATE_REALTIME : pc.SHADOWUPDATE_THISFRAME;
          lights.push(sceneLights[i]);
          sceneLights[i].isStatic = false;
        }
      }
      origEnabled.push(sceneLights[i]._enabled);
      sceneLights[i].enabled = false;
    }
    var chunks = pc.shaderChunks;
    var xformUv1 = "#define UV1LAYOUT\n" + chunks.transformVS;
    var bakeLmEnd = chunks.bakeLmEndPS;
    var dilate = chunks.dilatePS;
    var dilateShader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, dilate, "lmDilate");
    var constantTexSource = device.scope.resolve("source");
    var constantPixelOffset = device.scope.resolve("pixelOffset");
    var constantBakeDir = device.scope.resolve("bakeDir");
    var pixelOffset = new Float32Array(2);
    var drawCalls = activeComp._meshInstances;
    for (i = 0; i < drawCalls.length; i++) {
      if (drawCalls[i].node) {
        drawCalls[i].node.getWorldTransform();
      }
    }
    var origFog = scene.fog;
    var origAmbientR = scene.ambientLight.r;
    var origAmbientG = scene.ambientLight.g;
    var origAmbientB = scene.ambientLight.b;
    scene.fog = pc.FOG_NONE;
    scene.ambientLight.set(0, 0, 0);
    if (!lmCamera) {
      lmCamera = new pc.Camera;
      lmCamera._node = new pc.GraphNode;
      lmCamera.clearColor[0] = 0;
      lmCamera.clearColor[1] = 0;
      lmCamera.clearColor[2] = 0;
      lmCamera.clearColor[3] = 0;
      lmCamera.clearDepth = 1;
      lmCamera.clearFlags = pc.CLEARFLAG_COLOR;
      lmCamera.clearStencil = null;
      lmCamera.frustumCulling = false;
    }
    var node;
    var lm, rcv, m;
    var origShaderDefs = [];
    origShaderDefs.length = sceneLightmapsNode.length;
    var shaderDefs;
    for (node = 0; node < allNodes.length; node++) {
      rcv = allNodes[node].model.model.meshInstances;
      shaderDefs = [];
      for (i = 0; i < rcv.length; i++) {
        shaderDefs.push(rcv[i]._shaderDefs);
        rcv[i]._shaderDefs &= ~(pc.SHADERDEF_LM | pc.SHADERDEF_DIRLM);
      }
      for (i = 0; i < sceneLightmapsNode.length; i++) {
        if (sceneLightmapsNode[i] === allNodes[node]) {
          origShaderDefs[i] = shaderDefs;
          break;
        }
      }
    }
    var origCastShadows = [];
    var casters = [];
    var meshes;
    for (node = 0; node < allNodes.length; node++) {
      origCastShadows[node] = allNodes[node].model.castShadows;
      allNodes[node].model.castShadows = allNodes[node].model.castShadowsLightmap;
      if (allNodes[node].model.castShadowsLightmap) {
        meshes = allNodes[node].model.meshInstances;
        for (i = 0; i < meshes.length; i++) {
          meshes[i].visibleThisFrame = true;
          casters.push(meshes[i]);
        }
      }
    }
    this.renderer.updateCpuSkinMatrices(casters);
    this.renderer.gpuUpdate(casters);
    var origMat = [];
    var nodeBounds = [];
    var nodeTarg = [[], []];
    var targ, targTmp, texTmp;
    var light, shadowCam;
    var nodeLightCount = [];
    nodeLightCount.length = nodes.length;
    var lmMaterial;
    for (pass = 0; pass < passCount; pass++) {
      if (!passMaterial[pass]) {
        lmMaterial = new pc.StandardMaterial;
        lmMaterial.chunks.transformVS = xformUv1;
        if (pass === PASS_COLOR) {
          lmMaterial.chunks.endPS = bakeLmEnd;
          lmMaterial.ambient = new pc.Color(0, 0, 0);
          lmMaterial.ambientTint = true;
          lmMaterial.lightMap = blackTex;
        } else {
          lmMaterial.chunks.basePS = chunks.basePS + "\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n";
          lmMaterial.chunks.endPS = chunks.bakeDirLmEndPS;
        }
        lmMaterial.chunks.outputAlphaPS = "\n";
        lmMaterial.chunks.outputAlphaOpaquePS = "\n";
        lmMaterial.chunks.outputAlphaPremulPS = "\n";
        lmMaterial.cull = pc.CULLFACE_NONE;
        lmMaterial.forceUv1 = true;
        lmMaterial.update();
        lmMaterial.updateShader(device, scene);
        lmMaterial.name = "lmMaterial" + pass;
        passMaterial[pass] = lmMaterial;
      }
    }
    for (node = 0; node < nodes.length; node++) {
      rcv = nodesMeshInstances[node];
      nodeLightCount[node] = 0;
      if (rcv.length > 0) {
        bounds.copy(rcv[0].aabb);
        for (i = 0; i < rcv.length; i++) {
          rcv[i].node.getWorldTransform();
          bounds.add(rcv[i].aabb);
        }
      }
      var nbounds = new pc.BoundingBox;
      nbounds.copy(bounds);
      nodeBounds.push(nbounds);
      for (i = 0; i < rcv.length; i++) {
        m = rcv[i];
        m._shaderDefs &= ~(pc.SHADERDEF_LM | pc.SHADERDEF_DIRLM);
        m.mask = maskLightmap;
        m.deleteParameter("texture_lightMap");
        m.deleteParameter("texture_dirLightMap");
        m.setParameter("texture_lightMap", m.material.lightMap ? m.material.lightMap : blackTex);
        m.setParameter("texture_dirLightMap", blackTex);
      }
      for (pass = 0; pass < passCount; pass++) {
        lm = lmaps[pass][node];
        targ = new pc.RenderTarget(device, lm, {depth:false});
        nodeTarg[pass].push(targ);
      }
    }
    for (j = 0; j < lights.length; j++) {
      lights[j].enabled = false;
    }
    var lightArray = [[], [], []];
    var shadersUpdatedOn1stPass = false;
    var shadowMapRendered;
    for (i = 0; i < lights.length; i++) {
      lights[i].enabled = true;
      shadowMapRendered = false;
      lights[i]._cacheShadowMap = true;
      if (lights[i]._type !== pc.LIGHTTYPE_DIRECTIONAL) {
        lights[i]._node.getWorldTransform();
        lights[i].getBoundingSphere(tempSphere);
        lightBounds.center = tempSphere.center;
        lightBounds.halfExtents.x = tempSphere.radius;
        lightBounds.halfExtents.y = tempSphere.radius;
        lightBounds.halfExtents.z = tempSphere.radius;
      }
      if (lights[i]._type === pc.LIGHTTYPE_SPOT) {
        light = lights[i];
        shadowCam = this.renderer.getShadowCamera(device, light);
        shadowCam._node.setPosition(light._node.getPosition());
        shadowCam._node.setRotation(light._node.getRotation());
        shadowCam._node.rotateLocal(-90, 0, 0);
        shadowCam.projection = pc.PROJECTION_PERSPECTIVE;
        shadowCam.nearClip = light.attenuationEnd / 1000;
        shadowCam.farClip = light.attenuationEnd;
        shadowCam.aspectRatio = 1;
        shadowCam.fov = light._outerConeAngle * 2;
        this.renderer.updateCameraFrustum(shadowCam);
      }
      if (nodesMeshInstances.length > 0) {
        this.renderer.updateShaders(nodesMeshInstances[0]);
      }
      for (node = 0; node < nodes.length; node++) {
        rcv = nodesMeshInstances[node];
        bounds = nodeBounds[node];
        if (lights[i]._type === pc.LIGHTTYPE_DIRECTIONAL) {
          tempVec.copy(bounds.center);
          tempVec.y += bounds.halfExtents.y;
          lmCamera._node.setPosition(tempVec);
          lmCamera._node.setEulerAngles(-90, 0, 0);
          var frustumSize = Math.max(bounds.halfExtents.x, bounds.halfExtents.z);
          lmCamera.projection = pc.PROJECTION_ORTHOGRAPHIC;
          lmCamera.nearClip = 0;
          lmCamera.farClip = bounds.halfExtents.y * 2;
          lmCamera.aspectRatio = 1;
          lmCamera.orthoHeight = frustumSize;
        } else {
          if (!lightBounds.intersects(bounds)) {
            continue;
          }
        }
        if (lights[i]._type === pc.LIGHTTYPE_SPOT) {
          var nodeVisible = false;
          for (j = 0; j < rcv.length; j++) {
            if (this.renderer._isVisible(shadowCam, rcv[j])) {
              nodeVisible = true;
              break;
            }
          }
          if (!nodeVisible) {
            continue;
          }
        }
        if (lights[i]._type === pc.LIGHTTYPE_DIRECTIONAL) {
          lightArray[pc.LIGHTTYPE_DIRECTIONAL][0] = lights[i];
          lightArray[pc.LIGHTTYPE_POINT].length = 0;
          lightArray[pc.LIGHTTYPE_SPOT].length = 0;
          if (!shadowMapRendered && lights[i].castShadows) {
            this.renderer.cullDirectionalShadowmap(lights[i], casters, lmCamera, 0);
            this.renderer.renderShadows(lightArray[pc.LIGHTTYPE_DIRECTIONAL], 0);
            shadowMapRendered = true;
          }
        } else {
          lightArray[pc.LIGHTTYPE_DIRECTIONAL].length = 0;
          if (lights[i]._type === pc.LIGHTTYPE_POINT) {
            lightArray[pc.LIGHTTYPE_POINT][0] = lights[i];
            lightArray[pc.LIGHTTYPE_SPOT].length = 0;
            if (!shadowMapRendered && lights[i].castShadows) {
              this.renderer.cullLocalShadowmap(lights[i], casters);
              this.renderer.renderShadows(lightArray[pc.LIGHTTYPE_POINT]);
              shadowMapRendered = true;
            }
          } else {
            lightArray[pc.LIGHTTYPE_POINT].length = 0;
            lightArray[pc.LIGHTTYPE_SPOT][0] = lights[i];
            if (!shadowMapRendered && lights[i].castShadows) {
              this.renderer.cullLocalShadowmap(lights[i], casters);
              this.renderer.renderShadows(lightArray[pc.LIGHTTYPE_SPOT]);
              shadowMapRendered = true;
            }
          }
        }
        for (j = 0; j < rcv.length; j++) {
          origMat[j] = rcv[j].material;
        }
        for (pass = 0; pass < passCount; pass++) {
          lm = lmaps[pass][node];
          targ = nodeTarg[pass][node];
          targTmp = texPool[lm.width];
          texTmp = targTmp.colorBuffer;
          if (pass === 0) {
            shadersUpdatedOn1stPass = scene.updateShaders;
          } else {
            if (shadersUpdatedOn1stPass) {
              scene.updateShaders = true;
            }
          }
          for (j = 0; j < rcv.length; j++) {
            rcv[j].material = passMaterial[pass];
          }
          if (passCount > 1) {
            this.renderer.updateShaders(rcv);
          }
          this.renderer.setCamera(lmCamera, targTmp, true);
          if (pass === PASS_DIR) {
            constantBakeDir.setValue(lights[i].bakeDir ? 1 : 0);
          }
          this.renderer._forwardTime = 0;
          this.renderer._shadowMapTime = 0;
          this.renderer.renderForward(lmCamera, rcv, rcv.length, lightArray, pc.SHADER_FORWARDHDR);
          lmaps[pass][node] = texTmp;
          nodeTarg[pass][node] = targTmp;
          texPool[lm.width] = targ;
          for (j = 0; j < rcv.length; j++) {
            m = rcv[j];
            m.setParameter(passTexName[pass], texTmp);
            m._shaderDefs |= pc.SHADERDEF_LM;
          }
        }
        nodeLightCount[node]++;
        for (j = 0; j < rcv.length; j++) {
          rcv[j].material = origMat[j];
        }
      }
      lights[i].enabled = false;
      lights[i]._cacheShadowMap = false;
      if (lights[i]._isCachedShadowMap) {
        lights[i]._destroyShadowMap();
      }
    }
    var sceneLmaps;
    for (node = 0; node < nodes.length; node++) {
      rcv = nodesMeshInstances[node];
      sceneLmaps = [];
      for (pass = 0; pass < passCount; pass++) {
        lm = lmaps[pass][node];
        targ = nodeTarg[pass][node];
        targTmp = texPool[lm.width];
        texTmp = targTmp.colorBuffer;
        var numDilates2x = 4;
        pixelOffset[0] = 1 / lm.width;
        pixelOffset[1] = 1 / lm.height;
        constantPixelOffset.setValue(pixelOffset);
        for (i = 0; i < numDilates2x; i++) {
          constantTexSource.setValue(lm);
          pc.drawQuadWithShader(device, targTmp, dilateShader);
          constantTexSource.setValue(texTmp);
          pc.drawQuadWithShader(device, targ, dilateShader);
        }
        for (i = 0; i < rcv.length; i++) {
          m = rcv[i];
          m.mask = maskBaked;
          rcv[i].setParameter(passTexName[pass], lm);
          if (pass === PASS_DIR) {
            rcv[i]._shaderDefs |= pc.SHADERDEF_DIRLM;
          }
        }
        sceneLmaps[pass] = lm;
        if (pass === passCount - 1) {
          targ.destroy();
        }
      }
      sceneLightmaps.push(sceneLmaps);
      sceneLightmapsNode.push(nodes[node]);
    }
    for (var key in texPool) {
      if (texPool.hasOwnProperty(key)) {
        texPool[key].colorBuffer.destroy();
        texPool[key].destroy();
      }
    }
    for (i = 0; i < sceneLightmaps.length; i++) {
      for (j = 0; j < sceneLightmaps[i].length; j++) {
        tex = sceneLightmaps[i][j];
        tex.minFilter = pc.FILTER_LINEAR;
        tex.magFilter = pc.FILTER_LINEAR;
      }
    }
    for (node = 0; node < allNodes.length; node++) {
      allNodes[node].model.castShadows = origCastShadows[node];
    }
    for (i = 0; i < origShaderDefs.length; i++) {
      if (origShaderDefs[i]) {
        rcv = sceneLightmapsNode[i].model.model.meshInstances;
        for (j = 0; j < rcv.length; j++) {
          rcv[j]._shaderDefs |= origShaderDefs[i][j] & (pc.SHADERDEF_LM | pc.SHADERDEF_DIRLM);
        }
      }
    }
    for (i = 0; i < lights.length; i++) {
      lights[i]._mask = origMask[i];
      lights[i].shadowUpdateMode = origShadowMode[i];
    }
    for (i = 0; i < sceneLights.length; i++) {
      sceneLights[i].enabled = origEnabled[i];
    }
    scene.fog = origFog;
    scene.ambientLight.set(origAmbientR, origAmbientG, origAmbientB);
    if (revertStatic) {
      scene._needsStaticPrepare = true;
    }
  }});
  return {Lightmapper:Lightmapper};
}());
Object.assign(pc, function() {
  var Batch = function(meshInstances, dynamic, batchGroupId) {
    this.origMeshInstances = meshInstances;
    this._aabb = new pc.BoundingBox;
    this.meshInstance = null;
    this.model = null;
    this.dynamic = dynamic;
    this.batchGroupId = batchGroupId;
    this.refCounter = 0;
  };
  var BatchGroup = function(id, name, dynamic, maxAabbSize, layers) {
    this.dynamic = dynamic;
    this.maxAabbSize = maxAabbSize;
    this.id = id;
    this.name = name;
    this.layers = layers === undefined ? [pc.LAYERID_WORLD] : layers;
    this._ui = false;
    this._obj = {model:[], element:[], sprite:[]};
  };
  BatchGroup.MODEL = "model";
  BatchGroup.ELEMENT = "element";
  BatchGroup.SPRITE = "sprite";
  var SkinBatchInstance = function(device, nodes, rootNode) {
    this.device = device;
    this.rootNode = rootNode;
    this._dirty = true;
    this.bones = nodes;
    var numBones = nodes.length;
    if (device.supportsBoneTextures) {
      var size;
      if (numBones > 256) {
        size = 64;
      } else {
        if (numBones > 64) {
          size = 32;
        } else {
          if (numBones > 16) {
            size = 16;
          } else {
            size = 8;
          }
        }
      }
      this.boneTexture = new pc.Texture(device, {width:size, height:size, format:pc.PIXELFORMAT_RGBA32F, mipmaps:false, minFilter:pc.FILTER_NEAREST, magFilter:pc.FILTER_NEAREST});
      this.boneTexture.name = "batching";
      this.matrixPalette = this.boneTexture.lock();
    } else {
      this.matrixPalette = new Float32Array(numBones * 16);
    }
  };
  Object.assign(SkinBatchInstance.prototype, {updateMatrices:function(rootNode) {
  }, updateMatrixPalette:function() {
    var pe;
    var mp = this.matrixPalette;
    var base;
    for (var i = this.bones.length - 1; i >= 0; i--) {
      pe = this.bones[i].getWorldTransform().data;
      base = i * 16;
      mp[base] = pe[0];
      mp[base + 1] = pe[1];
      mp[base + 2] = pe[2];
      mp[base + 3] = pe[3];
      mp[base + 4] = pe[4];
      mp[base + 5] = pe[5];
      mp[base + 6] = pe[6];
      mp[base + 7] = pe[7];
      mp[base + 8] = pe[8];
      mp[base + 9] = pe[9];
      mp[base + 10] = pe[10];
      mp[base + 11] = pe[11];
      mp[base + 12] = pe[12];
      mp[base + 13] = pe[13];
      mp[base + 14] = pe[14];
      mp[base + 15] = pe[15];
    }
    if (this.device.supportsBoneTextures) {
      this.boneTexture.lock();
      this.boneTexture.unlock();
    }
  }});
  var BatchManager = function(device, root, scene) {
    this.device = device;
    this.rootNode = root;
    this.scene = scene;
    this._init = false;
    this._batchGroups = {};
    this._batchGroupCounter = 0;
    this._batchList = [];
    this._dirtyGroups = [];
  };
  BatchManager.prototype.destroyManager = function() {
    this.device = null;
    this.rootNode = null;
    this.scene = null;
    this._batchGroups = {};
    this._batchList = [];
    this._dirtyGroups = [];
  };
  BatchManager.prototype.addGroup = function(name, dynamic, maxAabbSize, id, layers) {
    if (id === undefined) {
      id = this._batchGroupCounter;
      this._batchGroupCounter++;
    }
    if (this._batchGroups[id]) {
      return;
    }
    var group;
    this._batchGroups[id] = group = new pc.BatchGroup(id, name, dynamic, maxAabbSize, layers);
    return group;
  };
  BatchManager.prototype.removeGroup = function(id) {
    if (!this._batchGroups[id]) {
      return;
    }
    var newBatchList = [];
    for (var i = 0; i < this._batchList.length; i++) {
      if (this._batchList[i].batchGroupId !== id) {
        newBatchList.push(this._batchList[i]);
        continue;
      }
      this.destroy(this._batchList[i]);
    }
    this._batchList = newBatchList;
    this._removeModelsFromBatchGroup(this.rootNode, id);
    delete this._batchGroups[id];
  };
  BatchManager.prototype.markGroupDirty = function(id) {
    if (this._dirtyGroups.indexOf(id) < 0) {
      this._dirtyGroups.push(id);
    }
  };
  BatchManager.prototype.getGroupByName = function(name) {
    var groups = this._batchGroups;
    for (var group in groups) {
      if (!groups.hasOwnProperty(group)) {
        continue;
      }
      if (groups[group].name === name) {
        return groups[group];
      }
    }
    return null;
  };
  BatchManager.prototype.getBatches = function(batchGroupId) {
    var results = [];
    var len = this._batchList.length;
    for (var i = 0; i < len; i++) {
      var batch = this._batchList[i];
      if (batch.batchGroupId === batchGroupId) {
        results.push(batch);
      }
    }
    return results;
  };
  BatchManager.prototype._removeModelsFromBatchGroup = function(node, id) {
    if (!node.enabled) {
      return;
    }
    if (node.model && node.model.batchGroupId === id) {
      node.model.batchGroupId = -1;
    }
    if (node.element && node.element.batchGroupId === id) {
      node.element.batchGroupId = -1;
    }
    if (node.sprite && node.sprite.batchGroupId === id) {
      node.sprite.batchGroupId = -1;
    }
    for (var i = 0; i < node._children.length; i++) {
      this._removeModelsFromBatchGroup(node._children[i], id);
    }
  };
  BatchManager.prototype.insert = function(type, groupId, node) {
    var group = this._batchGroups[groupId];
    if (group) {
      if (group._obj[type].indexOf(node) < 0) {
        group._obj[type].push(node);
        this.markGroupDirty(groupId);
      }
    } else {
    }
  };
  BatchManager.prototype.remove = function(type, groupId, node) {
    var group = this._batchGroups[groupId];
    if (group) {
      var idx = group._obj[type].indexOf(node);
      if (idx >= 0) {
        group._obj[type].splice(idx, 1);
        this.markGroupDirty(groupId);
      }
    } else {
    }
  };
  BatchManager.prototype._extractModel = function(node, arr, group, groupMeshInstances) {
    if (!node.model) {
      return arr;
    }
    var i;
    if (node.model.isStatic) {
      var drawCalls = this.scene.drawCalls;
      var nodeMeshInstances = node.model.meshInstances;
      for (i = 0; i < drawCalls.length; i++) {
        if (!drawCalls[i]._staticSource) {
          continue;
        }
        if (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) {
          continue;
        }
        arr.push(drawCalls[i]);
      }
      for (i = 0; i < nodeMeshInstances.length; i++) {
        if (drawCalls.indexOf(nodeMeshInstances[i]) >= 0) {
          arr.push(nodeMeshInstances[i]);
        }
      }
    } else {
      arr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);
    }
    node.model.removeModelFromLayers(node.model.model);
    return arr;
  };
  BatchManager.prototype._extractElement = function(node, arr, group) {
    if (!node.element) {
      return;
    }
    var valid = false;
    if (node.element._text && node.element._text._model.meshInstances.length > 0) {
      arr.push(node.element._text._model.meshInstances[0]);
      node.element.removeModelFromLayers(node.element._text._model);
      valid = true;
    } else {
      if (node.element._image) {
        arr.push(node.element._image._renderable.meshInstance);
        node.element.removeModelFromLayers(node.element._image._renderable.model);
        if (node.element._image._renderable.unmaskMeshInstance) {
          arr.push(node.element._image._renderable.unmaskMeshInstance);
          if (!node.element._image._renderable.unmaskMeshInstance.stencilFront || !node.element._image._renderable.unmaskMeshInstance.stencilBack) {
            node.element._dirtifyMask();
            node.element._onPrerender();
          }
        }
        valid = true;
      }
    }
    if (valid) {
      group._ui = true;
    }
  };
  BatchManager.prototype._collectAndRemoveModels = function(groupMeshInstances, groupIds) {
    var node, group, arr, id;
    for (var g = 0; g < groupIds.length; g++) {
      id = groupIds[g];
      group = this._batchGroups[id];
      if (!group) {
        continue;
      }
      arr = groupMeshInstances[id];
      if (!arr) {
        arr = groupMeshInstances[id] = [];
      }
      for (var m = 0; m < group._obj.model.length; m++) {
        arr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);
      }
      for (var e = 0; e < group._obj.element.length; e++) {
        this._extractElement(group._obj.element[e], arr, group);
      }
      for (var s = 0; s < group._obj.sprite.length; s++) {
        node = group._obj.sprite[s];
        if (node.sprite && node.sprite._meshInstance) {
          arr.push(node.sprite._meshInstance);
          this.scene.removeModel(node.sprite._model);
          node.sprite._batchGroup = group;
        }
      }
    }
  };
  BatchManager.prototype.generate = function(groupIds) {
    var i, j;
    var groupMeshInstances = {};
    if (!groupIds) {
      groupIds = Object.keys(this._batchGroups);
    }
    var newBatchList = [];
    for (i = 0; i < this._batchList.length; i++) {
      if (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {
        newBatchList.push(this._batchList[i]);
        continue;
      }
      this.destroy(this._batchList[i]);
    }
    this._batchList = newBatchList;
    this._collectAndRemoveModels(groupMeshInstances, groupIds);
    if (groupIds === this._dirtyGroups) {
      this._dirtyGroups.length = 0;
    } else {
      var newDirtyGroups = [];
      for (i = 0; i < this._dirtyGroups.length; i++) {
        if (groupIds.indexOf(this._dirtyGroups[i]) < 0) {
          newDirtyGroups.push(this._dirtyGroups[i]);
        }
      }
      this._dirtyGroups = newDirtyGroups;
    }
    var group, lists, groupData, batch;
    for (var groupId in groupMeshInstances) {
      if (!groupMeshInstances.hasOwnProperty(groupId)) {
        continue;
      }
      group = groupMeshInstances[groupId];
      groupData = this._batchGroups[groupId];
      if (!groupData) {
        continue;
      }
      lists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui);
      for (i = 0; i < lists.length; i++) {
        batch = this.create(lists[i], groupData.dynamic, parseInt(groupId, 10));
        if (!batch) {
          continue;
        }
        for (j = 0; j < groupData.layers.length; j++) {
          this.scene.layers.getLayerById(groupData.layers[j]).addMeshInstances(batch.model.meshInstances);
        }
      }
    }
  };
  function paramsIdentical(a, b) {
    if (a && !b) {
      return false;
    }
    if (!a && b) {
      return false;
    }
    a = a.data;
    b = b.data;
    if (a === b) {
      return true;
    }
    if (a instanceof Float32Array && b instanceof Float32Array) {
      if (a.length !== b.length) {
        return false;
      }
      for (var i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  function equalParamSets(params1, params2) {
    var param;
    for (param in params1) {
      if (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param])) {
        return false;
      }
    }
    for (param in params2) {
      if (params2.hasOwnProperty(param) && !paramsIdentical(params2[param], params1[param])) {
        return false;
      }
    }
    return true;
  }
  function equalLightLists(lightList1, lightList2) {
    var k;
    for (k = 0; k < lightList1.length; k++) {
      if (lightList2.indexOf(lightList1[k]) < 0) {
        return false;
      }
    }
    for (k = 0; k < lightList2.length; k++) {
      if (lightList1.indexOf(lightList2[k]) < 0) {
        return false;
      }
    }
    return true;
  }
  BatchManager.prototype.prepare = function(meshInstances, dynamic, maxAabbSize, isUI) {
    if (meshInstances.length === 0) {
      return [];
    }
    if (maxAabbSize === undefined) {
      maxAabbSize = Number.POSITIVE_INFINITY;
    }
    var halfMaxAabbSize = maxAabbSize * 0.5;
    var maxInstanceCount = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit;
    var i;
    var material, layer, vertCount, params, lightList, defs, stencil, staticLights;
    var aabb = new pc.BoundingBox;
    var testAabb = new pc.BoundingBox;
    var skipUIAabb = null;
    var lists = [];
    var j = 0;
    if (isUI) {
      meshInstances.sort(function(a, b) {
        return a.drawOrder - b.drawOrder;
      });
    }
    var meshInstancesLeftA = meshInstances;
    var meshInstancesLeftB;
    var skipMesh = isUI ? function(mi) {
      if (skipUIAabb) {
        skipUIAabb.add(mi.aabb);
      } else {
        skipUIAabb = mi.aabb.clone();
      }
      meshInstancesLeftB.push(mi);
    } : function(mi) {
      meshInstancesLeftB.push(mi);
    };
    var mi, sf;
    while (meshInstancesLeftA.length > 0) {
      lists[j] = [meshInstancesLeftA[0]];
      meshInstancesLeftB = [];
      material = meshInstancesLeftA[0].material;
      layer = meshInstancesLeftA[0].layer;
      defs = meshInstancesLeftA[0]._shaderDefs;
      params = meshInstancesLeftA[0].parameters;
      stencil = meshInstancesLeftA[0].stencilFront;
      lightList = meshInstancesLeftA[0]._staticLightList;
      vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();
      aabb.copy(meshInstancesLeftA[0].aabb);
      skipUIAabb = null;
      for (i = 1; i < meshInstancesLeftA.length; i++) {
        mi = meshInstancesLeftA[i];
        if (dynamic && lists[j].length >= maxInstanceCount) {
          meshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));
          break;
        }
        if (material !== mi.material || layer !== mi.layer || defs !== mi._shaderDefs || vertCount + mi.mesh.vertexBuffer.getNumVertices() > 65535) {
          skipMesh(mi);
          continue;
        }
        testAabb.copy(aabb);
        testAabb.add(mi.aabb);
        if (testAabb.halfExtents.x > halfMaxAabbSize || testAabb.halfExtents.y > halfMaxAabbSize || testAabb.halfExtents.z > halfMaxAabbSize) {
          skipMesh(mi);
          continue;
        }
        if (stencil) {
          if (!(sf = mi.stencilFront) || stencil.func != sf.func || stencil.zpass != sf.zpass) {
            skipMesh(mi);
            continue;
          }
        }
        if (!equalParamSets(params, mi.parameters)) {
          skipMesh(mi);
          continue;
        }
        staticLights = mi._staticLightList;
        if (lightList && staticLights) {
          if (!equalLightLists(lightList, staticLights)) {
            skipMesh(mi);
            continue;
          }
        } else {
          if (lightList || staticLights) {
            skipMesh(mi);
            continue;
          }
        }
        if (isUI && skipUIAabb && skipUIAabb.intersects(mi.aabb)) {
          skipMesh(mi);
          continue;
        }
        aabb.add(mi.aabb);
        vertCount += mi.mesh.vertexBuffer.getNumVertices();
        lists[j].push(mi);
      }
      j++;
      meshInstancesLeftA = meshInstancesLeftB;
    }
    return lists;
  };
  BatchManager.prototype.create = function(meshInstances, dynamic, batchGroupId) {
    if (!this._init) {
      var boneLimit = "#define BONE_LIMIT " + this.device.getBoneLimit() + "\n";
      this.transformVS = boneLimit + "#define DYNAMICBATCH\n" + pc.shaderChunks.transformVS;
      this.skinTexVS = pc.shaderChunks.skinBatchTexVS;
      this.skinConstVS = pc.shaderChunks.skinBatchConstVS;
      this.vertexFormats = {};
      this._init = true;
    }
    var i, j;
    var batch = new pc.Batch(meshInstances, dynamic, batchGroupId);
    this._batchList.push(batch);
    var material = null;
    var mesh, elems, numVerts, vertSize;
    var hasPos, hasNormal, hasUv, hasUv2, hasTangent, hasColor;
    var batchNumVerts = 0;
    var batchNumIndices = 0;
    for (i = 0; i < meshInstances.length; i++) {
      if (!meshInstances[i].visible) {
        continue;
      }
      if (!material) {
        material = meshInstances[i].material;
      } else {
        if (material !== meshInstances[i].material) {
          return;
        }
      }
      mesh = meshInstances[i].mesh;
      elems = mesh.vertexBuffer.format.elements;
      numVerts = mesh.vertexBuffer.numVertices;
      batchNumVerts += numVerts;
      for (j = 0; j < elems.length; j++) {
        if (elems[j].name === pc.SEMANTIC_POSITION) {
          hasPos = true;
        } else {
          if (elems[j].name === pc.SEMANTIC_NORMAL) {
            hasNormal = true;
          } else {
            if (elems[j].name === pc.SEMANTIC_TEXCOORD0) {
              hasUv = true;
            } else {
              if (elems[j].name === pc.SEMANTIC_TEXCOORD1) {
                hasUv2 = true;
              } else {
                if (elems[j].name === pc.SEMANTIC_TANGENT) {
                  hasTangent = true;
                } else {
                  if (elems[j].name === pc.SEMANTIC_COLOR) {
                    hasColor = true;
                  }
                }
              }
            }
          }
        }
      }
      batchNumIndices += mesh.primitive[0].count;
    }
    if (!hasPos) {
      return;
    }
    var entityIndexSizeF = dynamic ? 1 : 0;
    var batchVertSizeF = 3 + (hasNormal ? 3 : 0) + (hasUv ? 2 : 0) + (hasUv2 ? 2 : 0) + (hasTangent ? 4 : 0) + (hasColor ? 1 : 0) + entityIndexSizeF;
    var batchOffsetNF = 3;
    var batchOffsetUF = hasNormal ? 3 * 2 : 3;
    var batchOffsetU2F = (hasNormal ? 3 * 2 : 3) + (hasUv ? 2 : 0);
    var batchOffsetTF = (hasNormal ? 3 * 2 : 3) + (hasUv ? 2 : 0) + (hasUv2 ? 2 : 0);
    var batchOffsetCF = (hasNormal ? 3 * 2 : 3) + (hasUv ? 2 : 0) + (hasUv2 ? 2 : 0) + (hasTangent ? 4 : 0);
    var batchOffsetEF = (hasNormal ? 3 * 2 : 3) + (hasUv ? 2 : 0) + (hasUv2 ? 2 : 0) + (hasTangent ? 4 : 0) + (hasColor ? 1 : 0);
    var arrayBuffer = new ArrayBuffer(batchNumVerts * batchVertSizeF * 4);
    var batchData = new Float32Array(arrayBuffer);
    var batchData8 = new Uint8Array(arrayBuffer);
    var indexBuffer = new pc.IndexBuffer(this.device, pc.INDEXFORMAT_UINT16, batchNumIndices, pc.BUFFER_STATIC);
    var batchIndexData = new Uint16Array(indexBuffer.lock());
    var vertSizeF;
    var data, data8, indexBase, numIndices, indexData;
    var verticesOffset = 0;
    var indexOffset = 0;
    var vbOffset = 0;
    var offsetPF, offsetNF, offsetUF, offsetU2F, offsetTF, offsetCF;
    var transform, vec = new pc.Vec3;
    for (i = 0; i < meshInstances.length; i++) {
      if (!meshInstances[i].visible) {
        continue;
      }
      mesh = meshInstances[i].mesh;
      elems = mesh.vertexBuffer.format.elements;
      numVerts = mesh.vertexBuffer.numVertices;
      vertSize = mesh.vertexBuffer.format.size;
      vertSizeF = vertSize / 4;
      for (j = 0; j < elems.length; j++) {
        if (elems[j].name === pc.SEMANTIC_POSITION) {
          offsetPF = elems[j].offset / 4;
        } else {
          if (elems[j].name === pc.SEMANTIC_NORMAL) {
            offsetNF = elems[j].offset / 4;
          } else {
            if (elems[j].name === pc.SEMANTIC_TEXCOORD0) {
              offsetUF = elems[j].offset / 4;
            } else {
              if (elems[j].name === pc.SEMANTIC_TEXCOORD1) {
                offsetU2F = elems[j].offset / 4;
              } else {
                if (elems[j].name === pc.SEMANTIC_TANGENT) {
                  offsetTF = elems[j].offset / 4;
                } else {
                  if (elems[j].name === pc.SEMANTIC_COLOR) {
                    offsetCF = elems[j].offset / 4;
                  }
                }
              }
            }
          }
        }
      }
      data = new Float32Array(mesh.vertexBuffer.storage);
      data8 = new Uint8Array(mesh.vertexBuffer.storage);
      transform = meshInstances[i].node.getWorldTransform();
      for (j = 0; j < numVerts; j++) {
        vec.set(data[j * vertSizeF + offsetPF], data[j * vertSizeF + offsetPF + 1], data[j * vertSizeF + offsetPF + 2]);
        if (!dynamic) {
          transform.transformPoint(vec, vec);
        }
        batchData[j * batchVertSizeF + vbOffset] = vec.x;
        batchData[j * batchVertSizeF + vbOffset + 1] = vec.y;
        batchData[j * batchVertSizeF + vbOffset + 2] = vec.z;
        if (hasNormal) {
          vec.set(data[j * vertSizeF + offsetNF], data[j * vertSizeF + offsetNF + 1], data[j * vertSizeF + offsetNF + 2]);
          if (!dynamic) {
            transform.transformVector(vec, vec);
          }
          batchData[j * batchVertSizeF + vbOffset + batchOffsetNF] = vec.x;
          batchData[j * batchVertSizeF + vbOffset + batchOffsetNF + 1] = vec.y;
          batchData[j * batchVertSizeF + vbOffset + batchOffsetNF + 2] = vec.z;
        }
        if (hasUv) {
          batchData[j * batchVertSizeF + vbOffset + batchOffsetUF] = data[j * vertSizeF + offsetUF];
          batchData[j * batchVertSizeF + vbOffset + batchOffsetUF + 1] = data[j * vertSizeF + offsetUF + 1];
        }
        if (hasUv2) {
          batchData[j * batchVertSizeF + vbOffset + batchOffsetU2F] = data[j * vertSizeF + offsetU2F];
          batchData[j * batchVertSizeF + vbOffset + batchOffsetU2F + 1] = data[j * vertSizeF + offsetU2F + 1];
        }
        if (hasTangent) {
          vec.set(data[j * vertSizeF + offsetTF], data[j * vertSizeF + offsetTF + 1], data[j * vertSizeF + offsetTF + 2]);
          if (!dynamic) {
            transform.transformVector(vec, vec);
          }
          batchData[j * batchVertSizeF + vbOffset + batchOffsetTF] = vec.x;
          batchData[j * batchVertSizeF + vbOffset + batchOffsetTF + 1] = vec.y;
          batchData[j * batchVertSizeF + vbOffset + batchOffsetTF + 2] = vec.z;
          batchData[j * batchVertSizeF + vbOffset + batchOffsetTF + 3] = data[j * vertSizeF + offsetTF + 3];
        }
        if (hasColor) {
          batchData8[j * batchVertSizeF * 4 + vbOffset * 4 + batchOffsetCF * 4] = data8[j * vertSizeF * 4 + offsetCF * 4];
          batchData8[j * batchVertSizeF * 4 + vbOffset * 4 + batchOffsetCF * 4 + 1] = data8[j * vertSizeF * 4 + offsetCF * 4 + 1];
          batchData8[j * batchVertSizeF * 4 + vbOffset * 4 + batchOffsetCF * 4 + 2] = data8[j * vertSizeF * 4 + offsetCF * 4 + 2];
          batchData8[j * batchVertSizeF * 4 + vbOffset * 4 + batchOffsetCF * 4 + 3] = data8[j * vertSizeF * 4 + offsetCF * 4 + 3];
        }
        if (dynamic) {
          batchData[j * batchVertSizeF + batchOffsetEF + vbOffset] = i;
        }
      }
      indexBase = mesh.primitive[0].base;
      numIndices = mesh.primitive[0].count;
      indexData = new Uint16Array(mesh.indexBuffer[0].storage);
      for (j = 0; j < numIndices; j++) {
        batchIndexData[j + indexOffset] = indexData[indexBase + j] + verticesOffset;
      }
      indexOffset += numIndices;
      verticesOffset += numVerts;
      vbOffset = verticesOffset * batchVertSizeF;
    }
    var vertexFormatId = 0;
    if (hasNormal) {
      vertexFormatId |= 1 << 1;
    }
    if (hasUv) {
      vertexFormatId |= 1 << 2;
    }
    if (hasUv2) {
      vertexFormatId |= 1 << 3;
    }
    if (hasTangent) {
      vertexFormatId |= 1 << 4;
    }
    if (hasColor) {
      vertexFormatId |= 1 << 5;
    }
    if (dynamic) {
      vertexFormatId |= 1 << 6;
    }
    var vertexFormat = this.vertexFormats[vertexFormatId];
    if (!vertexFormat) {
      var formatDesc = [];
      formatDesc.push({semantic:pc.SEMANTIC_POSITION, components:3, type:pc.ELEMENTTYPE_FLOAT32, normalize:false});
      if (hasNormal) {
        formatDesc.push({semantic:pc.SEMANTIC_NORMAL, components:3, type:pc.ELEMENTTYPE_FLOAT32, normalize:false});
      }
      if (hasUv) {
        formatDesc.push({semantic:pc.SEMANTIC_TEXCOORD0, components:2, type:pc.ELEMENTTYPE_FLOAT32, normalize:false});
      }
      if (hasUv2) {
        formatDesc.push({semantic:pc.SEMANTIC_TEXCOORD1, components:2, type:pc.ELEMENTTYPE_FLOAT32, normalize:false});
      }
      if (hasTangent) {
        formatDesc.push({semantic:pc.SEMANTIC_TANGENT, components:4, type:pc.ELEMENTTYPE_FLOAT32, normalize:false});
      }
      if (hasColor) {
        formatDesc.push({semantic:pc.SEMANTIC_COLOR, components:4, type:pc.ELEMENTTYPE_UINT8, normalize:true});
      }
      if (dynamic) {
        formatDesc.push({semantic:pc.SEMANTIC_BLENDINDICES, components:1, type:pc.ELEMENTTYPE_FLOAT32, normalize:false});
      }
      vertexFormat = this.vertexFormats[vertexFormatId] = new pc.VertexFormat(this.device, formatDesc);
    }
    var vertexBuffer = new pc.VertexBuffer(this.device, vertexFormat, batchNumVerts, pc.BUFFER_STATIC, batchData.buffer);
    indexBuffer.unlock();
    mesh = new pc.Mesh;
    mesh.vertexBuffer = vertexBuffer;
    mesh.indexBuffer[0] = indexBuffer;
    mesh.primitive[0].type = batch.origMeshInstances[0].mesh.primitive[0].type;
    mesh.primitive[0].base = 0;
    mesh.primitive[0].count = batchNumIndices;
    mesh.primitive[0].indexed = true;
    mesh.cull = false;
    if (dynamic) {
      material = material.clone();
      material.chunks.transformVS = this.transformVS;
      material.chunks.skinTexVS = this.skinTexVS;
      material.chunks.skinConstVS = this.skinConstVS;
      material.update();
    }
    var meshInstance = new pc.MeshInstance(this.rootNode, mesh, material);
    meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
    meshInstance.parameters = batch.origMeshInstances[0].parameters;
    meshInstance.isStatic = batch.origMeshInstances[0].isStatic;
    meshInstance.cull = batch.origMeshInstances[0].cull;
    meshInstance.layer = batch.origMeshInstances[0].layer;
    meshInstance._staticLightList = batch.origMeshInstances[0]._staticLightList;
    meshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;
    if (dynamic) {
      var nodes = [];
      for (i = 0; i < batch.origMeshInstances.length; i++) {
        nodes.push(batch.origMeshInstances[i].node);
      }
      meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
    }
    meshInstance._updateAabb = false;
    meshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;
    meshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;
    meshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;
    batch.meshInstance = meshInstance;
    this.update(batch);
    var newModel = new pc.Model;
    newModel.meshInstances = [batch.meshInstance];
    newModel.castShadows = batch.origMeshInstances[0].castShadows;
    batch.model = newModel;
    return batch;
  };
  BatchManager.prototype.update = function(batch) {
    batch._aabb.copy(batch.origMeshInstances[0].aabb);
    for (var i = 1; i < batch.origMeshInstances.length; i++) {
      batch._aabb.add(batch.origMeshInstances[i].aabb);
    }
    batch.meshInstance.aabb = batch._aabb;
    batch._aabb._radiusVer = -1;
    batch.meshInstance._aabbVer = 0;
  };
  BatchManager.prototype.updateAll = function() {
    if (this._dirtyGroups.length > 0) {
      this.generate(this._dirtyGroups);
    }
    for (var i = 0; i < this._batchList.length; i++) {
      if (!this._batchList[i].dynamic) {
        continue;
      }
      this.update(this._batchList[i]);
    }
  };
  BatchManager.prototype.clone = function(batch, clonedMeshInstances) {
    var batch2 = new pc.Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);
    this._batchList.push(batch2);
    var nodes = [];
    for (var i = 0; i < clonedMeshInstances.length; i++) {
      nodes.push(clonedMeshInstances[i].node);
    }
    batch2.meshInstance = new pc.MeshInstance(batch.meshInstance.node, batch.meshInstance.mesh, batch.meshInstance.material);
    batch2.meshInstance._updateAabb = false;
    batch2.meshInstance.parameters = clonedMeshInstances[0].parameters;
    batch2.meshInstance.isStatic = clonedMeshInstances[0].isStatic;
    batch2.meshInstance.cull = clonedMeshInstances[0].cull;
    batch2.meshInstance.layer = clonedMeshInstances[0].layer;
    batch2.meshInstance._staticLightList = clonedMeshInstances[0]._staticLightList;
    if (batch.dynamic) {
      batch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
    }
    batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
    batch2.meshInstance._shader = batch.meshInstance._shader;
    var newModel = new pc.Model;
    newModel.meshInstances = [batch2.meshInstance];
    newModel.castShadows = batch.origMeshInstances[0].castShadows;
    batch2.model = newModel;
    return batch2;
  };
  BatchManager.prototype.destroy = function(batch) {
    batch.refCounter = 0;
    if (!batch.model) {
      return;
    }
    var layers = this._batchGroups[batch.batchGroupId].layers;
    for (var i = 0; i < layers.length; i++) {
      this.scene.layers.getLayerById(layers[i]).removeMeshInstances(batch.model.meshInstances);
    }
    batch.model.destroy();
  };
  BatchManager.prototype.decrement = function(batch) {
    batch.refCounter--;
    if (batch.refCounter === 0) {
      this.destroy(batch);
    }
  };
  return {Batch:Batch, BatchGroup:BatchGroup, BatchManager:BatchManager};
}());

  return pc;
}));

</script>
    <script>
        console.log("CCCCCCCCCCCCC");

        var scriptElt={type: ""}; 
 ASSET_PREFIX = "";
        SCRIPT_PREFIX = "";
        SCENE_PATH = JSON.parse('{"name":"Game","created":"2019-03-12T08:44:11.518Z","settings":{"physics":{"gravity":[0,-9.8,0]},"render":{"fog_end":1000,"tonemapping":0,"skybox":null,"fog_density":0.01,"gamma_correction":1,"exposure":1,"fog_start":1,"global_ambient":[0.2,0.2,0.2],"skyboxIntensity":1,"fog_color":[0,0,0],"lightmapMode":1,"fog":"none","lightmapMaxResolution":2048,"skyboxMip":0,"lightmapSizeMultiplier":16}},"entities":{"01fc56c5-44a3-11e9-97ae-026349a27a7c":{"position":[0,0,0],"scale":[1,1,1],"name":"Root","parent":null,"resource_id":"01fc56c5-44a3-11e9-97ae-026349a27a7c","components":{"script":{"enabled":true,"order":["gameController","bounceOntapAnimationController"],"scripts":{"gameController":{"enabled":true,"attributes":{"debug":false}},"bounceOntapAnimationController":{"enabled":true,"attributes":{"anims":["4bc70605-596f-49e0-8d1c-17a81c0d18bd","347841bc-4905-43ff-9579-2150615e0902","1363cdfa-5b30-40b9-873e-07346acb7571","b62ea200-416f-4cdc-af22-ece2d87e9b09","5bade964-a32d-4d83-999d-b06717c3e2b9","57b65b49-91e1-4bcb-8d17-9c43f82abc6d","1a84d214-0b75-44a1-a43f-c9f2ff339d8d","8a3b42f8-6490-4042-b0ef-9637f9f59086","25a16b40-80e4-455f-8ff8-e545e581d27f","0e03155b-fe72-43e0-b04d-b778e6806f0b","c4307644-0dd9-42b1-8063-c281699c6916","52d6e22d-40ab-4929-a3f8-1f487b171df6","9017e4b8-5eec-46cc-b5ed-f289c9f46a3d","341266cc-b98a-4991-9eb8-715783eb6ee8","196969be-858a-4cd6-8b37-30e1ba285f79","edf56e7d-2a3f-4537-8cc0-e371df3ed97c","d25457b3-5ce6-4e8c-8474-e696f56a20be","03f8b222-ea53-4269-b068-90b88b067f27","79833129-28eb-4efc-97f1-ecfd590918a3"],"cameraEntity":"01fc56c6-44a3-11e9-97ae-026349a27a7c"}}}}},"rotation":[0,0,0],"tags":[],"enabled":true,"children":["01fc56c6-44a3-11e9-97ae-026349a27a7c","01fc56c7-44a3-11e9-97ae-026349a27a7c","72762922-8d41-439a-afba-7556c37fa7db","78149a27-741a-43e0-8782-90fb3e800a2a"]},"01fc56c6-44a3-11e9-97ae-026349a27a7c":{"position":[0,0,11.998148918151855],"scale":[1,1,1],"name":"Camera","parent":"01fc56c5-44a3-11e9-97ae-026349a27a7c","resource_id":"01fc56c6-44a3-11e9-97ae-026349a27a7c","components":{"camera":{"projection":1,"farClip":1000,"clearColorBuffer":true,"layers":[0,1,2,3,4],"priority":0,"fov":45,"clearDepthBuffer":true,"frustumCulling":true,"clearColor":[0.118,0.118,0.118,1],"enabled":true,"orthoHeight":4.5,"nearClip":0.1,"rect":[0,0,1,1]}},"rotation":[0,0,1.4027382046339472e-7],"tags":[],"enabled":true,"children":[]},"01fc56c7-44a3-11e9-97ae-026349a27a7c":{"position":[2,2,-2],"scale":[1,1,1],"name":"Light","parent":"01fc56c5-44a3-11e9-97ae-026349a27a7c","resource_id":"01fc56c7-44a3-11e9-97ae-026349a27a7c","components":{"light":{"vsmBlurSize":11,"normalOffsetBias":0.05,"color":[1,1,1],"outerConeAngle":45,"castShadows":true,"intensity":1,"bakeDir":true,"cookieAngle":0,"cookieChannel":"rgb","innerConeAngle":40,"bake":false,"falloffMode":0,"layers":[0],"cookieIntensity":1,"vsmBias":0.01,"vsmBlurMode":1,"type":"directional","cookieFalloff":true,"isStatic":false,"shadowUpdateMode":2,"cookieScale":[1,1],"affectLightmapped":false,"shadowBias":0.2,"affectDynamic":true,"cookieAsset":null,"cookieOffset":[0,0],"shadowResolution":1024,"enabled":true,"range":8,"shadowDistance":16,"shadowType":0}},"rotation":[45,135,0],"tags":[],"enabled":true,"children":[]},"72762922-8d41-439a-afba-7556c37fa7db":{"name":"Zoo","tags":[],"enabled":true,"resource_id":"72762922-8d41-439a-afba-7556c37fa7db","parent":"01fc56c5-44a3-11e9-97ae-026349a27a7c","children":["d25457b3-5ce6-4e8c-8474-e696f56a20be","03f8b222-ea53-4269-b068-90b88b067f27","79833129-28eb-4efc-97f1-ecfd590918a3","4325aae2-081e-4a71-ae81-ee1dc5131496","a61924f6-1ec0-43b7-9d17-8d054d3159be","4048ce2c-d9b5-40c8-893f-9f981027c95c","60c52806-4b4c-4278-87ae-460fddbcf9c1"],"position":[0,0,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"d25457b3-5ce6-4e8c-8474-e696f56a20be":{"name":"MaleWombat","tags":[],"enabled":true,"resource_id":"d25457b3-5ce6-4e8c-8474-e696f56a20be","parent":"72762922-8d41-439a-afba-7556c37fa7db","children":[],"position":[-2.1257050037384033,0.29884889774155265,2],"rotation":[0,0,0],"scale":[0.5,0.5,1],"components":{"script":{"enabled":true,"order":["spine","bounceOntapAnimation"],"scripts":{"spine":{"enabled":true,"attributes":{"atlas":18515964,"skeleton":18515965,"textures":[18515966],"defaultAnimation":"idle-man","layer":"World"}},"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[1.2,1,100],"boundingBoxOffset":[0,0.3,0],"scaleCoefs":[0.85,0.85,0.85]}}}}}},"03f8b222-ea53-4269-b068-90b88b067f27":{"name":"FemaleWombat","tags":[],"enabled":true,"resource_id":"03f8b222-ea53-4269-b068-90b88b067f27","parent":"72762922-8d41-439a-afba-7556c37fa7db","children":[],"position":[2.0595922470092773,0.35130283288788444,5],"rotation":[0,0,0],"scale":[-0.45,0.45,1],"components":{"script":{"enabled":true,"order":["spine","bounceOntapAnimation"],"scripts":{"spine":{"enabled":true,"attributes":{"atlas":18515964,"skeleton":18515965,"textures":[18515966],"defaultAnimation":"idle-woman","layer":"World"}},"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[1.2,1,100],"boundingBoxOffset":[0,0.3,0],"scaleCoefs":[0.85,0.85,0.85]}}}}}},"79833129-28eb-4efc-97f1-ecfd590918a3":{"name":"BabyWombat","tags":[],"enabled":true,"resource_id":"79833129-28eb-4efc-97f1-ecfd590918a3","parent":"72762922-8d41-439a-afba-7556c37fa7db","children":[],"position":[-0.015921209007501602,-0.5750633770959412,2],"rotation":[0,0,0],"scale":[0.3,0.3,1],"components":{"script":{"enabled":true,"order":["spine","bounceOntapAnimation"],"scripts":{"spine":{"enabled":true,"attributes":{"atlas":18517116,"skeleton":18517118,"textures":[18517117],"defaultAnimation":"idle","layer":"World"}},"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.6,0.6,100],"boundingBoxOffset":[0,0.2,0],"scaleCoefs":[0.85,0.85,0.85]}}}}}},"4325aae2-081e-4a71-ae81-ee1dc5131496":{"name":"Environment","tags":[],"enabled":true,"resource_id":"4325aae2-081e-4a71-ae81-ee1dc5131496","parent":"72762922-8d41-439a-afba-7556c37fa7db","children":["d00093b6-b406-4a56-89f0-3e55a3541304","bf61907e-3de7-42a2-a88c-b350b2c41b46","8e3c5b3b-c150-4432-acf3-7ad22865b125"],"position":[0,0,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"d00093b6-b406-4a56-89f0-3e55a3541304":{"name":"Trees","tags":[],"enabled":true,"resource_id":"d00093b6-b406-4a56-89f0-3e55a3541304","parent":"4325aae2-081e-4a71-ae81-ee1dc5131496","children":["4bc70605-596f-49e0-8d1c-17a81c0d18bd","347841bc-4905-43ff-9579-2150615e0902","1363cdfa-5b30-40b9-873e-07346acb7571","b62ea200-416f-4cdc-af22-ece2d87e9b09","5bade964-a32d-4d83-999d-b06717c3e2b9","57b65b49-91e1-4bcb-8d17-9c43f82abc6d"],"position":[0,0,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"4bc70605-596f-49e0-8d1c-17a81c0d18bd":{"name":"Tree1","tags":[],"enabled":true,"resource_id":"4bc70605-596f-49e0-8d1c-17a81c0d18bd","parent":"d00093b6-b406-4a56-89f0-3e55a3541304","children":[],"position":[-4.375473499298096,0.4297625861952228,-0.800000011920929],"rotation":[0,0,0],"scale":[1.2,1.2,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672575,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceOntapAnimation"],"scripts":{"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.4,1.1,100],"boundingBoxOffset":[0,1.346,0],"scaleCoefs":[1,0.75,1]}}}}}},"347841bc-4905-43ff-9579-2150615e0902":{"name":"Tree2","tags":[],"enabled":true,"resource_id":"347841bc-4905-43ff-9579-2150615e0902","parent":"d00093b6-b406-4a56-89f0-3e55a3541304","children":[],"position":[-2.7589974403381348,1.3749585122406582,-1],"rotation":[0,0,0],"scale":[1.2,1.2,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672575,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceOntapAnimation"],"scripts":{"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.4,1.1,100],"boundingBoxOffset":[0,1.346,0],"scaleCoefs":[1,0.75,1]}}}}}},"1363cdfa-5b30-40b9-873e-07346acb7571":{"name":"Tree3","tags":[],"enabled":true,"resource_id":"1363cdfa-5b30-40b9-873e-07346acb7571","parent":"d00093b6-b406-4a56-89f0-3e55a3541304","children":[],"position":[-1.1089664697647095,2.337921974116571,-1.2000000476837158],"rotation":[0,0,0],"scale":[1.2,1.2,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672575,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceOntapAnimation"],"scripts":{"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.4,1.1,100],"boundingBoxOffset":[0,1.346,0],"scaleCoefs":[1,0.75,1]}}}}}},"b62ea200-416f-4cdc-af22-ece2d87e9b09":{"name":"Tree4","tags":[],"enabled":true,"resource_id":"b62ea200-416f-4cdc-af22-ece2d87e9b09","parent":"d00093b6-b406-4a56-89f0-3e55a3541304","children":[],"position":[0.48522040247917175,3.2106235811636212,-1.5],"rotation":[0,0,0],"scale":[1.2,1.2,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672575,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceOntapAnimation"],"scripts":{"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.4,1.1,100],"boundingBoxOffset":[0,1.346,0],"scaleCoefs":[1,0.75,1]}}}}}},"5bade964-a32d-4d83-999d-b06717c3e2b9":{"name":"Tree5","tags":[],"enabled":true,"resource_id":"5bade964-a32d-4d83-999d-b06717c3e2b9","parent":"d00093b6-b406-4a56-89f0-3e55a3541304","children":[],"position":[2.076719284057617,2.3365414142608643,-1.2000000476837158],"rotation":[0,0,0],"scale":[1.2,1.2,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672575,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceOntapAnimation"],"scripts":{"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.4,1.1,100],"boundingBoxOffset":[0,1.346,0],"scaleCoefs":[1,0.75,1]}}}}}},"57b65b49-91e1-4bcb-8d17-9c43f82abc6d":{"name":"Tree6","tags":[],"enabled":true,"resource_id":"57b65b49-91e1-4bcb-8d17-9c43f82abc6d","parent":"d00093b6-b406-4a56-89f0-3e55a3541304","children":[],"position":[3.649528632278776,1.4217915534973145,-1],"rotation":[0,0,0],"scale":[1.2,1.2,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672575,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceOntapAnimation"],"scripts":{"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.4,1.1,100],"boundingBoxOffset":[0,1.346,0],"scaleCoefs":[1,0.75,1]}}}}}},"bf61907e-3de7-42a2-a88c-b350b2c41b46":{"name":"Bushes","tags":[],"enabled":true,"resource_id":"bf61907e-3de7-42a2-a88c-b350b2c41b46","parent":"4325aae2-081e-4a71-ae81-ee1dc5131496","children":["1a84d214-0b75-44a1-a43f-c9f2ff339d8d","8a3b42f8-6490-4042-b0ef-9637f9f59086","25a16b40-80e4-455f-8ff8-e545e581d27f","0e03155b-fe72-43e0-b04d-b778e6806f0b","c4307644-0dd9-42b1-8063-c281699c6916","52d6e22d-40ab-4929-a3f8-1f487b171df6"],"position":[0,0,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"1a84d214-0b75-44a1-a43f-c9f2ff339d8d":{"name":"Bush","tags":[],"enabled":true,"resource_id":"1a84d214-0b75-44a1-a43f-c9f2ff339d8d","parent":"bf61907e-3de7-42a2-a88c-b350b2c41b46","children":[],"position":[-3.2721269130706787,0.9455946451708455,-0.8999999761581421],"rotation":[180,-4.4783975129637406e-38,180],"scale":[0.8,0.8,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672554,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceOntapAnimation"],"scripts":{"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.5,0.5,100],"boundingBoxOffset":[-0.2,0.5,0],"scaleCoefs":[1,0.75,1]}}}}}},"8a3b42f8-6490-4042-b0ef-9637f9f59086":{"name":"Bush","tags":[],"enabled":true,"resource_id":"8a3b42f8-6490-4042-b0ef-9637f9f59086","parent":"bf61907e-3de7-42a2-a88c-b350b2c41b46","children":[],"position":[-1.6294759511947632,1.9185803547233302,-1.100000023841858],"rotation":[180,-6.717595265839513e-38,180],"scale":[0.8,0.8,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672554,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceOntapAnimation"],"scripts":{"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.5,0.5,100],"boundingBoxOffset":[-0.2,0.5,0],"scaleCoefs":[1,0.75,1]}}}}}},"25a16b40-80e4-455f-8ff8-e545e581d27f":{"name":"Bush","tags":[],"enabled":true,"resource_id":"25a16b40-80e4-455f-8ff8-e545e581d27f","parent":"bf61907e-3de7-42a2-a88c-b350b2c41b46","children":[],"position":[0.006027198300842085,2.8312582969665527,-1.399999976158142],"rotation":[180,-6.717595265839513e-38,180],"scale":[0.8,0.8,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672554,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceOntapAnimation"],"scripts":{"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.5,0.5,100],"boundingBoxOffset":[-0.2,0.5,0],"scaleCoefs":[1,0.75,1]}}}}}},"0e03155b-fe72-43e0-b04d-b778e6806f0b":{"name":"Bush","tags":[],"enabled":true,"resource_id":"0e03155b-fe72-43e0-b04d-b778e6806f0b","parent":"bf61907e-3de7-42a2-a88c-b350b2c41b46","children":[],"position":[0.9535638093948364,2.845987833463229,-1.399999976158142],"rotation":[0,-6.717595265839513e-38,0],"scale":[0.8,0.8,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672554,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceOntapAnimation"],"scripts":{"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.5,0.5,100],"boundingBoxOffset":[0.2,0.5,0],"scaleCoefs":[1,0.75,1]}}}}}},"c4307644-0dd9-42b1-8063-c281699c6916":{"name":"Bush","tags":[],"enabled":true,"resource_id":"c4307644-0dd9-42b1-8063-c281699c6916","parent":"bf61907e-3de7-42a2-a88c-b350b2c41b46","children":[],"position":[2.5358549259945393,1.9348118305206299,-1.100000023841858],"rotation":[0,-6.717595265839513e-38,0],"scale":[0.8,0.8,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672554,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceOntapAnimation"],"scripts":{"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.5,0.5,100],"boundingBoxOffset":[0.2,0.5,0],"scaleCoefs":[1,0.75,1]}}}}}},"52d6e22d-40ab-4929-a3f8-1f487b171df6":{"name":"Bush","tags":[],"enabled":true,"resource_id":"52d6e22d-40ab-4929-a3f8-1f487b171df6","parent":"bf61907e-3de7-42a2-a88c-b350b2c41b46","children":[],"position":[4.1447673229993836,1.0052036046981812,-0.8999999761581421],"rotation":[0,-6.717595265839513e-38,0],"scale":[0.8,0.8,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672554,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceOntapAnimation"],"scripts":{"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.5,0.5,100],"boundingBoxOffset":[0.2,0.5,0],"scaleCoefs":[1,0.75,1]}}}}}},"8e3c5b3b-c150-4432-acf3-7ad22865b125":{"name":"Floor","tags":[],"enabled":true,"resource_id":"8e3c5b3b-c150-4432-acf3-7ad22865b125","parent":"4325aae2-081e-4a71-ae81-ee1dc5131496","children":["c21f8cda-aaf4-4914-a19f-31a4d8bffa88","b0cb124f-73ad-41dd-97f4-15131664bdd2","8b9843b0-92b6-406d-89a5-a13bc738b22a"],"position":[-0.07593968636162707,0.20000000298023224,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"c21f8cda-aaf4-4914-a19f-31a4d8bffa88":{"name":"WhiteFloor","tags":[],"enabled":true,"resource_id":"c21f8cda-aaf4-4914-a19f-31a4d8bffa88","parent":"8e3c5b3b-c150-4432-acf3-7ad22865b125","children":[],"position":[0,0,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{"script":{"enabled":true,"order":["spritesCloner"],"scripts":{"spritesCloner":{"enabled":true,"attributes":{"sprite":18672557,"container":"c21f8cda-aaf4-4914-a19f-31a4d8bffa88","ranges":[[-6,-11,3,-6],[-11,-8,-6,2],[-5,-5,5,4]],"tileOffset":[0.55,0.32,-10]}}}}}},"b0cb124f-73ad-41dd-97f4-15131664bdd2":{"name":"RedFloor","tags":[],"enabled":true,"resource_id":"b0cb124f-73ad-41dd-97f4-15131664bdd2","parent":"8e3c5b3b-c150-4432-acf3-7ad22865b125","children":[],"position":[0,0,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{"script":{"enabled":true,"order":["spritesCloner"],"scripts":{"spritesCloner":{"enabled":true,"attributes":{"sprite":18672556,"container":"b0cb124f-73ad-41dd-97f4-15131664bdd2","ranges":[[-6,-5,-5,4],[5,-5,6,4],[-6,4,6,5],[-6,-6,6,-5],[-4,-4,-3,-3],[-4,2,-3,3],[3,-4,4,-3]],"tileOffset":[0.55,0.32,-9]}}}}}},"8b9843b0-92b6-406d-89a5-a13bc738b22a":{"name":"Back","tags":[],"enabled":true,"resource_id":"8b9843b0-92b6-406d-89a5-a13bc738b22a","parent":"8e3c5b3b-c150-4432-acf3-7ad22865b125","children":[],"position":[0,0,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{"script":{"enabled":true,"order":["spritesCloner"],"scripts":{"spritesCloner":{"enabled":true,"attributes":{"sprite":18672558,"container":"8b9843b0-92b6-406d-89a5-a13bc738b22a","ranges":[[6,-3,12,5],[-3,5,10,12]],"tileOffset":[0.55,0.32,-11]}}}}}},"a61924f6-1ec0-43b7-9d17-8d054d3159be":{"name":"Dynamic","tags":[],"enabled":true,"resource_id":"a61924f6-1ec0-43b7-9d17-8d054d3159be","parent":"72762922-8d41-439a-afba-7556c37fa7db","children":["c2349172-1439-49cf-99df-6da9ac2c11e7"],"position":[0,0,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"c2349172-1439-49cf-99df-6da9ac2c11e7":{"name":"Habitat","tags":[],"enabled":true,"resource_id":"c2349172-1439-49cf-99df-6da9ac2c11e7","parent":"a61924f6-1ec0-43b7-9d17-8d054d3159be","children":[],"position":[0.029593540355563164,0.27696655228821143,1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672560,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"4048ce2c-d9b5-40c8-893f-9f981027c95c":{"name":"POIs","tags":[],"enabled":true,"resource_id":"4048ce2c-d9b5-40c8-893f-9f981027c95c","parent":"72762922-8d41-439a-afba-7556c37fa7db","children":["4d0056f5-f40c-43d7-bf53-b68934fc07f8","063df118-0111-48d4-ba6c-13c278a44f09","c5948127-0962-4905-a4fb-e8fec16425f0","5630311f-78d3-4cb3-ae96-741e3606f7f7","af1f2161-4057-47a8-9857-a44c166e9c3e"],"position":[0,0,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"4d0056f5-f40c-43d7-bf53-b68934fc07f8":{"name":"HabitatPoi","tags":[],"enabled":true,"resource_id":"4d0056f5-f40c-43d7-bf53-b68934fc07f8","parent":"4048ce2c-d9b5-40c8-893f-9f981027c95c","children":["7f3e41dd-7c1e-48d1-bd23-f53f0f4694d9","e4136df9-ef81-4f3e-8560-ef80494d13d1"],"position":[0.0820000022649765,0.7,1.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"script":{"enabled":true,"order":["poi"],"scripts":{"poi":{"enabled":true,"attributes":{"boundingBoxHalfSize":[4.5,3.5,100],"views":[],"flipX":false,"setupParticles":["7f3e41dd-7c1e-48d1-bd23-f53f0f4694d9","e4136df9-ef81-4f3e-8560-ef80494d13d1"]}}}}}},"7f3e41dd-7c1e-48d1-bd23-f53f0f4694d9":{"name":"PointParticles","tags":[],"enabled":true,"resource_id":"7f3e41dd-7c1e-48d1-bd23-f53f0f4694d9","parent":"4d0056f5-f40c-43d7-bf53-b68934fc07f8","children":[],"position":[-0.0820000022649765,1.2298246026039124,3],"rotation":[0,0,0],"scale":[1,1,1],"components":{"particlesystem":{"enabled":true,"autoPlay":false,"numParticles":20,"lifetime":1,"rate":0.002,"rate2":0.003,"startAngle":0,"startAngle2":0,"loop":false,"preWarm":false,"lighting":false,"halfLambert":false,"intensity":1,"depthWrite":true,"depthSoftening":1,"sort":0,"blendType":2,"stretch":0,"alignToMotion":false,"emitterShape":0,"emitterExtents":[0,0,0],"emitterRadius":0,"initialVelocity":0,"animTilesX":1,"animTilesY":1,"animNumFrames":1,"animSpeed":1,"animLoop":true,"wrap":false,"wrapBounds":[0,0,0],"colorMapAsset":18621502,"normalMapAsset":null,"mesh":null,"localVelocityGraph":{"type":1,"keys":[[0,0],[0,0],[0,0]],"betweenCurves":false},"localVelocityGraph2":{"type":1,"keys":[[0,0],[0,0],[0,0]]},"velocityGraph":{"type":1,"keys":[[0,4,1,4],[0,-2,1,-4],[0,-1]],"betweenCurves":true},"velocityGraph2":{"type":1,"keys":[[0,-4,1,-4],[0,4,1,-4],[0,0]]},"rotationSpeedGraph":{"type":1,"keys":[0,0,1,0],"betweenCurves":false},"rotationSpeedGraph2":{"type":1,"keys":[0,0,1,0]},"scaleGraph":{"type":1,"keys":[0,0.02,0.995,0.02],"betweenCurves":false},"scaleGraph2":{"type":1,"keys":[0,0.02,0.995,0.02]},"colorGraph":{"type":1,"keys":[[0,1,1,1],[0,1,1,1],[0,1,1,1]],"betweenCurves":false},"alphaGraph":{"type":1,"keys":[0,1,1,0.85625],"betweenCurves":false},"alphaGraph2":{"type":1,"keys":[0,1,1,0.85625]},"layers":[0]}}},"e4136df9-ef81-4f3e-8560-ef80494d13d1":{"name":"StarParticles","tags":[],"enabled":true,"resource_id":"e4136df9-ef81-4f3e-8560-ef80494d13d1","parent":"4d0056f5-f40c-43d7-bf53-b68934fc07f8","children":[],"position":[-0.0820000022649765,1.2298246026039124,3],"rotation":[0,0,0],"scale":[1,1,1],"components":{"particlesystem":{"enabled":true,"autoPlay":false,"numParticles":20,"lifetime":1,"rate":0.001,"rate2":0.002,"startAngle":0,"startAngle2":0,"loop":false,"preWarm":false,"lighting":false,"halfLambert":false,"intensity":1,"depthWrite":true,"depthSoftening":1,"sort":0,"blendType":2,"stretch":0,"alignToMotion":false,"emitterShape":0,"emitterExtents":[0,0,0],"emitterRadius":0,"initialVelocity":0,"animTilesX":1,"animTilesY":1,"animNumFrames":1,"animSpeed":1,"animLoop":true,"wrap":false,"wrapBounds":[0,0,0],"colorMapAsset":18621503,"normalMapAsset":null,"mesh":null,"localVelocityGraph":{"type":1,"keys":[[0,0],[0,0],[0,0]],"betweenCurves":false},"localVelocityGraph2":{"type":1,"keys":[[0,0],[0,0],[0,0]]},"velocityGraph":{"type":1,"keys":[[0,3,1,3],[0,-1,0.9906976744186047,-3.299999999999999],[0,-1]],"betweenCurves":true},"velocityGraph2":{"type":1,"keys":[[0,-3,1,-3],[0,5,1,-3],[0,0]]},"rotationSpeedGraph":{"type":1,"keys":[0,0,1,0],"betweenCurves":false},"rotationSpeedGraph2":{"type":1,"keys":[0,0,1,0]},"scaleGraph":{"type":1,"keys":[0,0.1],"betweenCurves":false},"scaleGraph2":{"type":1,"keys":[0,0.1]},"colorGraph":{"type":1,"keys":[[0,1,1,0.94375],[0,1,1,0.65625],[0,0]],"betweenCurves":false},"alphaGraph":{"type":1,"keys":[0,1,1,0.85625],"betweenCurves":false},"alphaGraph2":{"type":1,"keys":[0,1,1,0.85625]},"layers":[0]}}},"063df118-0111-48d4-ba6c-13c278a44f09":{"name":"LampPoi1","tags":[],"enabled":true,"resource_id":"063df118-0111-48d4-ba6c-13c278a44f09","parent":"4048ce2c-d9b5-40c8-893f-9f981027c95c","children":["73bfff7f-476c-47ba-a1b4-c1f0f0a66952","e1221e74-f25a-4b71-9c79-6dd4d5a610ef","dedd3773-f278-4238-8065-e9d2ce4c26cd"],"position":[3.8096253871917725,1.354644968495732,1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"script":{"enabled":true,"order":["poi"],"scripts":{"poi":{"enabled":true,"attributes":{"boundingBoxHalfSize":[3.7,3.5,100],"views":["73bfff7f-476c-47ba-a1b4-c1f0f0a66952"],"flipX":false,"setupParticles":["e1221e74-f25a-4b71-9c79-6dd4d5a610ef","dedd3773-f278-4238-8065-e9d2ce4c26cd"]}}}}}},"73bfff7f-476c-47ba-a1b4-c1f0f0a66952":{"name":"View","tags":[],"enabled":false,"resource_id":"73bfff7f-476c-47ba-a1b4-c1f0f0a66952","parent":"063df118-0111-48d4-ba6c-13c278a44f09","children":[],"position":[-0.0655364990234375,-0.6025186992306426,1],"rotation":[0,0,0],"scale":[1.5,1.5,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672568,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceAnimation"],"scripts":{"bounceAnimation":{"enabled":true,"attributes":{}}}}}},"e1221e74-f25a-4b71-9c79-6dd4d5a610ef":{"name":"PointParticles","tags":[],"enabled":true,"resource_id":"e1221e74-f25a-4b71-9c79-6dd4d5a610ef","parent":"063df118-0111-48d4-ba6c-13c278a44f09","children":[],"position":[-0.0820000171661377,0.7680717408175619,3],"rotation":[0,0,0],"scale":[1,1,1],"components":{"particlesystem":{"enabled":true,"autoPlay":false,"numParticles":20,"lifetime":0.8,"rate":0.002,"rate2":0.003,"startAngle":0,"startAngle2":0,"loop":false,"preWarm":false,"lighting":false,"halfLambert":false,"intensity":1,"depthWrite":true,"depthSoftening":1,"sort":0,"blendType":2,"stretch":0,"alignToMotion":false,"emitterShape":0,"emitterExtents":[0,0,0],"emitterRadius":0,"initialVelocity":0,"animTilesX":1,"animTilesY":1,"animNumFrames":1,"animSpeed":1,"animLoop":true,"wrap":false,"wrapBounds":[0,0,0],"colorMapAsset":18621502,"normalMapAsset":null,"mesh":null,"localVelocityGraph":{"type":1,"keys":[[0,0],[0,0],[0,0]],"betweenCurves":false},"localVelocityGraph2":{"type":1,"keys":[[0,0],[0,0],[0,0]]},"velocityGraph":{"type":1,"keys":[[0,4,1,4],[0,-2,1,-4],[0,-1]],"betweenCurves":true},"velocityGraph2":{"type":1,"keys":[[0,-4,1,-4],[0,4,1,-4],[0,0]]},"rotationSpeedGraph":{"type":1,"keys":[0,0,1,0],"betweenCurves":false},"rotationSpeedGraph2":{"type":1,"keys":[0,0,1,0]},"scaleGraph":{"type":1,"keys":[0,0.02,0.995,0.02],"betweenCurves":false},"scaleGraph2":{"type":1,"keys":[0,0.02,0.995,0.02]},"colorGraph":{"type":1,"keys":[[0,1,1,1],[0,1,1,1],[0,1,1,1]],"betweenCurves":false},"alphaGraph":{"type":1,"keys":[0,1,1,0.85625],"betweenCurves":false},"alphaGraph2":{"type":1,"keys":[0,1,1,0.85625]},"layers":[0]}}},"dedd3773-f278-4238-8065-e9d2ce4c26cd":{"name":"StarParticles","tags":[],"enabled":true,"resource_id":"dedd3773-f278-4238-8065-e9d2ce4c26cd","parent":"063df118-0111-48d4-ba6c-13c278a44f09","children":[],"position":[-0.0820000171661377,0.7680717408175619,3],"rotation":[0,0,0],"scale":[1,1,1],"components":{"particlesystem":{"enabled":true,"autoPlay":false,"numParticles":20,"lifetime":0.8,"rate":0.001,"rate2":0.002,"startAngle":0,"startAngle2":0,"loop":false,"preWarm":false,"lighting":false,"halfLambert":false,"intensity":1,"depthWrite":true,"depthSoftening":1,"sort":0,"blendType":2,"stretch":0,"alignToMotion":false,"emitterShape":0,"emitterExtents":[0,0,0],"emitterRadius":0,"initialVelocity":0,"animTilesX":1,"animTilesY":1,"animNumFrames":1,"animSpeed":1,"animLoop":true,"wrap":false,"wrapBounds":[0,0,0],"colorMapAsset":18621503,"normalMapAsset":null,"mesh":null,"localVelocityGraph":{"type":1,"keys":[[0,0],[0,0],[0,0]],"betweenCurves":false},"localVelocityGraph2":{"type":1,"keys":[[0,0],[0,0],[0,0]]},"velocityGraph":{"type":1,"keys":[[0,2,1,2],[0,-1,0.991,-2],[0,-1]],"betweenCurves":true},"velocityGraph2":{"type":1,"keys":[[0,-2,1,-2],[0,3,1,-2],[0,0]]},"rotationSpeedGraph":{"type":1,"keys":[0,0,1,0],"betweenCurves":false},"rotationSpeedGraph2":{"type":1,"keys":[0,0,1,0]},"scaleGraph":{"type":1,"keys":[0,0.1],"betweenCurves":false},"scaleGraph2":{"type":1,"keys":[0,0.1]},"colorGraph":{"type":1,"keys":[[0,1,1,0.94375],[0,1,1,0.65625],[0,0]],"betweenCurves":false},"alphaGraph":{"type":1,"keys":[0,1,1,0.85625],"betweenCurves":false},"alphaGraph2":{"type":1,"keys":[0,1,1,0.85625]},"layers":[0]}}},"c5948127-0962-4905-a4fb-e8fec16425f0":{"name":"LampPoi2","tags":[],"enabled":true,"resource_id":"c5948127-0962-4905-a4fb-e8fec16425f0","parent":"4048ce2c-d9b5-40c8-893f-9f981027c95c","children":["536498b5-267f-4051-8e37-f4880fac8524","980945e6-7630-4000-930d-d66260a9de91","f24093e8-8388-4135-a879-259637c8bba4"],"position":[-3.4805524943954835,2.2075610160827637,1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"script":{"enabled":true,"order":["poi"],"scripts":{"poi":{"enabled":true,"attributes":{"boundingBoxHalfSize":[3.5,5,100],"views":["536498b5-267f-4051-8e37-f4880fac8524"],"flipX":false,"setupParticles":["980945e6-7630-4000-930d-d66260a9de91","f24093e8-8388-4135-a879-259637c8bba4"]}}}}}},"536498b5-267f-4051-8e37-f4880fac8524":{"name":"View","tags":[],"enabled":false,"resource_id":"536498b5-267f-4051-8e37-f4880fac8524","parent":"c5948127-0962-4905-a4fb-e8fec16425f0","children":[],"position":[-0.0683363871710041,-0.5358158349990845,1],"rotation":[0,0,0],"scale":[1.5,1.5,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672568,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceAnimation"],"scripts":{"bounceAnimation":{"enabled":true,"attributes":{}}}}}},"980945e6-7630-4000-930d-d66260a9de91":{"name":"PointParticles","tags":[],"enabled":true,"resource_id":"980945e6-7630-4000-930d-d66260a9de91","parent":"c5948127-0962-4905-a4fb-e8fec16425f0","children":[],"position":[-0.0820000171661377,0.4042665245844974,3],"rotation":[0,0,0],"scale":[1,1,1],"components":{"particlesystem":{"enabled":true,"autoPlay":false,"numParticles":20,"lifetime":0.8,"rate":0.002,"rate2":0.003,"startAngle":0,"startAngle2":0,"loop":false,"preWarm":false,"lighting":false,"halfLambert":false,"intensity":1,"depthWrite":true,"depthSoftening":1,"sort":0,"blendType":2,"stretch":0,"alignToMotion":false,"emitterShape":0,"emitterExtents":[0,0,0],"emitterRadius":0,"initialVelocity":0,"animTilesX":1,"animTilesY":1,"animNumFrames":1,"animSpeed":1,"animLoop":true,"wrap":false,"wrapBounds":[0,0,0],"colorMapAsset":18621502,"normalMapAsset":null,"mesh":null,"localVelocityGraph":{"type":1,"keys":[[0,0],[0,0],[0,0]],"betweenCurves":false},"localVelocityGraph2":{"type":1,"keys":[[0,0],[0,0],[0,0]]},"velocityGraph":{"type":1,"keys":[[0,4,1,4],[0,-2,1,-4],[0,-1]],"betweenCurves":true},"velocityGraph2":{"type":1,"keys":[[0,-4,1,-4],[0,4,1,-4],[0,0]]},"rotationSpeedGraph":{"type":1,"keys":[0,0,1,0],"betweenCurves":false},"rotationSpeedGraph2":{"type":1,"keys":[0,0,1,0]},"scaleGraph":{"type":1,"keys":[0,0.02,0.995,0.02],"betweenCurves":false},"scaleGraph2":{"type":1,"keys":[0,0.02,0.995,0.02]},"colorGraph":{"type":1,"keys":[[0,1,1,1],[0,1,1,1],[0,1,1,1]],"betweenCurves":false},"alphaGraph":{"type":1,"keys":[0,1,1,0.85625],"betweenCurves":false},"alphaGraph2":{"type":1,"keys":[0,1,1,0.85625]},"layers":[0]}}},"f24093e8-8388-4135-a879-259637c8bba4":{"name":"StarParticles","tags":[],"enabled":true,"resource_id":"f24093e8-8388-4135-a879-259637c8bba4","parent":"c5948127-0962-4905-a4fb-e8fec16425f0","children":[],"position":[-0.0820000171661377,0.4042665245844974,3],"rotation":[0,0,0],"scale":[1,1,1],"components":{"particlesystem":{"enabled":true,"autoPlay":false,"numParticles":20,"lifetime":0.8,"rate":0.001,"rate2":0.002,"startAngle":0,"startAngle2":0,"loop":false,"preWarm":false,"lighting":false,"halfLambert":false,"intensity":1,"depthWrite":true,"depthSoftening":1,"sort":0,"blendType":2,"stretch":0,"alignToMotion":false,"emitterShape":0,"emitterExtents":[0,0,0],"emitterRadius":0,"initialVelocity":0,"animTilesX":1,"animTilesY":1,"animNumFrames":1,"animSpeed":1,"animLoop":true,"wrap":false,"wrapBounds":[0,0,0],"colorMapAsset":18621503,"normalMapAsset":null,"mesh":null,"localVelocityGraph":{"type":1,"keys":[[0,0],[0,0],[0,0]],"betweenCurves":false},"localVelocityGraph2":{"type":1,"keys":[[0,0],[0,0],[0,0]]},"velocityGraph":{"type":1,"keys":[[0,2,1,2],[0,-1,0.991,-2],[0,-1]],"betweenCurves":true},"velocityGraph2":{"type":1,"keys":[[0,-2,1,-2],[0,3,1,-2],[0,0]]},"rotationSpeedGraph":{"type":1,"keys":[0,0,1,0],"betweenCurves":false},"rotationSpeedGraph2":{"type":1,"keys":[0,0,1,0]},"scaleGraph":{"type":1,"keys":[0,0.1],"betweenCurves":false},"scaleGraph2":{"type":1,"keys":[0,0.1]},"colorGraph":{"type":1,"keys":[[0,1,1,0.94375],[0,1,1,0.65625],[0,0]],"betweenCurves":false},"alphaGraph":{"type":1,"keys":[0,1,1,0.85625],"betweenCurves":false},"alphaGraph2":{"type":1,"keys":[0,1,1,0.85625]},"layers":[0]}}},"5630311f-78d3-4cb3-ae96-741e3606f7f7":{"name":"BenchPoi1","tags":[],"enabled":true,"resource_id":"5630311f-78d3-4cb3-ae96-741e3606f7f7","parent":"4048ce2c-d9b5-40c8-893f-9f981027c95c","children":["f1fea4bb-ad6d-431d-9762-14e5b3e0e8bd","41919ca4-8ad0-4f54-b74e-983cc3d1cfae","f0b6187f-bd06-4ad4-b32c-fbee3a070584"],"position":[2.598356514582228,2.2042601108551025,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{"script":{"enabled":true,"order":["poi"],"scripts":{"poi":{"enabled":true,"attributes":{"boundingBoxHalfSize":[2.5,5,100],"views":["f1fea4bb-ad6d-431d-9762-14e5b3e0e8bd"],"flipX":false,"setupParticles":["41919ca4-8ad0-4f54-b74e-983cc3d1cfae","f0b6187f-bd06-4ad4-b32c-fbee3a070584"]}}}}}},"f1fea4bb-ad6d-431d-9762-14e5b3e0e8bd":{"name":"View","tags":[],"enabled":false,"resource_id":"f1fea4bb-ad6d-431d-9762-14e5b3e0e8bd","parent":"5630311f-78d3-4cb3-ae96-741e3606f7f7","children":[],"position":[-0.055586814880371094,0.5759562715076783,1],"rotation":[0,0,0],"scale":[1.5,1.5,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672568,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceAnimation"],"scripts":{"bounceAnimation":{"enabled":true,"attributes":{}}}}}},"41919ca4-8ad0-4f54-b74e-983cc3d1cfae":{"name":"PointParticles","tags":[],"enabled":true,"resource_id":"41919ca4-8ad0-4f54-b74e-983cc3d1cfae","parent":"5630311f-78d3-4cb3-ae96-741e3606f7f7","children":[],"position":[0.23982770542086307,0.19437885284423828,3],"rotation":[0,0,0],"scale":[1,1,1],"components":{"particlesystem":{"enabled":true,"autoPlay":false,"numParticles":20,"lifetime":0.8,"rate":0.002,"rate2":0.003,"startAngle":0,"startAngle2":0,"loop":false,"preWarm":false,"lighting":false,"halfLambert":false,"intensity":1,"depthWrite":true,"depthSoftening":1,"sort":0,"blendType":2,"stretch":0,"alignToMotion":false,"emitterShape":0,"emitterExtents":[0,0,0],"emitterRadius":0,"initialVelocity":0,"animTilesX":1,"animTilesY":1,"animNumFrames":1,"animSpeed":1,"animLoop":true,"wrap":false,"wrapBounds":[0,0,0],"colorMapAsset":18621502,"normalMapAsset":null,"mesh":null,"localVelocityGraph":{"type":1,"keys":[[0,0],[0,0],[0,0]],"betweenCurves":false},"localVelocityGraph2":{"type":1,"keys":[[0,0],[0,0],[0,0]]},"velocityGraph":{"type":1,"keys":[[0,4,1,4],[0,-2,1,-4],[0,-1]],"betweenCurves":true},"velocityGraph2":{"type":1,"keys":[[0,-4,1,-4],[0,4,1,-4],[0,0]]},"rotationSpeedGraph":{"type":1,"keys":[0,0,1,0],"betweenCurves":false},"rotationSpeedGraph2":{"type":1,"keys":[0,0,1,0]},"scaleGraph":{"type":1,"keys":[0,0.02,0.995,0.02],"betweenCurves":false},"scaleGraph2":{"type":1,"keys":[0,0.02,0.995,0.02]},"colorGraph":{"type":1,"keys":[[0,1,1,1],[0,1,1,1],[0,1,1,1]],"betweenCurves":false},"alphaGraph":{"type":1,"keys":[0,1,1,0.85625],"betweenCurves":false},"alphaGraph2":{"type":1,"keys":[0,1,1,0.85625]},"layers":[0]}}},"f0b6187f-bd06-4ad4-b32c-fbee3a070584":{"name":"StarParticles","tags":[],"enabled":true,"resource_id":"f0b6187f-bd06-4ad4-b32c-fbee3a070584","parent":"5630311f-78d3-4cb3-ae96-741e3606f7f7","children":[],"position":[0.23982770542086307,0.19437885284423828,3],"rotation":[0,0,0],"scale":[1,1,1],"components":{"particlesystem":{"enabled":true,"autoPlay":false,"numParticles":20,"lifetime":0.8,"rate":0.001,"rate2":0.002,"startAngle":0,"startAngle2":0,"loop":false,"preWarm":false,"lighting":false,"halfLambert":false,"intensity":1,"depthWrite":true,"depthSoftening":1,"sort":0,"blendType":2,"stretch":0,"alignToMotion":false,"emitterShape":0,"emitterExtents":[0,0,0],"emitterRadius":0,"initialVelocity":0,"animTilesX":1,"animTilesY":1,"animNumFrames":1,"animSpeed":1,"animLoop":true,"wrap":false,"wrapBounds":[0,0,0],"colorMapAsset":18621503,"normalMapAsset":null,"mesh":null,"localVelocityGraph":{"type":1,"keys":[[0,0],[0,0],[0,0]],"betweenCurves":false},"localVelocityGraph2":{"type":1,"keys":[[0,0],[0,0],[0,0]]},"velocityGraph":{"type":1,"keys":[[0,2,1,2],[0,-1,0.991,-2],[0,-1]],"betweenCurves":true},"velocityGraph2":{"type":1,"keys":[[0,-2,1,-2],[0,3,1,-2],[0,0]]},"rotationSpeedGraph":{"type":1,"keys":[0,0,1,0],"betweenCurves":false},"rotationSpeedGraph2":{"type":1,"keys":[0,0,1,0]},"scaleGraph":{"type":1,"keys":[0,0.1],"betweenCurves":false},"scaleGraph2":{"type":1,"keys":[0,0.1]},"colorGraph":{"type":1,"keys":[[0,1,1,0.94375],[0,1,1,0.65625],[0,0]],"betweenCurves":false},"alphaGraph":{"type":1,"keys":[0,1,1,0.85625],"betweenCurves":false},"alphaGraph2":{"type":1,"keys":[0,1,1,0.85625]},"layers":[0]}}},"af1f2161-4057-47a8-9857-a44c166e9c3e":{"name":"BenchPoi2","tags":[],"enabled":true,"resource_id":"af1f2161-4057-47a8-9857-a44c166e9c3e","parent":"4048ce2c-d9b5-40c8-893f-9f981027c95c","children":["5cca838f-027b-4345-818e-a071e2f8f1bd","edb2ddf9-9f01-4108-8b35-27b33e2f11fe","ac04f7cc-d216-4f2b-9534-e9a777f7060d"],"position":[-2.696715712808154,1.6105378866195679,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{"script":{"enabled":true,"order":["poi"],"scripts":{"poi":{"enabled":true,"attributes":{"boundingBoxHalfSize":[2.7,4.5,100],"views":["5cca838f-027b-4345-818e-a071e2f8f1bd"],"flipX":true,"setupParticles":["edb2ddf9-9f01-4108-8b35-27b33e2f11fe","ac04f7cc-d216-4f2b-9534-e9a777f7060d"]}}}}}},"5cca838f-027b-4345-818e-a071e2f8f1bd":{"name":"View","tags":[],"enabled":false,"resource_id":"5cca838f-027b-4345-818e-a071e2f8f1bd","parent":"af1f2161-4057-47a8-9857-a44c166e9c3e","children":[],"position":[0.10756044262608544,0.45339763164520264,1],"rotation":[0,0,0],"scale":[1.5,1.5,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672568,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["bounceAnimation"],"scripts":{"bounceAnimation":{"enabled":true,"attributes":{}}}}}},"edb2ddf9-9f01-4108-8b35-27b33e2f11fe":{"name":"PointParticles","tags":[],"enabled":true,"resource_id":"edb2ddf9-9f01-4108-8b35-27b33e2f11fe","parent":"af1f2161-4057-47a8-9857-a44c166e9c3e","children":[],"position":[-0.0820000171661377,0.4042665245844974,3],"rotation":[0,0,0],"scale":[1,1,1],"components":{"particlesystem":{"enabled":true,"autoPlay":false,"numParticles":20,"lifetime":0.8,"rate":0.002,"rate2":0.003,"startAngle":0,"startAngle2":0,"loop":false,"preWarm":false,"lighting":false,"halfLambert":false,"intensity":1,"depthWrite":true,"depthSoftening":1,"sort":0,"blendType":2,"stretch":0,"alignToMotion":false,"emitterShape":0,"emitterExtents":[0,0,0],"emitterRadius":0,"initialVelocity":0,"animTilesX":1,"animTilesY":1,"animNumFrames":1,"animSpeed":1,"animLoop":true,"wrap":false,"wrapBounds":[0,0,0],"colorMapAsset":18621502,"normalMapAsset":null,"mesh":null,"localVelocityGraph":{"type":1,"keys":[[0,0],[0,0],[0,0]],"betweenCurves":false},"localVelocityGraph2":{"type":1,"keys":[[0,0],[0,0],[0,0]]},"velocityGraph":{"type":1,"keys":[[0,4,1,4],[0,-2,1,-4],[0,-1]],"betweenCurves":true},"velocityGraph2":{"type":1,"keys":[[0,-4,1,-4],[0,4,1,-4],[0,0]]},"rotationSpeedGraph":{"type":1,"keys":[0,0,1,0],"betweenCurves":false},"rotationSpeedGraph2":{"type":1,"keys":[0,0,1,0]},"scaleGraph":{"type":1,"keys":[0,0.02,0.995,0.02],"betweenCurves":false},"scaleGraph2":{"type":1,"keys":[0,0.02,0.995,0.02]},"colorGraph":{"type":1,"keys":[[0,1,1,1],[0,1,1,1],[0,1,1,1]],"betweenCurves":false},"alphaGraph":{"type":1,"keys":[0,1,1,0.85625],"betweenCurves":false},"alphaGraph2":{"type":1,"keys":[0,1,1,0.85625]},"layers":[0]}}},"ac04f7cc-d216-4f2b-9534-e9a777f7060d":{"name":"StarParticles","tags":[],"enabled":true,"resource_id":"ac04f7cc-d216-4f2b-9534-e9a777f7060d","parent":"af1f2161-4057-47a8-9857-a44c166e9c3e","children":[],"position":[-0.0820000171661377,0.4042665245844974,3],"rotation":[0,0,0],"scale":[1,1,1],"components":{"particlesystem":{"enabled":true,"autoPlay":false,"numParticles":20,"lifetime":0.8,"rate":0.001,"rate2":0.002,"startAngle":0,"startAngle2":0,"loop":false,"preWarm":false,"lighting":false,"halfLambert":false,"intensity":1,"depthWrite":true,"depthSoftening":1,"sort":0,"blendType":2,"stretch":0,"alignToMotion":false,"emitterShape":0,"emitterExtents":[0,0,0],"emitterRadius":0,"initialVelocity":0,"animTilesX":1,"animTilesY":1,"animNumFrames":1,"animSpeed":1,"animLoop":true,"wrap":false,"wrapBounds":[0,0,0],"colorMapAsset":18621503,"normalMapAsset":null,"mesh":null,"localVelocityGraph":{"type":1,"keys":[[0,0],[0,0],[0,0]],"betweenCurves":false},"localVelocityGraph2":{"type":1,"keys":[[0,0],[0,0],[0,0]]},"velocityGraph":{"type":1,"keys":[[0,2,1,2],[0,-1,0.991,-2],[0,-1]],"betweenCurves":true},"velocityGraph2":{"type":1,"keys":[[0,-2,1,-2],[0,3,1,-2],[0,0]]},"rotationSpeedGraph":{"type":1,"keys":[0,0,1,0],"betweenCurves":false},"rotationSpeedGraph2":{"type":1,"keys":[0,0,1,0]},"scaleGraph":{"type":1,"keys":[0,0.1],"betweenCurves":false},"scaleGraph2":{"type":1,"keys":[0,0.1]},"colorGraph":{"type":1,"keys":[[0,1,1,0.94375],[0,1,1,0.65625],[0,0]],"betweenCurves":false},"alphaGraph":{"type":1,"keys":[0,1,1,0.85625],"betweenCurves":false},"alphaGraph2":{"type":1,"keys":[0,1,1,0.85625]},"layers":[0]}}},"60c52806-4b4c-4278-87ae-460fddbcf9c1":{"name":"TutorialPoints","tags":[],"enabled":true,"resource_id":"60c52806-4b4c-4278-87ae-460fddbcf9c1","parent":"72762922-8d41-439a-afba-7556c37fa7db","children":["db8b7c12-3eda-4eee-8ad7-c2bdbd35be36","e87ea785-e9a7-4021-9ef5-e2f1b087c35e","ecbf4b5b-34a6-4f21-bf11-545baff45cd3","b1aaf8af-ac04-4581-90b9-74dbc774fc3e","32f9b0fd-ca3e-44ab-8c24-92c9072af53b","7eb3f2e6-9d60-4fb6-8e68-916fb0bc0823","50f7a2b1-bc0b-4460-913c-96b6748390fe","ec77c1ce-d81d-4f00-a126-569ca71c445d","7e16189e-90b7-47ed-8060-34f20e8b9560"],"position":[0,0,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"db8b7c12-3eda-4eee-8ad7-c2bdbd35be36":{"name":"HabitatHand","tags":[],"enabled":false,"resource_id":"db8b7c12-3eda-4eee-8ad7-c2bdbd35be36","parent":"60c52806-4b4c-4278-87ae-460fddbcf9c1","children":[],"position":[1.1456851745330026,-3.1447646617889404,8],"rotation":[0,0,40.699113093112516],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672562,"frame":0,"speed":1,"batchGroupId":null,"layers":[4],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["tutorialHand"],"scripts":{"tutorialHand":{"enabled":true,"attributes":{"fromEntity":"e87ea785-e9a7-4021-9ef5-e2f1b087c35e","toEntity":"ecbf4b5b-34a6-4f21-bf11-545baff45cd3"}}}}}},"e87ea785-e9a7-4021-9ef5-e2f1b087c35e":{"name":"HabitatStart","tags":[],"enabled":false,"resource_id":"e87ea785-e9a7-4021-9ef5-e2f1b087c35e","parent":"60c52806-4b4c-4278-87ae-460fddbcf9c1","children":[],"position":[-3.4881746768951416,-3.302617040102735,8],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"ecbf4b5b-34a6-4f21-bf11-545baff45cd3":{"name":"HabitatFinish","tags":[],"enabled":false,"resource_id":"ecbf4b5b-34a6-4f21-bf11-545baff45cd3","parent":"60c52806-4b4c-4278-87ae-460fddbcf9c1","children":[],"position":[-0.7069767538449958,-0.6808091998100281,8],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"b1aaf8af-ac04-4581-90b9-74dbc774fc3e":{"name":"BenchHand","tags":[],"enabled":false,"resource_id":"b1aaf8af-ac04-4581-90b9-74dbc774fc3e","parent":"60c52806-4b4c-4278-87ae-460fddbcf9c1","children":[],"position":[0.6531732082366943,-0.10174422711133957,8],"rotation":[0,0,40.699113093112516],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672562,"frame":0,"speed":1,"batchGroupId":null,"layers":[4],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["tutorialHand"],"scripts":{"tutorialHand":{"enabled":true,"attributes":{"fromEntity":"32f9b0fd-ca3e-44ab-8c24-92c9072af53b","toEntity":"7eb3f2e6-9d60-4fb6-8e68-916fb0bc0823"}}}}}},"32f9b0fd-ca3e-44ab-8c24-92c9072af53b":{"name":"Bench1Start","tags":[],"enabled":false,"resource_id":"32f9b0fd-ca3e-44ab-8c24-92c9072af53b","parent":"60c52806-4b4c-4278-87ae-460fddbcf9c1","children":[],"position":[-1.4065596853878106,-3.302999973297119,8],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"7eb3f2e6-9d60-4fb6-8e68-916fb0bc0823":{"name":"Bench1Finish","tags":[],"enabled":false,"resource_id":"7eb3f2e6-9d60-4fb6-8e68-916fb0bc0823","parent":"60c52806-4b4c-4278-87ae-460fddbcf9c1","children":[],"position":[-0.5628669300081945,-1.5751150846481323,8],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"50f7a2b1-bc0b-4460-913c-96b6748390fe":{"name":"LampHand","tags":[],"enabled":false,"resource_id":"50f7a2b1-bc0b-4460-913c-96b6748390fe","parent":"60c52806-4b4c-4278-87ae-460fddbcf9c1","children":[],"position":[0.6531732082366943,-0.10174422711133957,8],"rotation":[0,0,40.699113093112516],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672562,"frame":0,"speed":1,"batchGroupId":null,"layers":[4],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["tutorialHand"],"scripts":{"tutorialHand":{"enabled":true,"attributes":{"fromEntity":"ec77c1ce-d81d-4f00-a126-569ca71c445d","toEntity":"7e16189e-90b7-47ed-8060-34f20e8b9560"}}}}}},"ec77c1ce-d81d-4f00-a126-569ca71c445d":{"name":"LampStart","tags":[],"enabled":false,"resource_id":"ec77c1ce-d81d-4f00-a126-569ca71c445d","parent":"60c52806-4b4c-4278-87ae-460fddbcf9c1","children":[],"position":[0.8309885626027045,-3.302999973297119,8],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"7e16189e-90b7-47ed-8060-34f20e8b9560":{"name":"LampFinish","tags":[],"enabled":false,"resource_id":"7e16189e-90b7-47ed-8060-34f20e8b9560","parent":"60c52806-4b4c-4278-87ae-460fddbcf9c1","children":[],"position":[1.675,-1.575,8],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"78149a27-741a-43e0-8782-90fb3e800a2a":{"name":"UI","tags":[],"enabled":true,"resource_id":"78149a27-741a-43e0-8782-90fb3e800a2a","parent":"01fc56c5-44a3-11e9-97ae-026349a27a7c","children":["4adc3b08-a202-4a2c-b4f0-758a01311590","88223070-a119-4f42-8dec-bd21d48ab4a3","4f5e803c-b842-455a-8696-1eaad16f6474"],"position":[0,0,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"4adc3b08-a202-4a2c-b4f0-758a01311590":{"name":"InventoryPanel","tags":[],"enabled":true,"resource_id":"4adc3b08-a202-4a2c-b4f0-758a01311590","parent":"78149a27-741a-43e0-8782-90fb3e800a2a","children":["7393caa1-067c-470b-9e4a-7b7d0b407a55"],"position":[0,-3.841216564178467,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{"script":{"enabled":true,"order":["inventoryPanel"],"scripts":{"inventoryPanel":{"enabled":true,"attributes":{"items":["9017e4b8-5eec-46cc-b5ed-f289c9f46a3d","341266cc-b98a-4991-9eb8-715783eb6ee8","196969be-858a-4cd6-8b37-30e1ba285f79","edf56e7d-2a3f-4537-8cc0-e371df3ed97c"],"cameraEntity":"01fc56c6-44a3-11e9-97ae-026349a27a7c","itemsContainer":"7393caa1-067c-470b-9e4a-7b7d0b407a55","rewardScreen":"88223070-a119-4f42-8dec-bd21d48ab4a3","animals":["d25457b3-5ce6-4e8c-8474-e696f56a20be","03f8b222-ea53-4269-b068-90b88b067f27","79833129-28eb-4efc-97f1-ecfd590918a3"],"bgHider":"4f5e803c-b842-455a-8696-1eaad16f6474","autoSetupDelay":8}}}}}},"7393caa1-067c-470b-9e4a-7b7d0b407a55":{"name":"Items","tags":[],"enabled":true,"resource_id":"7393caa1-067c-470b-9e4a-7b7d0b407a55","parent":"4adc3b08-a202-4a2c-b4f0-758a01311590","children":["9017e4b8-5eec-46cc-b5ed-f289c9f46a3d","341266cc-b98a-4991-9eb8-715783eb6ee8","196969be-858a-4cd6-8b37-30e1ba285f79","edf56e7d-2a3f-4537-8cc0-e371df3ed97c"],"position":[0,0,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{}},"9017e4b8-5eec-46cc-b5ed-f289c9f46a3d":{"name":"NewHabitat","tags":[],"enabled":true,"resource_id":"9017e4b8-5eec-46cc-b5ed-f289c9f46a3d","parent":"7393caa1-067c-470b-9e4a-7b7d0b407a55","children":["f9704447-b0fb-4ec1-a9fd-150c092c1b0a","8d41a7ff-cc87-4c3f-9413-002f5fc1a1d8","75b8436f-0811-4ece-ac6c-756582262fe3","8e1ea98a-7fb0-43b8-a291-eccb74356a53"],"position":[-3.3,0.6684092476352497,4],"rotation":[0,0,0],"scale":[1,1,1],"components":{"script":{"enabled":true,"order":["inventoryItem","bounceOntapAnimation"],"scripts":{"inventoryItem":{"enabled":false,"attributes":{"setupAnimType":1,"replaceItem":"c2349172-1439-49cf-99df-6da9ac2c11e7","boundingBoxHalfSize":[1,1,100],"pois":["4d0056f5-f40c-43d7-bf53-b68934fc07f8"],"draggable":true,"itemsToUnlock":["341266cc-b98a-4991-9eb8-715783eb6ee8","196969be-858a-4cd6-8b37-30e1ba285f79"],"lock":"8e1ea98a-7fb0-43b8-a291-eccb74356a53","hand":"db8b7c12-3eda-4eee-8ad7-c2bdbd35be36","handMoveDuration":1.5,"icon":"8d41a7ff-cc87-4c3f-9413-002f5fc1a1d8","dragScaleCoef":2,"finalScaleCoef":1}},"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.7,0.8,100],"boundingBoxOffset":[0,0,0],"scaleCoefs":[0.9,0.9,1]}}}}}},"f9704447-b0fb-4ec1-a9fd-150c092c1b0a":{"name":"Bg","tags":[],"enabled":true,"resource_id":"f9704447-b0fb-4ec1-a9fd-150c092c1b0a","parent":"9017e4b8-5eec-46cc-b5ed-f289c9f46a3d","children":["1f76c08e-6474-41ea-abb5-a7ed0adb199b","123d9d4e-eea9-4572-bf09-5a2af45f513a","02c42a9d-fbb1-48f6-b11f-d6da70f1f436","038f4201-7448-48b8-a441-5a1692564e92","0cb5f937-35d0-484a-b9fe-10af60b88b3e"],"position":[-0.000004257386024164589,6.703796771034831e-7,0],"rotation":[0,0,0],"scale":[0.75,0.75,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672570,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"8d41a7ff-cc87-4c3f-9413-002f5fc1a1d8":{"name":"Icon","tags":[],"enabled":true,"resource_id":"8d41a7ff-cc87-4c3f-9413-002f5fc1a1d8","parent":"9017e4b8-5eec-46cc-b5ed-f289c9f46a3d","children":[],"position":[-0.000004291534423828125,0.3166154486571733,1],"rotation":[0,0,0],"scale":[0.2,0.2,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672561,"frame":0,"speed":1,"batchGroupId":null,"layers":[4],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"75b8436f-0811-4ece-ac6c-756582262fe3":{"name":"Shadow","tags":[],"enabled":true,"resource_id":"75b8436f-0811-4ece-ac6c-756582262fe3","parent":"9017e4b8-5eec-46cc-b5ed-f289c9f46a3d","children":[],"position":[-0.0000016987323760986328,0.317,0.5],"rotation":[0,0,0],"scale":[0.2,0.2,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":0.2,"flipX":false,"flipY":false,"spriteAsset":18672561,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"8e1ea98a-7fb0-43b8-a291-eccb74356a53":{"name":"Lock","tags":[],"enabled":true,"resource_id":"8e1ea98a-7fb0-43b8-a291-eccb74356a53","parent":"9017e4b8-5eec-46cc-b5ed-f289c9f46a3d","children":[],"position":[-0.000004291534423828125,0.32,2],"rotation":[0,0,0],"scale":[1.5,1.5,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672567,"frame":0,"speed":1,"batchGroupId":null,"layers":[4],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"341266cc-b98a-4991-9eb8-715783eb6ee8":{"name":"Bench","tags":[],"enabled":true,"resource_id":"341266cc-b98a-4991-9eb8-715783eb6ee8","parent":"7393caa1-067c-470b-9e4a-7b7d0b407a55","children":["28392f67-5874-4920-b210-5f70a7a7c8ec","894dfe87-98ff-43e0-abb2-a20482945d07","0a1732e1-bdad-4321-8d6a-524b9fc83f39","0c47039f-5884-48ee-bfe2-73b9c23c0d96"],"position":[-1.1,0.6684093475341797,4],"rotation":[0,0,0],"scale":[1,1,1],"components":{"script":{"enabled":true,"order":["inventoryItem","bounceOntapAnimation"],"scripts":{"inventoryItem":{"enabled":false,"attributes":{"setupAnimType":1,"replaceItem":"","boundingBoxHalfSize":[1,1,100],"pois":["5630311f-78d3-4cb3-ae96-741e3606f7f7","af1f2161-4057-47a8-9857-a44c166e9c3e"],"draggable":false,"itemsToUnlock":[],"lock":"0c47039f-5884-48ee-bfe2-73b9c23c0d96","hand":"b1aaf8af-ac04-4581-90b9-74dbc774fc3e","handMoveDuration":1.5,"icon":"894dfe87-98ff-43e0-abb2-a20482945d07","dragScaleCoef":1.5,"finalScaleCoef":1}},"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.7,0.8,100],"boundingBoxOffset":[0,0,0],"scaleCoefs":[0.9,0.9,1]}}}}}},"28392f67-5874-4920-b210-5f70a7a7c8ec":{"name":"Bg","tags":[],"enabled":true,"resource_id":"28392f67-5874-4920-b210-5f70a7a7c8ec","parent":"341266cc-b98a-4991-9eb8-715783eb6ee8","children":["307f5eb6-83fb-4e33-8e01-1bc18144dce9","a1d72a7e-313d-4ae8-8203-abd8d2920bc7","9bebb0b4-84a4-4338-aceb-406ef7c79988","7237a581-8185-44f2-a880-f1616b8dedfe"],"position":[-0.000004257386024164589,6.703796771034831e-7,0],"rotation":[0,0,0],"scale":[0.75,0.75,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672570,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"894dfe87-98ff-43e0-abb2-a20482945d07":{"name":"Icon","tags":[],"enabled":true,"resource_id":"894dfe87-98ff-43e0-abb2-a20482945d07","parent":"341266cc-b98a-4991-9eb8-715783eb6ee8","children":[],"position":[-0.000004291534423828125,0.24625659555389845,1],"rotation":[0,0,0],"scale":[0.8,0.8,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672552,"frame":0,"speed":1,"batchGroupId":null,"layers":[4],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"0a1732e1-bdad-4321-8d6a-524b9fc83f39":{"name":"Shadow","tags":[],"enabled":true,"resource_id":"0a1732e1-bdad-4321-8d6a-524b9fc83f39","parent":"341266cc-b98a-4991-9eb8-715783eb6ee8","children":[],"position":[-0.0000016689300537109375,0.24625635713531935,0.5],"rotation":[0,0,0],"scale":[0.8,0.8,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":0.2,"flipX":false,"flipY":false,"spriteAsset":18672552,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"0c47039f-5884-48ee-bfe2-73b9c23c0d96":{"name":"Lock","tags":[],"enabled":true,"resource_id":"0c47039f-5884-48ee-bfe2-73b9c23c0d96","parent":"341266cc-b98a-4991-9eb8-715783eb6ee8","children":[],"position":[-0.000004356825229479,0.32,2],"rotation":[0,0,0],"scale":[1.5,1.5,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672567,"frame":0,"speed":1,"batchGroupId":null,"layers":[4],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"196969be-858a-4cd6-8b37-30e1ba285f79":{"name":"Lamp","tags":[],"enabled":true,"resource_id":"196969be-858a-4cd6-8b37-30e1ba285f79","parent":"7393caa1-067c-470b-9e4a-7b7d0b407a55","children":["02f36f3f-cb44-4912-a6cc-5c02a30c0ebf","5325e6a1-08d1-4a2f-b22c-04f1adc061b0","8299a8c3-3b6a-46cc-be10-6815e94b82be","5cef13be-0bf3-4982-b3fd-5d0e04dec348"],"position":[1.1,0.6684093475341797,4],"rotation":[0,0,0],"scale":[1,1,1],"components":{"script":{"enabled":true,"order":["inventoryItem","bounceOntapAnimation"],"scripts":{"inventoryItem":{"enabled":false,"attributes":{"setupAnimType":1,"replaceItem":"","boundingBoxHalfSize":[1,1,100],"pois":["063df118-0111-48d4-ba6c-13c278a44f09","c5948127-0962-4905-a4fb-e8fec16425f0"],"draggable":false,"itemsToUnlock":[],"lock":"5cef13be-0bf3-4982-b3fd-5d0e04dec348","hand":"50f7a2b1-bc0b-4460-913c-96b6748390fe","handMoveDuration":1.5,"icon":"5325e6a1-08d1-4a2f-b22c-04f1adc061b0","dragScaleCoef":1.5,"finalScaleCoef":1.7}},"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.7,0.8,100],"boundingBoxOffset":[0,0,0],"scaleCoefs":[0.9,0.9,1]}}}}}},"02f36f3f-cb44-4912-a6cc-5c02a30c0ebf":{"name":"Bg","tags":[],"enabled":true,"resource_id":"02f36f3f-cb44-4912-a6cc-5c02a30c0ebf","parent":"196969be-858a-4cd6-8b37-30e1ba285f79","children":["7f54ad88-3867-4a44-9d41-229454dcfcc1","786675cf-dd43-4e2b-8ec0-45dd74e1723e","5df68c59-8576-48c4-ae0b-d6bf8b02055b","4ad3d8ce-e79d-408c-a64b-844b176c24bc"],"position":[-0.000004257386024164589,6.703796771034831e-7,0],"rotation":[0,0,0],"scale":[0.75,0.75,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672570,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"5325e6a1-08d1-4a2f-b22c-04f1adc061b0":{"name":"Icon","tags":[],"enabled":true,"resource_id":"5325e6a1-08d1-4a2f-b22c-04f1adc061b0","parent":"196969be-858a-4cd6-8b37-30e1ba285f79","children":[],"position":[-0.000004291534423828125,0.45733309358551466,1],"rotation":[0,0,0],"scale":[0.9,0.9,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672563,"frame":0,"speed":1,"batchGroupId":null,"layers":[4],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"8299a8c3-3b6a-46cc-be10-6815e94b82be":{"name":"Shadow","tags":[],"enabled":true,"resource_id":"8299a8c3-3b6a-46cc-be10-6815e94b82be","parent":"196969be-858a-4cd6-8b37-30e1ba285f79","children":[],"position":[-0.0000016689300537109375,0.45733285516693556,0.5],"rotation":[0,0,0],"scale":[0.9,0.9,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":0.2,"flipX":false,"flipY":false,"spriteAsset":18672563,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"5cef13be-0bf3-4982-b3fd-5d0e04dec348":{"name":"Lock","tags":[],"enabled":true,"resource_id":"5cef13be-0bf3-4982-b3fd-5d0e04dec348","parent":"196969be-858a-4cd6-8b37-30e1ba285f79","children":[],"position":[-0.000004356825229479,0.32,2],"rotation":[0,0,0],"scale":[1.5,1.5,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672567,"frame":0,"speed":1,"batchGroupId":null,"layers":[4],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"edf56e7d-2a3f-4537-8cc0-e371df3ed97c":{"name":"Flowers","tags":[],"enabled":true,"resource_id":"edf56e7d-2a3f-4537-8cc0-e371df3ed97c","parent":"7393caa1-067c-470b-9e4a-7b7d0b407a55","children":["82307aab-ccd7-41e6-bbc2-5d5a31fb2a19","47177035-ac34-482c-bbe5-5650bf710e1e","ec80da28-980a-42ce-a2e4-8a9990520972","c5e275e3-a587-4b9b-bfae-bd73c61d8b1b"],"position":[3.3,0.6684093475341797,4],"rotation":[0,0,0],"scale":[1,1,1],"components":{"script":{"enabled":true,"order":["inventoryItem","bounceOntapAnimation"],"scripts":{"inventoryItem":{"enabled":false,"attributes":{"setupAnimType":1,"replaceItem":"","boundingBoxHalfSize":[1,1,100],"pois":[],"draggable":false,"itemsToUnlock":["574586cf-916c-4795-afdf-2e5e3769662e","856d818e-5df3-49cf-9177-0bd1956f8c1c"],"lock":"c5e275e3-a587-4b9b-bfae-bd73c61d8b1b","hand":"","handMoveDuration":1.5,"icon":"47177035-ac34-482c-bbe5-5650bf710e1e","dragScaleCoef":1.5,"finalScaleCoef":1.5}},"bounceOntapAnimation":{"enabled":true,"attributes":{"boundingBoxHalfSize":[0.7,0.8,100],"boundingBoxOffset":[0,0,0],"scaleCoefs":[0.9,0.9,1]}}}}}},"82307aab-ccd7-41e6-bbc2-5d5a31fb2a19":{"name":"Bg","tags":[],"enabled":true,"resource_id":"82307aab-ccd7-41e6-bbc2-5d5a31fb2a19","parent":"edf56e7d-2a3f-4537-8cc0-e371df3ed97c","children":["98b48860-bc93-4d44-a924-f69921a870ea","a3399cf9-9c5e-47bf-91a2-3c91f97fc50a","4d3708b3-4dee-4111-af47-12df6fabb9b3","15d9849d-f565-417d-aa3e-792f1206a437"],"position":[-0.000004257386024164589,6.703796771034831e-7,0],"rotation":[0,0,0],"scale":[0.75,0.75,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672570,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"47177035-ac34-482c-bbe5-5650bf710e1e":{"name":"Icon","tags":[],"enabled":true,"resource_id":"47177035-ac34-482c-bbe5-5650bf710e1e","parent":"edf56e7d-2a3f-4537-8cc0-e371df3ed97c","children":[],"position":[-0.000004291534423828125,0.3166152931444066,1],"rotation":[0,0,0],"scale":[1.25,1.25,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672559,"frame":0,"speed":1,"batchGroupId":null,"layers":[4],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"ec80da28-980a-42ce-a2e4-8a9990520972":{"name":"Shadow","tags":[],"enabled":true,"resource_id":"ec80da28-980a-42ce-a2e4-8a9990520972","parent":"edf56e7d-2a3f-4537-8cc0-e371df3ed97c","children":[],"position":[-0.0000016689300537109375,0.3166150547258275,0.5],"rotation":[0,0,0],"scale":[1.25,1.25,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":0.2,"flipX":false,"flipY":false,"spriteAsset":18672559,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"c5e275e3-a587-4b9b-bfae-bd73c61d8b1b":{"name":"Lock","tags":[],"enabled":true,"resource_id":"c5e275e3-a587-4b9b-bfae-bd73c61d8b1b","parent":"edf56e7d-2a3f-4537-8cc0-e371df3ed97c","children":[],"position":[-0.000004356825229479,0.32,2],"rotation":[0,0,0],"scale":[1.5,1.5,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672567,"frame":0,"speed":1,"batchGroupId":null,"layers":[4],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"88223070-a119-4f42-8dec-bd21d48ab4a3":{"name":"RewardScreen","tags":[],"enabled":false,"resource_id":"88223070-a119-4f42-8dec-bd21d48ab4a3","parent":"78149a27-741a-43e0-8782-90fb3e800a2a","children":["81e9811b-8a01-4cc0-9e3f-734805f41c81","91bb5c86-9c58-44b8-b07a-4d9609390bcf","3946e10f-9c19-4c1f-8002-e7a469c56790"],"position":[0,0.7955690697778639,10],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672573,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["rewardScreen"],"scripts":{"rewardScreen":{"enabled":true,"attributes":{"particles":["3946e10f-9c19-4c1f-8002-e7a469c56790","91bb5c86-9c58-44b8-b07a-4d9609390bcf"],"repeatParticlesDelay":1,"particleXOffset":1,"particleYOffset":0.5}}}}}},"81e9811b-8a01-4cc0-9e3f-734805f41c81":{"name":"ClaimButton","tags":[],"enabled":true,"resource_id":"81e9811b-8a01-4cc0-9e3f-734805f41c81","parent":"88223070-a119-4f42-8dec-bd21d48ab4a3","children":[],"position":[0,-1.4629768187942336,0],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672572,"frame":0,"speed":1,"batchGroupId":null,"layers":[4],"drawOrder":0,"autoPlayClip":null,"clips":{}},"script":{"enabled":true,"order":["claimButton"],"scripts":{"claimButton":{"enabled":true,"attributes":{"boundingBoxHalfSize":[3,3,100],"cameraEntity":"01fc56c6-44a3-11e9-97ae-026349a27a7c"}}}}}},"4f5e803c-b842-455a-8696-1eaad16f6474":{"name":"BgHider","tags":[],"enabled":false,"resource_id":"4f5e803c-b842-455a-8696-1eaad16f6474","parent":"78149a27-741a-43e0-8782-90fb3e800a2a","children":[],"position":[0,0,9],"rotation":[0,0,0],"scale":[118.77590535882847,118.77590535882847,1.2372490141544632],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[0.09019607843137255,0.09019607843137255,0.09019607843137255],"opacity":0.3,"flipX":false,"flipY":false,"spriteAsset":18549032,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"91bb5c86-9c58-44b8-b07a-4d9609390bcf":{"name":"PointParticles","tags":[],"enabled":true,"resource_id":"91bb5c86-9c58-44b8-b07a-4d9609390bcf","parent":"88223070-a119-4f42-8dec-bd21d48ab4a3","children":[],"position":[-0.15113167464733124,2.072402023181254,1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"particlesystem":{"enabled":true,"autoPlay":false,"numParticles":40,"lifetime":1,"rate":0.002,"rate2":0.003,"startAngle":0,"startAngle2":0,"loop":false,"preWarm":false,"lighting":false,"halfLambert":false,"intensity":1,"depthWrite":false,"depthSoftening":1,"sort":0,"blendType":2,"stretch":0,"alignToMotion":false,"emitterShape":0,"emitterExtents":[0,0,0],"emitterRadius":0,"initialVelocity":0,"animTilesX":1,"animTilesY":1,"animNumFrames":1,"animSpeed":1,"animLoop":false,"wrap":false,"wrapBounds":[0,0,0],"colorMapAsset":18621502,"normalMapAsset":null,"mesh":null,"localVelocityGraph":{"type":1,"keys":[[0,0],[0,0],[0,0]],"betweenCurves":false},"localVelocityGraph2":{"type":1,"keys":[[0,0],[0,0],[0,0]]},"velocityGraph":{"type":1,"keys":[[0,4,1,4],[0,-2,1,-4],[0,-1]],"betweenCurves":true},"velocityGraph2":{"type":1,"keys":[[0,-4,1,-4],[0,4,1,-4],[0,0]]},"rotationSpeedGraph":{"type":1,"keys":[0,0,1,0],"betweenCurves":false},"rotationSpeedGraph2":{"type":1,"keys":[0,0,1,0]},"scaleGraph":{"type":1,"keys":[0,0.02,0.995,0.02],"betweenCurves":false},"scaleGraph2":{"type":1,"keys":[0,0.02,0.995,0.02]},"colorGraph":{"type":1,"keys":[[0,1,1,1],[0,1,1,1],[0,1,1,1]],"betweenCurves":false},"alphaGraph":{"type":1,"keys":[0,1,1,0.85625],"betweenCurves":false},"alphaGraph2":{"type":1,"keys":[0,1,1,0.85625]},"layers":[0]}}},"3946e10f-9c19-4c1f-8002-e7a469c56790":{"name":"StarParticles","tags":[],"enabled":true,"resource_id":"3946e10f-9c19-4c1f-8002-e7a469c56790","parent":"88223070-a119-4f42-8dec-bd21d48ab4a3","children":[],"position":[-0.15113167464733124,2.166034005984599,1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"particlesystem":{"enabled":true,"autoPlay":false,"numParticles":40,"lifetime":1,"rate":0.001,"rate2":0.002,"startAngle":0,"startAngle2":0,"loop":false,"preWarm":false,"lighting":false,"halfLambert":false,"intensity":1,"depthWrite":false,"depthSoftening":1,"sort":0,"blendType":2,"stretch":0,"alignToMotion":false,"emitterShape":0,"emitterExtents":[0,0,0],"emitterRadius":0,"initialVelocity":0,"animTilesX":1,"animTilesY":1,"animNumFrames":1,"animSpeed":1,"animLoop":false,"wrap":false,"wrapBounds":[0,0,0],"colorMapAsset":18621503,"normalMapAsset":null,"mesh":null,"localVelocityGraph":{"type":1,"keys":[[0,0],[0,0],[0,0]],"betweenCurves":false},"localVelocityGraph2":{"type":1,"keys":[[0,0],[0,0],[0,0]]},"velocityGraph":{"type":1,"keys":[[0,3,1,3],[0,-1,0.9906976744186047,-3.299999999999999],[0,-1]],"betweenCurves":true},"velocityGraph2":{"type":1,"keys":[[0,-3,1,-3],[0,5,1,-3],[0,0]]},"rotationSpeedGraph":{"type":1,"keys":[0,0,1,0],"betweenCurves":false},"rotationSpeedGraph2":{"type":1,"keys":[0,0,1,0]},"scaleGraph":{"type":1,"keys":[0,0.1],"betweenCurves":false},"scaleGraph2":{"type":1,"keys":[0,0.1]},"colorGraph":{"type":1,"keys":[[0,1,1,0.94375],[0,1,1,0.65625],[0,0]],"betweenCurves":false},"alphaGraph":{"type":1,"keys":[0,1,1,0.85625],"betweenCurves":false},"alphaGraph2":{"type":1,"keys":[0,1,1,0.85625]},"layers":[4]}}},"1f76c08e-6474-41ea-abb5-a7ed0adb199b":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"1f76c08e-6474-41ea-abb5-a7ed0adb199b","parent":"f9704447-b0fb-4ec1-a9fd-150c092c1b0a","children":[],"position":[-0.7967023808769795,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672571,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"038f4201-7448-48b8-a441-5a1692564e92":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"038f4201-7448-48b8-a441-5a1692564e92","parent":"f9704447-b0fb-4ec1-a9fd-150c092c1b0a","children":[],"position":[-0.10218045618691463,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672576,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"123d9d4e-eea9-4572-bf09-5a2af45f513a":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"123d9d4e-eea9-4572-bf09-5a2af45f513a","parent":"f9704447-b0fb-4ec1-a9fd-150c092c1b0a","children":[],"position":[-0.5968869426913841,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672569,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"0cb5f937-35d0-484a-b9fe-10af60b88b3e":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"0cb5f937-35d0-484a-b9fe-10af60b88b3e","parent":"f9704447-b0fb-4ec1-a9fd-150c092c1b0a","children":[],"position":[0.4972668120442165,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672553,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"02c42a9d-fbb1-48f6-b11f-d6da70f1f436":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"02c42a9d-fbb1-48f6-b11f-d6da70f1f436","parent":"f9704447-b0fb-4ec1-a9fd-150c092c1b0a","children":[],"position":[-0.3756621512472975,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672576,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"307f5eb6-83fb-4e33-8e01-1bc18144dce9":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"307f5eb6-83fb-4e33-8e01-1bc18144dce9","parent":"28392f67-5874-4920-b210-5f70a7a7c8ec","children":[],"position":[-0.6775284452498198,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672571,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"a1d72a7e-313d-4ae8-8203-abd8d2920bc7":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"a1d72a7e-313d-4ae8-8203-abd8d2920bc7","parent":"28392f67-5874-4920-b210-5f70a7a7c8ec","children":[],"position":[-0.4211282228435467,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672555,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"9bebb0b4-84a4-4338-aceb-406ef7c79988":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"9bebb0b4-84a4-4338-aceb-406ef7c79988","parent":"28392f67-5874-4920-b210-5f70a7a7c8ec","children":[],"position":[-0.15275949383723475,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672576,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"7237a581-8185-44f2-a880-f1616b8dedfe":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"7237a581-8185-44f2-a880-f1616b8dedfe","parent":"28392f67-5874-4920-b210-5f70a7a7c8ec","children":[],"position":[0.4466880128124826,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672553,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"7f54ad88-3867-4a44-9d41-229454dcfcc1":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"7f54ad88-3867-4a44-9d41-229454dcfcc1","parent":"02f36f3f-cb44-4912-a6cc-5c02a30c0ebf","children":[],"position":[-0.7259722329967602,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672571,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"786675cf-dd43-4e2b-8ec0-45dd74e1723e":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"786675cf-dd43-4e2b-8ec0-45dd74e1723e","parent":"02f36f3f-cb44-4912-a6cc-5c02a30c0ebf","children":[],"position":[-0.46957211701803914,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672555,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"5df68c59-8576-48c4-ae0b-d6bf8b02055b":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"5df68c59-8576-48c4-ae0b-d6bf8b02055b","parent":"02f36f3f-cb44-4912-a6cc-5c02a30c0ebf","children":[],"position":[-0.2012033880117272,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672576,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"4ad3d8ce-e79d-408c-a64b-844b176c24bc":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"4ad3d8ce-e79d-408c-a64b-844b176c24bc","parent":"02f36f3f-cb44-4912-a6cc-5c02a30c0ebf","children":[],"position":[0.39824411863799014,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672553,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"98b48860-bc93-4d44-a924-f69921a870ea":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"98b48860-bc93-4d44-a924-f69921a870ea","parent":"82307aab-ccd7-41e6-bbc2-5d5a31fb2a19","children":[],"position":[-0.6801033396522103,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672571,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"a3399cf9-9c5e-47bf-91a2-3c91f97fc50a":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"a3399cf9-9c5e-47bf-91a2-3c91f97fc50a","parent":"82307aab-ccd7-41e6-bbc2-5d5a31fb2a19","children":[],"position":[-0.4237032236734892,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672574,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"4d3708b3-4dee-4111-af47-12df6fabb9b3":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"4d3708b3-4dee-4111-af47-12df6fabb9b3","parent":"82307aab-ccd7-41e6-bbc2-5d5a31fb2a19","children":[],"position":[-0.1553344946671773,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672576,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}},"15d9849d-f565-417d-aa3e-792f1206a437":{"name":"Sprite","tags":[],"enabled":true,"resource_id":"15d9849d-f565-417d-aa3e-792f1206a437","parent":"82307aab-ccd7-41e6-bbc2-5d5a31fb2a19","children":[],"position":[0.4441130914554021,-1.0802070293013912,0.1],"rotation":[0,0,0],"scale":[1,1,1],"components":{"sprite":{"enabled":true,"type":"simple","width":1,"height":1,"color":[1,1,1],"opacity":1,"flipX":false,"flipY":false,"spriteAsset":18672553,"frame":0,"speed":1,"batchGroupId":null,"layers":[0],"drawOrder":0,"autoPlayClip":null,"clips":{}}}}},"id":726274}');
        CONTEXT_OPTIONS = {
            'antialias': true,
            'alpha': false,
            'preserveDrawingBuffer': false,
            'preferWebGl2': true
        };
        SCRIPTS = [ 18368975, 18403671, 18409277, 18409323, 18410482, 18413283, 18414751, 18466427, 18466567, 18478347, 18477892, 18477897, 18477898, 18477899, 18477440, 18477996, 18555968, 18563311, 18581363, 18581368, 18624306 ];
        CONFIG_FILENAME = JSON.parse('{"application_properties":{"i18nAssets":[],"useTouch":true,"layerOrder":[{"layer":0,"enabled":true,"transparent":false},{"layer":1,"enabled":true,"transparent":false},{"layer":2,"enabled":true,"transparent":false},{"layer":0,"enabled":true,"transparent":true},{"layer":3,"enabled":true,"transparent":false},{"layer":3,"enabled":true,"transparent":true},{"layer":4,"enabled":true,"transparent":true}],"height":960,"vr":false,"useModelV2":false,"antiAlias":true,"layers":{"0":{"transparentSortMode":3,"opaqueSortMode":2,"name":"World"},"1":{"transparentSortMode":3,"opaqueSortMode":2,"name":"Depth"},"2":{"transparentSortMode":3,"opaqueSortMode":0,"name":"Skybox"},"3":{"transparentSortMode":3,"opaqueSortMode":0,"name":"Immediate"},"4":{"transparentSortMode":1,"opaqueSortMode":1,"name":"UI"}},"width":960,"useDevicePixelRatio":true,"useKeyboard":true,"batchGroups":[],"preserveDrawingBuffer":false,"useLegacyScripts":false,"fillMode":"KEEP_ASPECT","scripts":[18368975,18403671,18409277,18409323,18410482,18413283,18414751,18466427,18466567,18478347,18477892,18477897,18477898,18477899,18477440,18477996,18555968,18563311,18581363,18581368,18624306],"useMouse":true,"use3dPhysics":false,"transparentCanvas":false,"resolutionMode":"AUTO","loadingScreenScript":null,"preferWebGl2":true,"useGamepads":false,"libraries":[]},"scenes":[{"name":"Game","url":"726274.json"}],"assets":{"18368975":{"tags":[],"name":"tween.js","revision":1,"preload":true,"meta":null,"data":{"order":100,"scripts":{},"loading":false},"type":"script","file":{"filename":"tween.js","size":20048,"hash":"d0e89e2d42838aa9c8890190dd54de65","url":"files/assets/18368975/1/tween.js"},"region":"eu-west-1","id":"18368975"},"18403671":{"tags":[],"name":"SpritesCloner.js","revision":1,"preload":true,"meta":null,"data":{"scripts":{"spritesCloner":{"attributesOrder":["sprite","container","tileOffset","ranges"],"attributes":{"sprite":{"type":"asset","assetType":"sprite"},"container":{"type":"entity"},"ranges":{"type":"vec4","array":true},"tileOffset":{"type":"vec3"}}}},"loading":false},"type":"script","file":{"filename":"SpritesCloner.js","size":1210,"hash":"c84c0b2eedf2c11d09f89afc674786ea","url":"files/assets/18403671/1/SpritesCloner.js"},"region":"eu-west-1","id":"18403671"},"18409277":{"tags":[],"name":"InventoryItem.js","revision":1,"preload":true,"meta":null,"data":{"scripts":{"inventoryItem":{"attributesOrder":["setupAnimType","draggable","dragScaleCoef","finalScaleCoef","replaceItem","icon","lock","boundingBoxHalfSize","hand","handMoveDuration","pois","itemsToUnlock"],"attributes":{"setupAnimType":{"type":"number","default":0,"enum":{"order":["Bounce","ScaleUp"],"options":{"Bounce":0,"ScaleUp":1}}},"replaceItem":{"type":"entity"},"boundingBoxHalfSize":{"type":"vec3"},"pois":{"type":"entity","array":true},"draggable":{"type":"boolean"},"itemsToUnlock":{"type":"entity","array":true},"lock":{"type":"entity"},"hand":{"type":"entity"},"handMoveDuration":{"type":"number","default":2.5},"icon":{"type":"entity"},"dragScaleCoef":{"type":"number","default":1.5},"finalScaleCoef":{"type":"number","default":1.5}}}},"loading":false},"type":"script","file":{"filename":"InventoryItem.js","size":3086,"hash":"8242b6bd4274404119c47650876757b6","url":"files/assets/18409277/1/InventoryItem.js"},"region":"eu-west-1","id":"18409277"},"18409323":{"tags":[],"name":"SetupAnimation.js","revision":1,"preload":true,"meta":null,"data":{"scripts":{"setupAnimation":{"attributesOrder":[],"attributes":{}}},"loading":false},"type":"script","file":{"filename":"SetupAnimation.js","size":800,"hash":"17c8fe13da8d84ce9310315db049e2c6","url":"files/assets/18409323/1/SetupAnimation.js"},"region":"eu-west-1","id":"18409323"},"18410482":{"tags":[],"name":"InventoryPanel.js","revision":1,"preload":true,"meta":null,"data":{"scripts":{"inventoryPanel":{"attributesOrder":["cameraEntity","itemsContainer","rewardScreen","bgHider","autoSetupDelay","items","animals"],"attributes":{"items":{"type":"entity","array":true},"cameraEntity":{"type":"entity"},"itemsContainer":{"type":"entity"},"rewardScreen":{"type":"entity"},"animals":{"type":"entity","array":true},"bgHider":{"type":"entity"},"autoSetupDelay":{"type":"number","default":10}}}},"loading":false},"type":"script","file":{"filename":"InventoryPanel.js","size":9753,"hash":"8bc7fb95f21ee0379a6c1fbe0db6a7ec","url":"files/assets/18410482/1/InventoryPanel.js"},"region":"eu-west-1","id":"18410482"},"18413283":{"tags":[],"name":"POI.js","revision":1,"preload":true,"meta":null,"data":{"scripts":{"poi":{"attributesOrder":["boundingBoxHalfSize","flipX","views","setupParticles"],"attributes":{"boundingBoxHalfSize":{"type":"vec3"},"views":{"type":"entity","array":true},"flipX":{"type":"boolean","default":false},"setupParticles":{"type":"entity","array":true}}}},"loading":false},"type":"script","file":{"filename":"POI.js","size":959,"hash":"c30e0935a074659fa9f23eb686c79444","url":"files/assets/18413283/1/POI.js"},"region":"eu-west-1","id":"18413283"},"18414751":{"tags":[],"name":"TutorialHand.js","revision":1,"preload":true,"meta":null,"data":{"scripts":{"tutorialHand":{"attributesOrder":["fromEntity","toEntity"],"attributes":{"fromEntity":{"type":"entity"},"toEntity":{"type":"entity"}}}},"loading":false},"type":"script","file":{"filename":"TutorialHand.js","size":1220,"hash":"06467b532a20b0e031a2035801068734","url":"files/assets/18414751/1/TutorialHand.js"},"region":"eu-west-1","id":"18414751"},"18466427":{"tags":[],"name":"DebugUtils.js","revision":1,"preload":true,"meta":null,"data":{"scripts":{"debugUtils":{"attributesOrder":[],"attributes":{}}},"loading":false},"type":"script","file":{"filename":"DebugUtils.js","size":2509,"hash":"783c3e002ccc31864739bc92067c3670","url":"files/assets/18466427/1/DebugUtils.js"},"region":"eu-west-1","id":"18466427"},"18466567":{"tags":[],"name":"GameController.js","revision":1,"preload":true,"meta":null,"data":{"scripts":{"gameController":{"attributesOrder":["debug"],"attributes":{"debug":{"type":"boolean"}}}},"loading":false},"type":"script","file":{"filename":"GameController.js","size":605,"hash":"4d90c17203446c6bed209675628084f7","url":"files/assets/18466567/1/GameController.js"},"region":"eu-west-1","id":"18466567"},"18477440":{"tags":[],"name":"plugin.js","revision":1,"preload":true,"meta":null,"data":{"order":100,"scripts":{}},"type":"script","file":{"filename":"plugin.js","size":1665,"hash":"b425b31814e792a1e9880734496e34da","url":"files/assets/18477440/1/plugin.js"},"region":"eu-west-1","id":"18477440"},"18477892":{"tags":[],"name":"spine.js","revision":1,"preload":true,"meta":null,"data":{"order":100,"scripts":{},"loading":false},"type":"script","file":{"filename":"spine.js","size":20336,"hash":"97a1e0bc5c0ba4137af3523bfadc8d28","url":"files/assets/18477892/1/spine.js"},"region":"eu-west-1","id":"18477892"},"18477897":{"tags":[],"name":"spine-component-system.js","revision":1,"preload":true,"meta":null,"data":{"order":100,"scripts":{},"loading":false},"type":"script","file":{"filename":"spine-component-system.js","size":2106,"hash":"015adff9a01e0b3856179dbda4ba2029","url":"files/assets/18477897/1/spine-component-system.js"},"region":"eu-west-1","id":"18477897"},"18477898":{"tags":[],"name":"spine-component.js","revision":1,"preload":true,"meta":null,"data":{"order":100,"scripts":{},"loading":false},"type":"script","file":{"filename":"spine-component.js","size":5416,"hash":"5d8ccdf195eae363acadbe93d7989807","url":"files/assets/18477898/1/spine-component.js"},"region":"eu-west-1","id":"18477898"},"18477899":{"tags":[],"name":"spine-component-data.js","revision":1,"preload":true,"meta":null,"data":{"order":100,"scripts":{},"loading":false},"type":"script","file":{"filename":"spine-component-data.js","size":549,"hash":"3b6fa87ac780f5cff4a6ee9b8c801be0","url":"files/assets/18477899/1/spine-component-data.js"},"region":"eu-west-1","id":"18477899"},"18477996":{"tags":[],"name":"Spine.js","revision":1,"preload":true,"meta":null,"data":{"scripts":{"spine":{"attributesOrder":["atlas","skeleton","textures","layer","defaultAnimation"],"attributes":{"atlas":{"type":"asset","assetType":"text"},"skeleton":{"type":"asset","assetType":"json"},"textures":{"type":"asset","array":true,"assetType":"texture"},"defaultAnimation":{"type":"string","default":"idle"},"layer":{"type":"string","default":"World"}}}},"loading":false},"type":"script","file":{"filename":"Spine.js","size":1502,"hash":"c44c74d7a48646a855c75acf5b5fe922","url":"files/assets/18477996/1/Spine.js"},"region":"eu-west-1","id":"18477996"},"18478347":{"tags":[],"name":"spine-core.js","revision":1,"preload":true,"meta":null,"data":{"order":100,"scripts":{},"loading":false},"type":"script","file":{"filename":"spine-core.js","size":237023,"hash":"25bdafb0dc5c9fb99e53d14f930cebfa","url":"files/assets/18478347/1/spine-core.js"},"region":"eu-west-1","id":"18478347"},"18515964":{"tags":[],"name":"species-matamata.atlas","revision":1,"preload":true,"meta":null,"data":null,"type":"text","file":{"filename":"species-matamata.atlas","size":1499,"hash":"10767dbd5fd05e02d327505f92f3c7b6","url":"files/assets/18515964/1/species-matamata.atlas"},"region":"eu-west-1","id":"18515964"},"18515965":{"tags":[],"name":"species-matamata.json","revision":1,"preload":true,"meta":null,"data":null,"type":"json","file":{"filename":"species-matamata.json","size":108261,"hash":"cbece96270dc5663fe9201a1d52520c0","url":"files/assets/18515965/1/species-matamata.json"},"region":"eu-west-1","id":"18515965"},"18515966":{"tags":[],"name":"species-matamata.png","revision":1,"preload":true,"meta":{"compress":{"alpha":false,"dxt":false,"pvr":false,"pvrBpp":4,"etc1":false,"etc2":false},"format":"png","type":"TrueColorAlpha","width":256,"height":128,"alpha":true,"depth":8,"srgb":true,"interlaced":false},"data":{"addressu":"repeat","addressv":"repeat","minfilter":"linear_mip_linear","magfilter":"linear","anisotropy":1,"rgbm":false,"mipmaps":true},"type":"texture","file":{"filename":"species-matamata.png","hash":"28e8528da19afb6edb6fae673c54a021","size":36091,"variants":{},"url":"files/assets/18515966/1/species-matamata.png"},"region":"eu-west-1","id":"18515966"},"18517116":{"tags":[],"name":"species-matamata-baby.atlas","revision":1,"preload":true,"meta":null,"data":null,"type":"text","file":{"filename":"species-matamata-baby.atlas","size":1466,"hash":"0748a93f2f3acb22c483a029157c3fa3","url":"files/assets/18517116/1/species-matamata-baby.atlas"},"region":"eu-west-1","id":"18517116"},"18517117":{"tags":[],"name":"species-matamata-baby.png","revision":1,"preload":true,"meta":{"compress":{"alpha":false,"dxt":false,"pvr":false,"pvrBpp":4,"etc1":false,"etc2":false},"format":"png","type":"TrueColorAlpha","width":256,"height":128,"alpha":true,"depth":8,"srgb":true,"interlaced":false},"data":{"addressu":"repeat","addressv":"repeat","minfilter":"linear_mip_linear","magfilter":"linear","anisotropy":1,"rgbm":false,"mipmaps":true},"type":"texture","file":{"filename":"species-matamata-baby.png","hash":"5d6f7fe70f122aa2bfa395da3bf42037","size":23228,"variants":{},"url":"files/assets/18517117/1/species-matamata-baby.png"},"region":"eu-west-1","id":"18517117"},"18517118":{"tags":[],"name":"species-matamata-baby.json","revision":1,"preload":true,"meta":null,"data":null,"type":"json","file":{"filename":"species-matamata-baby.json","size":17468,"hash":"5a33add4895e31d357b3d3d1c740b32a","url":"files/assets/18517118/1/species-matamata-baby.json"},"region":"eu-west-1","id":"18517118"},"18549031":{"tags":[],"name":"hideTile.png","revision":1,"preload":true,"meta":{"compress":{"alpha":false,"dxt":false,"pvr":false,"pvrBpp":4,"etc1":false,"etc2":false},"format":"png","type":"Bilevel","width":8,"height":8,"alpha":false,"depth":8,"srgb":true,"interlaced":false},"data":{"addressu":"repeat","addressv":"repeat","minfilter":"linear_mip_linear","magfilter":"linear","anisotropy":1,"rgbm":false,"mipmaps":true,"frames":{"1":{"name":"Frame 1","rect":[0,0,8,8],"pivot":[0.5,0.5],"border":[0,0,0,0]}}},"type":"textureatlas","file":{"filename":"hideTile.png","hash":"809a623c7e1b75a7dabaafff6b038db8","size":317,"variants":{},"url":"files/assets/18549031/1/hideTile.png"},"region":"eu-west-1","id":"18549031"},"18549032":{"tags":[],"name":"hideTile","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":[1],"textureAtlasAsset":18549031,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18549032"},"18555968":{"tags":[],"name":"ClaimButton.js","revision":1,"preload":true,"meta":null,"data":{"scripts":{"claimButton":{"attributesOrder":["boundingBoxHalfSize","cameraEntity"],"attributes":{"boundingBoxHalfSize":{"type":"vec3"},"cameraEntity":{"type":"entity"}}}},"loading":false},"type":"script","file":{"filename":"ClaimButton.js","size":2780,"hash":"7d755ef43234a2b8b5c08dc08cc73d4f","url":"files/assets/18555968/1/ClaimButton.js"},"region":"eu-west-1","id":"18555968"},"18563311":{"tags":[],"name":"BounceAnimation.js","revision":1,"preload":true,"meta":null,"data":{"scripts":{"bounceAnimation":{"attributesOrder":[],"attributes":{}}},"loading":false},"type":"script","file":{"filename":"BounceAnimation.js","size":930,"hash":"b4bd2a5dc226b0002d50e032a42134b8","url":"files/assets/18563311/1/BounceAnimation.js"},"region":"eu-west-1","id":"18563311"},"18581363":{"tags":[],"name":"BounceOnTapAnimation.js","revision":1,"preload":true,"meta":null,"data":{"scripts":{"bounceOntapAnimation":{"attributesOrder":["boundingBoxHalfSize","boundingBoxOffset","scaleCoefs"],"attributes":{"boundingBoxHalfSize":{"type":"vec3"},"boundingBoxOffset":{"type":"vec3"},"scaleCoefs":{"type":"vec3"}}}},"loading":false},"type":"script","file":{"filename":"BounceOnTapAnimation.js","size":284,"hash":"50e534ba8c4da330b48c684c127a012b","url":"files/assets/18581363/1/BounceOnTapAnimation.js"},"region":"eu-west-1","id":"18581363"},"18581368":{"tags":[],"name":"BounceOnTapAnimationController.js","revision":1,"preload":true,"meta":null,"data":{"scripts":{"bounceOntapAnimationController":{"attributesOrder":["anims","cameraEntity"],"attributes":{"anims":{"type":"entity","array":true},"cameraEntity":{"type":"entity"}}}},"loading":false},"type":"script","file":{"filename":"BounceOnTapAnimationController.js","size":3970,"hash":"9747296947ba0de3b3c52b8e474bd549","url":"files/assets/18581368/1/BounceOnTapAnimationController.js"},"region":"eu-west-1","id":"18581368"},"18583364":{"tags":[],"name":"logo.png","revision":1,"preload":true,"meta":{"compress":{"alpha":false,"dxt":false,"pvr":false,"pvrBpp":4,"etc1":false,"etc2":false},"format":"png","type":"PaletteAlpha","width":256,"height":256,"alpha":true,"depth":8,"srgb":true,"interlaced":false},"data":{"addressu":"repeat","addressv":"repeat","minfilter":"linear_mip_linear","magfilter":"linear","anisotropy":1,"rgbm":false,"mipmaps":true},"type":"texture","file":{"filename":"logo.png","hash":"bdceee536a63ae50f415d0b2c5b66e59","size":79682,"variants":{},"url":"files/assets/18583364/1/logo.png"},"region":"eu-west-1","id":"18583364"},"18621502":{"tags":[],"name":"point.png","revision":1,"preload":true,"meta":{"compress":{"alpha":false,"dxt":false,"pvr":false,"pvrBpp":4,"etc1":false,"etc2":false},"format":"png","type":"Bilevel","width":4,"height":4,"alpha":false,"depth":8,"srgb":true,"interlaced":false},"data":{"addressu":"repeat","addressv":"repeat","minfilter":"linear_mip_linear","magfilter":"linear","anisotropy":1,"rgbm":false,"mipmaps":true},"type":"texture","file":{"filename":"point.png","hash":"8c430c1d73707aef53dd67a4f1c4209e","size":260,"variants":{},"url":"files/assets/18621502/1/point.png"},"region":"eu-west-1","id":"18621502"},"18621503":{"tags":[],"name":"star.png","revision":1,"preload":true,"meta":{"compress":{"alpha":false,"dxt":false,"pvr":false,"pvrBpp":4,"etc1":false,"etc2":false},"format":"png","type":"Bilevel","width":32,"height":32,"alpha":true,"depth":8,"srgb":true,"interlaced":false},"data":{"addressu":"repeat","addressv":"repeat","minfilter":"linear_mip_linear","magfilter":"linear","anisotropy":1,"rgbm":false,"mipmaps":true},"type":"texture","file":{"filename":"star.png","hash":"a72a1e62c64cde99f1464f016de78e46","size":800,"variants":{},"url":"files/assets/18621503/1/star.png"},"region":"eu-west-1","id":"18621503"},"18624306":{"tags":[],"name":"RewardScreen.js","revision":1,"preload":true,"meta":null,"data":{"scripts":{"rewardScreen":{"attributesOrder":["particles","repeatParticlesDelay","particleXOffset","particleYOffset"],"attributes":{"particles":{"type":"entity","array":true},"repeatParticlesDelay":{"type":"number","default":1},"particleXOffset":{"type":"number","default":1},"particleYOffset":{"type":"number","default":1}}}},"loading":false},"type":"script","file":{"filename":"RewardScreen.js","size":1860,"hash":"f89f1b3c3f711b93babe987f7cf2f430","url":"files/assets/18624306/1/RewardScreen.js"},"region":"eu-west-1","id":"18624306"},"18672552":{"tags":[],"name":"bench1","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["0"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672552"},"18672553":{"tags":[],"name":"exp","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["1"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672553"},"18672554":{"tags":[],"name":"fence","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["2"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672554"},"18672555":{"tags":[],"name":"five","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["3"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672555"},"18672556":{"tags":[],"name":"floor0","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["4"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672556"},"18672557":{"tags":[],"name":"floor1","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["5"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672557"},"18672558":{"tags":[],"name":"floor2","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["6"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672558"},"18672559":{"tags":[],"name":"flower","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["7"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672559"},"18672560":{"tags":[],"name":"habitat","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["8"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672560"},"18672561":{"tags":[],"name":"habitat_new","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["9"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672561"},"18672562":{"tags":[],"name":"hand","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["10"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672562"},"18672563":{"tags":[],"name":"lamp1","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["11"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672563"},"18672567":{"tags":[],"name":"lock","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["12"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672567"},"18672568":{"tags":[],"name":"mainArrowIcon","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["13"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672568"},"18672569":{"tags":[],"name":"one","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["14"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672569"},"18672570":{"tags":[],"name":"panel","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["15"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672570"},"18672571":{"tags":[],"name":"plus","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["16"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672571"},"18672572":{"tags":[],"name":"rewardButton","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["17"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672572"},"18672573":{"tags":[],"name":"rewardScreen","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["18"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672573"},"18672574":{"tags":[],"name":"six","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["19"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672574"},"18672575":{"tags":[],"name":"tree","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["20"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672575"},"18672576":{"tags":[],"name":"zero","revision":1,"preload":true,"meta":null,"data":{"pixelsPerUnit":100,"frameKeys":["21"],"textureAtlasAsset":18674919,"renderMode":0},"type":"sprite","file":null,"region":"eu-west-1","id":"18672576"},"18674919":{"tags":[],"name":"ZooPack.png","revision":1,"preload":true,"meta":{"compress":{"alpha":false,"dxt":false,"pvr":false,"pvrBpp":4,"etc1":false,"etc2":false},"format":"png","type":"PaletteAlpha","width":1024,"height":2048,"alpha":true,"depth":8,"srgb":true,"interlaced":false},"data":{"addressu":"repeat","addressv":"repeat","minfilter":"linear_mip_linear","magfilter":"linear","anisotropy":1,"rgbm":false,"mipmaps":true,"frames":{"0":{"name":"bench1","border":[0,0,0,0],"rect":[2,1881,181,165],"pivot":[0.5,0.5]},"1":{"name":"exp","border":[0,0,0,0],"rect":[744,588,87,31],"pivot":[0.5,0.5]},"2":{"name":"fence","border":[0,0,0,0],"rect":[440,1734,161,140],"pivot":[0.2588635772358296,0.08322764744837197]},"3":{"name":"five","border":[0,0,0,0],"rect":[273,1951,29,31],"pivot":[0.5,0.5]},"4":{"name":"floor0","border":[0,0,0,0],"rect":[273,1881,116,68],"pivot":[0.5,0.5]},"5":{"name":"floor1","border":[0,0,0,0],"rect":[603,1734,116,68],"pivot":[0.5,0.5]},"6":{"name":"floor2","border":[0,0,0,0],"rect":[603,1804,116,68],"pivot":[0.5,0.5]},"7":{"name":"flower","border":[0,0,0,0],"rect":[664,588,78,143],"pivot":[0.5,0.5]},"8":{"name":"habitat","border":[0,0,0,0],"rect":[2,1250,711,482],"pivot":[0.5,0.5]},"9":{"name":"habitat_new","border":[0,0,0,0],"rect":[2,21,660,587],"pivot":[0.5,0.5]},"10":{"name":"hand","border":[0,0,0,0],"rect":[664,371,189,215],"pivot":[0,1]},"11":{"name":"lamp1","border":[0,0,0,0],"rect":[855,371,106,208],"pivot":[0.5,0.5]},"12":{"name":"lock","border":[0,0,0,0],"rect":[583,826,62,72],"pivot":[0.5,0.5]},"13":{"name":"mainArrowIcon","border":[0,0,0,0],"rect":[185,1881,86,117],"pivot":[0.5,0.5]},"14":{"name":"one","border":[0,0,0,0],"rect":[391,1881,29,31],"pivot":[0.5,0.5]},"15":{"name":"panel","border":[0,0,0,0],"rect":[664,21,295,348],"pivot":[0.5,0.5]},"16":{"name":"plus","border":[0,0,0,0],"rect":[961,21,29,31],"pivot":[0.5,0.5]},"17":{"name":"rewardButton","border":[0,0,0,0],"rect":[2,1734,436,145],"pivot":[0.5,0.5]},"18":{"name":"rewardScreen","border":[0,0,0,0],"rect":[2,610,579,638],"pivot":[0.5,0.5]},"19":{"name":"six","border":[0,0,0,0],"rect":[664,733,29,31],"pivot":[0.5,0.5]},"20":{"name":"tree","border":[0,0,0,0],"rect":[583,610,79,214],"pivot":[0.5,0]},"21":{"name":"zero","border":[0,0,0,0],"rect":[185,2000,29,31],"pivot":[0.5,0.5]}}},"type":"textureatlas","file":{"filename":"ZooPack.png","hash":"0e8bbe28bced1802763586bf8c610e88","size":337874,"variants":{},"url":"files/assets/18674919/1/ZooPack.png"},"region":"eu-west-1","id":"18674919"}}}');
        INPUT_SETTINGS = {
            useKeyboard: true,
            useMouse: true,
            useGamepads: false,
            useTouch: true
        };
        pc.script.legacy = false;
    </script>
</head>
<body>
<script>var base64Images ={
'files/assets/18515966/1/species-matamata.png': 'data:image/png;base64,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',
'files/assets/18517117/1/species-matamata-baby.png': 'data:image/png;base64,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',
'files/assets/18549031/1/hideTile.png': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIAQAAAADsdIMmAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QAAd2KE6QAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAHdElNRQfjAxQHJwgVjlVGAAAADElEQVQI12P4z4ACAT/QB/mI84VSAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE5LTAzLTIwVDA3OjM5OjA4KzAwOjAwiBMOlQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxOS0wMy0yMFQwNzozOTowOCswMDowMPlOtikAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjEuNv1OCegAAAAASUVORK5CYII=',
'files/assets/18583364/1/logo.png': 'data:image/png;base64,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',
'files/assets/18621502/1/point.png': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAEAQAAAACBiqPTAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QAAd2KE6QAAAAHdElNRQfjAxYJIRtn/VafAAAADElEQVQI12P4wACGAA8IA8FeW+PBAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE5LTAzLTIyVDA5OjMzOjI3KzAwOjAwVhrAGwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxOS0wMy0yMlQwOTozMzoyNyswMDowMCdHeKcAAAAASUVORK5CYII=',
'files/assets/18621503/1/star.png': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAHdElNRQfjAxYJIRtn/VafAAACKElEQVRIx52VT0hUURSHv5lemWmpKGVQQQsDyTYFkbQRzEXhTtoG/YFaCG3aB0HRqqLIolW0aGPQJnJT0UKCoMJw00xJpg1iukitcUjHr8XM6Jt64zj+3u5yznd+95z77oVVZe7rttdqqVj59EO+9Yk1FQPy6QcdVF+5rUJAPv2Ag6om3OFqgSXTX5vTlG2lAHuskpUvlN7mCwua9Xg0IOASdST5yhijTLIoeUorN+gMxe0iFmGVgCFuU8UMc8wyToIkn0lSw02OheI20FyqWfX2uaIF0844YsJFw8r6wFjkJsR2E5bXM4MoQBx4Tz9/ys51J9sjZyZiix/KOkjbb6d1/g8RY55ztiwi64zPPenufyAi1vt0DX1QnfelvbYVQUTsMrVGhC74zmsedmMYUOu9NQNyGvWhR+LLraimsewkwprmG8P8KDiIe8ZfFdR+ZE9uIoUN7PPjmlKzJrxuh9WFFgb5P+IU+8uazvCJxwzwhUxuIbZc/6gjZWtPedFmg/8OkljrfbNlAW8iTyEBcIIe4kWr5twVaYLfRCwH7OUsTQAsscACGVIMUU03W0Jxi4yRjWpMwGnaSTHHFMn8ZTJBhs1850IIkSUVVR8C5rnCMGOMkw5tMM1VYpxfRiwyWWI2xosv1NDhbvSW6XwLf9qxyrVeat1G75hRdcKW9b1MDd51Xh22cb1vY5N9ph1wa6l3YRXFEKa5TANZlio3sOKi1S43RTv4CzAv/1N28Ey9AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE5LTAzLTIyVDA5OjMzOjI3KzAwOjAwVhrAGwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxOS0wMy0yMlQwOTozMzoyNyswMDowMCdHeKcAAAAASUVORK5CYII=',
'files/assets/18674919/1/ZooPack.png': 'data:image/png;base64,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',
}
function getImageSrcByKey(key) {
 return base64Images[key];
}
var strScripts ={
'files/assets/18368975/1/tween.js': 'pc.extend(pc,function(){var t=function(t){this._app=t,this._tweens=[],this._add=[]};t.prototype={add:function(t){return this._add.push(t),t},update:function(t){for(var i=0,e=this._tweens.length;i<e;)this._tweens[i].update(t)?i++:(this._tweens.splice(i,1),e--);this._add.length&&(this._tweens=this._tweens.concat(this._add),this._add.length=0)}};var i=function(t,i,e){pc.events.attach(this),this.manager=i,e&&(this.entity=null),this.time=0,this.complete=!1,this.playing=!1,this.stopped=!0,this.pending=!1,this.target=t,this.duration=0,this._currentDelay=0,this.timeScale=1,this._reverse=!1,this._delay=0,this._yoyo=!1,this._count=0,this._numRepeats=0,this._repeatDelay=0,this._from=!1,this._slerp=!1,this._fromQuat=new pc.Quat,this._toQuat=new pc.Quat,this._quat=new pc.Quat,this.easing=pc.EASE_LINEAR,this._sv={},this._ev={}},h=function(t){var i;return t instanceof pc.Vec2?i={x:t.x,y:t.y}:t instanceof pc.Vec3?i={x:t.x,y:t.y,z:t.z}:t instanceof pc.Vec4?i={x:t.x,y:t.y,z:t.z,w:t.w}:t instanceof pc.Quat?i={x:t.x,y:t.y,z:t.z,w:t.w}:t instanceof pc.Color?(i={r:t.r,g:t.g,b:t.b},void 0!==t.a&&(i.a=t.a)):i=t,i};i.prototype={to:function(t,i,e,n,s,r){return this._properties=h(t),this.duration=i,e&&(this.easing=e),n&&this.delay(n),s&&this.repeat(s),r&&this.yoyo(r),this},from:function(t,i,e,n,s,r){return this._properties=h(t),this.duration=i,e&&(this.easing=e),n&&this.delay(n),s&&this.repeat(s),r&&this.yoyo(r),this._from=!0,this},rotate:function(t,i,e,n,s,r){return this._properties=h(t),this.duration=i,e&&(this.easing=e),n&&this.delay(n),s&&this.repeat(s),r&&this.yoyo(r),this._slerp=!0,this},start:function(){var t,i,e,n;if(this.playing=!0,this.complete=!1,this.stopped=!1,this._count=0,this.pending=0<this._delay,this._reverse&&!this.pending?this.time=this.duration:this.time=0,this._from){for(t in this._properties)this._properties.hasOwnProperty(t)&&(this._sv[t]=this._properties[t],this._ev[t]=this.target[t]);this._slerp&&(this._toQuat.setFromEulerAngles(this.target.x,this.target.y,this.target.z),i=void 0!==this._properties.x?this._properties.x:this.target.x,e=void 0!==this._properties.y?this._properties.y:this.target.y,n=void 0!==this._properties.z?this._properties.z:this.target.z,this._fromQuat.setFromEulerAngles(i,e,n))}else{for(t in this._properties)this._properties.hasOwnProperty(t)&&(this._sv[t]=this.target[t],this._ev[t]=this._properties[t]);this._slerp&&(this._fromQuat.setFromEulerAngles(this.target.x,this.target.y,this.target.z),i=void 0!==this._properties.x?this._properties.x:this.target.x,e=void 0!==this._properties.y?this._properties.y:this.target.y,n=void 0!==this._properties.z?this._properties.z:this.target.z,this._toQuat.setFromEulerAngles(i,e,n))}return this._currentDelay=this._delay,this.manager.add(this),this},pause:function(){this.playing=!1},resume:function(){this.playing=!0},stop:function(){this.playing=!1,this.stopped=!0},delay:function(t){return this._delay=t,this.pending=!0,this},repeat:function(t,i){return this._count=0,this._numRepeats=t,this._repeatDelay=i||0,this},loop:function(t){return this._numRepeats=t?1/(this._count=0):0,this},yoyo:function(t){return this._yoyo=t,this},reverse:function(){return this._reverse=!this._reverse,this},chain:function(){for(var t=arguments.length;t--;)0<t?arguments[t-1]._chained=arguments[t]:this._chained=arguments[t];return this},update:function(t){if(this.stopped)return!1;if(!this.playing)return!0;if(!this._reverse||this.pending?this.time+=t*this.timeScale:this.time-=t*this.timeScale,this.pending){if(!(this.time>this._currentDelay))return!0;this._reverse?this.time=this.duration-(this.time-this._currentDelay):this.time=this.time-this._currentDelay,this.pending=!1}var i=0;(!this._reverse&&this.time>this.duration||this._reverse&&this.time<0)&&(this._count++,this.complete=!0,this.playing=!1,this._reverse?(i=this.duration-this.time,this.time=0):(i=this.time-this.duration,this.time=this.duration));var e,n,s=this.time/this.duration,r=this.easing(s);for(var h in this._properties)this._properties.hasOwnProperty(h)&&(e=this._sv[h],n=this._ev[h],this.target[h]=e+(n-e)*r);if(this._slerp&&this._quat.slerp(this._fromQuat,this._toQuat,r),this.entity&&(this.entity._dirtifyLocal(),this.element&&this.entity.element&&(this.entity.element[this.element]=this.target),this._slerp&&this.entity.setLocalRotation(this._quat)),this.fire("update",t),this.complete){var a=this._repeat(i);return a?this.fire("loop"):(this.fire("complete",i),this._chained&&this._chained.start()),a}return!0},_repeat:function(t){if(this._count<this._numRepeats){if(this._reverse?this.time=this.duration-t:this.time=t,this.complete=!1,this.playing=!0,this._currentDelay=this._repeatDelay,this.pending=!0,this._yoyo){for(var i in this._properties)tmp=this._sv[i],this._sv[i]=this._ev[i],this._ev[i]=tmp;this._slerp&&(this._quat.copy(this._fromQuat),this._fromQuat.copy(this._toQuat),this._toQuat.copy(this._quat))}return!0}return!1}};var e=function(t){return 1-n(1-t)},n=function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375};return{TweenManager:t,Tween:i,Linear:function(t){return t},QuadraticIn:function(t){return t*t},QuadraticOut:function(t){return t*(2-t)},QuadraticInOut:function(t){return(t*=2)<1?.5*t*t:-.5*(--t*(t-2)-1)},CubicIn:function(t){return t*t*t},CubicOut:function(t){return--t*t*t+1},CubicInOut:function(t){return(t*=2)<1?.5*t*t*t:.5*((t-=2)*t*t+2)},QuarticIn:function(t){return t*t*t*t},QuarticOut:function(t){return 1- --t*t*t*t},QuarticInOut:function(t){return(t*=2)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)},QuinticIn:function(t){return t*t*t*t*t},QuinticOut:function(t){return--t*t*t*t*t+1},QuinticInOut:function(t){return(t*=2)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)},SineIn:function(t){return 0===t?0:1===t?1:1-Math.cos(t*Math.PI/2)},SineOut:function(t){return 0===t?0:1===t?1:Math.sin(t*Math.PI/2)},SineInOut:function(t){return 0===t?0:1===t?1:.5*(1-Math.cos(Math.PI*t))},ExponentialIn:function(t){return 0===t?0:Math.pow(1024,t-1)},ExponentialOut:function(t){return 1===t?1:1-Math.pow(2,-10*t)},ExponentialInOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?.5*Math.pow(1024,t-1):.5*(2-Math.pow(2,-10*(t-1)))},CircularIn:function(t){return 1-Math.sqrt(1-t*t)},CircularOut:function(t){return Math.sqrt(1- --t*t)},CircularInOut:function(t){return(t*=2)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},BackIn:function(t){return t*t*(2.70158*t-1.70158)},BackOut:function(t){return--t*t*(2.70158*t+1.70158)+1},BackInOut:function(t){var i=2.5949095;return(t*=2)<1?t*t*((i+1)*t-i)*.5:.5*((t-=2)*t*((i+1)*t+i)+2)},BounceIn:e,BounceOut:n,BounceInOut:function(t){return t<.5?.5*e(2*t):.5*n(2*t-1)+.5},ElasticIn:function(t){var i,e=.1;return 0===t?0:1===t?1:(i=!e||e<1?(e=1,.1):.4*Math.asin(1/e)/(2*Math.PI),-e*Math.pow(2,10*(t-=1))*Math.sin((t-i)*(2*Math.PI)/.4))},ElasticOut:function(t){var i,e=.1;return 0===t?0:1===t?1:(i=!e||e<1?(e=1,.1):.4*Math.asin(1/e)/(2*Math.PI),e*Math.pow(2,-10*t)*Math.sin((t-i)*(2*Math.PI)/.4)+1)},ElasticInOut:function(t){var i,e=.1;return 0===t?0:1===t?1:(i=!e||e<1?(e=1,.1):.4*Math.asin(1/e)/(2*Math.PI),(t*=2)<1?e*Math.pow(2,10*(t-=1))*Math.sin((t-i)*(2*Math.PI)/.4)*-.5:e*Math.pow(2,-10*(t-=1))*Math.sin((t-i)*(2*Math.PI)/.4)*.5+1)}}}()),function(){pc.Application.prototype.addTweenManager=function(){this._tweenManager=new pc.TweenManager(this),this.on("update",function(t){this._tweenManager.update(t)})},pc.Application.prototype.tween=function(t){return new pc.Tween(t,this._tweenManager)},pc.Entity.prototype.tween=function(t,i){var e=this._app.tween(t);return(e.entity=this).on("destroy",function(){e.stop()}),i&&i.element&&(e.element=i.element),e};var t=pc.Application.getApplication();t&&t.addTweenManager()}();',
'files/assets/18403671/1/SpritesCloner.js': 'var SpritesCloner=pc.createScript("spritesCloner");SpritesCloner.attributes.add("sprite",{type:"asset",assetType:"sprite"}),SpritesCloner.attributes.add("container",{type:"entity"}),SpritesCloner.attributes.add("tileOffset",{type:"vec3"}),SpritesCloner.attributes.add("ranges",{type:"vec4",array:!0}),SpritesCloner.prototype.initialize=function(){for(var t=0;t<this.ranges.length;t++){var e=this.ranges[t];this.buildRange(e)}},SpritesCloner.prototype.buildRange=function(t){for(var e=this.sprite.id,r=this.tileOffset,i=0,s=0,a=t.x;a<t.z;a++){i=a*r.x,s=a*r.y;for(var n=t.y;n<t.w;n++){var p=new pc.Entity;p.setLocalPosition(-n*r.x+i,n*r.y+s,r.z),p.addComponent("sprite"),p.sprite.spriteAsset=e,this.container.addChild(p)}}};',
'files/assets/18409277/1/InventoryItem.js': 'var InventoryItem=pc.createScript("inventoryItem");InventoryItem.attributes.add("draggable",{type:"boolean"}),InventoryItem.attributes.add("dragScaleCoef",{type:"number",default:1.5}),InventoryItem.attributes.add("finalScaleCoef",{type:"number",default:1.5}),InventoryItem.attributes.add("replaceItem",{type:"entity"}),InventoryItem.attributes.add("icon",{type:"entity"}),InventoryItem.attributes.add("lock",{type:"entity"}),InventoryItem.attributes.add("boundingBoxHalfSize",{type:"vec3"}),InventoryItem.attributes.add("hand",{type:"entity"}),InventoryItem.attributes.add("handMoveDuration",{type:"number",default:2.5}),InventoryItem.attributes.add("pois",{type:"entity",array:!0}),InventoryItem.attributes.add("itemsToUnlock",{type:"entity",array:!0}),InventoryItem.prototype.highlightPois=function(){for(var t=0;t<this.pois.length;t++)this.pois[t].script.poi.showHighlight()},InventoryItem.prototype.hidePois=function(){for(var t=0;t<this.pois.length;t++)this.pois[t].script.poi.hideHighlight()},InventoryItem.prototype.debugShowPoisBounds=function(){for(var t=0;t<this.pois.length;t++)addDebugBoundingBox(this.pois[t].boundingBox)},InventoryItem.prototype.trySetup=function(){this.hidePois();for(var t=this.icon.getPosition(),e=0;e<this.pois.length;e++)if(this.isOnBoundingBox(t,this.pois[e]))return this.setup(this.pois[e]),!0;return!1},InventoryItem.prototype.isOnBoundingBox=function(t,e){return e.boundingBox.containsPoint(t)},InventoryItem.prototype.setup=function(t){this.icon.sprite.layers=[0],this.draggable=!1,this.playSetupAnimation(),this.unlockItems(),this.icon.reparent(t,0),this.icon.setPosition(t.getPosition()),this.icon.sprite.flipX=t.script.poi.flipX,t.script.poi.showSetupParticles()},InventoryItem.prototype.setupToRandomPoi=function(){this.stopTutorialAnimation();for(var t=0;t<this.pois.length;t++){this.setup(this.pois[t]);break}},InventoryItem.prototype.playSetupAnimation=function(){SetupAnimation.playScaleUpAnim(this.icon,this.finalScaleCoef,this.replaceItem)},InventoryItem.prototype.unlockItems=function(t){for(var e=0;e<this.itemsToUnlock.length;e++)this.itemsToUnlock[e].script.inventoryItem.onUnlockItem()},InventoryItem.prototype.onUnlockItem=function(t){this.draggable=!0,this.lock.enabled=!1},InventoryItem.prototype.startTutorialAnimation=function(t,e,n,i){this.hand.script.tutorialHand.startAnimation(t,e,n,i)},InventoryItem.prototype.stopTutorialAnimation=function(){this.hand.script.tutorialHand.stopAnimation()};',
'files/assets/18409323/1/SetupAnimation.js': 'var SetupAnimation={playScaleUpAnim:function(t,c,e){var a=new pc.Vec3;t.setLocalScale(a),t.tween(t.getLocalScale()).to(new pc.Vec3(c,c,1),1.5,pc.ElasticOut).start(),SetupAnimation.fadeOutSprite(e)},fadeOutSprite:function(t){if(t){var c={colorOpacity:1};t.tween(c).to({colorOpacity:0},1,pc.SineOut).on("update",function(){t.sprite.opacity=c.colorOpacity}).start()}}};',
'files/assets/18410482/1/InventoryPanel.js': 'var InventoryPanel=pc.createScript("inventoryPanel");InventoryPanel.attributes.add("cameraEntity",{type:"entity"}),InventoryPanel.attributes.add("itemsContainer",{type:"entity"}),InventoryPanel.attributes.add("rewardScreen",{type:"entity"}),InventoryPanel.attributes.add("bgHider",{type:"entity"}),InventoryPanel.attributes.add("autoSetupDelay",{type:"number",default:10}),InventoryPanel.attributes.add("items",{type:"entity",array:!0}),InventoryPanel.attributes.add("animals",{type:"entity",array:!0}),InventoryPanel.prototype.postInitialize=function(){console.log("postInitialize"),window.mraid?(console.log("window.mraid exist"),"loading"===window.mraid.getState()?window.mraid.addEventListener("ready",this.onSdkReady.bind(this)):this.onSdkReady()):(console.log("window.mraid !exist"),this.showMyAd())},InventoryPanel.prototype.viewableChangeHandler=function(t){t&&showMyAd()},InventoryPanel.prototype.onSdkReady=function(){window.mraid.addEventListener("viewableChange",this.viewableChangeHandler.bind(this)),window.mraid.isViewable()&&this.showMyAd()},InventoryPanel.prototype.showMyAd=function(){this.setItemsCounter=0;var t=this.items.length;this.boundingBoxes=[];for(var n=0;n<t;n++){var o=this.items[n],e=o.script.inventoryItem,i=e.icon;i.startPos=i.getPosition().clone(),i.startScale=i.getLocalScale().clone();var a=e.dragScaleCoef;i.dragScale=new pc.Vec3(i.startScale.x*a,i.startScale.y*a,1),this.boundingBoxes[n]={box:new pc.BoundingBox(o.getPosition(),e.boundingBoxHalfSize),item:o,icon:e.icon,itemScript:e},addDebugBoundingBox(this.boundingBoxes[n].box),e.hidePois(),e.debugShowPoisBounds(),e.draggable&&e.onUnlockItem()}this.subscribeToInputEvents(),this.dragInputEnabled=!0,this.showTutorialAnimations(),this.setupRandomItemWithDelay()},InventoryPanel.prototype.subscribeToInputEvents=function(){var t=this.app.touch;if(t)return t.on(pc.EVENT_TOUCHMOVE,this.onTouchMove,this),t.on(pc.EVENT_TOUCHSTART,this.onTouchDown,this),t.on(pc.EVENT_TOUCHEND,this.onTouchUp,this),void t.on(pc.EVENT_TOUCHCANCEL,this.onTouchUp,this);var n=this.app.mouse;n&&(n.on(pc.EVENT_MOUSEMOVE,this.onMouseMove,this),n.on(pc.EVENT_MOUSEDOWN,this.onMouseDown,this),n.on(pc.EVENT_MOUSEUP,this.onMouseUp,this))},InventoryPanel.prototype.onTouchMove=function(t){0<t.touches.length&&this.onDragging(t.touches[0].x,t.touches[0].y)},InventoryPanel.prototype.onTouchDown=function(t){0<t.touches.length&&this.onStartDrag(t.touches[0].x,t.touches[0].y)},InventoryPanel.prototype.onTouchUp=function(t){this.onFinishDrag()},InventoryPanel.prototype.onMouseMove=function(t){this.onDragging(t.x,t.y)},InventoryPanel.prototype.onMouseDown=function(t){this.onStartDrag(t.x,t.y)},InventoryPanel.prototype.onMouseUp=function(t){this.onFinishDrag()},InventoryPanel.prototype.onDragging=function(t,n){this.dragInputEnabled&&this.onDrag&&this.syncWithMousePos(this.dragItemBox,t,n)},InventoryPanel.prototype.onStartDrag=function(t,n){if(this.dragInputEnabled&&!this.onDrag){var o=new pc.Vec3;this.cameraEntity.camera.screenToWorld(t,n,20,o);for(var e=0;e<this.boundingBoxes.length;e++){var i=this.boundingBoxes[e];if(i.itemScript.draggable)if(i.box.intersectsRay(new pc.Ray(o,this.entity.forward))){this.startDrag(i,t,n);break}}}},InventoryPanel.prototype.onFinishDrag=function(){if(this.dragInputEnabled&&this.onDrag)if(this.dragItemBox.itemScript.trySetup())this.afterItemSetup();else{var t=this.dragItemBox.icon.startPos,n=this.dragItemBox.icon.getPosition();n.x=t.x,n.y=t.y,n.z=t.z,this.dragItemBox.icon.setPosition(n),this.dragItemBox.icon.setLocalScale(this.dragItemBox.icon.startScale),this.onDrag=!1,this.showTutorialAnimations(),this.setupRandomItemWithDelay()}},InventoryPanel.prototype.afterItemSetup=function(){this.setItemsCounter++,3==this.setItemsCounter?(this.dragInputEnabled=!1,this.showRewardScreen(),this.unlockAllItems(),this.app.fire("game:finish")):(this.setupRandomItemWithDelay(),this.onDrag=!1,this.showTutorialAnimations())},InventoryPanel.prototype.startDrag=function(t,n,o){this.onDrag=!0,this.stopAutoSetupItem(),this.dragItemBox=t,this.dragItemBox.icon.setLocalScale(this.dragItemBox.icon.dragScale),this.syncWithMousePos(t,n,o),this.dragItemBox.item.script.inventoryItem.highlightPois(),this.stopTutorialAnimations()},InventoryPanel.prototype.syncWithMousePos=function(t,n,o){var e=new pc.Vec3;this.cameraEntity.camera.screenToWorld(n,o,0,e),e.z=8,t.icon.setPosition(e)},InventoryPanel.prototype.showRewardScreen=function(){this.rewardScreen.enabled=!0;this.rewardScreen.tween({}).to({},1.1,pc.Linear).on("complete",function(){for(var t=0;t<this.animals.length;t++)this.animals[t].enabled=!1;this.bgHider.enabled=!0}.bind(this)).start()},InventoryPanel.prototype.unlockAllItems=function(){for(var t=0;t<this.boundingBoxes.length;t++)this.boundingBoxes[t].itemScript.onUnlockItem()},InventoryPanel.prototype.showTutorialAnimations=function(){if(this.dragInputEnabled){for(var t,n=function(){},o=function(){this.showTutorialAnimations()},e=[],i=0;i<this.boundingBoxes.length;i++)(t=this.boundingBoxes[i].itemScript).draggable&&e.push(t);var a=e.length;for(i=0;i<a;i++){var s=(t=e[i]).handMoveDuration,r=i===a-1?o:n,h=i*(.5+s);t.startTutorialAnimation(h,.5,s,r.bind(this))}}},InventoryPanel.prototype.stopTutorialAnimations=function(){for(var t=0;t<this.boundingBoxes.length;t++){var n=this.boundingBoxes[t].itemScript;n.draggable&&n.stopTutorialAnimation()}},InventoryPanel.prototype.showTutorialHand=function(t,n,o){this.hand.script.tutorialHand.startAnimation(t.tutorialStartPoint,t.tutorialFinishPoint,n,2.5,o)},InventoryPanel.prototype.setupRandomItemWithDelay=function(){var t;this.stopAutoSetupItem();for(var n=0;n<this.boundingBoxes.length;n++){var o=this.boundingBoxes[n].itemScript;o.draggable&&(t=o)}t&&(this.setupItemAction=this.app.tween({}).to({},this.autoSetupDelay,pc.Linear).on("complete",function(){t.setupToRandomPoi(),this.afterItemSetup()}.bind(this)).start())},InventoryPanel.prototype.stopAutoSetupItem=function(t,n){this.setupItemAction&&(this.setupItemAction.stop(),this.setupItemAction=void 0)};',
'files/assets/18413283/1/POI.js': 'var Poi=pc.createScript("poi");Poi.attributes.add("boundingBoxHalfSize",{type:"vec3"}),Poi.attributes.add("flipX",{type:"boolean",default:!1}),Poi.attributes.add("views",{type:"entity",array:!0}),Poi.attributes.add("setupParticles",{type:"entity",array:!0}),Poi.prototype.initialize=function(){this.entity.boundingBox=new pc.BoundingBox(this.entity.getPosition(),this.boundingBoxHalfSize)},Poi.prototype.showHighlight=function(){this.setPoisVisible(!0)},Poi.prototype.hideHighlight=function(){this.setPoisVisible(!1)},Poi.prototype.setPoisVisible=function(t){for(var i=0;i<this.views.length;i++)this.views[i].enabled=t},Poi.prototype.showSetupParticles=function(){for(var t=0;t<this.setupParticles.length;t++)this.setupParticles[t].particlesystem.play()};',
'files/assets/18414751/1/TutorialHand.js': 'var TutorialHand=pc.createScript("tutorialHand");TutorialHand.attributes.add("fromEntity",{type:"entity"}),TutorialHand.attributes.add("toEntity",{type:"entity"}),TutorialHand.prototype.startAnimation=function(t,i,n,e){this.stopAnimation(),this.enableTween=this.app.tween({}).to({},t,pc.Linear).on("complete",function(){this.entity.enabled=!0}.bind(this)).start();var o=this.fromEntity.getPosition().clone(),a=this.toEntity.getPosition().clone();a.z=o.z,this.entity.setLocalPosition(o),this.moveTween=this.entity.tween(this.entity.getLocalPosition()).to(a,n,pc.SineOut).delay(t+i).on("complete",function(){this.stopAnimation(),e()}.bind(this)).start()},TutorialHand.prototype.stopAnimation=function(){this.moveTween&&this.moveTween.stop(),this.enableTween&&this.enableTween.stop(),this.entity.enabled=!1};',
'files/assets/18466427/1/DebugUtils.js': 'var DebugUtils={w0:new pc.Vec3,w1:new pc.Vec3,w2:new pc.Vec3,w3:new pc.Vec3,color:new pc.Color(1,0,0),drawLineMode:pc.LINEBATCH_OVERLAY,render2DBoundingBox:function(e,c){var i=c.getMin(),o=c.getMax(),w=this.w3.copy(c.halfExtents).scale(2);e.renderLine(this.w0.copy(i),this.w2.copy(i).add(this.w1.copy(w).mul(new pc.Vec3(0,0,1))),this.color,this.drawLineMode),e.renderLine(this.w0.copy(i),this.w2.copy(i).add(this.w1.copy(w).mul(new pc.Vec3(0,1,0))),this.color,this.drawLineMode),e.renderLine(this.w0.copy(i),this.w2.copy(i).add(this.w1.copy(w).mul(new pc.Vec3(1,0,0))),this.color,this.drawLineMode),e.renderLine(this.w0.copy(o),this.w2.copy(o).add(this.w1.copy(w).mul(new pc.Vec3(0,0,-1))),this.color,this.drawLineMode),e.renderLine(this.w0.copy(o),this.w2.copy(o).add(this.w1.copy(w).mul(new pc.Vec3(0,-1,0))),this.color,this.drawLineMode),e.renderLine(this.w0.copy(o),this.w2.copy(o).add(this.w1.copy(w).mul(new pc.Vec3(-1,0,0))),this.color,this.drawLineMode);var t=this.w2.copy(i).add(this.w1.copy(w).mul(new pc.Vec3(0,0,1)));e.renderLine(this.w0.copy(t),this.w2.copy(t).add(this.w1.copy(w).mul(new pc.Vec3(1,0,0))),this.color,this.drawLineMode),e.renderLine(this.w0.copy(t),this.w2.copy(t).add(this.w1.copy(w).mul(new pc.Vec3(0,1,0))),this.color,this.drawLineMode),t=this.w2.copy(i).add(this.w1.copy(w).mul(new pc.Vec3(1,0,1))),e.renderLine(this.w0.copy(t),this.w2.copy(t).add(this.w1.copy(w).mul(new pc.Vec3(0,0,-1))),this.color,this.drawLineMode),t=this.w2.copy(i).add(this.w1.copy(w).mul(new pc.Vec3(0,0,1))),e.renderLine(this.w0.copy(t),this.w2.copy(t).add(this.w1.copy(w).mul(new pc.Vec3(0,1,0))),this.color,this.drawLineMode),t=this.w2.copy(i).add(this.w1.copy(w).mul(new pc.Vec3(0,1,1))),e.renderLine(this.w0.copy(t),this.w2.copy(t).add(this.w1.copy(w).mul(new pc.Vec3(0,0,-1))),this.color,this.drawLineMode),t=this.w2.copy(i).add(this.w1.copy(w).mul(new pc.Vec3(0,1,0))),e.renderLine(this.w0.copy(t),this.w2.copy(t).add(this.w1.copy(w).mul(new pc.Vec3(1,0,0))),this.color,this.drawLineMode)}};',
'files/assets/18466567/1/GameController.js': 'var GameController=pc.createScript("gameController");GameController.attributes.add("debug",{type:"boolean"});var DEBUG={enabled:!1,boundingBoxes:[]};function addDebugBoundingBox(e){DEBUG.enabled&&DEBUG.boundingBoxes.push(e)}GameController.prototype.initialize=function(){DEBUG.enabled=this.debug},GameController.prototype.update=function(e){if(DEBUG.enabled)for(var o=0;o<DEBUG.boundingBoxes.length;o++)DebugUtils.render2DBoundingBox(this.app,DEBUG.boundingBoxes[o])};',
'files/assets/18477440/1/plugin.js': '!function(){if(pc.Mesh.prototype.startUpdate=function(){this._iterator=new pc.VertexIterator(this.vertexBuffer),this._counter=0},pc.Mesh.prototype.finishUpdate=function(){this._iterator.end(),this._iterator=null},pc.Mesh.prototype.updateVertices=function(t,e,i,n,r){var p=t.length/3;this._counter+=p;for(var o=0;o<p;o++)this._iterator.element[pc.SEMANTIC_POSITION].set(t[3*o],t[3*o+1],t[3*o+2]),e&&this._iterator.element[pc.SEMANTIC_NORMAL].set(e[3*o],e[3*o+1],e[3*o+2]),i&&this._iterator.element[pc.SEMANTIC_TANGENT].set(i[4*o],i[4*o+1],i[4*o+2],i[4*o+3]),n&&this._iterator.element[pc.SEMANTIC_TEXCOORD0].set(n[2*o],n[2*o+1]),r&&this._iterator.element[pc.SEMANTIC_COLOR].set(r[4*o],r[4*o+1],r[4*o+2],r[4*o+3]),this._iterator.next()},pc.Application.registerPlugin){pc.Application.registerPlugin("spine",function(t){new pc.SpineComponentSystem(t)})}else{var t=pc.Application.getApplication(),e=new pc.SpineComponentSystem(t);t.systems.add(e)}}();',
'files/assets/18477892/1/spine.js': 'pc.extend(pc,function(){var f=0,v=1,y=2,s={9728:pc.FILTER_NEAREST,9729:pc.FILTER_LINEAR,9987:pc.FILTER_LINEAR_MIPMAP_LINEAR,9984:pc.FILTER_NEAREST_MIPMAP_NEAREST,9985:pc.FILTER_LINEAR_MIPMAP_NEAREST,9986:pc.FILTER_NEAREST_MIPMAP_LINEAR},r={33648:pc.ADDRESS_MIRRORED_REPEAT,33071:pc.ADDRESS_CLAMP_TO_EDGE,10487:pc.ADDRESS_REPEAT},a=function(t){this._image={width:t.width,height:t.height},this.pcTexture=t};a.prototype={setFilters:function(t,e){this.pcTexture.minFilter=s[t],this.pcTexture.magFilter=s[e]},setWraps:function(t,e){this.pcTexture.addressU=r[t],this.pcTexture.addressV=r[e]},getImage:function(){return this._image}};var t=function(t,e,s,r){this._app=t,this._position=new pc.Vec3;var i=new spine.TextureAtlas(e,function(t){return new a(r[t])}),o=new spine.SkeletonJson(new spine.AtlasAttachmentLoader(i));o.scale*=.01;var n=o.readSkeletonData(s);this.skeleton=new spine.Skeleton(n),this.skeleton.updateWorldTransform(),this.stateData=new spine.AnimationStateData(this.skeleton.data),this.states=[new spine.AnimationState(this.stateData)],this._node=new pc.GraphNode,this._meshInstances=[],this._materials={},this._offset={},this._tint={},this._priority=0,this._layers=[pc.LAYERID_UI],this.init(),this.autoUpdate=!0,this._model=new pc.Model,this._model.graph=this._node,this._model.meshInstances=this._meshInstances,this._modelChanged=!0,this._reordered=!0,this._hidden=!1};t.prototype.destroy=function(){this._model&&this.removeFromLayers(),this._model=null,this._meshInstances=[],this.skeleton=null,this.stateData=null,this.state=null,this._materials={},this._node=null},t.prototype.hide=function(){if(!this._hidden){for(var t=0,e=this._meshInstances.length;t<e;t++)this._meshInstances[t].visible=!1;this._hidden=!0}},t.prototype.show=function(){if(this._hidden){for(var t=0,e=this._meshInstances.length;t<e;t++)this._meshInstances[t].visible=!0;this._hidden=!1}},t.prototype.init=function(){for(var t=this.skeleton.drawOrder,e=0,s=t.length;e<s;e++)this.initSlot(t[e]);this.rebuildMeshes()},t.prototype.initSlot=function(t){t.vertices=[],t.positions=[],t.options={},t.colorUniforms={},t.current={mesh:-1,vertices:0,offset:0},t._active={name:"",type:f},this.initAttachment(t)};var h=function(t,e){return e%2?1-t:t},c=function(t,e){return e%3==1?1:0};t.prototype.initAttachment=function(t){var e=t.attachment;if(e){var s=e.name;if(t._active.name=s,e instanceof spine.RegionAttachment)t._active.type=y,t.positions=new Array(12),t.options={normals:[0,1,0,0,1,0,0,1,0,0,1,0],uvs:e.uvs.map(h),colors:Array(16),indices:[0,3,2,2,1,0]};else if(e instanceof spine.MeshAttachment){t._active.type=v;var r=e.worldVerticesLength/2;t.positions=new Array(3*r),t.options={normals:new Array(3*r).map(c),uvs:e.uvs.map(h),colors:Array(4*r),indices:e.triangles}}var i=e.region.texture.pcTexture;if(i)if(i instanceof pc.StandardMaterial)this._materials[i.name]=i,t.material=i.name;else{var o=null;if(i.getSource()instanceof Image?o=i.getSource().getAttribute("src"):i instanceof pc.Texture&&(o=i.name),o){if(void 0===this._materials[o]){var n=new pc.StandardMaterial;n.shadingModel=pc.SPECULAR_BLINN,n.diffuse=new pc.Color(0,0,0),n.emissiveMap=i,n.emissiveMapChannel="rgb",n.emissiveVertexColor=!0,n.emissiveVertexColorChannel="rgb",n.opacityMap=i,n.opacityMapChannel="a",n.opacityVertexColor=!0,n.opacityVertexColorChannel="a",n.depthWrite=!1,n.cull=pc.CULLFACE_NONE,n.blendType=pc.BLEND_PREMULTIPLIED,n.update();var a=["gl_FragColor.rgb *= vVertexColor.a;","gl_FragColor.a = dAlpha;"].join(String.fromCharCode(10));n.chunks.outputAlphaPremulPS=a,this._materials[o]=n,this._offset[o]=0}t.material=o}}this._modelChanged=!0}},t.prototype.rebuildMeshes=function(){this.removeFromLayers(),this._meshes=[];for(var t=0,e=this._meshInstances.length;t<e;t++){var s=this._meshInstances[t].mesh;if(s){s.vertexBuffer&&(s.vertexBuffer.destroy(),s.vertexBuffer=null);for(var r=0;r<s.indexBuffer.length;r++)s.indexBuffer[r]&&s.indexBuffer[r].destroy();s.indexBuffer.length=0}this._meshInstances[t].material=null}this._meshInstances.length=0,this.createMeshes(),this.addToLayers()};var p=function(t,e){return e.attachment&&(t.curr.mat||(t.curr.mat=e.material),e.material===t.curr.mat?(t.curr.pos+=e.positions.length,t.curr.norm+=e.options.normals.length,t.curr.idx+=e.options.indices.length,t.curr.uv+=e.options.uvs.length,t.curr.col+=e.options.colors.length):(t.batches.push({mat:t.curr.mat,pos:t.curr.pos,norm:t.curr.norm,idx:t.curr.idx,uv:t.curr.uv,col:t.curr.col}),t.curr.mat=e.material,t.curr.pos=e.positions.length,t.curr.norm=e.options.normals.length,t.curr.idx=e.options.indices.length,t.curr.uv=e.options.uvs.length,t.curr.col=e.options.colors.length)),t},i=function(t,e,s,r){for(var i=0,o=t.length;i<o;i++)e[s+i]=t[i],r&&(e[s+i]+=r);return t.length},l=function(t,e){return e.attachment&&(t.curr.mat||(t.curr.mat=e.material),e.material!==t.curr.mat&&(t.meshes.push(pc.createMesh(t.gd,t.positions[t.batchIdx],t.options[t.batchIdx])),t.batchIdx++,t.curr.mat=e.material,t.curr.pos=0,t.curr.norm=0,t.curr.idx=0,t.curr.uv=0,t.curr.col=0),e.current.offset=t.curr.pos/3,e.current.vertices=e.positions.length/3,e.current.mesh=t.batchIdx,t.curr.idx+=i(e.options.indices,t.options[t.batchIdx].indices,t.curr.idx,e.current.offset),t.curr.pos+=i(e.positions,t.positions[t.batchIdx],t.curr.pos,0),t.curr.norm+=i(e.options.normals,t.options[t.batchIdx].normals,t.curr.norm,0),t.curr.uv+=i(e.options.uvs,t.options[t.batchIdx].uvs,t.curr.uv,0),t.curr.col+=i(e.options.colors,t.options[t.batchIdx].colors,t.curr.col,0)),t};return t.prototype.createMeshes=function(){var t=this.skeleton.drawOrder,e=t.reduce(p,{curr:{pos:0,norm:0,idx:0,uv:0,col:0},batches:[]});0<e.curr.pos&&e.batches.push(e.curr);var s,r=e.batches,i=[],o=[],n=r.length;if(0!==n){for(s=0;s<n;s++)i.push(Array(r[s].pos)),o.push({normals:Array(r[s].norm),uvs:new Float32Array(r[s].uv),indices:Array(r[s].idx),colors:Array(r[s].col)});var a=t.reduce(l,{meshes:this._meshes,gd:this._app.graphicsDevice,batchIdx:0,curr:{pos:0,norm:0,idx:0,uv:0,col:0},positions:i,options:o});for(this._meshes.push(pc.createMesh(a.gd,i[a.batchIdx],o[a.batchIdx])),s=0;s<n;s++){this._meshes[s].name=r[s].mat;var h=new pc.MeshInstance(this._node,this._meshes[s],this._materials[r[s].mat]);h.drawOrder=s+1e3*this.priority,h.visible=!this._hidden,this._meshInstances.push(h)}}},t.prototype.updateMeshes=function(){var t;for(t=0;t<this._meshes.length;t++)this._meshes[t].startUpdate();for(var e=this.skeleton.drawOrder,s=0,r=e.length;s<r;s++){var i=e[s];i.attachment&&0<=i.current.mesh&&this._meshes[i.current.mesh].updateVertices(i.positions,null,null,null,i.options.colors)}for(t=0;t<this._meshes.length;t++)this._meshes[t].finishUpdate()},t.prototype.updateSlot=function(t,e){var s=t.attachment,r=s.name,i=s instanceof spine.RegionAttachment?y:s instanceof spine.MeshAttachment?v:f;t._active.name===r&&t._active.type==i||this.initAttachment(t);var o,n,a=0,h=0;i===y?(s.computeWorldVertices(t.bone,t.vertices,0,2),n=8):i===v&&(s.computeWorldVertices(t,0,s.worldVerticesLength,t.vertices,0,2),n=s.worldVerticesLength);var c=this._tint[r],p=Math.round(255*t.color.r*(c?c.r:1)),l=Math.round(255*t.color.g*(c?c.g:1)),u=Math.round(255*t.color.b*(c?c.b:1)),d=Math.round(255*t.color.a*(c?c.a:1));for(o=0;o<n;o+=2,a+=3,h+=4)t.positions[a+0]=t.vertices[o+0],t.positions[a+1]=t.vertices[o+1],t.positions[a+2]=0,t.options.colors[h+0]=p,t.options.colors[h+1]=l,t.options.colors[h+2]=u,t.options.colors[h+3]=d;var m=t.positions.length/3,_=this._offset[e];t.current.offset===_&&t.current.vertices===m&&t.current.mesh===e||(this._reordered=!0),this._offset[e]+=m},t.prototype.update=function(t){if(!this._hidden){for(var e=0,s=this.states.length;e<s;e++)this.states[e].update(t);for(e=0,s=this.states.length;e<s;e++)this.states[e].apply(this.skeleton);for(var r in this.autoUpdate&&this.skeleton.updateWorldTransform(),this._materials)this._materials.hasOwnProperty(r)&&(this._offset[r]=0);e=this.skeleton.drawOrder,drawOrder=this.skeleton.drawOrder;var i,o=0,n=(s=drawOrder.length)?drawOrder[0].material:"";for(e=0;e<s;e++){(i=drawOrder[e]).attachment?(n!==i.material&&(o++,n=i.material),this.updateSlot(i,o)):i._active.type!=f&&(i.current={mesh:-1,vertices:0,offset:0},i._active={name:"",type:f},this._modelChanged=!0)}this._modelChanged||this._reordered?(this.rebuildMeshes(),this._modelChanged=!1,this._reordered=!1):this.updateMeshes()}},t.prototype.setPosition=function(t){this._position.copy(t)},t.prototype.setTint=function(t,e){this._tint[t]=e},t.prototype.removeFromLayers=function(){if(this._model)for(var t=0;t<this._layers.length;t++){var e=this._layers[t],s=this._app.scene.layers.getLayerById(e);s&&s.removeMeshInstances(this._model.meshInstances)}},t.prototype.addToLayers=function(){if(this._model)for(var t=0;t<this._layers.length;t++){var e=this._layers[t],s=this._app.scene.layers.getLayerById(e);s&&s.addMeshInstances(this._model.meshInstances)}},Object.defineProperty(t.prototype,"state",{get:function(){return this.states[0]}}),Object.defineProperty(t.prototype,"priority",{get:function(){return this._priority},set:function(t){this._priority=t,this._reordered=!0}}),Object.defineProperty(t.prototype,"layers",{get:function(){return this._layers},set:function(t){this._model&&this.removeFromLayers(),this._layers=t||[],this._model&&this.addToLayers()}}),{Spine:t}}());',
'files/assets/18477897/1/spine-component-system.js': 'pc.extend(pc,function(){var s=function(e){this.id="spine",this.ComponentType=pc.SpineComponent,this.DataType=pc.SpineComponentData,this.schema=["enabled","atlasAsset","textureAssets","skeletonAsset","atlasData","textures","skeletonData","speed","spine"],this.on("remove",this.onRemove,this),pc.ComponentSystem.bind("update",this.onUpdate,this)};return s=pc.inherits(s,pc.ComponentSystem),pc.extend(s.prototype,{initializeComponentData:function(e,t,n){n=["enabled","atlasAsset","textureAssets","skeletonAsset","atlasData","textures","skeletonData","spine"],s._super.initializeComponentData.call(this,e,t,n)},removeComponent:function(e){var t=e.spine.data;t.spine&&t.spine.destroy()},onUpdate:function(e){var t=this.store;for(var n in t)if(t.hasOwnProperty(n)){var s=t[n],i=s.data;i.enabled&&s.entity.enabled&&i.spine&&(i.spine.setPosition(s.entity.getPosition()),i.spine.update(i.speed*e))}},onRemove:function(e,t){}}),{SpineComponentSystem:s}}());',
'files/assets/18477898/1/spine-component.js': 'pc.extend(pc,function(){var s=function(t,s){this.on("set_atlasAsset",this.onSetAsset,this),this.on("set_textureAssets",this.onSetAssets,this),this.on("set_skeletonAsset",this.onSetAsset,this),this.on("set_atlasData",this.onSetResource,this),this.on("set_textures",this.onSetResource,this),this.on("set_skeletonData",this.onSetResource,this)};return s=pc.inherits(s,pc.Component),pc.extend(s.prototype,{_createSpine:function(){this.data.spine&&(this.data.spine.destroy(),this.data.spine=null);for(var t={},s=0,e=this.textureAssets.length;s<e;s++){var n=this.system.app.assets.get(this.textureAssets[s]),i=pc.path.getBasename(n.file.url),a=i.indexOf("?");-1!==a&&(i=i.substring(0,a)),t[i]=n.resource}this.data.spine=new pc.Spine(this.system.app,this.atlasData,this.skeletonData,t),this.state=this.data.spine.state,this.states=this.data.spine.states,this.skeleton=this.data.spine.skeleton,this.entity.addChild(this.data.spine._node)},_onAssetReady:function(t){"texture"===t.type&&this.textures.push(t.resource),"json"===t.type&&(this.skeletonData=t.resource),"text"===t.type&&(this.atlasData=t.resource)},_onAssetAdd:function(t){t.off("change",this.onAssetChanged,this),t.on("change",this.onAssetChanged,this),t.off("remove",this.onAssetRemoved,this),t.on("remove",this.onAssetRemoved,this),t.ready(this._onAssetReady,this),this.system.app.assets.load(t)},onSetResource:function(){this.data.atlasData&&this.data.textures.length&&this.data.skeletonData&&this._createSpine()},onSetAsset:function(t,s,e){var n=this.system.app.assets,i=null;if(s&&(i=n.get(s))&&(i.off("change",this.onAssetChanged),i.off("remove",this.onAssetRemoved)),e){var a=e;e instanceof pc.Asset&&(a=e.id,this.data[t]=a),(i=n.get(a))?this._onAssetAdd(i):n.on("add:"+a)}},onSetAssets:function(t,s,e){var n,i,a=this.system.app.assets,o=null;if(s.length)for(n=0,i=s.length;n<i;n++)(o=a.get(s[n]))&&(o.off("change",this.onAssetChanged),o.off("remove",this.onAssetRemoved));if(e&&e.length){var h=e.map(function(t){return t instanceof pc.Asset?t.id:t});for(n=0,i=e.length;n<i;n++)(o=a.get(h[n]))?this._onAssetAdd(o):a.on("add:"+h[n])}},onAssetChanged:function(t,s,e,n){},onAssetRemoved:function(t){},onEnable:function(){s._super.onEnable.call(this);var t=this.data.spine;t&&t.addToLayers()},onDisable:function(){s._super.onDisable.call(this);var t=this.data.spine;t&&t.removeFromLayers()},hide:function(){this.data.spine&&this.data.spine.hide()},show:function(){this.data.spine&&this.data.spine.show()}}),{SpineComponent:s}}());',
'files/assets/18477899/1/spine-component-data.js': 'pc.extend(pc,function(){var t=function(){this.enabled=!0,this.atlasAsset=null,this.textureAssets=[],this.skeletonAsset=null,this.speed=1,this.spine=null,this.atlasData=null,this.textures=[],this.skeletonData=null};return{SpineComponentData:t=pc.inherits(t,pc.ComponentData)}}());',
'files/assets/18477996/1/Spine.js': 'var Spine=pc.createScript("spine");Spine.attributes.add("atlas",{type:"asset",assetType:"text"}),Spine.attributes.add("skeleton",{type:"asset",assetType:"json"}),Spine.attributes.add("textures",{type:"asset",array:!0,assetType:"texture"}),Spine.attributes.add("defaultAnimation",{type:"string",default:"idle"}),Spine.prototype.initialize=function(){this.atlas&&this.textures&&this.skeleton&&(this.entity.addComponent("spine",{atlasAsset:this.atlas.id,textureAssets:this.textures.map(function(t){return t.id}),skeletonAsset:this.skeleton.id}),this.entity.spine.spine.layers=[3],this.defaultAnimation&&this.entity.spine.state.setAnimation(0,this.defaultAnimation,!0)),this.on("attr:priority",function(t){this.entity.spine&&(this.entity.spine.spine.priority=t)},this)};',
'files/assets/18478347/1/spine-core.js': 'var spine,__extends=this&&this.__extends||function(){var r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])};return function(t,e){function n(){this.constructor=t}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}}();!function(Y){var X,t,v,e,r,n,D=function(){function t(t,e,n){if(null==t)throw new Error("name cannot be null.");if(null==e)throw new Error("timelines cannot be null.");this.name=t,this.timelines=e,this.duration=n}return t.prototype.apply=function(t,e,n,r,i,a,o,s){if(null==t)throw new Error("skeleton cannot be null.");r&&0!=this.duration&&(n%=this.duration,0<e&&(e%=this.duration));for(var h=this.timelines,l=0,u=h.length;l<u;l++)h[l].apply(t,e,n,i,a,o,s)},t.binarySearch=function(t,e,n){void 0===n&&(n=1);var r=0,i=t.length/n-2;if(0==i)return n;for(var a=i>>>1;;){if(t[(a+1)*n]<=e?r=a+1:i=a,r==i)return(r+1)*n;a=r+i>>>1}},t.linearSearch=function(t,e,n){for(var r=0,i=t.length-n;r<=i;r+=n)if(t[r]>e)return r;return-1},t}();Y.Animation=D,(t=X=Y.MixPose||(Y.MixPose={}))[t.setup=0]="setup",t[t.current=1]="current",t[t.currentLayered=2]="currentLayered",(e=v=Y.MixDirection||(Y.MixDirection={}))[e.in=0]="in",e[e.out=1]="out",(n=r=Y.TimelineType||(Y.TimelineType={}))[n.rotate=0]="rotate",n[n.translate=1]="translate",n[n.scale=2]="scale",n[n.shear=3]="shear",n[n.attachment=4]="attachment",n[n.color=5]="color",n[n.deform=6]="deform",n[n.event=7]="event",n[n.drawOrder=8]="drawOrder",n[n.ikConstraint=9]="ikConstraint",n[n.transformConstraint=10]="transformConstraint",n[n.pathConstraintPosition=11]="pathConstraintPosition",n[n.pathConstraintSpacing=12]="pathConstraintSpacing",n[n.pathConstraintMix=13]="pathConstraintMix",n[n.twoColor=14]="twoColor";var i=function(){function y(t){if(t<=0)throw new Error("frameCount must be > 0: "+t);this.curves=Y.Utils.newFloatArray((t-1)*y.BEZIER_SIZE)}return y.prototype.getFrameCount=function(){return this.curves.length/y.BEZIER_SIZE+1},y.prototype.setLinear=function(t){this.curves[t*y.BEZIER_SIZE]=y.LINEAR},y.prototype.setStepped=function(t){this.curves[t*y.BEZIER_SIZE]=y.STEPPED},y.prototype.getCurveType=function(t){var e=t*y.BEZIER_SIZE;if(e==this.curves.length)return y.LINEAR;var n=this.curves[e];return n==y.LINEAR?y.LINEAR:n==y.STEPPED?y.STEPPED:y.BEZIER},y.prototype.setCurve=function(t,e,n,r,i){var a=.03*(2*-e+r),o=.03*(2*-n+i),s=.006*(3*(e-r)+1),h=.006*(3*(n-i)+1),l=2*a+s,u=2*o+h,c=.3*e+a+.16666667*s,p=.3*n+o+.16666667*h,f=t*y.BEZIER_SIZE,d=this.curves;d[f++]=y.BEZIER;for(var m=c,g=p,v=f+y.BEZIER_SIZE-1;f<v;f+=2)d[f]=m,d[f+1]=g,c+=l,p+=u,l+=s,u+=h,m+=c,g+=p},y.prototype.getCurvePercent=function(t,e){e=Y.MathUtils.clamp(e,0,1);var n=this.curves,r=t*y.BEZIER_SIZE,i=n[r];if(i==y.LINEAR)return e;if(i==y.STEPPED)return 0;for(var a=0,o=++r,s=r+y.BEZIER_SIZE-1;r<s;r+=2)if(e<=(a=n[r])){var h=void 0,l=void 0;return(l=r==o?h=0:(h=n[r-2],n[r-1]))+(n[r+1]-l)*(e-h)/(a-h)}var u=n[r-1];return u+(1-u)*(e-a)/(1-a)},y.LINEAR=0,y.STEPPED=1,y.BEZIER=2,y.BEZIER_SIZE=19,y}(),a=function(n){function g(t){var e=n.call(this,t)||this;return e.frames=Y.Utils.newFloatArray(t<<1),e}return __extends(g,n),g.prototype.getPropertyId=function(){return(r.rotate<<24)+this.boneIndex},g.prototype.setFrame=function(t,e,n){t<<=1,this.frames[t]=e,this.frames[t+g.ROTATION]=n},g.prototype.apply=function(t,e,n,r,i,a,o){var s=this.frames,h=t.bones[this.boneIndex];if(n<s[0])switch(a){case X.setup:return void(h.rotation=h.data.rotation);case X.current:var l=h.data.rotation-h.rotation;l-=360*(16384-(16384.499999999996-l/360|0)),h.rotation+=l*i}else if(n>=s[s.length-g.ENTRIES])if(a==X.setup)h.rotation=h.data.rotation+s[s.length+g.PREV_ROTATION]*i;else{var u=h.data.rotation+s[s.length+g.PREV_ROTATION]-h.rotation;u-=360*(16384-(16384.499999999996-u/360|0)),h.rotation+=u*i}else{var c=D.binarySearch(s,n,g.ENTRIES),p=s[c+g.PREV_ROTATION],f=s[c],d=this.getCurvePercent((c>>1)-1,1-(n-f)/(s[c+g.PREV_TIME]-f)),m=s[c+g.ROTATION]-p;m=p+(m-=360*(16384-(16384.499999999996-m/360|0)))*d,a==X.setup?(m-=360*(16384-(16384.499999999996-m/360|0)),h.rotation=h.data.rotation+m*i):(m=h.data.rotation+m-h.rotation,m-=360*(16384-(16384.499999999996-m/360|0)),h.rotation+=m*i)}},g.ENTRIES=2,g.PREV_TIME=-2,g.PREV_ROTATION=-1,g.ROTATION=1,g}(Y.CurveTimeline=i);Y.RotateTimeline=a;var o=function(n){function d(t){var e=n.call(this,t)||this;return e.frames=Y.Utils.newFloatArray(t*d.ENTRIES),e}return __extends(d,n),d.prototype.getPropertyId=function(){return(r.translate<<24)+this.boneIndex},d.prototype.setFrame=function(t,e,n,r){t*=d.ENTRIES,this.frames[t]=e,this.frames[t+d.X]=n,this.frames[t+d.Y]=r},d.prototype.apply=function(t,e,n,r,i,a,o){var s=this.frames,h=t.bones[this.boneIndex];if(n<s[0])switch(a){case X.setup:return h.x=h.data.x,void(h.y=h.data.y);case X.current:h.x+=(h.data.x-h.x)*i,h.y+=(h.data.y-h.y)*i}else{var l=0,u=0;if(n>=s[s.length-d.ENTRIES])l=s[s.length+d.PREV_X],u=s[s.length+d.PREV_Y];else{var c=D.binarySearch(s,n,d.ENTRIES);l=s[c+d.PREV_X],u=s[c+d.PREV_Y];var p=s[c],f=this.getCurvePercent(c/d.ENTRIES-1,1-(n-p)/(s[c+d.PREV_TIME]-p));l+=(s[c+d.X]-l)*f,u+=(s[c+d.Y]-u)*f}a==X.setup?(h.x=h.data.x+l*i,h.y=h.data.y+u*i):(h.x+=(h.data.x+l-h.x)*i,h.y+=(h.data.y+u-h.y)*i)}},d.ENTRIES=3,d.PREV_TIME=-3,d.PREV_X=-2,d.PREV_Y=-1,d.X=1,d.Y=2,d}(i),s=function(e){function g(t){return e.call(this,t)||this}return __extends(g,e),g.prototype.getPropertyId=function(){return(r.scale<<24)+this.boneIndex},g.prototype.apply=function(t,e,n,r,i,a,o){var s=this.frames,h=t.bones[this.boneIndex];if(n<s[0])switch(a){case X.setup:return h.scaleX=h.data.scaleX,void(h.scaleY=h.data.scaleY);case X.current:h.scaleX+=(h.data.scaleX-h.scaleX)*i,h.scaleY+=(h.data.scaleY-h.scaleY)*i}else{var l=0,u=0;if(n>=s[s.length-g.ENTRIES])l=s[s.length+g.PREV_X]*h.data.scaleX,u=s[s.length+g.PREV_Y]*h.data.scaleY;else{var c=D.binarySearch(s,n,g.ENTRIES);l=s[c+g.PREV_X],u=s[c+g.PREV_Y];var p=s[c],f=this.getCurvePercent(c/g.ENTRIES-1,1-(n-p)/(s[c+g.PREV_TIME]-p));l=(l+(s[c+g.X]-l)*f)*h.data.scaleX,u=(u+(s[c+g.Y]-u)*f)*h.data.scaleY}if(1==i)h.scaleX=l,h.scaleY=u;else{var d=0,m=0;m=a==X.setup?(d=h.data.scaleX,h.data.scaleY):(d=h.scaleX,h.scaleY),o==v.out?(l=Math.abs(l)*Y.MathUtils.signum(d),u=Math.abs(u)*Y.MathUtils.signum(m)):(d=Math.abs(d)*Y.MathUtils.signum(l),m=Math.abs(m)*Y.MathUtils.signum(u)),h.scaleX=d+(l-d)*i,h.scaleY=m+(u-m)*i}}},g}(Y.TranslateTimeline=o);Y.ScaleTimeline=s;var h=function(e){function d(t){return e.call(this,t)||this}return __extends(d,e),d.prototype.getPropertyId=function(){return(r.shear<<24)+this.boneIndex},d.prototype.apply=function(t,e,n,r,i,a,o){var s=this.frames,h=t.bones[this.boneIndex];if(n<s[0])switch(a){case X.setup:return h.shearX=h.data.shearX,void(h.shearY=h.data.shearY);case X.current:h.shearX+=(h.data.shearX-h.shearX)*i,h.shearY+=(h.data.shearY-h.shearY)*i}else{var l=0,u=0;if(n>=s[s.length-d.ENTRIES])l=s[s.length+d.PREV_X],u=s[s.length+d.PREV_Y];else{var c=D.binarySearch(s,n,d.ENTRIES);l=s[c+d.PREV_X],u=s[c+d.PREV_Y];var p=s[c],f=this.getCurvePercent(c/d.ENTRIES-1,1-(n-p)/(s[c+d.PREV_TIME]-p));l+=(s[c+d.X]-l)*f,u+=(s[c+d.Y]-u)*f}a==X.setup?(h.shearX=h.data.shearX+l*i,h.shearY=h.data.shearY+u*i):(h.shearX+=(h.data.shearX+l-h.shearX)*i,h.shearY+=(h.data.shearY+u-h.shearY)*i)}},d}(o);Y.ShearTimeline=h;var l=function(n){function x(t){var e=n.call(this,t)||this;return e.frames=Y.Utils.newFloatArray(t*x.ENTRIES),e}return __extends(x,n),x.prototype.getPropertyId=function(){return(r.color<<24)+this.slotIndex},x.prototype.setFrame=function(t,e,n,r,i,a){t*=x.ENTRIES,this.frames[t]=e,this.frames[t+x.R]=n,this.frames[t+x.G]=r,this.frames[t+x.B]=i,this.frames[t+x.A]=a},x.prototype.apply=function(t,e,n,r,i,a,o){var s=t.slots[this.slotIndex],h=this.frames;if(n<h[0])switch(a){case X.setup:return void s.color.setFromColor(s.data.color);case X.current:var l=s.color,u=s.data.color;l.add((u.r-l.r)*i,(u.g-l.g)*i,(u.b-l.b)*i,(u.a-l.a)*i)}else{var c=0,p=0,f=0,d=0;if(n>=h[h.length-x.ENTRIES]){var m=h.length;c=h[m+x.PREV_R],p=h[m+x.PREV_G],f=h[m+x.PREV_B],d=h[m+x.PREV_A]}else{var g=D.binarySearch(h,n,x.ENTRIES);c=h[g+x.PREV_R],p=h[g+x.PREV_G],f=h[g+x.PREV_B],d=h[g+x.PREV_A];var v=h[g],y=this.getCurvePercent(g/x.ENTRIES-1,1-(n-v)/(h[g+x.PREV_TIME]-v));c+=(h[g+x.R]-c)*y,p+=(h[g+x.G]-p)*y,f+=(h[g+x.B]-f)*y,d+=(h[g+x.A]-d)*y}if(1==i)s.color.set(c,p,f,d);else{l=s.color;a==X.setup&&l.setFromColor(s.data.color),l.add((c-l.r)*i,(p-l.g)*i,(f-l.b)*i,(d-l.a)*i)}}},x.ENTRIES=5,x.PREV_TIME=-5,x.PREV_R=-4,x.PREV_G=-3,x.PREV_B=-2,x.PREV_A=-1,x.R=1,x.G=2,x.B=3,x.A=4,x}(i);Y.ColorTimeline=l;var u=function(n){function A(t){var e=n.call(this,t)||this;return e.frames=Y.Utils.newFloatArray(t*A.ENTRIES),e}return __extends(A,n),A.prototype.getPropertyId=function(){return(r.twoColor<<24)+this.slotIndex},A.prototype.setFrame=function(t,e,n,r,i,a,o,s,h){t*=A.ENTRIES,this.frames[t]=e,this.frames[t+A.R]=n,this.frames[t+A.G]=r,this.frames[t+A.B]=i,this.frames[t+A.A]=a,this.frames[t+A.R2]=o,this.frames[t+A.G2]=s,this.frames[t+A.B2]=h},A.prototype.apply=function(t,e,n,r,i,a,o){var s=t.slots[this.slotIndex],h=this.frames;if(n<h[0])switch(a){case X.setup:return s.color.setFromColor(s.data.color),void s.darkColor.setFromColor(s.data.darkColor);case X.current:var l=s.color,u=s.darkColor,c=s.data.color,p=s.data.darkColor;l.add((c.r-l.r)*i,(c.g-l.g)*i,(c.b-l.b)*i,(c.a-l.a)*i),u.add((p.r-u.r)*i,(p.g-u.g)*i,(p.b-u.b)*i,0)}else{var f=0,d=0,m=0,g=0,v=0,y=0,x=0;if(n>=h[h.length-A.ENTRIES]){var w=h.length;f=h[w+A.PREV_R],d=h[w+A.PREV_G],m=h[w+A.PREV_B],g=h[w+A.PREV_A],v=h[w+A.PREV_R2],y=h[w+A.PREV_G2],x=h[w+A.PREV_B2]}else{var M=D.binarySearch(h,n,A.ENTRIES);f=h[M+A.PREV_R],d=h[M+A.PREV_G],m=h[M+A.PREV_B],g=h[M+A.PREV_A],v=h[M+A.PREV_R2],y=h[M+A.PREV_G2],x=h[M+A.PREV_B2];var E=h[M],T=this.getCurvePercent(M/A.ENTRIES-1,1-(n-E)/(h[M+A.PREV_TIME]-E));f+=(h[M+A.R]-f)*T,d+=(h[M+A.G]-d)*T,m+=(h[M+A.B]-m)*T,g+=(h[M+A.A]-g)*T,v+=(h[M+A.R2]-v)*T,y+=(h[M+A.G2]-y)*T,x+=(h[M+A.B2]-x)*T}if(1==i)s.color.set(f,d,m,g),s.darkColor.set(v,y,x,1);else{l=s.color,u=s.darkColor;a==X.setup&&(l.setFromColor(s.data.color),u.setFromColor(s.data.darkColor)),l.add((f-l.r)*i,(d-l.g)*i,(m-l.b)*i,(g-l.a)*i),u.add((v-u.r)*i,(y-u.g)*i,(x-u.b)*i,0)}}},A.ENTRIES=8,A.PREV_TIME=-8,A.PREV_R=-7,A.PREV_G=-6,A.PREV_B=-5,A.PREV_A=-4,A.PREV_R2=-3,A.PREV_G2=-2,A.PREV_B2=-1,A.R=1,A.G=2,A.B=3,A.A=4,A.R2=5,A.G2=6,A.B2=7,A}(i);Y.TwoColorTimeline=u;var c=function(){function t(t){this.frames=Y.Utils.newFloatArray(t),this.attachmentNames=new Array(t)}return t.prototype.getPropertyId=function(){return(r.attachment<<24)+this.slotIndex},t.prototype.getFrameCount=function(){return this.frames.length},t.prototype.setFrame=function(t,e,n){this.frames[t]=e,this.attachmentNames[t]=n},t.prototype.apply=function(t,e,n,r,i,a,o){var s=t.slots[this.slotIndex];if(o!=v.out||a!=X.setup){var h=this.frames;if(n<h[0]){if(a==X.setup){var l=s.data.attachmentName;s.setAttachment(null==l?null:t.getAttachment(this.slotIndex,l))}}else{var u=0;u=n>=h[h.length-1]?h.length-1:D.binarySearch(h,n,1)-1;var c=this.attachmentNames[u];t.slots[this.slotIndex].setAttachment(null==c?null:t.getAttachment(this.slotIndex,c))}}else{var p=s.data.attachmentName;s.setAttachment(null==p?null:t.getAttachment(this.slotIndex,p))}},t}();Y.AttachmentTimeline=c;var p=null,f=function(n){function t(t){var e=n.call(this,t)||this;return e.frames=Y.Utils.newFloatArray(t),e.frameVertices=new Array(t),null==p&&(p=Y.Utils.newFloatArray(64)),e}return __extends(t,n),t.prototype.getPropertyId=function(){return(r.deform<<27)+ +this.attachment.id+this.slotIndex},t.prototype.setFrame=function(t,e,n){this.frames[t]=e,this.frameVertices[t]=n},t.prototype.apply=function(t,e,n,r,i,a,o){var s=t.slots[this.slotIndex],h=s.getAttachment();if(h instanceof Y.VertexAttachment&&h.applyDeform(this.attachment)){var l=s.attachmentVertices;0==l.length&&(i=1);var u=this.frameVertices,c=u[0].length,p=this.frames;if(n<p[0]){var f=h;switch(a){case X.setup:return void(l.length=0);case X.current:if(1==i){l.length=0;break}var d=Y.Utils.setArraySize(l,c);if(null==f.bones)for(var m=f.vertices,g=0;g<c;g++)d[g]+=(m[g]-d[g])*i;else{i=1-i;for(g=0;g<c;g++)d[g]*=i}}}else{var v=Y.Utils.setArraySize(l,c);if(n>=p[p.length-1]){var y=u[p.length-1];if(1==i)Y.Utils.arrayCopy(y,0,v,0,c);else if(a==X.setup){if(null==(f=h).bones)for(var x=f.vertices,w=0;w<c;w++){var M=x[w];v[w]=M+(y[w]-M)*i}else for(var E=0;E<c;E++)v[E]=y[E]*i}else for(var T=0;T<c;T++)v[T]+=(y[T]-v[T])*i}else{var A=D.binarySearch(p,n),b=u[A-1],R=u[A],I=p[A],P=this.getCurvePercent(A-1,1-(n-I)/(p[A-1]-I));if(1==i)for(var S=0;S<c;S++){var C=b[S];v[S]=C+(R[S]-C)*P}else if(a==X.setup){if(null==(f=h).bones)for(var V=f.vertices,k=0;k<c;k++){C=b[k],M=V[k];v[k]=M+(C+(R[k]-C)*P-M)*i}else for(var N=0;N<c;N++){C=b[N];v[N]=(C+(R[N]-C)*P)*i}}else for(var _=0;_<c;_++){C=b[_];v[_]+=(C+(R[_]-C)*P-v[_])*i}}}}},t}(i);Y.DeformTimeline=f;var d=function(){function t(t){this.frames=Y.Utils.newFloatArray(t),this.events=new Array(t)}return t.prototype.getPropertyId=function(){return r.event<<24},t.prototype.getFrameCount=function(){return this.frames.length},t.prototype.setFrame=function(t,e){this.frames[t]=e.time,this.events[t]=e},t.prototype.apply=function(t,e,n,r,i,a,o){if(null!=r){var s=this.frames,h=this.frames.length;if(n<e)this.apply(t,e,Number.MAX_VALUE,r,i,a,o),e=-1;else if(e>=s[h-1])return;if(!(n<s[0])){var l=0;if(e<s[0])l=0;else for(var u=s[l=D.binarySearch(s,e)];0<l&&s[l-1]==u;)l--;for(;l<h&&n>=s[l];l++)r.push(this.events[l])}}},t}();Y.EventTimeline=d;var m=function(){function t(t){this.frames=Y.Utils.newFloatArray(t),this.drawOrders=new Array(t)}return t.prototype.getPropertyId=function(){return r.drawOrder<<24},t.prototype.getFrameCount=function(){return this.frames.length},t.prototype.setFrame=function(t,e,n){this.frames[t]=e,this.drawOrders[t]=n},t.prototype.apply=function(t,e,n,r,i,a,o){var s=t.drawOrder,h=t.slots;if(o!=v.out||a!=X.setup){var l=this.frames;if(n<l[0])a==X.setup&&Y.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);else{var u=0;u=n>=l[l.length-1]?l.length-1:D.binarySearch(l,n)-1;var c=this.drawOrders[u];if(null==c)Y.Utils.arrayCopy(h,0,s,0,h.length);else for(var p=0,f=c.length;p<f;p++)s[p]=h[c[p]]}}else Y.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length)},t}();Y.DrawOrderTimeline=m;var g=function(n){function f(t){var e=n.call(this,t)||this;return e.frames=Y.Utils.newFloatArray(t*f.ENTRIES),e}return __extends(f,n),f.prototype.getPropertyId=function(){return(r.ikConstraint<<24)+this.ikConstraintIndex},f.prototype.setFrame=function(t,e,n,r){t*=f.ENTRIES,this.frames[t]=e,this.frames[t+f.MIX]=n,this.frames[t+f.BEND_DIRECTION]=r},f.prototype.apply=function(t,e,n,r,i,a,o){var s=this.frames,h=t.ikConstraints[this.ikConstraintIndex];if(n<s[0])switch(a){case X.setup:return h.mix=h.data.mix,void(h.bendDirection=h.data.bendDirection);case X.current:h.mix+=(h.data.mix-h.mix)*i,h.bendDirection=h.data.bendDirection}else if(n>=s[s.length-f.ENTRIES])a==X.setup?(h.mix=h.data.mix+(s[s.length+f.PREV_MIX]-h.data.mix)*i,h.bendDirection=o==v.out?h.data.bendDirection:s[s.length+f.PREV_BEND_DIRECTION]):(h.mix+=(s[s.length+f.PREV_MIX]-h.mix)*i,o==v.in&&(h.bendDirection=s[s.length+f.PREV_BEND_DIRECTION]));else{var l=D.binarySearch(s,n,f.ENTRIES),u=s[l+f.PREV_MIX],c=s[l],p=this.getCurvePercent(l/f.ENTRIES-1,1-(n-c)/(s[l+f.PREV_TIME]-c));a==X.setup?(h.mix=h.data.mix+(u+(s[l+f.MIX]-u)*p-h.data.mix)*i,h.bendDirection=o==v.out?h.data.bendDirection:s[l+f.PREV_BEND_DIRECTION]):(h.mix+=(u+(s[l+f.MIX]-u)*p-h.mix)*i,o==v.in&&(h.bendDirection=s[l+f.PREV_BEND_DIRECTION]))}},f.ENTRIES=3,f.PREV_TIME=-3,f.PREV_MIX=-2,f.PREV_BEND_DIRECTION=-1,f.MIX=1,f.BEND_DIRECTION=2,f}(i);Y.IkConstraintTimeline=g;var y=function(n){function y(t){var e=n.call(this,t)||this;return e.frames=Y.Utils.newFloatArray(t*y.ENTRIES),e}return __extends(y,n),y.prototype.getPropertyId=function(){return(r.transformConstraint<<24)+this.transformConstraintIndex},y.prototype.setFrame=function(t,e,n,r,i,a){t*=y.ENTRIES,this.frames[t]=e,this.frames[t+y.ROTATE]=n,this.frames[t+y.TRANSLATE]=r,this.frames[t+y.SCALE]=i,this.frames[t+y.SHEAR]=a},y.prototype.apply=function(t,e,n,r,i,a,o){var s=this.frames,h=t.transformConstraints[this.transformConstraintIndex];if(n<s[0]){var l=h.data;switch(a){case X.setup:return h.rotateMix=l.rotateMix,h.translateMix=l.translateMix,h.scaleMix=l.scaleMix,void(h.shearMix=l.shearMix);case X.current:h.rotateMix+=(l.rotateMix-h.rotateMix)*i,h.translateMix+=(l.translateMix-h.translateMix)*i,h.scaleMix+=(l.scaleMix-h.scaleMix)*i,h.shearMix+=(l.shearMix-h.shearMix)*i}}else{var u=0,c=0,p=0,f=0;if(n>=s[s.length-y.ENTRIES]){var d=s.length;u=s[d+y.PREV_ROTATE],c=s[d+y.PREV_TRANSLATE],p=s[d+y.PREV_SCALE],f=s[d+y.PREV_SHEAR]}else{var m=D.binarySearch(s,n,y.ENTRIES);u=s[m+y.PREV_ROTATE],c=s[m+y.PREV_TRANSLATE],p=s[m+y.PREV_SCALE],f=s[m+y.PREV_SHEAR];var g=s[m],v=this.getCurvePercent(m/y.ENTRIES-1,1-(n-g)/(s[m+y.PREV_TIME]-g));u+=(s[m+y.ROTATE]-u)*v,c+=(s[m+y.TRANSLATE]-c)*v,p+=(s[m+y.SCALE]-p)*v,f+=(s[m+y.SHEAR]-f)*v}if(a==X.setup){l=h.data;h.rotateMix=l.rotateMix+(u-l.rotateMix)*i,h.translateMix=l.translateMix+(c-l.translateMix)*i,h.scaleMix=l.scaleMix+(p-l.scaleMix)*i,h.shearMix=l.shearMix+(f-l.shearMix)*i}else h.rotateMix+=(u-h.rotateMix)*i,h.translateMix+=(c-h.translateMix)*i,h.scaleMix+=(p-h.scaleMix)*i,h.shearMix+=(f-h.shearMix)*i}},y.ENTRIES=5,y.PREV_TIME=-5,y.PREV_ROTATE=-4,y.PREV_TRANSLATE=-3,y.PREV_SCALE=-2,y.PREV_SHEAR=-1,y.ROTATE=1,y.TRANSLATE=2,y.SCALE=3,y.SHEAR=4,y}(i);Y.TransformConstraintTimeline=y;var x=function(n){function f(t){var e=n.call(this,t)||this;return e.frames=Y.Utils.newFloatArray(t*f.ENTRIES),e}return __extends(f,n),f.prototype.getPropertyId=function(){return(r.pathConstraintPosition<<24)+this.pathConstraintIndex},f.prototype.setFrame=function(t,e,n){t*=f.ENTRIES,this.frames[t]=e,this.frames[t+f.VALUE]=n},f.prototype.apply=function(t,e,n,r,i,a,o){var s=this.frames,h=t.pathConstraints[this.pathConstraintIndex];if(n<s[0])switch(a){case X.setup:return void(h.position=h.data.position);case X.current:h.position+=(h.data.position-h.position)*i}else{var l=0;if(n>=s[s.length-f.ENTRIES])l=s[s.length+f.PREV_VALUE];else{var u=D.binarySearch(s,n,f.ENTRIES);l=s[u+f.PREV_VALUE];var c=s[u],p=this.getCurvePercent(u/f.ENTRIES-1,1-(n-c)/(s[u+f.PREV_TIME]-c));l+=(s[u+f.VALUE]-l)*p}a==X.setup?h.position=h.data.position+(l-h.data.position)*i:h.position+=(l-h.position)*i}},f.ENTRIES=2,f.PREV_TIME=-2,f.PREV_VALUE=-1,f.VALUE=1,f}(i),w=function(e){function f(t){return e.call(this,t)||this}return __extends(f,e),f.prototype.getPropertyId=function(){return(r.pathConstraintSpacing<<24)+this.pathConstraintIndex},f.prototype.apply=function(t,e,n,r,i,a,o){var s=this.frames,h=t.pathConstraints[this.pathConstraintIndex];if(n<s[0])switch(a){case X.setup:return void(h.spacing=h.data.spacing);case X.current:h.spacing+=(h.data.spacing-h.spacing)*i}else{var l=0;if(n>=s[s.length-f.ENTRIES])l=s[s.length+f.PREV_VALUE];else{var u=D.binarySearch(s,n,f.ENTRIES);l=s[u+f.PREV_VALUE];var c=s[u],p=this.getCurvePercent(u/f.ENTRIES-1,1-(n-c)/(s[u+f.PREV_TIME]-c));l+=(s[u+f.VALUE]-l)*p}a==X.setup?h.spacing=h.data.spacing+(l-h.data.spacing)*i:h.spacing+=(l-h.spacing)*i}},f}(Y.PathConstraintPositionTimeline=x);Y.PathConstraintSpacingTimeline=w;var M=function(n){function d(t){var e=n.call(this,t)||this;return e.frames=Y.Utils.newFloatArray(t*d.ENTRIES),e}return __extends(d,n),d.prototype.getPropertyId=function(){return(r.pathConstraintMix<<24)+this.pathConstraintIndex},d.prototype.setFrame=function(t,e,n,r){t*=d.ENTRIES,this.frames[t]=e,this.frames[t+d.ROTATE]=n,this.frames[t+d.TRANSLATE]=r},d.prototype.apply=function(t,e,n,r,i,a,o){var s=this.frames,h=t.pathConstraints[this.pathConstraintIndex];if(n<s[0])switch(a){case X.setup:return h.rotateMix=h.data.rotateMix,void(h.translateMix=h.data.translateMix);case X.current:h.rotateMix+=(h.data.rotateMix-h.rotateMix)*i,h.translateMix+=(h.data.translateMix-h.translateMix)*i}else{var l=0,u=0;if(n>=s[s.length-d.ENTRIES])l=s[s.length+d.PREV_ROTATE],u=s[s.length+d.PREV_TRANSLATE];else{var c=D.binarySearch(s,n,d.ENTRIES);l=s[c+d.PREV_ROTATE],u=s[c+d.PREV_TRANSLATE];var p=s[c],f=this.getCurvePercent(c/d.ENTRIES-1,1-(n-p)/(s[c+d.PREV_TIME]-p));l+=(s[c+d.ROTATE]-l)*f,u+=(s[c+d.TRANSLATE]-u)*f}a==X.setup?(h.rotateMix=h.data.rotateMix+(l-h.data.rotateMix)*i,h.translateMix=h.data.translateMix+(u-h.data.translateMix)*i):(h.rotateMix+=(l-h.rotateMix)*i,h.translateMix+=(u-h.translateMix)*i)}},d.ENTRIES=3,d.PREV_TIME=-3,d.PREV_ROTATE=-2,d.PREV_TRANSLATE=-1,d.ROTATE=1,d.TRANSLATE=2,d}(i);Y.PathConstraintMixTimeline=M}(spine||(spine={})),function(A){var d=function(){function T(t){this.tracks=new Array,this.events=new Array,this.listeners=new Array,this.queue=new n(this),this.propertyIDs=new A.IntSet,this.mixingTo=new Array,this.animationsChanged=!1,this.timeScale=1,this.trackEntryPool=new A.Pool(function(){return new e}),this.data=t}return T.prototype.update=function(t){t*=this.timeScale;for(var e=this.tracks,n=0,r=e.length;n<r;n++){var i=e[n];if(null!=i){i.animationLast=i.nextAnimationLast,i.trackLast=i.nextTrackLast;var a=t*i.timeScale;if(0<i.delay){if(i.delay-=a,0<i.delay)continue;a=-i.delay,i.delay=0}var o=i.next;if(null!=o){var s=i.trackLast-o.delay;if(0<=s){for(o.delay=0,o.trackTime=s+t*o.timeScale,i.trackTime+=a,this.setCurrent(n,o,!0);null!=o.mixingFrom;)o.mixTime+=a,o=o.mixingFrom;continue}}else if(i.trackLast>=i.trackEnd&&null==i.mixingFrom){e[n]=null,this.queue.end(i),this.disposeNext(i);continue}if(null!=i.mixingFrom&&this.updateMixingFrom(i,t)){var h=i.mixingFrom;for(i.mixingFrom=null;null!=h;)this.queue.end(h),h=h.mixingFrom}i.trackTime+=a}}this.queue.drain()},T.prototype.updateMixingFrom=function(t,e){var n=t.mixingFrom;if(null==n)return!0;var r=this.updateMixingFrom(n,e);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,0<t.mixTime&&(t.mixTime>=t.mixDuration||0==t.timeScale)?(0!=n.totalAlpha&&0!=t.mixDuration||(t.mixingFrom=n.mixingFrom,t.interruptAlpha=n.interruptAlpha,this.queue.end(n)),r):(n.trackTime+=e*n.timeScale,t.mixTime+=e*t.timeScale,!1)},T.prototype.apply=function(t){if(null==t)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();for(var e=this.events,n=this.tracks,r=!1,i=0,a=n.length;i<a;i++){var o=n[i];if(!(null==o||0<o.delay)){r=!0;var s=0==i?A.MixPose.current:A.MixPose.currentLayered,h=o.alpha;null!=o.mixingFrom?h*=this.applyMixingFrom(o,t,s):o.trackTime>=o.trackEnd&&null==o.next&&(h=0);var l=o.animationLast,u=o.getAnimationTime(),c=o.animation.timelines.length,p=o.animation.timelines;if(1==h)for(var f=0;f<c;f++)p[f].apply(t,l,u,e,1,A.MixPose.setup,A.MixDirection.in);else{var d=o.timelineData,m=0==o.timelinesRotation.length;m&&A.Utils.setArraySize(o.timelinesRotation,c<<1,null);var g=o.timelinesRotation;for(f=0;f<c;f++){var v=p[f],y=d[f]>=T.FIRST?A.MixPose.setup:s;v instanceof A.RotateTimeline?this.applyRotateTimeline(v,t,u,h,y,g,f<<1,m):(A.Utils.webkit602BugfixHelper(h,y),v.apply(t,l,u,e,h,y,A.MixDirection.in))}}this.queueEvents(o,u),e.length=0,o.nextAnimationLast=u,o.nextTrackLast=o.trackTime}}return this.queue.drain(),r},T.prototype.applyMixingFrom=function(t,e,n){var r=t.mixingFrom;null!=r.mixingFrom&&this.applyMixingFrom(r,e,n);var i=0;0==t.mixDuration?(i=1,n=A.MixPose.setup):1<(i=t.mixTime/t.mixDuration)&&(i=1);var a=i<r.eventThreshold?this.events:null,o=i<r.attachmentThreshold,s=i<r.drawOrderThreshold,h=r.animationLast,l=r.getAnimationTime(),u=r.animation.timelines.length,c=r.animation.timelines,p=r.timelineData,f=r.timelineDipMix,d=0==r.timelinesRotation.length;d&&A.Utils.setArraySize(r.timelinesRotation,u<<1,null);for(var m,g=r.timelinesRotation,v=r.alpha*t.interruptAlpha,y=v*(1-i),x=0,w=r.totalAlpha=0;w<u;w++){var M=c[w];switch(p[w]){case T.SUBSEQUENT:if(!o&&M instanceof A.AttachmentTimeline)continue;if(!s&&M instanceof A.DrawOrderTimeline)continue;m=n,x=y;break;case T.FIRST:m=A.MixPose.setup,x=y;break;case T.DIP:m=A.MixPose.setup,x=v;break;default:m=A.MixPose.setup,x=v;var E=f[w];x*=Math.max(0,1-E.mixTime/E.mixDuration)}r.totalAlpha+=x,M instanceof A.RotateTimeline?this.applyRotateTimeline(M,e,l,x,m,g,w<<1,d):(A.Utils.webkit602BugfixHelper(x,m),M.apply(e,h,l,a,x,m,A.MixDirection.out))}return 0<t.mixDuration&&this.queueEvents(r,l),this.events.length=0,r.nextAnimationLast=l,r.nextTrackLast=r.trackTime,i},T.prototype.applyRotateTimeline=function(t,e,n,r,i,a,o,s){if(s&&(a[o]=0),1!=r){var h=t,l=h.frames,u=e.bones[h.boneIndex];if(n<l[0])i==A.MixPose.setup&&(u.rotation=u.data.rotation);else{var c=0;if(n>=l[l.length-A.RotateTimeline.ENTRIES])c=u.data.rotation+l[l.length+A.RotateTimeline.PREV_ROTATION];else{var p=A.Animation.binarySearch(l,n,A.RotateTimeline.ENTRIES),f=l[p+A.RotateTimeline.PREV_ROTATION],d=l[p],m=h.getCurvePercent((p>>1)-1,1-(n-d)/(l[p+A.RotateTimeline.PREV_TIME]-d));c=l[p+A.RotateTimeline.ROTATION]-f,c=f+(c-=360*(16384-(16384.499999999996-c/360|0)))*m+u.data.rotation,c-=360*(16384-(16384.499999999996-c/360|0))}var g=i==A.MixPose.setup?u.data.rotation:u.rotation,v=0,y=c-g;if(0==y)v=a[o];else{y-=360*(16384-(16384.499999999996-y/360|0));var x=0,w=0;w=s?(x=0,y):(x=a[o],a[o+1]);var M=0<y,E=0<=x;A.MathUtils.signum(w)!=A.MathUtils.signum(y)&&Math.abs(w)<=90&&(180<Math.abs(x)&&(x+=360*A.MathUtils.signum(x)),E=M),v=y+x-x%360,E!=M&&(v+=360*A.MathUtils.signum(x)),a[o]=v}a[o+1]=y,g+=v*r,u.rotation=g-360*(16384-(16384.499999999996-g/360|0))}}else t.apply(e,0,n,null,1,i,A.MixDirection.in)},T.prototype.queueEvents=function(t,e){for(var n=t.animationStart,r=t.animationEnd,i=r-n,a=t.trackLast%i,o=this.events,s=0,h=o.length;s<h;s++){var l=o[s];if(l.time<a)break;l.time>r||this.queue.event(t,l)}for((t.loop?0==i||a>t.trackTime%i:r<=e&&t.animationLast<r)&&this.queue.complete(t);s<h;s++){o[s].time<n||this.queue.event(t,o[s])}},T.prototype.clearTracks=function(){var t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(var e=0,n=this.tracks.length;e<n;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()},T.prototype.clearTrack=function(t){if(!(t>=this.tracks.length)){var e=this.tracks[t];if(null!=e){this.queue.end(e),this.disposeNext(e);for(var n=e;;){var r=n.mixingFrom;if(null==r)break;this.queue.end(r),n.mixingFrom=null,n=r}this.tracks[e.trackIndex]=null,this.queue.drain()}}},T.prototype.setCurrent=function(t,e,n){var r=this.expandToIndex(t);this.tracks[t]=e,null!=r&&(n&&this.queue.interrupt(r),e.mixingFrom=r,e.mixTime=0,null!=r.mixingFrom&&0<r.mixDuration&&(e.interruptAlpha*=Math.min(1,r.mixTime/r.mixDuration)),r.timelinesRotation.length=0),this.queue.start(e)},T.prototype.setAnimation=function(t,e,n){var r=this.data.skeletonData.findAnimation(e);if(null==r)throw new Error("Animation not found: "+e);return this.setAnimationWith(t,r,n)},T.prototype.setAnimationWith=function(t,e,n){if(null==e)throw new Error("animation cannot be null.");var r=!0,i=this.expandToIndex(t);null!=i&&(-1==i.nextTrackLast?(this.tracks[t]=i.mixingFrom,this.queue.interrupt(i),this.queue.end(i),this.disposeNext(i),i=i.mixingFrom,r=!1):this.disposeNext(i));var a=this.trackEntry(t,e,n,i);return this.setCurrent(t,a,r),this.queue.drain(),a},T.prototype.addAnimation=function(t,e,n,r){var i=this.data.skeletonData.findAnimation(e);if(null==i)throw new Error("Animation not found: "+e);return this.addAnimationWith(t,i,n,r)},T.prototype.addAnimationWith=function(t,e,n,r){if(null==e)throw new Error("animation cannot be null.");var i=this.expandToIndex(t);if(null!=i)for(;null!=i.next;)i=i.next;var a=this.trackEntry(t,e,n,i);if(null==i)this.setCurrent(t,a,!0),this.queue.drain();else if(i.next=a,r<=0){var o=i.animationEnd-i.animationStart;0!=o?(i.loop?r+=o*(1+(i.trackTime/o|0)):r+=o,r-=this.data.getMix(i.animation,e)):r=0}return a.delay=r,a},T.prototype.setEmptyAnimation=function(t,e){var n=this.setAnimationWith(t,T.emptyAnimation,!1);return n.mixDuration=e,n.trackEnd=e,n},T.prototype.addEmptyAnimation=function(t,e,n){n<=0&&(n-=e);var r=this.addAnimationWith(t,T.emptyAnimation,!1,n);return r.mixDuration=e,r.trackEnd=e,r},T.prototype.setEmptyAnimations=function(t){var e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(var n=0,r=this.tracks.length;n<r;n++){var i=this.tracks[n];null!=i&&this.setEmptyAnimation(i.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()},T.prototype.expandToIndex=function(t){return t<this.tracks.length?this.tracks[t]:(A.Utils.ensureArrayCapacity(this.tracks,t-this.tracks.length+1,null),this.tracks.length=t+1,null)},T.prototype.trackEntry=function(t,e,n,r){var i=this.trackEntryPool.obtain();return i.trackIndex=t,i.animation=e,i.loop=n,i.eventThreshold=0,i.attachmentThreshold=0,i.drawOrderThreshold=0,i.animationStart=0,i.animationEnd=e.duration,i.animationLast=-1,i.nextAnimationLast=-1,i.delay=0,i.trackTime=0,i.trackLast=-1,i.nextTrackLast=-1,i.trackEnd=Number.MAX_VALUE,i.timeScale=1,i.alpha=1,i.interruptAlpha=1,i.mixTime=0,i.mixDuration=null==r?0:this.data.getMix(r.animation,e),i},T.prototype.disposeNext=function(t){for(var e=t.next;null!=e;)this.queue.dispose(e),e=e.next;t.next=null},T.prototype._animationsChanged=function(){this.animationsChanged=!1;var t=this.propertyIDs;t.clear();for(var e=this.mixingTo,n=0,r=this.tracks.length;n<r;n++){var i=this.tracks[n];null!=i&&i.setTimelineData(null,e,t)}},T.prototype.getCurrent=function(t){return t>=this.tracks.length?null:this.tracks[t]},T.prototype.addListener=function(t){if(null==t)throw new Error("listener cannot be null.");this.listeners.push(t)},T.prototype.removeListener=function(t){var e=this.listeners.indexOf(t);0<=e&&this.listeners.splice(e,1)},T.prototype.clearListeners=function(){this.listeners.length=0},T.prototype.clearListenerNotifications=function(){this.queue.clear()},T.emptyAnimation=new A.Animation("<empty>",[],0),T.SUBSEQUENT=0,T.FIRST=1,T.DIP=2,T.DIP_MIX=3,T}();A.AnimationState=d;var e=function(){function t(){this.timelineData=new Array,this.timelineDipMix=new Array,this.timelinesRotation=new Array}return t.prototype.reset=function(){this.next=null,this.mixingFrom=null,this.animation=null,this.listener=null,this.timelineData.length=0,this.timelineDipMix.length=0,this.timelinesRotation.length=0},t.prototype.setTimelineData=function(t,e,n){null!=t&&e.push(t);var r=null!=this.mixingFrom?this.mixingFrom.setTimelineData(this,e,n):this;null!=t&&e.pop();var i=e,a=e.length-1,o=this.animation.timelines,s=this.animation.timelines.length,h=A.Utils.setArraySize(this.timelineData,s);this.timelineDipMix.length=0;var l=A.Utils.setArraySize(this.timelineDipMix,s);t:for(var u=0;u<s;u++){var c=o[u].getPropertyId();if(n.add(c))if(null!=t&&t.hasTimeline(c)){for(var p=a;0<=p;p--){var f=i[p];if(!f.hasTimeline(c)&&0<f.mixDuration){h[u]=d.DIP_MIX,l[u]=f;continue t}}h[u]=d.DIP}else h[u]=d.FIRST;else h[u]=d.SUBSEQUENT}return r},t.prototype.hasTimeline=function(t){for(var e=this.animation.timelines,n=0,r=e.length;n<r;n++)if(e[n].getPropertyId()==t)return!0;return!1},t.prototype.getAnimationTime=function(){if(this.loop){var t=this.animationEnd-this.animationStart;return 0==t?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)},t.prototype.setAnimationLast=function(t){this.animationLast=t,this.nextAnimationLast=t},t.prototype.isComplete=function(){return this.trackTime>=this.animationEnd-this.animationStart},t.prototype.resetRotationDirections=function(){this.timelinesRotation.length=0},t}();A.TrackEntry=e;var s,t,n=function(){function t(t){this.objects=[],this.drainDisabled=!1,this.animState=t}return t.prototype.start=function(t){this.objects.push(s.start),this.objects.push(t),this.animState.animationsChanged=!0},t.prototype.interrupt=function(t){this.objects.push(s.interrupt),this.objects.push(t)},t.prototype.end=function(t){this.objects.push(s.end),this.objects.push(t),this.animState.animationsChanged=!0},t.prototype.dispose=function(t){this.objects.push(s.dispose),this.objects.push(t)},t.prototype.complete=function(t){this.objects.push(s.complete),this.objects.push(t)},t.prototype.event=function(t,e){this.objects.push(s.event),this.objects.push(t),this.objects.push(e)},t.prototype.drain=function(){if(!this.drainDisabled){this.drainDisabled=!0;for(var t=this.objects,e=this.animState.listeners,n=0;n<t.length;n+=2){var r=t[n],i=t[n+1];switch(r){case s.start:null!=i.listener&&i.listener.start&&i.listener.start(i);for(var a=0;a<e.length;a++)e[a].start&&e[a].start(i);break;case s.interrupt:null!=i.listener&&i.listener.interrupt&&i.listener.interrupt(i);for(a=0;a<e.length;a++)e[a].interrupt&&e[a].interrupt(i);break;case s.end:null!=i.listener&&i.listener.end&&i.listener.end(i);for(a=0;a<e.length;a++)e[a].end&&e[a].end(i);case s.dispose:null!=i.listener&&i.listener.dispose&&i.listener.dispose(i);for(a=0;a<e.length;a++)e[a].dispose&&e[a].dispose(i);this.animState.trackEntryPool.free(i);break;case s.complete:null!=i.listener&&i.listener.complete&&i.listener.complete(i);for(a=0;a<e.length;a++)e[a].complete&&e[a].complete(i);break;case s.event:var o=t[2+n++];null!=i.listener&&i.listener.event&&i.listener.event(i,o);for(a=0;a<e.length;a++)e[a].event&&e[a].event(i,o)}}this.clear(),this.drainDisabled=!1}},t.prototype.clear=function(){this.objects.length=0},t}();A.EventQueue=n,(t=s=A.EventType||(A.EventType={}))[t.start=0]="start",t[t.interrupt=1]="interrupt",t[t.end=2]="end",t[t.dispose=3]="dispose",t[t.complete=4]="complete",t[t.event=5]="event";var r=function(){function t(){}return t.prototype.start=function(t){},t.prototype.interrupt=function(t){},t.prototype.end=function(t){},t.prototype.dispose=function(t){},t.prototype.complete=function(t){},t.prototype.event=function(t,e){},t}();A.AnimationStateAdapter2=r}(spine||(spine={})),function(t){var e=function(){function t(t){if(this.animationToMixTime={},this.defaultMix=0,null==t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}return t.prototype.setMix=function(t,e,n){var r=this.skeletonData.findAnimation(t);if(null==r)throw new Error("Animation not found: "+t);var i=this.skeletonData.findAnimation(e);if(null==i)throw new Error("Animation not found: "+e);this.setMixWith(r,i,n)},t.prototype.setMixWith=function(t,e,n){if(null==t)throw new Error("from cannot be null.");if(null==e)throw new Error("to cannot be null.");var r=t.name+"."+e.name;this.animationToMixTime[r]=n},t.prototype.getMix=function(t,e){var n=t.name+"."+e.name,r=this.animationToMixTime[n];return void 0===r?this.defaultMix:r},t}();t.AnimationStateData=e}(spine||(spine={})),function(f){var t=function(){function t(t,e){void 0===e&&(e=""),this.assets={},this.errors={},this.toLoad=0,this.loaded=0,this.textureLoader=t,this.pathPrefix=e}return t.downloadText=function(t,e,n){var r=new XMLHttpRequest;r.open("GET",t,!0),r.onload=function(){200==r.status?e(r.responseText):n(r.status,r.responseText)},r.onerror=function(){n(r.status,r.responseText)},r.send()},t.downloadBinary=function(t,e,n){var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=function(){200==r.status?e(new Uint8Array(r.response)):n(r.status,r.responseText)},r.onerror=function(){n(r.status,r.responseText)},r.send()},t.prototype.loadText=function(n,e,r){var i=this;void 0===e&&(e=null),void 0===r&&(r=null),n=this.pathPrefix+n,this.toLoad++,t.downloadText(n,function(t){i.assets[n]=t,e&&e(n,t),i.toLoad--,i.loaded++},function(t,e){i.errors[n]="Couldnt load text "+n+": status "+status+", "+e,r&&r(n,"Couldnt load text "+n+": status "+status+", "+e),i.toLoad--,i.loaded++})},t.prototype.loadTexture=function(n,r,e){var i=this;void 0===r&&(r=null),void 0===e&&(e=null),n=this.pathPrefix+n,this.toLoad++;var a=new Image;a.crossOrigin="anonymous",a.onload=function(t){var e=i.textureLoader(a);i.assets[n]=e,i.toLoad--,i.loaded++,r&&r(n,a)},a.onerror=function(t){i.errors[n]="Couldnt load image "+n,i.toLoad--,i.loaded++,e&&e(n,"Couldnt load image "+n)},a.src=n},t.prototype.loadTextureData=function(n,t,r,e){var i=this;void 0===r&&(r=null),void 0===e&&(e=null),n=this.pathPrefix+n,this.toLoad++;var a=new Image;a.onload=function(t){var e=i.textureLoader(a);i.assets[n]=e,i.toLoad--,i.loaded++,r&&r(n,a)},a.onerror=function(t){i.errors[n]="Couldnt load image "+n,i.toLoad--,i.loaded++,e&&e(n,"Couldnt load image "+n)},a.src=t},t.prototype.loadTextureAtlas=function(h,l,u){var c=this;void 0===l&&(l=null),void 0===u&&(u=null);var p=0<=h.lastIndexOf("/")?h.substring(0,h.lastIndexOf("/")):"";h=this.pathPrefix+h,this.toLoad++,t.downloadText(h,function(a){var o={count:0},s=new Array;try{new f.TextureAtlas(a,function(t){s.push(p+"/"+t);var e=document.createElement("img");return e.width=16,e.height=16,new f.FakeTexture(e)})}catch(t){var e=t;return c.errors[h]="Couldnt load texture atlas "+h+": "+e.message,u&&u(h,"Couldnt load texture atlas "+h+": "+e.message),c.toLoad--,void c.loaded++}for(var t=function(t){var i=!1;c.loadTexture(t,function(t,e){if(o.count++,o.count==s.length)if(i)c.errors[h]="Couldnt load texture atlas page "+t+"} of atlas "+h,u&&u(h,"Couldnt load texture atlas page "+t+" of atlas "+h),c.toLoad--,c.loaded++;else try{var n=new f.TextureAtlas(a,function(t){return c.get(p+"/"+t)});c.assets[h]=n,l&&l(h,n),c.toLoad--,c.loaded++}catch(t){var r=t;c.errors[h]="Couldnt load texture atlas "+h+": "+r.message,u&&u(h,"Couldnt load texture atlas "+h+": "+r.message),c.toLoad--,c.loaded++}},function(t,e){i=!0,o.count++,o.count==s.length&&(c.errors[h]="Couldnt load texture atlas page "+t+"} of atlas "+h,u&&u(h,"Couldnt load texture atlas page "+t+" of atlas "+h),c.toLoad--,c.loaded++)})},n=0,r=s;n<r.length;n++){t(r[n])}},function(t,e){c.errors[h]="Couldnt load texture atlas "+h+": status "+status+", "+e,u&&u(h,"Couldnt load texture atlas "+h+": status "+status+", "+e),c.toLoad--,c.loaded++})},t.prototype.get=function(t){return t=this.pathPrefix+t,this.assets[t]},t.prototype.remove=function(t){t=this.pathPrefix+t;var e=this.assets[t];e.dispose&&e.dispose(),this.assets[t]=null},t.prototype.removeAll=function(){for(var t in this.assets){var e=this.assets[t];e.dispose&&e.dispose()}this.assets={}},t.prototype.isLoadingComplete=function(){return 0==this.toLoad},t.prototype.getToLoad=function(){return this.toLoad},t.prototype.getLoaded=function(){return this.loaded},t.prototype.dispose=function(){this.removeAll()},t.prototype.hasErrors=function(){return 0<Object.keys(this.errors).length},t.prototype.getErrors=function(){return this.errors},t}();f.AssetManager=t}(spine||(spine={})),function(a){var t=function(){function t(t){this.atlas=t}return t.prototype.newRegionAttachment=function(t,e,n){var r=this.atlas.findRegion(n);if(null==r)throw new Error("Region not found in atlas: "+n+" (region attachment: "+e+")");r.renderObject=r;var i=new a.RegionAttachment(e);return i.setRegion(r),i},t.prototype.newMeshAttachment=function(t,e,n){var r=this.atlas.findRegion(n);if(null==r)throw new Error("Region not found in atlas: "+n+" (mesh attachment: "+e+")");r.renderObject=r;var i=new a.MeshAttachment(e);return i.region=r,i},t.prototype.newBoundingBoxAttachment=function(t,e){return new a.BoundingBoxAttachment(e)},t.prototype.newPathAttachment=function(t,e){return new a.PathAttachment(e)},t.prototype.newPointAttachment=function(t,e){return new a.PointAttachment(e)},t.prototype.newClippingAttachment=function(t,e){return new a.ClippingAttachment(e)},t}();a.AtlasAttachmentLoader=t}(spine||(spine={})),function(t){var e;(e=t.BlendMode||(t.BlendMode={}))[e.Normal=0]="Normal",e[e.Additive=1]="Additive",e[e.Multiply=2]="Multiply",e[e.Screen=3]="Screen"}(spine||(spine={})),function(S){var t=function(){function t(t,e,n){if(this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.a=0,this.b=0,this.worldX=0,this.c=0,this.d=0,this.worldY=0,this.sorted=!1,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=n,this.setToSetupPose()}return t.prototype.update=function(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)},t.prototype.updateWorldTransform=function(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)},t.prototype.updateWorldTransformWith=function(t,e,n,r,i,a,o){this.ax=t,this.ay=e,this.arotation=n,this.ascaleX=r,this.ascaleY=i,this.ashearX=a,this.ashearY=o,this.appliedValid=!0;var s=this.parent;if(null==s){var h=n+90+o,l=S.MathUtils.cosDeg(n+a)*r,u=S.MathUtils.cosDeg(h)*i,c=S.MathUtils.sinDeg(n+a)*r,p=S.MathUtils.sinDeg(h)*i,f=this.skeleton;return f.flipX&&(t=-t,l=-l,u=-u),f.flipY&&(e=-e,c=-c,p=-p),this.a=l,this.b=u,this.c=c,this.d=p,this.worldX=t+f.x,void(this.worldY=e+f.y)}var d=s.a,m=s.b,g=s.c,v=s.d;switch(this.worldX=d*t+m*e+s.worldX,this.worldY=g*t+v*e+s.worldY,this.data.transformMode){case S.TransformMode.Normal:h=n+90+o,l=S.MathUtils.cosDeg(n+a)*r,u=S.MathUtils.cosDeg(h)*i,c=S.MathUtils.sinDeg(n+a)*r,p=S.MathUtils.sinDeg(h)*i;return this.a=d*l+m*c,this.b=d*u+m*p,this.c=g*l+v*c,void(this.d=g*u+v*p);case S.TransformMode.OnlyTranslation:h=n+90+o;this.a=S.MathUtils.cosDeg(n+a)*r,this.b=S.MathUtils.cosDeg(h)*i,this.c=S.MathUtils.sinDeg(n+a)*r,this.d=S.MathUtils.sinDeg(h)*i;break;case S.TransformMode.NoRotationOrReflection:var y=0,x=n+a-(y=1e-4<(M=d*d+g*g)?(m=g*(M=Math.abs(d*v-m*g)/M),v=d*M,Math.atan2(g,d)*S.MathUtils.radDeg):(g=d=0,90-Math.atan2(v,m)*S.MathUtils.radDeg)),w=n+o-y+90;l=S.MathUtils.cosDeg(x)*r,u=S.MathUtils.cosDeg(w)*i,c=S.MathUtils.sinDeg(x)*r,p=S.MathUtils.sinDeg(w)*i;this.a=d*l-m*c,this.b=d*u-m*p,this.c=g*l+v*c,this.d=g*u+v*p;break;case S.TransformMode.NoScale:case S.TransformMode.NoScaleOrReflection:var M,E=S.MathUtils.cosDeg(n),T=S.MathUtils.sinDeg(n),A=d*E+m*T,b=g*E+v*T;1e-5<(M=Math.sqrt(A*A+b*b))&&(M=1/M),A*=M,b*=M,M=Math.sqrt(A*A+b*b);var R=Math.PI/2+Math.atan2(b,A),I=Math.cos(R)*M,P=Math.sin(R)*M;l=S.MathUtils.cosDeg(a)*r,u=S.MathUtils.cosDeg(90+o)*i,c=S.MathUtils.sinDeg(a)*r,p=S.MathUtils.sinDeg(90+o)*i;return(this.data.transformMode!=S.TransformMode.NoScaleOrReflection?d*v-m*g<0:this.skeleton.flipX!=this.skeleton.flipY)&&(I=-I,P=-P),this.a=A*l+I*c,this.b=A*u+I*p,this.c=b*l+P*c,void(this.d=b*u+P*p)}this.skeleton.flipX&&(this.a=-this.a,this.b=-this.b),this.skeleton.flipY&&(this.c=-this.c,this.d=-this.d)},t.prototype.setToSetupPose=function(){var t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY},t.prototype.getWorldRotationX=function(){return Math.atan2(this.c,this.a)*S.MathUtils.radDeg},t.prototype.getWorldRotationY=function(){return Math.atan2(this.d,this.b)*S.MathUtils.radDeg},t.prototype.getWorldScaleX=function(){return Math.sqrt(this.a*this.a+this.c*this.c)},t.prototype.getWorldScaleY=function(){return Math.sqrt(this.b*this.b+this.d*this.d)},t.prototype.updateAppliedTransform=function(){this.appliedValid=!0;var t=this.parent;if(null==t)return this.ax=this.worldX,this.ay=this.worldY,this.arotation=Math.atan2(this.c,this.a)*S.MathUtils.radDeg,this.ascaleX=Math.sqrt(this.a*this.a+this.c*this.c),this.ascaleY=Math.sqrt(this.b*this.b+this.d*this.d),this.ashearX=0,void(this.ashearY=Math.atan2(this.a*this.b+this.c*this.d,this.a*this.d-this.b*this.c)*S.MathUtils.radDeg);var e=t.a,n=t.b,r=t.c,i=t.d,a=1/(e*i-n*r),o=this.worldX-t.worldX,s=this.worldY-t.worldY;this.ax=o*i*a-s*n*a,this.ay=s*e*a-o*r*a;var h=a*i,l=a*e,u=a*n,c=a*r,p=h*this.a-u*this.c,f=h*this.b-u*this.d,d=l*this.c-c*this.a,m=l*this.d-c*this.b;if(this.ashearX=0,this.ascaleX=Math.sqrt(p*p+d*d),1e-4<this.ascaleX){var g=p*m-f*d;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(p*f+d*m,g)*S.MathUtils.radDeg,this.arotation=Math.atan2(d,p)*S.MathUtils.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(f*f+m*m),this.ashearY=0,this.arotation=90-Math.atan2(m,f)*S.MathUtils.radDeg},t.prototype.worldToLocal=function(t){var e=this.a,n=this.b,r=this.c,i=this.d,a=1/(e*i-n*r),o=t.x-this.worldX,s=t.y-this.worldY;return t.x=o*i*a-s*n*a,t.y=s*e*a-o*r*a,t},t.prototype.localToWorld=function(t){var e=t.x,n=t.y;return t.x=e*this.a+n*this.b+this.worldX,t.y=e*this.c+n*this.d+this.worldY,t},t.prototype.worldToLocalRotation=function(t){var e=S.MathUtils.sinDeg(t),n=S.MathUtils.cosDeg(t);return Math.atan2(this.a*e-this.c*n,this.d*n-this.b*e)*S.MathUtils.radDeg},t.prototype.localToWorldRotation=function(t){var e=S.MathUtils.sinDeg(t),n=S.MathUtils.cosDeg(t);return Math.atan2(n*this.c+e*this.d,n*this.a+e*this.b)*S.MathUtils.radDeg},t.prototype.rotateWorld=function(t){var e=this.a,n=this.b,r=this.c,i=this.d,a=S.MathUtils.cosDeg(t),o=S.MathUtils.sinDeg(t);this.a=a*e-o*r,this.b=a*n-o*i,this.c=o*e+a*r,this.d=o*n+a*i,this.appliedValid=!1},t}();S.Bone=t}(spine||(spine={})),function(t){var r,e,n=function(t,e,n){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=r.Normal,t<0)throw new Error("index must be >= 0.");if(null==e)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=n};t.BoneData=n,(e=r=t.TransformMode||(t.TransformMode={}))[e.Normal=0]="Normal",e[e.OnlyTranslation=1]="OnlyTranslation",e[e.NoRotationOrReflection=2]="NoRotationOrReflection",e[e.NoScale=3]="NoScale",e[e.NoScaleOrReflection=4]="NoScaleOrReflection"}(spine||(spine={})),function(t){var e=function(t,e){if(null==e)throw new Error("data cannot be null.");this.time=t,this.data=e};(spine||(spine={})).Event=e}(),function(t){var e=function(t){this.name=t};(spine||(spine={})).EventData=e}(),function(nt){var t=function(){function t(t,e){if(this.mix=1,this.bendDirection=0,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.bendDirection=t.bendDirection,this.bones=new Array;for(var n=0;n<t.bones.length;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findBone(t.target.name)}return t.prototype.getOrder=function(){return this.data.order},t.prototype.apply=function(){this.update()},t.prototype.update=function(){var t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.mix)}},t.prototype.apply1=function(t,e,n,r){t.appliedValid||t.updateAppliedTransform();var i=t.parent,a=1/(i.a*i.d-i.b*i.c),o=e-i.worldX,s=n-i.worldY,h=(o*i.d-s*i.b)*a-t.ax,l=(s*i.a-o*i.c)*a-t.ay,u=Math.atan2(l,h)*nt.MathUtils.radDeg-t.ashearX-t.arotation;t.ascaleX<0&&(u+=180),180<u?u-=360:u<-180&&(u+=360),t.updateWorldTransformWith(t.ax,t.ay,t.arotation+u*r,t.ascaleX,t.ascaleY,t.ashearX,t.ashearY)},t.prototype.apply2=function(t,e,n,r,i,a){if(0!=a){t.appliedValid||t.updateAppliedTransform(),e.appliedValid||e.updateAppliedTransform();var o=t.ax,s=t.ay,h=t.ascaleX,l=t.ascaleY,u=e.ascaleX,c=0,p=0,f=0;f=h<0?(h=-h,c=180,-1):(c=0,1),l<0&&(l=-l,f=-f),p=u<0?(u=-u,180):0;var d=e.ax,m=0,g=0,v=0,y=t.a,x=t.b,w=t.c,M=t.d,E=Math.abs(h-l)<=1e-4;v=E?(g=y*d+x*(m=e.ay)+t.worldX,w*d+M*m+t.worldY):(m=0,g=y*d+t.worldX,w*d+t.worldY);var T=t.parent;y=T.a,x=T.b,w=T.c;var A=1/(y*(M=T.d)-x*w),b=n-T.worldX,R=r-T.worldY,I=(b*M-R*x)*A-o,P=(R*y-b*w)*A-s,S=((b=g-T.worldX)*M-(R=v-T.worldY)*x)*A-o,C=(R*y-b*w)*A-s,V=Math.sqrt(S*S+C*C),k=e.data.length*u,N=0,_=0;t:if(E){var Y=(I*I+P*P-V*V-(k*=h)*k)/(2*V*k);Y<-1?Y=-1:1<Y&&(Y=1),_=Math.acos(Y)*i,y=V+k*Y,x=k*Math.sin(_),N=Math.atan2(P*y-I*x,I*y+P*x)}else{var X=(y=h*k)*y,D=(x=l*k)*x,U=I*I+P*P,F=Math.atan2(P,I),L=-2*D*V,O=D-X;if(0<=(M=L*L-4*O*(w=D*V*V+X*U-X*D))){var B=Math.sqrt(M);L<0&&(B=-B);var W=(B=-(L+B)/2)/O,q=w/B,G=Math.abs(W)<Math.abs(q)?W:q;if(G*G<=U){R=Math.sqrt(U-G*G)*i,N=F-Math.atan2(R,G),_=Math.atan2(R/l,(G-V)/h);break t}}var j=nt.MathUtils.PI,z=V-y,Z=z*z,H=0,J=0,Q=V+y,K=Q*Q,$=0;-1<=(w=-y*V/(X-D))&&w<=1&&(w=Math.acos(w),(M=(b=y*Math.cos(w)+V)*b+(R=x*Math.sin(w))*R)<Z&&(j=w,Z=M,z=b,H=R),K<M&&(J=w,K=M,Q=b,$=R)),_=U<=(Z+K)/2?(N=F-Math.atan2(H*i,z),j*i):(N=F-Math.atan2($*i,Q),J*i)}var tt=Math.atan2(m,d)*f,et=t.arotation;180<(N=(N-tt)*nt.MathUtils.radDeg+c-et)?N-=360:N<-180&&(N+=360),t.updateWorldTransformWith(o,s,et+N*a,t.ascaleX,t.ascaleY,0,0),et=e.arotation,180<(_=((_+tt)*nt.MathUtils.radDeg-e.ashearX)*f+p-et)?_-=360:_<-180&&(_+=360),e.updateWorldTransformWith(d,m,et+_*a,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}else e.updateWorldTransform()},t}();nt.IkConstraint=t}(spine||(spine={})),function(t){var e=function(t){this.order=0,this.bones=new Array,this.bendDirection=1,this.mix=1,this.name=t};(spine||(spine={})).IkConstraintData=e}(),function(H){var t=function(){function Z(t,e){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(var n=0,r=t.bones.length;n<r;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findSlot(t.target.name),this.position=t.position,this.spacing=t.spacing,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix}return Z.prototype.apply=function(){this.update()},Z.prototype.update=function(){var t=this.target.getAttachment();if(t instanceof H.PathAttachment){var e=this.rotateMix,n=this.translateMix,r=0<e;if(0<n||r){var i=this.data,a=i.spacingMode,o=a==H.SpacingMode.Length,s=i.rotateMode,h=s==H.RotateMode.Tangent,l=s==H.RotateMode.ChainScale,u=this.bones.length,c=h?u:u+1,p=this.bones,f=H.Utils.setArraySize(this.spaces,c),d=null,m=this.spacing;if(l||o){l&&(d=H.Utils.setArraySize(this.lengths,u));for(var g=0,v=c-1;g<v;){var y=(P=p[g]).data.length;if(y<Z.epsilon)l&&(d[g]=0),f[++g]=0;else{var x=y*P.a,w=y*P.c,M=Math.sqrt(x*x+w*w);l&&(d[g]=M),f[++g]=(o?y+m:m)*M/y}}}else for(g=1;g<c;g++)f[g]=m;var E=this.computeWorldPositions(t,c,h,i.positionMode==H.PositionMode.Percent,a==H.SpacingMode.Percent),T=E[0],A=E[1],b=i.offsetRotation,R=!1;if(0==b)R=s==H.RotateMode.Chain;else R=!1,b*=0<(I=this.target.bone).a*I.d-I.b*I.c?H.MathUtils.degRad:-H.MathUtils.degRad;g=0;for(var I=3;g<u;g++,I+=3){var P;(P=p[g]).worldX+=(T-P.worldX)*n,P.worldY+=(A-P.worldY)*n;var S=(x=E[I])-T,C=(w=E[I+1])-A;if(l){var V=d[g];if(0!=V){var k=(Math.sqrt(S*S+C*C)/V-1)*e+1;P.a*=k,P.c*=k}}if(T=x,A=w,r){var N=P.a,_=P.b,Y=P.c,X=P.d,D=0,U=0,F=0;if(D=h?E[I-1]:0==f[g+1]?E[I+2]:Math.atan2(C,S),D-=Math.atan2(Y,N),R){U=Math.cos(D),F=Math.sin(D);var L=P.data.length;T+=(L*(U*N-F*Y)-S)*e,A+=(L*(F*N+U*Y)-C)*e}else D+=b;D>H.MathUtils.PI?D-=H.MathUtils.PI2:D<-H.MathUtils.PI&&(D+=H.MathUtils.PI2),D*=e,U=Math.cos(D),F=Math.sin(D),P.a=U*N-F*Y,P.b=U*_-F*X,P.c=F*N+U*Y,P.d=F*_+U*X}P.appliedValid=!1}}}},Z.prototype.computeWorldPositions=function(t,e,n,r,i){var a=this.target,o=this.position,s=this.spaces,h=H.Utils.setArraySize(this.positions,3*e+2),l=null,u=t.closed,c=t.worldVerticesLength,p=c/6,f=Z.NONE;if(!t.constantSpeed){var d=t.lengths,m=d[p-=u?1:2];if(r&&(o*=m),i)for(var g=0;g<e;g++)s[g]*=m;l=H.Utils.setArraySize(this.world,8);g=0;for(var v=0,y=0;g<e;g++,v+=3){var x=o+=W=s[g];if(u)(x%=m)<0&&(x+=m),y=0;else{if(x<0){f!=Z.BEFORE&&(f=Z.BEFORE,t.computeWorldVertices(a,2,4,l,0,2)),this.addBeforePosition(x,l,0,h,v);continue}if(m<x){f!=Z.AFTER&&(f=Z.AFTER,t.computeWorldVertices(a,c-6,4,l,0,2)),this.addAfterPosition(x-m,l,0,h,v);continue}}for(;;y++){var w=d[y];if(!(w<x)){if(0==y)x/=w;else x=(x-(z=d[y-1]))/(w-z);break}}y!=f&&(f=y,u&&y==p?(t.computeWorldVertices(a,c-4,4,l,0,2),t.computeWorldVertices(a,0,4,l,4,2)):t.computeWorldVertices(a,6*y+2,8,l,0,2)),this.addCurvePosition(x,l[0],l[1],l[2],l[3],l[4],l[5],l[6],l[7],h,v,n||0<g&&0==W)}return h}u?(c+=2,l=H.Utils.setArraySize(this.world,c),t.computeWorldVertices(a,2,c-4,l,0,2),t.computeWorldVertices(a,0,2,l,c-4,2),l[c-2]=l[0],l[c-1]=l[1]):(p--,c-=4,l=H.Utils.setArraySize(this.world,c),t.computeWorldVertices(a,2,c,l,0,2));for(var M=H.Utils.setArraySize(this.curves,p),E=0,T=l[0],A=l[1],b=0,R=0,I=0,P=0,S=0,C=0,V=0,k=0,N=0,_=0,Y=0,X=0,D=0,U=0,F=(g=0,2);g<p;g++,F+=6)b=l[F],R=l[F+1],I=l[F+2],P=l[F+3],Y=2*(V=.1875*(T-2*b+I))+(N=.09375*(3*(b-I)-T+(S=l[F+4]))),X=2*(k=.1875*(A-2*R+P))+(_=.09375*(3*(R-P)-A+(C=l[F+5]))),D=.75*(b-T)+V+.16666667*N,U=.75*(R-A)+k+.16666667*_,E+=Math.sqrt(D*D+U*U),D+=Y,U+=X,Y+=N,X+=_,E+=Math.sqrt(D*D+U*U),D+=Y,U+=X,E+=Math.sqrt(D*D+U*U),D+=Y+N,U+=X+_,E+=Math.sqrt(D*D+U*U),M[g]=E,T=S,A=C;if(r&&(o*=E),i)for(g=0;g<e;g++)s[g]*=E;for(var L=this.segments,O=0,B=(g=0,v=0,y=0,0);g<e;g++,v+=3){var W;x=o+=W=s[g];if(u)(x%=E)<0&&(x+=E),y=0;else{if(x<0){this.addBeforePosition(x,l,0,h,v);continue}if(E<x){this.addAfterPosition(x-E,l,c-4,h,v);continue}}for(;;y++){var q=M[y];if(!(q<x)){if(0==y)x/=q;else x=(x-(z=M[y-1]))/(q-z);break}}if(y!=f){var G=6*(f=y);for(T=l[G],A=l[G+1],b=l[G+2],R=l[G+3],I=l[G+4],P=l[G+5],Y=2*(V=.03*(T-2*b+I))+(N=.006*(3*(b-I)-T+(S=l[G+6]))),X=2*(k=.03*(A-2*R+P))+(_=.006*(3*(R-P)-A+(C=l[G+7]))),D=.3*(b-T)+V+.16666667*N,U=.3*(R-A)+k+.16666667*_,O=Math.sqrt(D*D+U*U),L[0]=O,G=1;G<8;G++)D+=Y,U+=X,Y+=N,X+=_,O+=Math.sqrt(D*D+U*U),L[G]=O;D+=Y,U+=X,O+=Math.sqrt(D*D+U*U),L[8]=O,D+=Y+N,U+=X+_,O+=Math.sqrt(D*D+U*U),L[9]=O,B=0}for(x*=O;;B++){var j=L[B];if(!(j<x)){var z;if(0==B)x/=j;else x=B+(x-(z=L[B-1]))/(j-z);break}}this.addCurvePosition(.1*x,T,A,b,R,I,P,S,C,h,v,n||0<g&&0==W)}return h},Z.prototype.addBeforePosition=function(t,e,n,r,i){var a=e[n],o=e[n+1],s=e[n+2]-a,h=e[n+3]-o,l=Math.atan2(h,s);r[i]=a+t*Math.cos(l),r[i+1]=o+t*Math.sin(l),r[i+2]=l},Z.prototype.addAfterPosition=function(t,e,n,r,i){var a=e[n+2],o=e[n+3],s=a-e[n],h=o-e[n+1],l=Math.atan2(h,s);r[i]=a+t*Math.cos(l),r[i+1]=o+t*Math.sin(l),r[i+2]=l},Z.prototype.addCurvePosition=function(t,e,n,r,i,a,o,s,h,l,u,c){(0==t||isNaN(t))&&(t=1e-4);var p=t*t,f=p*t,d=1-t,m=d*d,g=m*d,v=d*t,y=3*v,x=d*y,w=y*t,M=e*g+r*x+a*w+s*f,E=n*g+i*x+o*w+h*f;l[u]=M,l[u+1]=E,c&&(l[u+2]=Math.atan2(E-(n*m+i*v*2+o*p),M-(e*m+r*v*2+a*p)))},Z.prototype.getOrder=function(){return this.data.order},Z.NONE=-1,Z.BEFORE=-2,Z.AFTER=-3,Z.epsilon=1e-5,Z}();H.PathConstraint=t}(spine||(spine={})),function(t){var e,n,r,i=function(t){this.order=0,this.bones=new Array,this.name=t};t.PathConstraintData=i,(e=t.PositionMode||(t.PositionMode={}))[e.Fixed=0]="Fixed",e[e.Percent=1]="Percent",(n=t.SpacingMode||(t.SpacingMode={}))[n.Length=0]="Length",n[n.Fixed=1]="Fixed",n[n.Percent=2]="Percent",(r=t.RotateMode||(t.RotateMode={}))[r.Tangent=0]="Tangent",r[r.Chain=1]="Chain",r[r.ChainScale=2]="ChainScale"}(spine||(spine={})),function(t){var i=function(){function t(t){this.toLoad=new Array,this.assets={},this.clientId=t}return t.prototype.loaded=function(){var t=0;for(var e in this.assets)t++;return t},t}(),e=function(){function t(t){void 0===t&&(t=""),this.clientAssets={},this.queuedAssets={},this.rawAssets={},this.errors={},this.pathPrefix=t}return t.prototype.queueAsset=function(t,e,n){var r=this.clientAssets[t];return null==r&&(r=new i(t),this.clientAssets[t]=r),null!==e&&(r.textureLoader=e),r.toLoad.push(n),this.queuedAssets[n]!==n&&(this.queuedAssets[n]=n,!0)},t.prototype.loadText=function(t,e){var n=this;if(e=this.pathPrefix+e,this.queueAsset(t,null,e)){var r=new XMLHttpRequest;r.onreadystatechange=function(){r.readyState==XMLHttpRequest.DONE&&(200<=r.status&&r.status<300?n.rawAssets[e]=r.responseText:n.errors[e]="Couldnt load text "+e+": status "+r.status+", "+r.responseText)},r.open("GET",e,!0),r.send()}},t.prototype.loadJson=function(t,e){var n=this;if(e=this.pathPrefix+e,this.queueAsset(t,null,e)){var r=new XMLHttpRequest;r.onreadystatechange=function(){r.readyState==XMLHttpRequest.DONE&&(200<=r.status&&r.status<300?n.rawAssets[e]=JSON.parse(r.responseText):n.errors[e]="Couldnt load text "+e+": status "+r.status+", "+r.responseText)},r.open("GET",e,!0),r.send()}},t.prototype.loadTexture=function(t,e,n){var r=this;if(n=this.pathPrefix+n,this.queueAsset(t,e,n)){var i=new Image;i.src=n,i.crossOrigin="anonymous",i.onload=function(t){r.rawAssets[n]=i},i.onerror=function(t){r.errors[n]="Couldnt load image "+n}}},t.prototype.get=function(t,e){e=this.pathPrefix+e;var n=this.clientAssets[t];return null==n||n.assets[e]},t.prototype.updateClientAssets=function(t){for(var e=0;e<t.toLoad.length;e++){var n=t.toLoad[e],r=t.assets[n];if(null==r){var i=this.rawAssets[n];if(null==i)continue;i instanceof HTMLImageElement?t.assets[n]=t.textureLoader(i):t.assets[n]=i}}},t.prototype.isLoadingComplete=function(t){var e=this.clientAssets[t];return null==e||(this.updateClientAssets(e),e.toLoad.length==e.loaded())},t.prototype.dispose=function(){},t.prototype.hasErrors=function(){return 0<Object.keys(this.errors).length},t.prototype.getErrors=function(){return this.errors},t}();t.SharedAssetManager=e}(spine||(spine={})),function(x){var t=function(){function t(t){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.flipX=!1,this.flipY=!1,this.x=0,this.y=0,null==t)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(var e=0;e<t.bones.length;e++){var n=t.bones[e],r=void 0;if(null==n.parent)r=new x.Bone(n,this,null);else{var i=this.bones[n.parent.index];r=new x.Bone(n,this,i),i.children.push(r)}this.bones.push(r)}this.slots=new Array,this.drawOrder=new Array;for(e=0;e<t.slots.length;e++){var a=t.slots[e],o=(r=this.bones[a.boneData.index],new x.Slot(a,r));this.slots.push(o),this.drawOrder.push(o)}this.ikConstraints=new Array;for(e=0;e<t.ikConstraints.length;e++){var s=t.ikConstraints[e];this.ikConstraints.push(new x.IkConstraint(s,this))}this.transformConstraints=new Array;for(e=0;e<t.transformConstraints.length;e++){var h=t.transformConstraints[e];this.transformConstraints.push(new x.TransformConstraint(h,this))}this.pathConstraints=new Array;for(e=0;e<t.pathConstraints.length;e++){var l=t.pathConstraints[e];this.pathConstraints.push(new x.PathConstraint(l,this))}this.color=new x.Color(1,1,1,1),this.updateCache()}return t.prototype.updateCache=function(){this._updateCache.length=0,this.updateCacheReset.length=0;for(var t=this.bones,e=0,n=t.length;e<n;e++)t[e].sorted=!1;var r=this.ikConstraints,i=this.transformConstraints,a=this.pathConstraints,o=r.length,s=i.length,h=a.length,l=o+s+h;t:for(e=0;e<l;e++){for(var u=0;u<o;u++){if((c=r[u]).data.order==e){this.sortIkConstraint(c);continue t}}for(u=0;u<s;u++){if((c=i[u]).data.order==e){this.sortTransformConstraint(c);continue t}}for(u=0;u<h;u++){var c;if((c=a[u]).data.order==e){this.sortPathConstraint(c);continue t}}}for(e=0,n=t.length;e<n;e++)this.sortBone(t[e])},t.prototype.sortIkConstraint=function(t){var e=t.target;this.sortBone(e);var n=t.bones,r=n[0];if(this.sortBone(r),1<n.length){var i=n[n.length-1];-1<this._updateCache.indexOf(i)||this.updateCacheReset.push(i)}this._updateCache.push(t),this.sortReset(r.children),n[n.length-1].sorted=!0},t.prototype.sortPathConstraint=function(t){var e=t.target,n=e.data.index,r=e.bone;null!=this.skin&&this.sortPathConstraintAttachment(this.skin,n,r),null!=this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,n,r);for(var i=0,a=this.data.skins.length;i<a;i++)this.sortPathConstraintAttachment(this.data.skins[i],n,r);var o=e.getAttachment();o instanceof x.PathAttachment&&this.sortPathConstraintAttachmentWith(o,r);var s=t.bones,h=s.length;for(i=0;i<h;i++)this.sortBone(s[i]);this._updateCache.push(t);for(i=0;i<h;i++)this.sortReset(s[i].children);for(i=0;i<h;i++)s[i].sorted=!0},t.prototype.sortTransformConstraint=function(t){this.sortBone(t.target);var e=t.bones,n=e.length;if(t.data.local)for(var r=0;r<n;r++){var i=e[r];this.sortBone(i.parent),-1<this._updateCache.indexOf(i)||this.updateCacheReset.push(i)}else for(r=0;r<n;r++)this.sortBone(e[r]);this._updateCache.push(t);for(var a=0;a<n;a++)this.sortReset(e[a].children);for(a=0;a<n;a++)e[a].sorted=!0},t.prototype.sortPathConstraintAttachment=function(t,e,n){var r=t.attachments[e];if(r)for(var i in r)this.sortPathConstraintAttachmentWith(r[i],n)},t.prototype.sortPathConstraintAttachmentWith=function(t,e){if(t instanceof x.PathAttachment){var n=t.bones;if(null==n)this.sortBone(e);else for(var r=this.bones,i=0;i<n.length;)for(var a=n[i++],o=i+a;i<o;i++){var s=n[i];this.sortBone(r[s])}}},t.prototype.sortBone=function(t){if(!t.sorted){var e=t.parent;null!=e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}},t.prototype.sortReset=function(t){for(var e=0,n=t.length;e<n;e++){var r=t[e];r.sorted&&this.sortReset(r.children),r.sorted=!1}},t.prototype.updateWorldTransform=function(){for(var t=this.updateCacheReset,e=0,n=t.length;e<n;e++){var r=t[e];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY,r.appliedValid=!0}var i=this._updateCache;for(e=0,n=i.length;e<n;e++)i[e].update()},t.prototype.setToSetupPose=function(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()},t.prototype.setBonesToSetupPose=function(){for(var t=this.bones,e=0,n=t.length;e<n;e++)t[e].setToSetupPose();var r=this.ikConstraints;for(e=0,n=r.length;e<n;e++){(s=r[e]).bendDirection=s.data.bendDirection,s.mix=s.data.mix}var i=this.transformConstraints;for(e=0,n=i.length;e<n;e++){var a=(s=i[e]).data;s.rotateMix=a.rotateMix,s.translateMix=a.translateMix,s.scaleMix=a.scaleMix,s.shearMix=a.shearMix}var o=this.pathConstraints;for(e=0,n=o.length;e<n;e++){var s;a=(s=o[e]).data;s.position=a.position,s.spacing=a.spacing,s.rotateMix=a.rotateMix,s.translateMix=a.translateMix}},t.prototype.setSlotsToSetupPose=function(){var t=this.slots;x.Utils.arrayCopy(t,0,this.drawOrder,0,t.length);for(var e=0,n=t.length;e<n;e++)t[e].setToSetupPose()},t.prototype.getRootBone=function(){return 0==this.bones.length?null:this.bones[0]},t.prototype.findBone=function(t){if(null==t)throw new Error("boneName cannot be null.");for(var e=this.bones,n=0,r=e.length;n<r;n++){var i=e[n];if(i.data.name==t)return i}return null},t.prototype.findBoneIndex=function(t){if(null==t)throw new Error("boneName cannot be null.");for(var e=this.bones,n=0,r=e.length;n<r;n++)if(e[n].data.name==t)return n;return-1},t.prototype.findSlot=function(t){if(null==t)throw new Error("slotName cannot be null.");for(var e=this.slots,n=0,r=e.length;n<r;n++){var i=e[n];if(i.data.name==t)return i}return null},t.prototype.findSlotIndex=function(t){if(null==t)throw new Error("slotName cannot be null.");for(var e=this.slots,n=0,r=e.length;n<r;n++)if(e[n].data.name==t)return n;return-1},t.prototype.setSkinByName=function(t){var e=this.data.findSkin(t);if(null==e)throw new Error("Skin not found: "+t);this.setSkin(e)},t.prototype.setSkin=function(t){if(null!=t)if(null!=this.skin)t.attachAll(this,this.skin);else for(var e=this.slots,n=0,r=e.length;n<r;n++){var i=e[n],a=i.data.attachmentName;if(null!=a){var o=t.getAttachment(n,a);null!=o&&i.setAttachment(o)}}this.skin=t},t.prototype.getAttachmentByName=function(t,e){return this.getAttachment(this.data.findSlotIndex(t),e)},t.prototype.getAttachment=function(t,e){if(null==e)throw new Error("attachmentName cannot be null.");if(null!=this.skin){var n=this.skin.getAttachment(t,e);if(null!=n)return n}return null!=this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null},t.prototype.setAttachment=function(t,e){if(null==t)throw new Error("slotName cannot be null.");for(var n=this.slots,r=0,i=n.length;r<i;r++){var a=n[r];if(a.data.name==t){var o=null;if(null!=e&&null==(o=this.getAttachment(r,e)))throw new Error("Attachment not found: "+e+", for slot: "+t);return void a.setAttachment(o)}}throw new Error("Slot not found: "+t)},t.prototype.findIkConstraint=function(t){if(null==t)throw new Error("constraintName cannot be null.");for(var e=this.ikConstraints,n=0,r=e.length;n<r;n++){var i=e[n];if(i.data.name==t)return i}return null},t.prototype.findTransformConstraint=function(t){if(null==t)throw new Error("constraintName cannot be null.");for(var e=this.transformConstraints,n=0,r=e.length;n<r;n++){var i=e[n];if(i.data.name==t)return i}return null},t.prototype.findPathConstraint=function(t){if(null==t)throw new Error("constraintName cannot be null.");for(var e=this.pathConstraints,n=0,r=e.length;n<r;n++){var i=e[n];if(i.data.name==t)return i}return null},t.prototype.getBounds=function(t,e,n){if(null==t)throw new Error("offset cannot be null.");if(null==e)throw new Error("size cannot be null.");for(var r=this.drawOrder,i=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY,s=Number.NEGATIVE_INFINITY,h=0,l=r.length;h<l;h++){var u=r[h],c=0,p=null,f=u.getAttachment();if(f instanceof x.RegionAttachment)c=8,p=x.Utils.setArraySize(n,c,0),f.computeWorldVertices(u.bone,p,0,2);else if(f instanceof x.MeshAttachment){var d=f;c=d.worldVerticesLength,p=x.Utils.setArraySize(n,c,0),d.computeWorldVertices(u,0,c,p,0,2)}if(null!=p)for(var m=0,g=p.length;m<g;m+=2){var v=p[m],y=p[m+1];i=Math.min(i,v),a=Math.min(a,y),o=Math.max(o,v),s=Math.max(s,y)}}t.set(i,a),e.set(o-i,s-a)},t.prototype.update=function(t){this.time+=t},t}();x.Skeleton=t}(spine||(spine={})),function(p){var t=function(){function t(){this.minX=0,this.minY=0,this.maxX=0,this.maxY=0,this.boundingBoxes=new Array,this.polygons=new Array,this.polygonPool=new p.Pool(function(){return p.Utils.newFloatArray(16)})}return t.prototype.update=function(t,e){if(null==t)throw new Error("skeleton cannot be null.");var n=this.boundingBoxes,r=this.polygons,i=this.polygonPool,a=t.slots,o=a.length;n.length=0,i.freeAll(r);for(var s=r.length=0;s<o;s++){var h=a[s],l=h.getAttachment();if(l instanceof p.BoundingBoxAttachment){var u=l;n.push(u);var c=i.obtain();c.length!=u.worldVerticesLength&&(c=p.Utils.newFloatArray(u.worldVerticesLength)),r.push(c),u.computeWorldVertices(h,0,u.worldVerticesLength,c,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)},t.prototype.aabbCompute=function(){for(var t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY,r=Number.NEGATIVE_INFINITY,i=this.polygons,a=0,o=i.length;a<o;a++)for(var s=i[a],h=s,l=0,u=s.length;l<u;l+=2){var c=h[l],p=h[l+1];t=Math.min(t,c),e=Math.min(e,p),n=Math.max(n,c),r=Math.max(r,p)}this.minX=t,this.minY=e,this.maxX=n,this.maxY=r},t.prototype.aabbContainsPoint=function(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY},t.prototype.aabbIntersectsSegment=function(t,e,n,r){var i=this.minX,a=this.minY,o=this.maxX,s=this.maxY;if(t<=i&&n<=i||e<=a&&r<=a||o<=t&&o<=n||s<=e&&s<=r)return!1;var h=(r-e)/(n-t),l=h*(i-t)+e;if(a<l&&l<s)return!0;if(a<(l=h*(o-t)+e)&&l<s)return!0;var u=(a-e)/h+t;return i<u&&u<o||i<(u=(s-e)/h+t)&&u<o},t.prototype.aabbIntersectsSkeleton=function(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY},t.prototype.containsPoint=function(t,e){for(var n=this.polygons,r=0,i=n.length;r<i;r++)if(this.containsPointPolygon(n[r],t,e))return this.boundingBoxes[r];return null},t.prototype.containsPointPolygon=function(t,e,n){for(var r=t,i=t.length,a=i-2,o=!1,s=0;s<i;s+=2){var h=r[s+1],l=r[a+1];if(h<n&&n<=l||l<n&&n<=h){var u=r[s];u+(n-h)/(l-h)*(r[a]-u)<e&&(o=!o)}a=s}return o},t.prototype.intersectsSegment=function(t,e,n,r){for(var i=this.polygons,a=0,o=i.length;a<o;a++)if(this.intersectsSegmentPolygon(i[a],t,e,n,r))return this.boundingBoxes[a];return null},t.prototype.intersectsSegmentPolygon=function(t,e,n,r,i){for(var a=t,o=t.length,s=e-r,h=n-i,l=e*i-n*r,u=a[o-2],c=a[o-1],p=0;p<o;p+=2){var f=a[p],d=a[p+1],m=u*d-c*f,g=u-f,v=c-d,y=s*v-h*g,x=(l*g-s*m)/y;if((u<=x&&x<=f||f<=x&&x<=u)&&(e<=x&&x<=r||r<=x&&x<=e)){var w=(l*v-h*m)/y;if((c<=w&&w<=d||d<=w&&w<=c)&&(n<=w&&w<=i||i<=w&&w<=n))return!0}u=f,c=d}return!1},t.prototype.getPolygon=function(t){if(null==t)throw new Error("boundingBox cannot be null.");var e=this.boundingBoxes.indexOf(t);return-1==e?null:this.polygons[e]},t.prototype.getWidth=function(){return this.maxX-this.minX},t.prototype.getHeight=function(){return this.maxY-this.minY},t}();p.SkeletonBounds=t}(spine||(spine={})),function(H){var t=function(){function l(){this.triangulator=new H.Triangulator,this.clippingPolygon=new Array,this.clipOutput=new Array,this.clippedVertices=new Array,this.clippedTriangles=new Array,this.scratch=new Array}return l.prototype.clipStart=function(t,e){if(null!=this.clipAttachment)return 0;var n=(this.clipAttachment=e).worldVerticesLength,r=H.Utils.setArraySize(this.clippingPolygon,n);e.computeWorldVertices(t,0,n,r,0,2);var i=this.clippingPolygon;l.makeClockwise(i);for(var a=this.clippingPolygons=this.triangulator.decompose(i,this.triangulator.triangulate(i)),o=0,s=a.length;o<s;o++){var h=a[o];l.makeClockwise(h),h.push(h[0]),h.push(h[1])}return a.length},l.prototype.clipEndWithSlot=function(t){null!=this.clipAttachment&&this.clipAttachment.endSlot==t.data&&this.clipEnd()},l.prototype.clipEnd=function(){null!=this.clipAttachment&&(this.clipAttachment=null,this.clippingPolygons=null,this.clippedVertices.length=0,this.clippedTriangles.length=0,this.clippingPolygon.length=0)},l.prototype.isClipping=function(){return null!=this.clipAttachment},l.prototype.clipTriangles=function(t,e,n,r,i,a,o,s){var h=this.clipOutput,l=this.clippedVertices,u=this.clippedTriangles,c=this.clippingPolygons,p=this.clippingPolygons.length,f=s?12:8,d=0;l.length=0;t:for(var m=u.length=0;m<r;m+=3)for(var g=n[m]<<1,v=t[g],y=t[g+1],x=i[g],w=i[g+1],M=t[g=n[m+1]<<1],E=t[g+1],T=i[g],A=i[g+1],b=t[g=n[m+2]<<1],R=t[g+1],I=i[g],P=i[g+1],S=0;S<p;S++){var C=l.length;if(!this.clip(v,y,M,E,b,R,c[S],h)){(F=H.Utils.setArraySize(l,C+3*f))[C]=v,F[C+1]=y,F[C+2]=a.r,F[C+3]=a.g,F[C+4]=a.b,F[C+5]=a.a,s?(F[C+6]=x,F[C+7]=w,F[C+8]=o.r,F[C+9]=o.g,F[C+10]=o.b,F[C+11]=o.a,F[C+12]=M,F[C+13]=E,F[C+14]=a.r,F[C+15]=a.g,F[C+16]=a.b,F[C+17]=a.a,F[C+18]=T,F[C+19]=A,F[C+20]=o.r,F[C+21]=o.g,F[C+22]=o.b,F[C+23]=o.a,F[C+24]=b,F[C+25]=R,F[C+26]=a.r,F[C+27]=a.g,F[C+28]=a.b,F[C+29]=a.a,F[C+30]=I,F[C+31]=P,F[C+32]=o.r,F[C+33]=o.g,F[C+34]=o.b,F[C+35]=o.a):(F[C+6]=x,F[C+7]=w,F[C+8]=M,F[C+9]=E,F[C+10]=a.r,F[C+11]=a.g,F[C+12]=a.b,F[C+13]=a.a,F[C+14]=T,F[C+15]=A,F[C+16]=b,F[C+17]=R,F[C+18]=a.r,F[C+19]=a.g,F[C+20]=a.b,F[C+21]=a.a,F[C+22]=I,F[C+23]=P),C=u.length,(Z=H.Utils.setArraySize(u,C+3))[C]=d,Z[C+1]=d+1,Z[C+2]=d+2,d+=3;continue t}var V=h.length;if(0!=V){for(var k=E-R,N=b-M,_=v-b,Y=R-y,X=1/(k*_+N*(y-R)),D=V>>1,U=this.clipOutput,F=H.Utils.setArraySize(l,C+D*f),L=0;L<V;L+=2){var O=U[L],B=U[L+1];F[C]=O,F[C+1]=B,F[C+2]=a.r,F[C+3]=a.g,F[C+4]=a.b,F[C+5]=a.a;var W=O-b,q=B-R,G=(k*W+N*q)*X,j=(Y*W+_*q)*X,z=1-G-j;F[C+6]=x*G+T*j+I*z,F[C+7]=w*G+A*j+P*z,s&&(F[C+8]=o.r,F[C+9]=o.g,F[C+10]=o.b,F[C+11]=o.a),C+=f}C=u.length;var Z=H.Utils.setArraySize(u,C+3*(D-2));D--;for(L=1;L<D;L++)Z[C]=d,Z[C+1]=d+L,Z[C+2]=d+L+1,C+=3;d+=D+1}}},l.prototype.clip=function(t,e,n,r,i,a,o,s){var h=s,l=!1,u=null;2<=o.length%4?(u=s,s=this.scratch):u=this.scratch,u.length=0,u.push(t),u.push(e),u.push(n),u.push(r),u.push(i),u.push(a),u.push(t),u.push(e),s.length=0;for(var c=o,p=o.length-4,f=0;;f+=2){for(var d=c[f],m=c[f+1],g=c[f+2],v=c[f+3],y=d-g,x=m-v,w=u,M=u.length-2,E=s.length,T=0;T<M;T+=2){var A=w[T],b=w[T+1],R=w[T+2],I=w[T+3],P=0<y*(I-v)-x*(R-g);if(0<y*(b-v)-x*(A-g)){if(P){s.push(R),s.push(I);continue}var S=((V=R-A)*(m-b)-(C=I-b)*(d-A))/(C*(g-d)-V*(v-m));s.push(d+(g-d)*S),s.push(m+(v-m)*S)}else if(P){var C,V;S=((V=R-A)*(m-b)-(C=I-b)*(d-A))/(C*(g-d)-V*(v-m));s.push(d+(g-d)*S),s.push(m+(v-m)*S),s.push(R),s.push(I)}l=!0}if(E==s.length)return!(h.length=0);if(s.push(s[0]),s.push(s[1]),f==p)break;var k=s;(s=u).length=0,u=k}if(h!=s){f=h.length=0;for(var N=s.length-2;f<N;f++)h[f]=s[f]}else h.length=h.length-2;return l},l.makeClockwise=function(t){for(var e=t,n=t.length,r=e[n-2]*e[1]-e[0]*e[n-1],i=0,a=0,o=0,s=0,h=n-3;s<h;s+=2)i=e[s],a=e[s+1],o=e[s+2],r+=i*e[s+3]-o*a;if(!(r<0)){s=0;var l=n-2;for(h=n>>1;s<h;s+=2){var u=e[s],c=e[s+1],p=l-s;e[s]=e[p],e[s+1]=e[p+1],e[p]=u,e[p+1]=c}}},l}();H.SkeletonClipping=t}(spine||(spine={})),function(t){var e=function(){function t(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}return t.prototype.findBone=function(t){if(null==t)throw new Error("boneName cannot be null.");for(var e=this.bones,n=0,r=e.length;n<r;n++){var i=e[n];if(i.name==t)return i}return null},t.prototype.findBoneIndex=function(t){if(null==t)throw new Error("boneName cannot be null.");for(var e=this.bones,n=0,r=e.length;n<r;n++)if(e[n].name==t)return n;return-1},t.prototype.findSlot=function(t){if(null==t)throw new Error("slotName cannot be null.");for(var e=this.slots,n=0,r=e.length;n<r;n++){var i=e[n];if(i.name==t)return i}return null},t.prototype.findSlotIndex=function(t){if(null==t)throw new Error("slotName cannot be null.");for(var e=this.slots,n=0,r=e.length;n<r;n++)if(e[n].name==t)return n;return-1},t.prototype.findSkin=function(t){if(null==t)throw new Error("skinName cannot be null.");for(var e=this.skins,n=0,r=e.length;n<r;n++){var i=e[n];if(i.name==t)return i}return null},t.prototype.findEvent=function(t){if(null==t)throw new Error("eventDataName cannot be null.");for(var e=this.events,n=0,r=e.length;n<r;n++){var i=e[n];if(i.name==t)return i}return null},t.prototype.findAnimation=function(t){if(null==t)throw new Error("animationName cannot be null.");for(var e=this.animations,n=0,r=e.length;n<r;n++){var i=e[n];if(i.name==t)return i}return null},t.prototype.findIkConstraint=function(t){if(null==t)throw new Error("constraintName cannot be null.");for(var e=this.ikConstraints,n=0,r=e.length;n<r;n++){var i=e[n];if(i.name==t)return i}return null},t.prototype.findTransformConstraint=function(t){if(null==t)throw new Error("constraintName cannot be null.");for(var e=this.transformConstraints,n=0,r=e.length;n<r;n++){var i=e[n];if(i.name==t)return i}return null},t.prototype.findPathConstraint=function(t){if(null==t)throw new Error("constraintName cannot be null.");for(var e=this.pathConstraints,n=0,r=e.length;n<r;n++){var i=e[n];if(i.name==t)return i}return null},t.prototype.findPathConstraintIndex=function(t){if(null==t)throw new Error("pathConstraintName cannot be null.");for(var e=this.pathConstraints,n=0,r=e.length;n<r;n++)if(e[n].name==t)return n;return-1},t}();t.SkeletonData=e}(spine||(spine={})),function($){var t=function(){function N(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}return N.prototype.readSkeletonData=function(t){var e=this.scale,n=new $.SkeletonData,r="string"==typeof t?JSON.parse(t):t,i=r.skeleton;if(null!=i&&(n.hash=i.hash,n.version=i.spine,n.width=i.width,n.height=i.height,n.fps=i.fps,n.imagesPath=i.images),r.bones)for(var a=0;a<r.bones.length;a++){var o=r.bones[a],s=null,h=this.getValue(o,"parent",null);if(null!=h&&null==(s=n.findBone(h)))throw new Error("Parent bone not found: "+h);(p=new $.BoneData(n.bones.length,o.name,s)).length=this.getValue(o,"length",0)*e,p.x=this.getValue(o,"x",0)*e,p.y=this.getValue(o,"y",0)*e,p.rotation=this.getValue(o,"rotation",0),p.scaleX=this.getValue(o,"scaleX",1),p.scaleY=this.getValue(o,"scaleY",1),p.shearX=this.getValue(o,"shearX",0),p.shearY=this.getValue(o,"shearY",0),p.transformMode=N.transformModeFromString(this.getValue(o,"transform","normal")),n.bones.push(p)}if(r.slots)for(a=0;a<r.slots.length;a++){var l=(T=r.slots[a]).name,u=T.bone,c=n.findBone(u);if(null==c)throw new Error("Slot bone not found: "+u);var p=new $.SlotData(n.slots.length,l,c),f=this.getValue(T,"color",null);null!=f&&p.color.setFromString(f);var d=this.getValue(T,"dark",null);null!=d&&(p.darkColor=new $.Color(1,1,1,1),p.darkColor.setFromString(d)),p.attachmentName=this.getValue(T,"attachment",null),p.blendMode=N.blendModeFromString(this.getValue(T,"blend","normal")),n.slots.push(p)}if(r.ik)for(a=0;a<r.ik.length;a++){var m=r.ik[a];(p=new $.IkConstraintData(m.name)).order=this.getValue(m,"order",0);for(var g=0;g<m.bones.length;g++){u=m.bones[g];if(null==(y=n.findBone(u)))throw new Error("IK bone not found: "+u);p.bones.push(y)}var v=m.target;if(p.target=n.findBone(v),null==p.target)throw new Error("IK target bone not found: "+v);p.bendDirection=this.getValue(m,"bendPositive",!0)?1:-1,p.mix=this.getValue(m,"mix",1),n.ikConstraints.push(p)}if(r.transform)for(a=0;a<r.transform.length;a++){m=r.transform[a];(p=new $.TransformConstraintData(m.name)).order=this.getValue(m,"order",0);for(g=0;g<m.bones.length;g++){u=m.bones[g];if(null==(y=n.findBone(u)))throw new Error("Transform constraint bone not found: "+u);p.bones.push(y)}v=m.target;if(p.target=n.findBone(v),null==p.target)throw new Error("Transform constraint target bone not found: "+v);p.local=this.getValue(m,"local",!1),p.relative=this.getValue(m,"relative",!1),p.offsetRotation=this.getValue(m,"rotation",0),p.offsetX=this.getValue(m,"x",0)*e,p.offsetY=this.getValue(m,"y",0)*e,p.offsetScaleX=this.getValue(m,"scaleX",0),p.offsetScaleY=this.getValue(m,"scaleY",0),p.offsetShearY=this.getValue(m,"shearY",0),p.rotateMix=this.getValue(m,"rotateMix",1),p.translateMix=this.getValue(m,"translateMix",1),p.scaleMix=this.getValue(m,"scaleMix",1),p.shearMix=this.getValue(m,"shearMix",1),n.transformConstraints.push(p)}if(r.path)for(a=0;a<r.path.length;a++){m=r.path[a];(p=new $.PathConstraintData(m.name)).order=this.getValue(m,"order",0);for(g=0;g<m.bones.length;g++){var y;u=m.bones[g];if(null==(y=n.findBone(u)))throw new Error("Transform constraint bone not found: "+u);p.bones.push(y)}v=m.target;if(p.target=n.findSlot(v),null==p.target)throw new Error("Path target slot not found: "+v);p.positionMode=N.positionModeFromString(this.getValue(m,"positionMode","percent")),p.spacingMode=N.spacingModeFromString(this.getValue(m,"spacingMode","length")),p.rotateMode=N.rotateModeFromString(this.getValue(m,"rotateMode","tangent")),p.offsetRotation=this.getValue(m,"rotation",0),p.position=this.getValue(m,"position",0),p.positionMode==$.PositionMode.Fixed&&(p.position*=e),p.spacing=this.getValue(m,"spacing",0),p.spacingMode!=$.SpacingMode.Length&&p.spacingMode!=$.SpacingMode.Fixed||(p.spacing*=e),p.rotateMix=this.getValue(m,"rotateMix",1),p.translateMix=this.getValue(m,"translateMix",1),n.pathConstraints.push(p)}if(r.skins)for(var x in r.skins){var w=r.skins[x],M=new $.Skin(x);for(var l in w){var E=n.findSlotIndex(l);if(-1==E)throw new Error("Slot not found: "+l);var T=w[l];for(var A in T){var b=this.readAttachment(T[A],M,E,A,n);null!=b&&M.addAttachment(E,A,b)}}n.skins.push(M),"default"==M.name&&(n.defaultSkin=M)}a=0;for(var R=this.linkedMeshes.length;a<R;a++){var I=this.linkedMeshes[a];if(null==(M=null==I.skin?n.defaultSkin:n.findSkin(I.skin)))throw new Error("Skin not found: "+I.skin);var P=M.getAttachment(I.slotIndex,I.parent);if(null==P)throw new Error("Parent mesh not found: "+I.parent);I.mesh.setParentMesh(P),I.mesh.updateUVs()}if(this.linkedMeshes.length=0,r.events)for(var S in r.events){var C=r.events[S];(p=new $.EventData(S)).intValue=this.getValue(C,"int",0),p.floatValue=this.getValue(C,"float",0),p.stringValue=this.getValue(C,"string",""),n.events.push(p)}if(r.animations)for(var V in r.animations){var k=r.animations[V];this.readAnimation(k,V,n)}return n},N.prototype.readAttachment=function(t,e,n,r,i){var a=this.scale;switch(r=this.getValue(t,"name",r),this.getValue(t,"type","region")){case"region":var o=this.getValue(t,"path",r),s=this.attachmentLoader.newRegionAttachment(e,r,o);return null==s?null:(s.path=o,s.x=this.getValue(t,"x",0)*a,s.y=this.getValue(t,"y",0)*a,s.scaleX=this.getValue(t,"scaleX",1),s.scaleY=this.getValue(t,"scaleY",1),s.rotation=this.getValue(t,"rotation",0),s.width=t.width*a,s.height=t.height*a,null!=(x=this.getValue(t,"color",null))&&s.color.setFromString(x),s.updateOffset(),s);case"boundingbox":var h=this.attachmentLoader.newBoundingBoxAttachment(e,r);return null==h?null:(this.readVertices(t,h,t.vertexCount<<1),null!=(x=this.getValue(t,"color",null))&&h.color.setFromString(x),h);case"mesh":case"linkedmesh":o=this.getValue(t,"path",r);var l=this.attachmentLoader.newMeshAttachment(e,r,o);if(null==l)return null;l.path=o,null!=(x=this.getValue(t,"color",null))&&l.color.setFromString(x);var u=this.getValue(t,"parent",null);if(null!=u)return l.inheritDeform=this.getValue(t,"deform",!0),this.linkedMeshes.push(new w(l,this.getValue(t,"skin",null),n,u)),l;var c=t.uvs;return this.readVertices(t,l,c.length),l.triangles=t.triangles,l.regionUVs=c,l.updateUVs(),l.hullLength=2*this.getValue(t,"hull",0),l;case"path":if(null==(o=this.attachmentLoader.newPathAttachment(e,r)))return null;o.closed=this.getValue(t,"closed",!1),o.constantSpeed=this.getValue(t,"constantSpeed",!0);var p=t.vertexCount;this.readVertices(t,o,p<<1);for(var f=$.Utils.newArray(p/3,0),d=0;d<t.lengths.length;d++)f[d]=t.lengths[d]*a;return o.lengths=f,null!=(x=this.getValue(t,"color",null))&&o.color.setFromString(x),o;case"point":var m=this.attachmentLoader.newPointAttachment(e,r);return null==m?null:(m.x=this.getValue(t,"x",0)*a,m.y=this.getValue(t,"y",0)*a,m.rotation=this.getValue(t,"rotation",0),null!=(x=this.getValue(t,"color",null))&&m.color.setFromString(x),m);case"clipping":var g=this.attachmentLoader.newClippingAttachment(e,r);if(null==g)return null;var v=this.getValue(t,"end",null);if(null!=v){var y=i.findSlot(v);if(null==y)throw new Error("Clipping end slot not found: "+v);g.endSlot=y}var x;p=t.vertexCount;return this.readVertices(t,g,p<<1),null!=(x=this.getValue(t,"color",null))&&g.color.setFromString(x),g}return null},N.prototype.readVertices=function(t,e,n){var r=this.scale;e.worldVerticesLength=n;var i=t.vertices;if(n!=i.length){var a=new Array,o=new Array;for(u=0,c=i.length;u<c;){var s=i[u++];o.push(s);for(var h=u+4*s;u<h;u+=4)o.push(i[u]),a.push(i[u+1]*r),a.push(i[u+2]*r),a.push(i[u+3])}e.bones=o,e.vertices=$.Utils.toFloatArray(a)}else{var l=$.Utils.toFloatArray(i);if(1!=r)for(var u=0,c=i.length;u<c;u++)l[u]*=r;e.vertices=l}},N.prototype.readAnimation=function(t,e,n){var r=this.scale,i=new Array,a=0;if(t.slots)for(var o in t.slots){var s=t.slots[o];if(-1==(Z=n.findSlotIndex(o)))throw new Error("Slot not found: "+o);for(var h in s){var l=s[h];if("attachment"==h){(x=new $.AttachmentTimeline(l.length)).slotIndex=Z;for(var u=0,c=0;c<l.length;c++){var p=l[c];x.setFrame(u++,p.time,p.name)}i.push(x),a=Math.max(a,x.frames[x.getFrameCount()-1])}else if("color"==h){(x=new $.ColorTimeline(l.length)).slotIndex=Z;for(u=0,c=0;c<l.length;c++){p=l[c];var f=new $.Color;f.setFromString(p.color),x.setFrame(u,p.time,f.r,f.g,f.b,f.a),this.readCurve(p,x,u),u++}i.push(x),a=Math.max(a,x.frames[(x.getFrameCount()-1)*$.ColorTimeline.ENTRIES])}else{if("twoColor"!=h)throw new Error("Invalid timeline type for a slot: "+h+" ("+o+")");(x=new $.TwoColorTimeline(l.length)).slotIndex=Z;for(u=0,c=0;c<l.length;c++){p=l[c];var d=new $.Color,m=new $.Color;d.setFromString(p.light),m.setFromString(p.dark),x.setFrame(u,p.time,d.r,d.g,d.b,d.a,m.r,m.g,m.b),this.readCurve(p,x,u),u++}i.push(x),a=Math.max(a,x.frames[(x.getFrameCount()-1)*$.TwoColorTimeline.ENTRIES])}}}if(t.bones)for(var g in t.bones){var v=t.bones[g],y=n.findBoneIndex(g);if(-1==y)throw new Error("Bone not found: "+g);for(var h in v){l=v[h];if("rotate"===h){(x=new $.RotateTimeline(l.length)).boneIndex=y;for(u=0,c=0;c<l.length;c++){p=l[c];x.setFrame(u,p.time,p.angle),this.readCurve(p,x,u),u++}i.push(x),a=Math.max(a,x.frames[(x.getFrameCount()-1)*$.RotateTimeline.ENTRIES])}else{if("translate"!==h&&"scale"!==h&&"shear"!==h)throw new Error("Invalid timeline type for a bone: "+h+" ("+g+")");var x=null,w=1;"scale"===h?x=new $.ScaleTimeline(l.length):"shear"===h?x=new $.ShearTimeline(l.length):(x=new $.TranslateTimeline(l.length),w=r),x.boneIndex=y;for(u=0,c=0;c<l.length;c++){p=l[c];var M=this.getValue(p,"x",0),E=this.getValue(p,"y",0);x.setFrame(u,p.time,M*w,E*w),this.readCurve(p,x,u),u++}i.push(x),a=Math.max(a,x.frames[(x.getFrameCount()-1)*$.TranslateTimeline.ENTRIES])}}}if(t.ik)for(var T in t.ik){var A=t.ik[T],b=n.findIkConstraint(T);(x=new $.IkConstraintTimeline(A.length)).ikConstraintIndex=n.ikConstraints.indexOf(b);for(u=0,c=0;c<A.length;c++){p=A[c];x.setFrame(u,p.time,this.getValue(p,"mix",1),this.getValue(p,"bendPositive",!0)?1:-1),this.readCurve(p,x,u),u++}i.push(x),a=Math.max(a,x.frames[(x.getFrameCount()-1)*$.IkConstraintTimeline.ENTRIES])}if(t.transform)for(var T in t.transform){A=t.transform[T],b=n.findTransformConstraint(T);(x=new $.TransformConstraintTimeline(A.length)).transformConstraintIndex=n.transformConstraints.indexOf(b);for(u=0,c=0;c<A.length;c++){p=A[c];x.setFrame(u,p.time,this.getValue(p,"rotateMix",1),this.getValue(p,"translateMix",1),this.getValue(p,"scaleMix",1),this.getValue(p,"shearMix",1)),this.readCurve(p,x,u),u++}i.push(x),a=Math.max(a,x.frames[(x.getFrameCount()-1)*$.TransformConstraintTimeline.ENTRIES])}if(t.paths)for(var T in t.paths){A=t.paths[T];var R=n.findPathConstraintIndex(T);if(-1==R)throw new Error("Path constraint not found: "+T);var I=n.pathConstraints[R];for(var h in A){l=A[h];if("position"===h||"spacing"===h){x=null,w=1;"spacing"===h?(x=new $.PathConstraintSpacingTimeline(l.length),I.spacingMode!=$.SpacingMode.Length&&I.spacingMode!=$.SpacingMode.Fixed||(w=r)):(x=new $.PathConstraintPositionTimeline(l.length),I.positionMode==$.PositionMode.Fixed&&(w=r)),x.pathConstraintIndex=R;for(u=0,c=0;c<l.length;c++){p=l[c];x.setFrame(u,p.time,this.getValue(p,h,0)*w),this.readCurve(p,x,u),u++}i.push(x),a=Math.max(a,x.frames[(x.getFrameCount()-1)*$.PathConstraintPositionTimeline.ENTRIES])}else if("mix"===h){(x=new $.PathConstraintMixTimeline(l.length)).pathConstraintIndex=R;for(u=0,c=0;c<l.length;c++){p=l[c];x.setFrame(u,p.time,this.getValue(p,"rotateMix",1),this.getValue(p,"translateMix",1)),this.readCurve(p,x,u),u++}i.push(x),a=Math.max(a,x.frames[(x.getFrameCount()-1)*$.PathConstraintMixTimeline.ENTRIES])}}}if(t.deform)for(var P in t.deform){var S=t.deform[P],C=n.findSkin(P);if(null==C)throw new Error("Skin not found: "+P);for(var o in S){s=S[o];if(-1==(Z=n.findSlotIndex(o)))throw new Error("Slot not found: "+s.name);for(var h in s){l=s[h];var V=C.getAttachment(Z,h);if(null==V)throw new Error("Deform attachment not found: "+l.name);var k=null!=V.bones,N=V.vertices,_=k?N.length/3*2:N.length;(x=new $.DeformTimeline(l.length)).slotIndex=Z,x.attachment=V;u=0;for(var Y=0;Y<l.length;Y++){p=l[Y];var X=void 0,D=this.getValue(p,"vertices",null);if(null==D)X=k?$.Utils.newFloatArray(_):N;else{X=$.Utils.newFloatArray(_);var U=this.getValue(p,"offset",0);if($.Utils.arrayCopy(D,0,X,U,D.length),1!=r)for(var F=(c=U)+D.length;c<F;c++)X[c]*=r;if(!k)for(c=0;c<_;c++)X[c]+=N[c]}x.setFrame(u,p.time,X),this.readCurve(p,x,u),u++}i.push(x),a=Math.max(a,x.frames[x.getFrameCount()-1])}}}var L=t.drawOrder;if(null==L&&(L=t.draworder),null!=L){x=new $.DrawOrderTimeline(L.length);var O=n.slots.length;for(u=0,Y=0;Y<L.length;Y++){var B=L[Y],W=null,q=this.getValue(B,"offsets",null);if(null!=q){W=$.Utils.newArray(O,-1);var G=$.Utils.newArray(O-q.length,0),j=0,z=0;for(c=0;c<q.length;c++){var Z,H=q[c];if(-1==(Z=n.findSlotIndex(H.slot)))throw new Error("Slot not found: "+H.slot);for(;j!=Z;)G[z++]=j++;W[j+H.offset]=j++}for(;j<O;)G[z++]=j++;for(c=O-1;0<=c;c--)-1==W[c]&&(W[c]=G[--z])}x.setFrame(u++,B.time,W)}i.push(x),a=Math.max(a,x.frames[x.getFrameCount()-1])}if(t.events){for(x=new $.EventTimeline(t.events.length),u=0,c=0;c<t.events.length;c++){var J=t.events[c],Q=n.findEvent(J.name);if(null==Q)throw new Error("Event not found: "+J.name);var K=new $.Event($.Utils.toSinglePrecision(J.time),Q);K.intValue=this.getValue(J,"int",Q.intValue),K.floatValue=this.getValue(J,"float",Q.floatValue),K.stringValue=this.getValue(J,"string",Q.stringValue),x.setFrame(u++,K)}i.push(x),a=Math.max(a,x.frames[x.getFrameCount()-1])}if(isNaN(a))throw new Error("Error while parsing animation, duration is NaN");n.animations.push(new $.Animation(e,i,a))},N.prototype.readCurve=function(t,e,n){if(t.curve)if("stepped"===t.curve)e.setStepped(n);else if("[object Array]"===Object.prototype.toString.call(t.curve)){var r=t.curve;e.setCurve(n,r[0],r[1],r[2],r[3])}},N.prototype.getValue=function(t,e,n){return void 0!==t[e]?t[e]:n},N.blendModeFromString=function(t){if("normal"==(t=t.toLowerCase()))return $.BlendMode.Normal;if("additive"==t)return $.BlendMode.Additive;if("multiply"==t)return $.BlendMode.Multiply;if("screen"==t)return $.BlendMode.Screen;throw new Error("Unknown blend mode: "+t)},N.positionModeFromString=function(t){if("fixed"==(t=t.toLowerCase()))return $.PositionMode.Fixed;if("percent"==t)return $.PositionMode.Percent;throw new Error("Unknown position mode: "+t)},N.spacingModeFromString=function(t){if("length"==(t=t.toLowerCase()))return $.SpacingMode.Length;if("fixed"==t)return $.SpacingMode.Fixed;if("percent"==t)return $.SpacingMode.Percent;throw new Error("Unknown position mode: "+t)},N.rotateModeFromString=function(t){if("tangent"==(t=t.toLowerCase()))return $.RotateMode.Tangent;if("chain"==t)return $.RotateMode.Chain;if("chainscale"==t)return $.RotateMode.ChainScale;throw new Error("Unknown rotate mode: "+t)},N.transformModeFromString=function(t){if("normal"==(t=t.toLowerCase()))return $.TransformMode.Normal;if("onlytranslation"==t)return $.TransformMode.OnlyTranslation;if("norotationorreflection"==t)return $.TransformMode.NoRotationOrReflection;if("noscale"==t)return $.TransformMode.NoScale;if("noscaleorreflection"==t)return $.TransformMode.NoScaleOrReflection;throw new Error("Unknown transform mode: "+t)},N}();$.SkeletonJson=t;var w=function(t,e,n,r){this.mesh=t,this.skin=e,this.slotIndex=n,this.parent=r}}(spine||(spine={})),function(t){var e=function(){function t(t){if(this.attachments=new Array,null==t)throw new Error("name cannot be null.");this.name=t}return t.prototype.addAttachment=function(t,e,n){if(null==n)throw new Error("attachment cannot be null.");var r=this.attachments;t>=r.length&&(r.length=t+1),r[t]||(r[t]={}),r[t][e]=n},t.prototype.getAttachment=function(t,e){var n=this.attachments[t];return n?n[e]:null},t.prototype.attachAll=function(t,e){for(var n=0,r=0;r<t.slots.length;r++){var i=t.slots[r],a=i.getAttachment();if(a&&n<e.attachments.length){var o=e.attachments[n];for(var s in o){if(a==o[s]){var h=this.getAttachment(n,s);null!=h&&i.setAttachment(h);break}}}n++}},t}();t.Skin=e}(spine||(spine={})),function(n){var t=function(){function t(t,e){if(this.attachmentVertices=new Array,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new n.Color,this.darkColor=null==t.darkColor?null:new n.Color,this.setToSetupPose()}return t.prototype.getAttachment=function(){return this.attachment},t.prototype.setAttachment=function(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.attachmentVertices.length=0)},t.prototype.setAttachmentTime=function(t){this.attachmentTime=this.bone.skeleton.time-t},t.prototype.getAttachmentTime=function(){return this.bone.skeleton.time-this.attachmentTime},t.prototype.setToSetupPose=function(){this.color.setFromColor(this.data.color),null!=this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),null==this.data.attachmentName?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))},t}();n.Slot=t}(spine||(spine={})),function(r){var t=function(t,e,n){if(this.color=new r.Color(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(null==e)throw new Error("name cannot be null.");if(null==n)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=n};r.SlotData=t}(spine||(spine={})),function(t){var e,n,r,i,a=function(){function t(t){this._image=t}return t.prototype.getImage=function(){return this._image},t.filterFromString=function(t){switch(t.toLowerCase()){case"nearest":return e.Nearest;case"linear":return e.Linear;case"mipmap":return e.MipMap;case"mipmapnearestnearest":return e.MipMapNearestNearest;case"mipmaplinearnearest":return e.MipMapLinearNearest;case"mipmapnearestlinear":return e.MipMapNearestLinear;case"mipmaplinearlinear":return e.MipMapLinearLinear;default:throw new Error("Unknown texture filter "+t)}},t.wrapFromString=function(t){switch(t.toLowerCase()){case"mirroredtepeat":return r.MirroredRepeat;case"clamptoedge":return r.ClampToEdge;case"repeat":return r.Repeat;default:throw new Error("Unknown texture wrap "+t)}},t}();t.Texture=a,(n=e=t.TextureFilter||(t.TextureFilter={}))[n.Nearest=9728]="Nearest",n[n.Linear=9729]="Linear",n[n.MipMap=9987]="MipMap",n[n.MipMapNearestNearest=9984]="MipMapNearestNearest",n[n.MipMapLinearNearest=9985]="MipMapLinearNearest",n[n.MipMapNearestLinear=9986]="MipMapNearestLinear",n[n.MipMapLinearLinear=9987]="MipMapLinearLinear",(i=r=t.TextureWrap||(t.TextureWrap={}))[i.MirroredRepeat=33648]="MirroredRepeat",i[i.ClampToEdge=33071]="ClampToEdge",i[i.Repeat=10497]="Repeat";var o=function(){this.u=0,this.v=0,this.u2=0,this.v2=0,this.width=0,this.height=0,this.rotate=!1,this.offsetX=0,this.offsetY=0,this.originalWidth=0,this.originalHeight=0};t.TextureRegion=o;var s=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return __extends(e,t),e.prototype.setFilters=function(t,e){},e.prototype.setWraps=function(t,e){},e.prototype.dispose=function(){},e}(t.Texture);t.FakeTexture=s}(spine||(spine={})),function(p){var t=function(){function t(t,e){this.pages=new Array,this.regions=new Array,this.load(t,e)}return t.prototype.load=function(t,e){if(null==e)throw new Error("textureLoader cannot be null.");for(var n=new f(t),r=new Array(4),i=null;;){var a=n.readLine();if(null==a)break;if(0==(a=a.trim()).length)i=null;else if(i){var o=new m;o.name=a,o.page=i,o.rotate="true"==n.readValue(),n.readTuple(r);var s=parseInt(r[0]),h=parseInt(r[1]);n.readTuple(r);var l=parseInt(r[0]),u=parseInt(r[1]);o.u=s/i.width,o.v=h/i.height,o.rotate?(o.u2=(s+u)/i.width,o.v2=(h+l)/i.height):(o.u2=(s+l)/i.width,o.v2=(h+u)/i.height),o.x=s,o.y=h,o.width=Math.abs(l),o.height=Math.abs(u),4==n.readTuple(r)&&4==n.readTuple(r)&&n.readTuple(r),o.originalWidth=parseInt(r[0]),o.originalHeight=parseInt(r[1]),n.readTuple(r),o.offsetX=parseInt(r[0]),o.offsetY=parseInt(r[1]),o.index=parseInt(n.readValue()),o.texture=i.texture,this.regions.push(o)}else{(i=new d).name=a,2==n.readTuple(r)&&(i.width=parseInt(r[0]),i.height=parseInt(r[1]),n.readTuple(r)),n.readTuple(r),i.minFilter=p.Texture.filterFromString(r[0]),i.magFilter=p.Texture.filterFromString(r[1]);var c=n.readValue();i.uWrap=p.TextureWrap.ClampToEdge,i.vWrap=p.TextureWrap.ClampToEdge,"x"==c?i.uWrap=p.TextureWrap.Repeat:"y"==c?i.vWrap=p.TextureWrap.Repeat:"xy"==c&&(i.uWrap=i.vWrap=p.TextureWrap.Repeat),i.texture=e(a),i.texture.setFilters(i.minFilter,i.magFilter),i.texture.setWraps(i.uWrap,i.vWrap),i.width=i.texture.getImage().width,i.height=i.texture.getImage().height,this.pages.push(i)}}},t.prototype.findRegion=function(t){for(var e=0;e<this.regions.length;e++)if(this.regions[e].name==t)return this.regions[e];return null},t.prototype.dispose=function(){for(var t=0;t<this.pages.length;t++)this.pages[t].texture.dispose()},t}();p.TextureAtlas=t;var f=function(){function t(t){this.index=0;var e=new RegExp(String.fromCharCode(13,10,124,13,124,10));this.lines=t.split(e)}return t.prototype.readLine=function(){return this.index>=this.lines.length?null:this.lines[this.index++]},t.prototype.readValue=function(){var t=this.readLine(),e=t.indexOf(":");if(-1==e)throw new Error("Invalid line: "+t);return t.substring(e+1).trim()},t.prototype.readTuple=function(t){var e=this.readLine(),n=e.indexOf(":");if(-1==n)throw new Error("Invalid line: "+e);for(var r=0,i=n+1;r<3;r++){var a=e.indexOf(",",i);if(-1==a)break;t[r]=e.substr(i,a-i).trim(),i=a+1}return t[r]=e.substring(i).trim(),r+1},t}(),d=function(){};p.TextureAtlasPage=d;var m=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return __extends(e,t),e}(p.TextureRegion);p.TextureAtlasRegion=m}(spine||(spine={})),function(P){var t=function(){function t(t,e){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new P.Vector2,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(var n=0;n<t.bones.length;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findBone(t.target.name)}return t.prototype.apply=function(){this.update()},t.prototype.update=function(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()},t.prototype.applyAbsoluteWorld=function(){for(var t=this.rotateMix,e=this.translateMix,n=this.scaleMix,r=this.shearMix,i=this.target,a=i.a,o=i.b,s=i.c,h=i.d,l=0<a*h-o*s?P.MathUtils.degRad:-P.MathUtils.degRad,u=this.data.offsetRotation*l,c=this.data.offsetShearY*l,p=this.bones,f=0,d=p.length;f<d;f++){var m=p[f],g=!1;if(0!=t){var v=m.a,y=m.b,x=m.c,w=m.d;(R=Math.atan2(s,a)-Math.atan2(x,v)+u)>P.MathUtils.PI?R-=P.MathUtils.PI2:R<-P.MathUtils.PI&&(R+=P.MathUtils.PI2),R*=t;var M=Math.cos(R),E=Math.sin(R);m.a=M*v-E*x,m.b=M*y-E*w,m.c=E*v+M*x,m.d=E*y+M*w,g=!0}if(0!=e){var T=this.temp;i.localToWorld(T.set(this.data.offsetX,this.data.offsetY)),m.worldX+=(T.x-m.worldX)*e,m.worldY+=(T.y-m.worldY)*e,g=!0}if(0<n){var A=Math.sqrt(m.a*m.a+m.c*m.c),b=Math.sqrt(a*a+s*s);1e-5<A&&(A=(A+(b-A+this.data.offsetScaleX)*n)/A),m.a*=A,m.c*=A,A=Math.sqrt(m.b*m.b+m.d*m.d),b=Math.sqrt(o*o+h*h),1e-5<A&&(A=(A+(b-A+this.data.offsetScaleY)*n)/A),m.b*=A,m.d*=A,g=!0}if(0<r){y=m.b,w=m.d;var R,I=Math.atan2(w,y);(R=Math.atan2(h,o)-Math.atan2(s,a)-(I-Math.atan2(m.c,m.a)))>P.MathUtils.PI?R-=P.MathUtils.PI2:R<-P.MathUtils.PI&&(R+=P.MathUtils.PI2),R=I+(R+c)*r;A=Math.sqrt(y*y+w*w);m.b=Math.cos(R)*A,m.d=Math.sin(R)*A,g=!0}g&&(m.appliedValid=!1)}},t.prototype.applyRelativeWorld=function(){for(var t=this.rotateMix,e=this.translateMix,n=this.scaleMix,r=this.shearMix,i=this.target,a=i.a,o=i.b,s=i.c,h=i.d,l=0<a*h-o*s?P.MathUtils.degRad:-P.MathUtils.degRad,u=this.data.offsetRotation*l,c=this.data.offsetShearY*l,p=this.bones,f=0,d=p.length;f<d;f++){var m=p[f],g=!1;if(0!=t){var v=m.a,y=m.b,x=m.c,w=m.d;(b=Math.atan2(s,a)+u)>P.MathUtils.PI?b-=P.MathUtils.PI2:b<-P.MathUtils.PI&&(b+=P.MathUtils.PI2),b*=t;var M=Math.cos(b),E=Math.sin(b);m.a=M*v-E*x,m.b=M*y-E*w,m.c=E*v+M*x,m.d=E*y+M*w,g=!0}if(0!=e){var T=this.temp;i.localToWorld(T.set(this.data.offsetX,this.data.offsetY)),m.worldX+=T.x*e,m.worldY+=T.y*e,g=!0}if(0<n){var A=(Math.sqrt(a*a+s*s)-1+this.data.offsetScaleX)*n+1;m.a*=A,m.c*=A,A=(Math.sqrt(o*o+h*h)-1+this.data.offsetScaleY)*n+1,m.b*=A,m.d*=A,g=!0}if(0<r){var b;(b=Math.atan2(h,o)-Math.atan2(s,a))>P.MathUtils.PI?b-=P.MathUtils.PI2:b<-P.MathUtils.PI&&(b+=P.MathUtils.PI2);y=m.b,w=m.d;b=Math.atan2(w,y)+(b-P.MathUtils.PI/2+c)*r;A=Math.sqrt(y*y+w*w);m.b=Math.cos(b)*A,m.d=Math.sin(b)*A,g=!0}g&&(m.appliedValid=!1)}},t.prototype.applyAbsoluteLocal=function(){var t=this.rotateMix,e=this.translateMix,n=this.scaleMix,r=this.shearMix,i=this.target;i.appliedValid||i.updateAppliedTransform();for(var a=this.bones,o=0,s=a.length;o<s;o++){var h=a[o];h.appliedValid||h.updateAppliedTransform();var l=h.arotation;if(0!=t){var u=i.arotation-l+this.data.offsetRotation;l+=(u-=360*(16384-(16384.499999999996-u/360|0)))*t}var c=h.ax,p=h.ay;0!=e&&(c+=(i.ax-c+this.data.offsetX)*e,p+=(i.ay-p+this.data.offsetY)*e);var f=h.ascaleX,d=h.ascaleY;0<n&&(1e-5<f&&(f=(f+(i.ascaleX-f+this.data.offsetScaleX)*n)/f),1e-5<d&&(d=(d+(i.ascaleY-d+this.data.offsetScaleY)*n)/d));var m=h.ashearY;if(0<r){u=i.ashearY-m+this.data.offsetShearY;u-=360*(16384-(16384.499999999996-u/360|0)),h.shearY+=u*r}h.updateWorldTransformWith(c,p,l,f,d,h.ashearX,m)}},t.prototype.applyRelativeLocal=function(){var t=this.rotateMix,e=this.translateMix,n=this.scaleMix,r=this.shearMix,i=this.target;i.appliedValid||i.updateAppliedTransform();for(var a=this.bones,o=0,s=a.length;o<s;o++){var h=a[o];h.appliedValid||h.updateAppliedTransform();var l=h.arotation;0!=t&&(l+=(i.arotation+this.data.offsetRotation)*t);var u=h.ax,c=h.ay;0!=e&&(u+=(i.ax+this.data.offsetX)*e,c+=(i.ay+this.data.offsetY)*e);var p=h.ascaleX,f=h.ascaleY;0<n&&(1e-5<p&&(p*=(i.ascaleX-1+this.data.offsetScaleX)*n+1),1e-5<f&&(f*=(i.ascaleY-1+this.data.offsetScaleY)*n+1));var d=h.ashearY;0<r&&(d+=(i.ashearY+this.data.offsetShearY)*r),h.updateWorldTransformWith(u,c,l,p,f,h.ashearX,d)}},t.prototype.getOrder=function(){return this.data.order},t}();P.TransformConstraint=t}(spine||(spine={})),function(t){var e=function(t){if(this.order=0,this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1,null==t)throw new Error("name cannot be null.");this.name=t};(spine||(spine={})).TransformConstraintData=e}(),function(t){var e=function(){function O(){this.convexPolygons=new Array,this.convexPolygonsIndices=new Array,this.indicesArray=new Array,this.isConcaveArray=new Array,this.triangles=new Array,this.polygonPool=new t.Pool(function(){return new Array}),this.polygonIndicesPool=new t.Pool(function(){return new Array})}return O.prototype.triangulate=function(t){for(var e=t,n=t.length>>1,r=this.indicesArray,i=r.length=0;i<n;i++)r[i]=i;for(var a=this.isConcaveArray,o=(i=a.length=0,n);i<o;++i)a[i]=O.isConcave(i,n,e,r);var s=this.triangles;for(s.length=0;3<n;){for(var h=n-1,l=(i=0,1);;){t:if(!a[i]){for(var u=r[h]<<1,c=r[i]<<1,p=r[l]<<1,f=e[u],d=e[u+1],m=e[c],g=e[c+1],v=e[p],y=e[p+1],x=(l+1)%n;x!=h;x=(x+1)%n)if(a[x]){var w=r[x]<<1,M=e[w],E=e[w+1];if(O.positiveArea(v,y,f,d,M,E)&&O.positiveArea(f,d,m,g,M,E)&&O.positiveArea(m,g,v,y,M,E))break t}break}if(0==l){do{if(!a[i])break;i--}while(0<i);break}h=i,l=((i=l)+1)%n}s.push(r[(n+i-1)%n]),s.push(r[i]),s.push(r[(i+1)%n]),r.splice(i,1),a.splice(i,1);var T=(--n+i-1)%n,A=i==n?0:i;a[T]=O.isConcave(T,n,e,r),a[A]=O.isConcave(A,n,e,r)}return 3==n&&(s.push(r[2]),s.push(r[0]),s.push(r[1])),s},O.prototype.decompose=function(t,e){var n=t,r=this.convexPolygons;this.polygonPool.freeAll(r),r.length=0;var i=this.convexPolygonsIndices;this.polygonIndicesPool.freeAll(i),i.length=0;var a=this.polygonIndicesPool.obtain();a.length=0;for(var o=this.polygonPool.obtain(),s=-1,h=o.length=0,l=0,u=e.length;l<u;l+=3){var c=e[l]<<1,p=e[l+1]<<1,f=e[l+2]<<1,d=n[c],m=n[c+1],g=n[p],v=n[p+1],y=n[f],x=n[f+1],w=!1;if(s==c){var M=o.length-4,E=O.winding(o[M],o[M+1],o[M+2],o[M+3],y,x),T=O.winding(y,x,o[0],o[1],o[2],o[3]);E==h&&T==h&&(o.push(y),o.push(x),a.push(f),w=!0)}w||(0<o.length?(r.push(o),i.push(a)):(this.polygonPool.free(o),this.polygonIndicesPool.free(a)),(o=this.polygonPool.obtain()).length=0,o.push(d),o.push(m),o.push(g),o.push(v),o.push(y),o.push(x),(a=this.polygonIndicesPool.obtain()).length=0,a.push(c),a.push(p),a.push(f),h=O.winding(d,m,g,v,y,x),s=c)}0<o.length&&(r.push(o),i.push(a));for(l=0,u=r.length;l<u;l++)if(0!=(a=i[l]).length)for(var A=a[0],b=a[a.length-1],R=(o=r[l])[M=o.length-4],I=o[M+1],P=o[M+2],S=o[M+3],C=o[0],V=o[1],k=o[2],N=o[3],_=O.winding(R,I,P,S,C,V),Y=0;Y<u;Y++)if(Y!=l){var X=i[Y];if(3==X.length){var D=X[0],U=X[1],F=X[2],L=r[Y];y=L[L.length-2],x=L[L.length-1];if(D==A&&U==b){E=O.winding(R,I,P,S,y,x),T=O.winding(y,x,C,V,k,N);E==_&&T==_&&(L.length=0,X.length=0,o.push(y),o.push(x),a.push(F),R=P,I=S,P=y,S=x,Y=0)}}}for(l=r.length-1;0<=l;l--)0==(o=r[l]).length&&(r.splice(l,1),this.polygonPool.free(o),a=i[l],i.splice(l,1),this.polygonIndicesPool.free(a));return r},O.isConcave=function(t,e,n,r){var i=r[(e+t-1)%e]<<1,a=r[t]<<1,o=r[(t+1)%e]<<1;return!this.positiveArea(n[i],n[i+1],n[a],n[a+1],n[o],n[o+1])},O.positiveArea=function(t,e,n,r,i,a){return 0<=t*(a-r)+n*(e-a)+i*(r-e)},O.winding=function(t,e,n,r,i,a){var o=n-t,s=r-e;return 0<=i*s-a*o+o*e-t*s?1:-1},O}();t.Triangulator=e}(spine||(spine={})),function(t){var e=function(){function t(){this.array=new Array}return t.prototype.add=function(t){var e=this.contains(t);return this.array[0|t]=0|t,!e},t.prototype.contains=function(t){return null!=this.array[0|t]},t.prototype.remove=function(t){this.array[0|t]=void 0},t.prototype.clear=function(){this.array.length=0},t}();t.IntSet=e;var n=function(){function t(t,e,n,r){void 0===t&&(t=0),void 0===e&&(e=0),void 0===n&&(n=0),void 0===r&&(r=0),this.r=t,this.g=e,this.b=n,this.a=r}return t.prototype.set=function(t,e,n,r){return this.r=t,this.g=e,this.b=n,this.a=r,this.clamp(),this},t.prototype.setFromColor=function(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this},t.prototype.setFromString=function(t){return t="#"==t.charAt(0)?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=(8!=t.length?255:parseInt(t.substr(6,2),16))/255,this},t.prototype.add=function(t,e,n,r){return this.r+=t,this.g+=e,this.b+=n,this.a+=r,this.clamp(),this},t.prototype.clamp=function(){return this.r<0?this.r=0:1<this.r&&(this.r=1),this.g<0?this.g=0:1<this.g&&(this.g=1),this.b<0?this.b=0:1<this.b&&(this.b=1),this.a<0?this.a=0:1<this.a&&(this.a=1),this},t.WHITE=new t(1,1,1,1),t.RED=new t(1,0,0,1),t.GREEN=new t(0,1,0,1),t.BLUE=new t(0,0,1,1),t.MAGENTA=new t(1,0,1,1),t}();t.Color=n;var r=function(){function n(){}return n.clamp=function(t,e,n){return t<e?e:n<t?n:t},n.cosDeg=function(t){return Math.cos(t*n.degRad)},n.sinDeg=function(t){return Math.sin(t*n.degRad)},n.signum=function(t){return 0<t?1:t<0?-1:0},n.toInt=function(t){return 0<t?Math.floor(t):Math.ceil(t)},n.cbrt=function(t){var e=Math.pow(Math.abs(t),1/3);return t<0?-e:e},n.randomTriangular=function(t,e){return n.randomTriangularWith(t,e,.5*(t+e))},n.randomTriangularWith=function(t,e,n){var r=Math.random(),i=e-t;return r<=(n-t)/i?t+Math.sqrt(r*i*(n-t)):e-Math.sqrt((1-r)*i*(e-n))},n.PI2=2*(n.PI=3.1415927),n.radDeg=n.radiansToDegrees=180/n.PI,n.degRad=n.degreesToRadians=n.PI/180,n}();t.MathUtils=r;var i=function(){function t(){}return t.prototype.apply=function(t,e,n){return t+(e-t)*this.applyInternal(n)},t}(),a=function(n){function t(t){var e=n.call(this)||this;return e.power=2,e.power=t,e}return __extends(t,n),t.prototype.applyInternal=function(t){return t<=.5?Math.pow(2*t,this.power)/2:Math.pow(2*(t-1),this.power)/(this.power%2==0?-2:2)+1},t}(t.Interpolation=i),o=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.applyInternal=function(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1},t}(t.Pow=a);t.PowOut=o;var s=function(){function r(){}return r.arrayCopy=function(t,e,n,r,i){for(var a=e,o=r;a<e+i;a++,o++)n[o]=t[a]},r.setArraySize=function(t,e,n){void 0===n&&(n=0);var r=t.length;if(r==e)return t;if(r<(t.length=e))for(var i=r;i<e;i++)t[i]=n;return t},r.ensureArrayCapacity=function(t,e,n){return void 0===n&&(n=0),t.length>=e?t:r.setArraySize(t,e,n)},r.newArray=function(t,e){for(var n=new Array(t),r=0;r<t;r++)n[r]=e;return n},r.newFloatArray=function(t){if(r.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);for(var e=new Array(t),n=0;n<e.length;n++)e[n]=0;return e},r.newShortArray=function(t){if(r.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);for(var e=new Array(t),n=0;n<e.length;n++)e[n]=0;return e},r.toFloatArray=function(t){return r.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t},r.toSinglePrecision=function(t){return r.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t},r.webkit602BugfixHelper=function(t,e){},r.SUPPORTS_TYPED_ARRAYS="undefined"!=typeof Float32Array,r}();t.Utils=s;var h=function(){function t(){}return t.logBones=function(t){for(var e=0;e<t.bones.length;e++){var n=t.bones[e];console.log(n.data.name+", "+n.a+", "+n.b+", "+n.c+", "+n.d+", "+n.worldX+", "+n.worldY)}},t}();t.DebugUtils=h;var l=function(){function t(t){this.items=new Array,this.instantiator=t}return t.prototype.obtain=function(){return 0<this.items.length?this.items.pop():this.instantiator()},t.prototype.free=function(t){t.reset&&t.reset(),this.items.push(t)},t.prototype.freeAll=function(t){for(var e=0;e<t.length;e++)t[e].reset&&t[e].reset(),this.items[e]=t[e]},t.prototype.clear=function(){this.items.length=0},t}();t.Pool=l;var u=function(){function t(t,e){void 0===t&&(t=0),void 0===e&&(e=0),this.x=t,this.y=e}return t.prototype.set=function(t,e){return this.x=t,this.y=e,this},t.prototype.length=function(){var t=this.x,e=this.y;return Math.sqrt(t*t+e*e)},t.prototype.normalize=function(){var t=this.length();return 0!=t&&(this.x/=t,this.y/=t),this},t}();t.Vector2=u;var c=function(){function t(){this.maxDelta=.064,this.framesPerSecond=0,this.delta=0,this.totalTime=0,this.lastTime=Date.now()/1e3,this.frameCount=0,this.frameTime=0}return t.prototype.update=function(){var t=Date.now()/1e3;this.delta=t-this.lastTime,this.frameTime+=this.delta,this.totalTime+=this.delta,this.delta>this.maxDelta&&(this.delta=this.maxDelta),this.lastTime=t,this.frameCount++,1<this.frameTime&&(this.framesPerSecond=this.frameCount/this.frameTime,this.frameTime=0,this.frameCount=0)},t}();t.TimeKeeper=c;var p=function(){function t(t){void 0===t&&(t=32),this.addedValues=0,this.lastValue=0,this.mean=0,this.dirty=!0,this.values=new Array(t)}return t.prototype.hasEnoughData=function(){return this.addedValues>=this.values.length},t.prototype.addValue=function(t){this.addedValues<this.values.length&&this.addedValues++,this.values[this.lastValue++]=t,this.lastValue>this.values.length-1&&(this.lastValue=0),this.dirty=!0},t.prototype.getMean=function(){if(this.hasEnoughData()){if(this.dirty){for(var t=0,e=0;e<this.values.length;e++)t+=this.values[e];this.mean=t/this.values.length,this.dirty=!1}return this.mean}return 0},t}();t.WindowedMean=p}(spine||(spine={})),function(){var e;Math.fround||(Math.fround=(e=new Float32Array(1),function(t){return e[0]=t,e[0]}))}(),function(t){var e=function(t){if(null==t)throw new Error("name cannot be null.");this.name=t},n=function(n){function r(t){var e=n.call(this,t)||this;return e.id=(65535&r.nextID++)<<11,e.worldVerticesLength=0,e}return __extends(r,n),r.prototype.computeWorldVertices=function(t,e,n,r,i,a){n=i+(n>>1)*a;var o=t.bone.skeleton,s=t.attachmentVertices,h=this.vertices,l=this.bones;if(null!=l){for(var u=0,c=0,p=0;p<e;p+=2){u+=(g=l[u])+1,c+=g}var f=o.bones;if(0==s.length)for(P=i,A=3*c;P<n;P+=a){var d=0,m=0,g=l[u++];for(g+=u;u<g;u++,A+=3){w=f[l[u]],S=h[A],C=h[A+1];var v=h[A+2];d+=(S*w.a+C*w.b+w.worldX)*v,m+=(S*w.c+C*w.d+w.worldY)*v}r[P]=d,r[P+1]=m}else for(var y=s,x=(P=i,A=3*c,c<<1);P<n;P+=a){d=0,m=0,g=l[u++];for(g+=u;u<g;u++,A+=3,x+=2){w=f[l[u]],S=h[A]+y[x],C=h[A+1]+y[x+1],v=h[A+2];d+=(S*w.a+C*w.b+w.worldX)*v,m+=(S*w.c+C*w.d+w.worldY)*v}r[P]=d,r[P+1]=m}}else{0<s.length&&(h=s);for(var w,M=(w=t.bone).worldX,E=w.worldY,T=w.a,A=w.b,b=w.c,R=w.d,I=e,P=i;P<n;I+=2,P+=a){var S=h[I],C=h[I+1];r[P]=S*T+C*A+M,r[P+1]=S*b+C*R+E}}},r.prototype.applyDeform=function(t){return this==t},r.nextID=0,r}(t.Attachment=e);t.VertexAttachment=n}(spine||(spine={})),function(t){var e;(e=t.AttachmentType||(t.AttachmentType={}))[e.Region=0]="Region",e[e.BoundingBox=1]="BoundingBox",e[e.Mesh=2]="Mesh",e[e.LinkedMesh=3]="LinkedMesh",e[e.Path=4]="Path",e[e.Point=5]="Point"}(spine||(spine={})),function(r){var t=function(n){function t(t){var e=n.call(this,t)||this;return e.color=new r.Color(1,1,1,1),e}return __extends(t,n),t}(r.VertexAttachment);r.BoundingBoxAttachment=t}(spine||(spine={})),function(r){var t=function(n){function t(t){var e=n.call(this,t)||this;return e.color=new r.Color(.2275,.2275,.8078,1),e}return __extends(t,n),t}(r.VertexAttachment);r.ClippingAttachment=t}(spine||(spine={})),function(h){var t=function(n){function t(t){var e=n.call(this,t)||this;return e.color=new h.Color(1,1,1,1),e.inheritDeform=!1,e.tempColor=new h.Color(0,0,0,0),e}return __extends(t,n),t.prototype.updateUVs=function(){var t=0,e=0,n=0,r=0;null==this.region?(t=e=0,n=r=1):(t=this.region.u,e=this.region.v,n=this.region.u2-t,r=this.region.v2-e);var i=this.regionUVs;null!=this.uvs&&this.uvs.length==i.length||(this.uvs=h.Utils.newFloatArray(i.length));var a=this.uvs;if(this.region.rotate)for(var o=0,s=a.length;o<s;o+=2)a[o]=t+i[o+1]*n,a[o+1]=e+r-i[o]*r;else for(o=0,s=a.length;o<s;o+=2)a[o]=t+i[o]*n,a[o+1]=e+i[o+1]*r},t.prototype.applyDeform=function(t){return this==t||this.inheritDeform&&this.parentMesh==t},t.prototype.getParentMesh=function(){return this.parentMesh},t.prototype.setParentMesh=function(t){null!=(this.parentMesh=t)&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)},t}(h.VertexAttachment);h.MeshAttachment=t}(spine||(spine={})),function(r){var t=function(n){function t(t){var e=n.call(this,t)||this;return e.closed=!1,e.constantSpeed=!1,e.color=new r.Color(1,1,1,1),e}return __extends(t,n),t}(r.VertexAttachment);r.PathAttachment=t}(spine||(spine={})),function(a){var t=function(n){function t(t){var e=n.call(this,t)||this;return e.color=new a.Color(.38,.94,0,1),e}return __extends(t,n),t.prototype.computeWorldPosition=function(t,e){return e.x=this.x*t.a+this.y*t.b+t.worldX,e.y=this.x*t.c+this.y*t.d+t.worldY,e},t.prototype.computeWorldRotation=function(t){var e=a.MathUtils.cosDeg(this.rotation),n=a.MathUtils.sinDeg(this.rotation),r=e*t.a+n*t.b,i=e*t.c+n*t.d;return Math.atan2(i,r)*a.MathUtils.radDeg},t}(a.VertexAttachment);a.PointAttachment=t}(spine||(spine={})),function(r){var t=function(n){function y(t){var e=n.call(this,t)||this;return e.x=0,e.y=0,e.scaleX=1,e.scaleY=1,e.rotation=0,e.width=0,e.height=0,e.color=new r.Color(1,1,1,1),e.offset=r.Utils.newFloatArray(8),e.uvs=r.Utils.newFloatArray(8),e.tempColor=new r.Color(1,1,1,1),e}return __extends(y,n),y.prototype.updateOffset=function(){var t=this.width/this.region.originalWidth*this.scaleX,e=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*t,r=-this.height/2*this.scaleY+this.region.offsetY*e,i=n+this.region.width*t,a=r+this.region.height*e,o=this.rotation*Math.PI/180,s=Math.cos(o),h=Math.sin(o),l=n*s+this.x,u=n*h,c=r*s+this.y,p=r*h,f=i*s+this.x,d=i*h,m=a*s+this.y,g=a*h,v=this.offset;v[y.OX1]=l-p,v[y.OY1]=c+u,v[y.OX2]=l-g,v[y.OY2]=m+u,v[y.OX3]=f-g,v[y.OY3]=m+d,v[y.OX4]=f-p,v[y.OY4]=c+d},y.prototype.setRegion=function(t){this.region=t;var e=this.uvs;t.rotate?(e[2]=t.u,e[3]=t.v2,e[4]=t.u,e[5]=t.v,e[6]=t.u2,e[7]=t.v,e[0]=t.u2,e[1]=t.v2):(e[0]=t.u,e[1]=t.v2,e[2]=t.u,e[3]=t.v,e[4]=t.u2,e[5]=t.v,e[6]=t.u2,e[7]=t.v2)},y.prototype.computeWorldVertices=function(t,e,n,r){var i=this.offset,a=t.worldX,o=t.worldY,s=t.a,h=t.b,l=t.c,u=t.d,c=0,p=0;c=i[y.OX1],p=i[y.OY1],e[n]=c*s+p*h+a,e[n+1]=c*l+p*u+o,n+=r,c=i[y.OX2],p=i[y.OY2],e[n]=c*s+p*h+a,e[n+1]=c*l+p*u+o,n+=r,c=i[y.OX3],p=i[y.OY3],e[n]=c*s+p*h+a,e[n+1]=c*l+p*u+o,n+=r,c=i[y.OX4],p=i[y.OY4],e[n]=c*s+p*h+a,e[n+1]=c*l+p*u+o},y.OX1=0,y.OY1=1,y.OX2=2,y.OY2=3,y.OX3=4,y.OY3=5,y.OX4=6,y.OY4=7,y.X1=0,y.Y1=1,y.C1R=2,y.C1G=3,y.C1B=4,y.C1A=5,y.U1=6,y.V1=7,y.X2=8,y.Y2=9,y.C2R=10,y.C2G=11,y.C2B=12,y.C2A=13,y.U2=14,y.V2=15,y.X3=16,y.Y3=17,y.C3R=18,y.C3G=19,y.C3B=20,y.C3A=21,y.U3=22,y.V3=23,y.X4=24,y.Y4=25,y.C4R=26,y.C4G=27,y.C4B=28,y.C4A=29,y.U4=30,y.V4=31,y}(r.Attachment);r.RegionAttachment=t}(spine||(spine={})),function(i){var t=function(){function t(t,e){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=e}return t.prototype.begin=function(t){},t.prototype.transform=function(t,e,n,r){t.x+=i.MathUtils.randomTriangular(-this.jitterX,this.jitterY),t.y+=i.MathUtils.randomTriangular(-this.jitterX,this.jitterY)},t.prototype.end=function(){},t}();i.JitterEffect=t}(spine||(spine={})),function(p){var t=function(){function c(t){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=t}return c.prototype.begin=function(t){this.worldX=t.x+this.centerX,this.worldY=t.y+this.centerY},c.prototype.transform=function(t,e,n,r){var i=this.angle*p.MathUtils.degreesToRadians,a=t.x-this.worldX,o=t.y-this.worldY,s=Math.sqrt(a*a+o*o);if(s<this.radius){var h=c.interpolation.apply(0,i,(this.radius-s)/this.radius),l=Math.cos(h),u=Math.sin(h);t.x=l*a-u*o+this.worldX,t.y=u*a+l*o+this.worldY}},c.prototype.end=function(){},c.interpolation=new p.PowOut(2),c}();p.SwirlEffect=t}(spine||(spine={}));',
'files/assets/18555968/1/ClaimButton.js': 'var ClaimButton=pc.createScript("claimButton");ClaimButton.attributes.add("boundingBoxHalfSize",{type:"vec3"}),ClaimButton.attributes.add("cameraEntity",{type:"entity"}),ClaimButton.prototype.initialize=function(){this.setupBoundingBox(),this.subscribeToInputEvents(),this.startAnimation()},ClaimButton.prototype.setupBoundingBox=function(){this.box=new pc.BoundingBox(this.entity.getPosition(),this.boundingBoxHalfSize),addDebugBoundingBox(this.box)},ClaimButton.prototype.startAnimation=function(){var t=new pc.Vec3(0,0,-1),o=new pc.Vec3(0,0,1);this.anim=this.entity.tween(t).rotate(o,.1,pc.BounceInOut).on("update",function(){this.entity.setLocalEulerAngles(t.x,t.y,t.z)}.bind(this)).loop(!0).yoyo(!0).start()},ClaimButton.prototype.subscribeToInputEvents=function(){var t=this.app.touch;if(t)t.on(pc.EVENT_TOUCHSTART,this.onTouchDown,this);else{var o=this.app.mouse;o&&o.on(pc.EVENT_MOUSEDOWN,this.onMouseDown,this)}},ClaimButton.prototype.onTouchDown=function(t){0<t.touches.length&&this.checkPressed(t.touches[0].x,t.touches[0].y)},ClaimButton.prototype.onMouseDown=function(t){this.checkPressed(t.x,t.y)},ClaimButton.prototype.checkPressed=function(t,o){var i=new pc.Vec3;this.cameraEntity.camera.screenToWorld(t,o,20,i),this.box.intersectsRay(new pc.Ray(i,this.entity.forward))&&this.onPressed()},ClaimButton.prototype.onPressed=function(){if(this.anim&&this.anim.stop(),window.FbPlayableAd)FbPlayableAd.onCTAClick();else{if(window.mraid){var t=navigator.userAgent||navigator.vendor;if(/android/i.test(t))return void window.mraid.open("https://play.google.com/store/apps/details?id=com.creativemobile.zc");if(/iPad|iPhone|iPod/i.test(t))return void window.mraid.open("https://itunes.apple.com/us/app/zoocraft-animal-family/id1247409901?mt=8")}window.open("https://play.google.com/store/apps/details?id=com.creativemobile.zc","_blank")}};',
'files/assets/18563311/1/BounceAnimation.js': 'var BounceAnimation=pc.createScript("bounceAnimation");BounceAnimation.prototype.initialize=function(){this.entity.getLocalPosition().clone();var t=this.entity.getLocalPosition().clone();t.y+=.5,this.entity.tween(this.entity.getLocalPosition()).to(t,.5,pc.SineOut).loop(!0).yoyo(!0).start();var i=this.entity.getLocalScale(),e=new pc.Vec3(i.x,.9*i.y,i.z),o=i.clone();this.entity.setLocalScale(e),this.entity.tween(this.entity.getLocalScale()).to(o,.5,pc.SineOut).loop(!0).yoyo(!0).start()};',
'files/assets/18581363/1/BounceOnTapAnimation.js': 'var BounceOntapAnimation=pc.createScript("bounceOntapAnimation");BounceOntapAnimation.attributes.add("boundingBoxHalfSize",{type:"vec3"}),BounceOntapAnimation.attributes.add("boundingBoxOffset",{type:"vec3"}),BounceOntapAnimation.attributes.add("scaleCoefs",{type:"vec3"});',
'files/assets/18581368/1/BounceOnTapAnimationController.js': 'var BounceOntapAnimationController=pc.createScript("bounceOntapAnimationController");BounceOntapAnimationController.attributes.add("anims",{type:"entity",array:!0}),BounceOntapAnimationController.attributes.add("cameraEntity",{type:"entity"}),BounceOntapAnimationController.prototype.initialize=function(){for(var n=0;n<this.anims.length;n++){var t=this.anims[n];t.initScale=t.getLocalScale().clone();var o=t.script.bounceOntapAnimation.scaleCoefs;t.onTapScale=new pc.Vec3(t.initScale.x*o.x,t.initScale.y*o.y,t.initScale.z*o.z),this.setupBoundingBox(t)}this.subscribeToInputEvents(),this.app.on("game:finish",this.onGameFinished.bind(this)),this.active=!0},BounceOntapAnimationController.prototype.onGameFinished=function(){this.active=!1},BounceOntapAnimationController.prototype.setupBoundingBox=function(n){var t=n.getPosition(),o=n.script.bounceOntapAnimation.boundingBoxOffset,e=new pc.Vec3(t.x+o.x,t.y+o.y,t.z+o.z);n.box=new pc.BoundingBox(e,n.script.bounceOntapAnimation.boundingBoxHalfSize)},BounceOntapAnimationController.prototype.subscribeToInputEvents=function(){var n=this.app.touch;if(n)return n.on(pc.EVENT_TOUCHSTART,this.onTouchDown,this),void n.on(pc.EVENT_TOUCHEND,this.onTouchUp,this);var t=this.app.mouse;t&&(t.on(pc.EVENT_MOUSEDOWN,this.onMouseDown,this),t.on(pc.EVENT_MOUSEUP,this.onMouseUp,this))},BounceOntapAnimationController.prototype.onTouchDown=function(n){0<n.touches.length&&this.checkPressed(n.touches[0].x,n.touches[0].y)},BounceOntapAnimationController.prototype.onTouchUp=function(n){this.checkUnpressed()},BounceOntapAnimationController.prototype.onMouseDown=function(n){this.checkPressed(n.x,n.y)},BounceOntapAnimationController.prototype.onMouseUp=function(n){this.checkUnpressed()},BounceOntapAnimationController.prototype.checkPressed=function(n,t){if(this.active){var o=new pc.Vec3;this.cameraEntity.camera.screenToWorld(n,t,20,o);for(var e=0;e<this.anims.length;e++){if(this.anims[e].box.intersectsRay(new pc.Ray(o,this.entity.forward))){this.onPressed(this.anims[e]);break}}}},BounceOntapAnimationController.prototype.checkUnpressed=function(){this.active&&this.pressedEntity&&this.onUnpressed(this.pressedEntity)},BounceOntapAnimationController.prototype.onPressed=function(n){(this.pressedEntity=n).unpressAnim&&(n.unpressAnim.stop(),n.unpressAnim=void 0);var t=n.initScale.clone(),o=n.onTapScale.clone();n.setLocalScale(t),n.tween(n.getLocalScale()).to(o,.08,pc.ElasticOut).start()},BounceOntapAnimationController.prototype.onUnpressed=function(n){this.pressedEntity=void 0;var t=n.initScale.clone();n.unpressAnim=n.tween(n.getLocalScale()).to(t,.6,pc.ElasticOut).start()};',
'files/assets/18624306/1/RewardScreen.js': 'var RewardScreen=pc.createScript("rewardScreen");RewardScreen.attributes.add("particles",{type:"entity",array:!0}),RewardScreen.attributes.add("repeatParticlesDelay",{type:"number",default:1}),RewardScreen.attributes.add("particleXOffset",{type:"number",default:1}),RewardScreen.attributes.add("particleYOffset",{type:"number",default:1}),RewardScreen.prototype.initialize=function(){this.show();for(var t=0;t<this.particles.length;t++){var e=this.particles[t];e.startPos=e.getLocalPosition().clone()}this.startParticles()},RewardScreen.prototype.show=function(){var t=new pc.Vec3;this.entity.setLocalScale(t),this.entity.tween(this.entity.getLocalScale()).to(new pc.Vec3(1,1,1),1.5,pc.ElasticOut).delay(1).start()},RewardScreen.prototype.invokeWithDelay=function(t,e){this.delayTween=this.app.tween({}).to({},t,pc.Linear).on("complete",function(){e()}.bind(this)).start()},RewardScreen.prototype.startParticles=function(){for(var t=pc.math.random(-this.particleXOffset,this.particleXOffset),e=pc.math.random(-this.particleYOffset,this.particleYOffset),a=0;a<this.particles.length;a++){var r=this.particles[a],i=r.startPos;r.setLocalPosition(new pc.Vec3(i.x+t,i.y+e,i.z));var s=r.particlesystem;s.reset(),s.play()}this.invokeWithDelay(this.repeatParticlesDelay,this.startParticles.bind(this))};',
}
function getScriptSrcByKey(key) {
 return strScripts[key];
}
var strJSONs ={
'files/assets/18515965/1/species-matamata.json': '{"skeleton":{"hash":"wA1I/BUg6BszJXalQIpjQOoPt7g","spine":"3.5.51","width":567.31,"height":331.3,"images":"./images/"},"bones":[{"name":"root"},{"name":"bone","parent":"root","length":39.12,"rotation":-32.2,"x":24.5,"y":-10},{"name":"bone2","parent":"root","length":44.72,"rotation":-36.23,"x":-126.15,"y":-1.2,"scaleX":0.774,"scaleY":0.774},{"name":"bone3","parent":"root","length":28.8,"rotation":-32.56,"x":185.3,"y":41.89,"scaleX":1.163},{"name":"matamata-top","parent":"root","length":126.1,"rotation":-87.75,"x":-9.03,"y":153.99},{"name":"matamata-neck","parent":"matamata-top","length":45.78,"rotation":41.66,"x":81.01,"y":74.88},{"name":"bone4","parent":"matamata-neck","length":31.25,"rotation":40.9,"x":99.7,"y":2.88},{"name":"bone5","parent":"bone4","length":12.46,"rotation":39.85,"x":82.93,"y":23.97},{"name":"matamata-head","parent":"bone5","length":104.33,"rotation":-67.46,"x":45.26,"y":37.28},{"name":"matamata-brow","parent":"matamata-head","length":78.79,"rotation":-113.79,"x":28.94,"y":40.04},{"name":"matamata-eyeball1","parent":"matamata-head","x":35.99,"y":-49.48},{"name":"matamata-eyeball2","parent":"matamata-head","x":69.76,"y":34.23},{"name":"matamata-hand1","parent":"matamata-top","length":61.03,"rotation":-20.31,"x":91.19,"y":28.44},{"name":"matamata-hand2","parent":"matamata-top","length":62.3,"rotation":16.36,"x":37.77,"y":144.37},{"name":"matamata-leg1","parent":"matamata-top","length":65.15,"rotation":-19.91,"x":67.66,"y":-111.75},{"name":"matamata-leg2","parent":"matamata-top","length":66.37,"rotation":3.6,"x":8.66,"y":16.67},{"name":"matamata-ltongue","parent":"matamata-head","length":97.26,"rotation":2.25,"x":17.27,"y":-30.52},{"name":"matamata-pupil","parent":"matamata-eyeball1","x":0.82,"y":10.46},{"name":"matamata-pupil2","parent":"matamata-eyeball2","x":-1.97,"y":9.85}],"slots":[{"name":"matamata-elipse","bone":"root","attachment":"matamata-elipse"},{"name":"matamata-leg2","bone":"matamata-leg2","attachment":"matamata-leg2"},{"name":"matamata-leg1","bone":"matamata-leg1","attachment":"matamata-leg1"},{"name":"matamata-hand2","bone":"matamata-hand2","attachment":"matamata-hand2"},{"name":"matamata-hand1","bone":"matamata-hand1","attachment":"matamata-hand1"},{"name":"matamata-neck","bone":"matamata-neck","attachment":"matamata-neck"},{"name":"matamata-beads","bone":"bone4","attachment":"matamata-beads"},{"name":"matamata-top","bone":"matamata-top","attachment":"matamata-top"},{"name":"matamata-ltongue","bone":"matamata-ltongue","attachment":"matamata-ltongue"},{"name":"matamata-head","bone":"matamata-head","attachment":"matamata-head"},{"name":"matamata-bow","bone":"matamata-head","attachment":"matamata-bow"},{"name":"matamata-brow","bone":"matamata-brow","attachment":"matamata-brow"},{"name":"matamata-eyeball1","bone":"matamata-eyeball1","attachment":"matamata-eyeball1"},{"name":"matamata-eyeball2","bone":"matamata-eyeball2","attachment":"matamata-eyeball1"},{"name":"matamata-pupil","bone":"matamata-pupil","attachment":"matamata-pupil"},{"name":"matamata-pupil2","bone":"matamata-pupil2","attachment":"matamata-pupil"}],"skins":{"default":{"matamata-beads":{"matamata-beads":{"x":42.39,"y":9.46,"scaleX":2.152,"scaleY":2.152,"rotation":-15.91,"width":19,"height":46}},"matamata-bow":{"matamata-bow":{"x":-24.39,"y":29.44,"scaleX":2.974,"scaleY":2.974,"rotation":12.49,"width":37,"height":38}},"matamata-brow":{"matamata-brow":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0,0.25629,0.59434,0.34097,0.78053,0.63733,0.19611,0.74124,0.43401],"triangles":[6,2,3,7,6,3,4,2,6,4,6,7,5,4,7,1,2,4,1,4,5,7,3,0,5,7,0,1,5,0],"vertices":[15.83,53.04,87.62,5.69,52.38,-47.74,-19.41,-0.39,54.92,-3.85,55.4,10.11,13.53,-7.08,14.46,10.55],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":26,"height":20}},"matamata-elipse":{"matamata-elipse":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0],"triangles":[1,2,3,1,3,0],"vertices":[274.22,-89.81,-206.83,-87.1,-205.68,117.59,275.37,114.89],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":39,"height":20}},"matamata-eyeball1":{"matamata-eyeball1":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0],"triangles":[1,2,3,1,3,0],"vertices":[24.54,-0.48,-8.26,-21.59,-19.75,6.09,1.8,34.84],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":12,"height":13}},"matamata-eyeball2":{"matamata-eyeball1":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0],"triangles":[1,2,3,1,3,0],"vertices":[23.39,-0.74,-7.9,-20.89,-20.9,5.03,1.55,32.19],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":12,"height":13}},"matamata-hand1":{"matamata-hand1":{"type":"mesh","uvs":[1,1,0,1,0,0.78978,0,0.57243,0,0.41631,0,0,1,0,0.50272,0.64284,0.48789,0.54488,0.51261,0.42855,0.80931,0.91835],"triangles":[1,10,0,1,7,10,10,6,0,1,2,7,7,9,10,7,2,3,10,9,6,7,3,8,7,8,9,3,4,8,8,4,9,6,9,5,9,4,5],"vertices":[1,1,75.39,-16.3,1,1,1,-1.62,-64.81,1,2,12,120.8,-5.8,0.10799,1,-18.1,-38.65,0.89201,2,12,90.42,-15.7,0.81376,1,-35.13,-11.62,0.18624,1,12,68.6,-22.81,1,2,12,10.41,-41.77,1,1,-79.99,59.6,0,1,12,-17.78,44.75,1,2,12,86.08,31,0.44172,1,9.1,4.01,0.55828,2,12,72.81,25.26,0.6535,1,0.28,15.48,0.3465,2,12,55.86,22.1,0.86475,1,-6.93,31.15,0.13525,2,12,115.95,70.08,0.00011,1,54.3,-15.39,0.99989],"hull":7,"edges":[0,2,10,12,0,12,8,10,6,8,2,4,4,6],"width":27,"height":45}},"matamata-hand2":{"matamata-hand2":{"type":"mesh","uvs":[1,0.81718,1,1,0.52784,1,0,1,0,0,1,0,0.21428,0.69333,0.63333,0.62667,0.61428,0.51333,0.61428,0.37333,0.24286,0.56,0.22381,0.41333,0.82525,0.92971],"triangles":[0,7,8,12,7,0,2,7,12,2,6,7,3,6,2,12,0,1,2,12,1,9,4,5,11,4,9,0,8,9,11,9,8,10,11,8,11,3,4,6,11,10,5,0,9,6,3,11,10,7,6,7,10,8],"vertices":[2,13,130.84,40.79,0.05172,3,43.65,18.33,0.94828,1,3,54.4,-6.07,1,1,3,16.45,-28.69,1,2,13,113.13,-66.27,0.03183,3,-25.97,-53.96,0.96817,2,13,-23.87,-5.2,1,3,-84.8,79.54,0,1,13,18.89,90.7,1,2,13,80.28,-26.99,0.49736,3,-26.79,-2.76,0.50264,2,13,89.06,17.27,0.3799,3,2.97,26.21,0.6201,2,13,72.72,22.36,0.82174,3,-5.23,40.42,0.17826,2,13,53.54,30.91,0.94525,3,-13.47,59.11,0.05475,2,13,63.24,-16.11,0.86178,3,-32.34,16.41,0.13822,2,13,42.33,-8.98,0.99696,3,-42.5,35.07,0.00304,1,3,36.22,-5.06,1],"hull":6,"edges":[6,8,8,10,2,4,4,6,2,0,0,10],"width":31,"height":46}},"matamata-head":{"matamata-head":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0,0.55625,0.39394,0.77386,0.58966,0.92619,0.70709,0.93163,0.07368,0.34136,0.09147],"triangles":[3,8,2,7,8,3,4,8,7,5,4,7,6,5,7,1,2,8,1,8,4,3,0,6,6,7,3,5,6,0,1,4,5,0,1,5],"vertices":[160.04,-27.76,-0.52,-131.21,-79.6,-8.48,80.96,94.97,40.86,0.72,91.28,-0.79,125.02,0.55,75.81,78.86,-17.56,15.61],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":54,"height":41}},"matamata-leg1":{"matamata-leg1":{"type":"mesh","uvs":[1,0.78354,1,1,0.50767,1,0,1,0,0.77146,0,0.69294,0,0.56609,0,0.32448,0,0,1,0,0.72525,0.67482,0.7203,0.59629,0.66096,0.48757,0.69063,0.36072,0.81921,0.92851,0.30987,0.61441],"triangles":[2,14,1,14,0,1,3,15,2,2,10,14,10,15,11,15,10,2,3,4,15,14,10,0,4,5,15,0,10,11,11,15,12,9,0,13,5,6,15,13,12,15,12,13,11,0,11,13,15,6,7,13,15,7,9,13,8,13,7,8],"vertices":[2,14,88.01,70.49,0.1285,2,64.23,37.36,0.8715,1,2,86.75,-4.72,1,1,2,42.16,-30.5,1,1,2,-15.81,-62.34,1,2,14,107.95,-19.13,0.16186,2,-37.37,-23.96,0.83814,2,14,96.45,-21.31,0.37926,2,-44.78,-10.78,0.62074,2,14,77.88,-24.84,0.8033,2,-56.75,10.52,0.1967,1,14,42.52,-31.55,1,1,14,-4.98,-40.57,1,1,14,-21.96,48.83,1,2,14,81.49,43.02,0.25677,2,27.89,34.05,0.74323,2,14,70.08,40.4,0.42735,2,19.97,46.95,0.57265,2,14,55.17,32.07,0.81711,2,3.63,61.79,0.18289,2,14,36.1,31.2,0.95298,2,-5.29,84.8,0.04702,2,14,117.03,58.48,0.00041,2,61.46,-3.14,0.99959,2,14,83.05,3,0.65215,2,-20.51,15.66,0.34785],"hull":10,"edges":[16,18,14,16,12,14,10,12,6,8,8,10,2,4,4,6,2,0,0,18],"width":27,"height":45}},"matamata-leg2":{"matamata-leg2":{"x":51.17,"y":8.83,"rotation":84.14,"width":27,"height":44}},"matamata-ltongue":{"matamata-ltongue":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0],"triangles":[1,2,3,1,3,0],"vertices":[129.86,-7.59,-16.57,-93.95,-78.04,10.27,68.39,96.63],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":51,"height":37}},"matamata-neck":{"matamata-neck":{"type":"mesh","uvs":[1,0.54988,1,0.61912,1,1,0.46878,1,0.41865,1,0.3594,1,0,1,0,0.49498,0,0,1,0,0.52195,0.47941,0.45663,0.74088,0.55082,0.51461,0.49309,0.4417,0.7752,0.48781,0.80261,0.46633,0.81848,0.62867,0.88483,0.79816,0.86031,0.83159,0.83723,0.86024,0.75212,0.51646,0.89493,0.31831,0.90936,0.28012,0.44774,0.12971,0.45495,0.07242,0.44918,0.19895,0.03373,0.60957,0.13903,0.82681],"triangles":[22,24,9,21,25,22,15,13,25,21,15,25,14,10,13,15,14,13,12,10,14,20,12,14,22,9,0,21,22,0,15,21,0,16,15,0,1,16,0,14,15,16,20,14,16,17,16,1,18,16,17,19,16,18,16,12,20,19,11,16,17,1,2,18,17,2,19,18,2,3,19,2,11,26,13,11,13,10,11,10,12,5,27,11,16,11,12,4,5,11,19,3,11,4,11,3,24,8,9,23,8,24,22,25,23,22,23,24,25,7,8,25,8,23,7,25,13,26,7,13,27,26,11,6,7,26,6,26,27,6,27,5],"vertices":[3,5,168.01,113.8,0.00013,6,124.24,39.1,0,7,41.41,-14.84,0.99987,1,7,35.82,-22.93,1,2,6,130.01,-24.54,0.01613,7,5.07,-67.41,0.98387,2,5,127.47,-20.46,0.02025,6,5.71,-35.82,0.97975,2,5,119.3,-28.95,0.08277,6,-6.02,-36.89,0.91723,2,5,109.65,-38.98,0.21315,6,-19.89,-38.15,0.78685,2,5,51.07,-99.82,0.81776,6,-103.99,-45.78,0.18224,2,5,-0.59,-50.08,0.98021,6,-110.47,25.63,0.01979,1,5,-51.23,-1.34,1,2,5,111.76,167.96,0.02923,7,85.8,49.38,0.97077,3,5,82.89,39.81,0.40021,6,11.47,38.92,0.41427,7,-45.3,57.25,0.18552,1,6,-0.46,0.56,1,3,5,91.19,41.23,0.18505,6,18.68,34.55,0.66607,7,-42.56,49.28,0.14889,3,5,74.32,38.64,0.40021,6,4.23,43.63,0.41427,7,-47.83,65.51,0.18552,3,5,125.02,81.86,0.03341,6,70.84,43.11,0.05388,7,2.97,22.44,0.91272,3,5,127.29,88.62,0.03341,6,76.98,46.73,0.05388,7,10,21.28,0.91272,1,7,-0.04,0.2,1,2,6,100.47,1.55,0.03774,7,-0.89,-28.46,0.96226,2,6,95.17,-3.7,0.12903,7,-8.33,-29.08,0.87097,2,6,90.13,-8.24,0.12903,7,-15.1,-29.35,0.87097,3,5,124.19,75.13,0.02511,6,65.8,38.56,0.10178,7,-3.8,22.17,0.87311,3,5,127.2,118.82,0.02198,6,96.68,69.61,0.00302,7,39.79,26.24,0.97501,3,5,125.64,125.03,0.02305,6,99.57,75.32,0.00003,7,45.67,28.77,0.97692,3,5,35.02,61.69,0.7227,6,-10.38,86.79,0.07537,7,-31.41,108,0.20193,3,5,30.33,68.55,0.7227,6,-9.43,95.04,0.07537,7,-25.4,113.73,0.20193,3,5,42.33,55.12,0.76116,6,-9.16,77.03,0.08904,7,-36.72,99.73,0.1498,2,5,16.63,-55.66,0.94814,6,-101.11,10.14,0.05186,2,5,56.01,-59.23,0.76701,6,-73.68,-18.34,0.23299],"hull":10,"edges":[16,18,4,6,6,8,8,10,10,12,0,18,0,2,2,4,12,14,14,16],"width":71,"height":42}},"matamata-pupil":{"matamata-pupil":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0],"triangles":[1,2,3,1,3,0],"vertices":[14.81,-3.92,-2.85,-15.29,-15.84,4.88,1.81,16.26],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":7,"height":6}},"matamata-pupil2":{"matamata-pupil":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0],"triangles":[1,2,3,1,3,0],"vertices":[15.73,-4.76,-1.79,-16.05,-14.69,3.97,2.83,15.26],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":7,"height":6}},"matamata-top":{"matamata-top":{"type":"mesh","uvs":[1,0.48312,1,1,0.62241,1,0.35915,1,0,1,0,0.72207,0,0.44937,0,0,0.48592,0,1,0,0.4048,0.79838,0.13755,0.9218,0.23684,0.73667,0.59177,0.78572,0.3643,0.30989,0.54638,0.46164,0.27942,0.53341,0.16031,0.30989,0.27805,0.06792,0.49298,0.28118,0.6162,0.10278,0.70107,0.3468,0.74488,0.32014,0.66,0.57442,0.77911,0.49855,0.75173,0.12944,0.78048,0.21146,0.83934,0.1684,0.8722,0.33245,0.67369,0.07202,0.63673,0.13764,0.57923,0.15199,0.43412,0.09458,0.38073,0.03511,0.34239,0.12739,0.17674,0.20736,0.24245,0.19301,0.17674,0.26068,0.07817,0.27708,0.08913,0.35706,0.91601,0.70566,0.82292,0.60518,0.80649,0.86151,0.88178,0.42883,0.73941,0.71797,0.11651,0.61954,0.10555,0.45549,0.42094,0.65609,0.20822,0.56468,0.61275,0.65348,0.42946,0.35323,0.32948,0.36505,0.59653,0.302,0.31107,0.21727,0.37663,0.36598,0.39219,0.49666,0.21679,0.32114,0.30482,0.16539,0.32814,0.31678],"triangles":[33,7,8,18,7,33,29,8,9,32,33,8,20,8,29,31,32,8,34,18,33,34,33,32,25,29,9,30,20,29,30,29,25,20,31,8,31,20,30,57,18,34,27,25,9,18,35,7,36,18,57,36,35,18,26,25,27,53,57,34,36,57,53,37,35,36,38,7,35,38,35,37,19,32,31,34,32,19,53,34,19,52,31,30,19,31,52,14,53,19,17,38,37,58,53,14,30,26,52,26,30,25,22,52,26,56,37,36,56,36,53,56,53,58,17,37,56,28,27,9,26,27,28,22,26,28,21,52,22,50,14,19,39,38,17,51,58,14,54,51,14,56,58,51,50,54,14,0,43,28,6,7,38,6,38,39,46,39,17,6,39,46,15,19,52,15,52,21,50,19,15,0,28,9,55,54,50,55,50,15,43,24,22,43,22,28,21,22,24,23,15,21,16,56,51,55,16,51,55,51,54,56,46,17,16,46,56,16,48,46,24,23,21,41,24,43,41,43,0,23,24,41,45,46,48,49,15,23,47,55,15,47,15,49,16,55,47,40,41,0,44,23,41,44,41,40,49,23,44,45,5,6,45,6,46,12,48,16,12,16,47,45,48,12,13,47,49,13,49,44,10,12,47,10,47,13,42,44,40,12,5,45,11,5,12,4,5,11,3,12,10,11,12,3,4,11,3,42,2,13,42,13,44,10,13,2,3,10,2,40,0,1,42,40,1,2,42,1],"vertices":[33.99,177.3,156.4,172.49,151.13,38.54,147.46,-54.84,142.45,-182.24,76.63,-179.65,12.05,-177.11,-94.37,-172.93,-87.59,-0.56,-80.42,181.8,100.35,-36.77,125.85,-132.72,83.39,-95.77,99.96,29.67,-15.9,-46.59,22.58,16.59,35.85,-78.78,-18.74,-118.94,-74.41,-74.93,-20.9,-0.67,-61.43,44.7,-2.46,72.53,-8.16,88.32,50.87,55.85,34.57,98.8,-53.23,92.53,-33.4,101.96,-42.78,123.24,-3.47,133.37,-67.91,65.38,-52.89,51.66,-50.29,31.13,-65.91,-19.81,-80.74,-38.2,-59.42,-52.66,-42.8,-112.16,-45.28,-88.72,-30.17,-112.66,-27.66,-147.78,-8.57,-144.64,85.52,145.43,60.43,113.35,120.9,105.13,19.49,135.87,85.97,82.67,53.97,-137.37,14.97,-139.72,66.88,-29.72,42.26,-104.32,68.94,38.35,-4.73,-23.87,-3.32,-59.45,-14.53,35.87,-38.58,-64.61,-2.44,-42.73,28.72,-38.43,-15.29,-99.02,-50.95,-66.34,-14.77,-59.48],"hull":10,"edges":[2,0,0,18,6,8,14,16,16,18,12,14,2,4,4,6,8,10,10,12],"width":107,"height":71}}}},"animations":{"idle-man":{"slots":{"matamata-beads":{"attachment":[{"time":0,"name":null},{"time":7.5,"name":null}]},"matamata-bow":{"attachment":[{"time":0,"name":null},{"time":7.5,"name":null}]}},"bones":{"matamata-hand1":{"rotate":[{"time":2.2667,"angle":0,"curve":"stepped"},{"time":2.4667,"angle":0},{"time":2.8,"angle":-16.04},{"time":3.1,"angle":4.02},{"time":3.2667,"angle":-10.94},{"time":3.5333,"angle":0.79},{"time":3.7333,"angle":-12.07},{"time":4.1,"angle":0,"curve":"stepped"},{"time":5.2333,"angle":0,"curve":"stepped"},{"time":7.5,"angle":0}]},"matamata-head":{"rotate":[{"time":0,"angle":0,"curve":"stepped"},{"time":0.8,"angle":0},{"time":1.2333,"angle":-1.74},{"time":2.2667,"angle":0},{"time":2.5,"angle":-22.46},{"time":2.6,"angle":-22.97},{"time":3.2,"angle":-22.65},{"time":3.7333,"angle":-23.87},{"time":4.3,"angle":0},{"time":4.5,"angle":-8.64},{"time":4.6667,"angle":0.82},{"time":4.9,"angle":-11.22},{"time":5.2333,"angle":0,"curve":"stepped"},{"time":6.0333,"angle":0},{"time":6.4667,"angle":-1.74},{"time":7.5,"angle":0}],"translate":[{"time":2.2667,"x":0,"y":0},{"time":2.6,"x":-2.15,"y":2.89},{"time":3.4667,"x":6.29,"y":1.65},{"time":4.1,"x":0,"y":0,"curve":"stepped"},{"time":5.2333,"x":0,"y":0,"curve":"stepped"},{"time":7.5,"x":0,"y":0}]},"matamata-brow":{"rotate":[{"time":2.2667,"angle":0},{"time":2.5667,"angle":-8.66},{"time":3.0333,"angle":-1.15},{"time":4.1,"angle":0,"curve":"stepped"},{"time":5.2333,"angle":0,"curve":"stepped"},{"time":7.5,"angle":0}],"translate":[{"time":0,"x":0,"y":0,"curve":"stepped"},{"time":0.3,"x":0,"y":0},{"time":0.4667,"x":-8.15,"y":1.61},{"time":1.2333,"x":-6.05,"y":-5.88},{"time":1.5667,"x":-1.15,"y":-6},{"time":2.2667,"x":0,"y":0},{"time":2.3333,"x":1.16,"y":-0.35},{"time":2.4333,"x":-10.34,"y":6.63,"curve":"stepped"},{"time":2.5667,"x":-10.34,"y":6.63},{"time":3,"x":12.1,"y":-2.76},{"time":3.4333,"x":-9.85,"y":-0.84},{"time":3.7667,"x":5.54,"y":-4.54},{"time":3.8667,"x":3.88,"y":-3.18},{"time":4.1,"x":-14.85,"y":7.59},{"time":4.5667,"x":4.22,"y":-7.63,"curve":"stepped"},{"time":5.0333,"x":4.22,"y":-7.63},{"time":5.2333,"x":0,"y":0,"curve":"stepped"},{"time":5.5333,"x":0,"y":0},{"time":5.7,"x":-8.15,"y":1.61},{"time":6.4667,"x":-6.05,"y":-5.88},{"time":6.8,"x":-1.15,"y":-6},{"time":7.5,"x":0,"y":0}]},"matamata-hand2":{"rotate":[{"time":0,"angle":0},{"time":1.2333,"angle":24.01},{"time":2.2667,"angle":0,"curve":"stepped"},{"time":5.2333,"angle":0},{"time":6.4667,"angle":24.01},{"time":7.5,"angle":0}],"translate":[{"time":0,"x":0,"y":0},{"time":1.2333,"x":3.5,"y":-14.81},{"time":2.2667,"x":0,"y":0},{"time":2.5333,"x":11.39,"y":-19.22},{"time":2.9333,"x":1.08,"y":-22.34},{"time":3.3,"x":-0.66,"y":-8.91},{"time":3.7333,"x":-0.3,"y":-4.08},{"time":4.1,"x":6.17,"y":-13.66},{"time":4.3667,"x":-6.2,"y":-15.41},{"time":5.2333,"x":0,"y":0},{"time":6.4667,"x":3.5,"y":-14.81},{"time":7.5,"x":0,"y":0}]},"matamata-top":{"rotate":[{"time":0,"angle":0},{"time":1.1333,"angle":-1.51,"curve":"stepped"},{"time":1.2333,"angle":-1.51},{"time":2.2667,"angle":0},{"time":2.5333,"angle":3.98},{"time":2.6333,"angle":0.5},{"time":2.9,"angle":-2.88},{"time":3.2,"angle":3.67},{"time":3.5667,"angle":-3.53},{"time":4.1667,"angle":3.23},{"time":4.5,"angle":-4.83},{"time":4.6333,"angle":-2.86},{"time":4.8,"angle":-4.8},{"time":5.2333,"angle":0},{"time":6.3667,"angle":-1.51,"curve":"stepped"},{"time":6.4667,"angle":-1.51},{"time":7.5,"angle":0}],"translate":[{"time":0,"x":0,"y":0},{"time":0.6333,"x":-6.5,"y":-9.71},{"time":1.0667,"x":-8.07,"y":-14.28,"curve":"stepped"},{"time":1.2,"x":-8.07,"y":-14.28},{"time":2.2667,"x":0,"y":0},{"time":2.4667,"x":9.61,"y":22.14},{"time":2.7667,"x":20.3,"y":-24.48},{"time":2.9,"x":21.14,"y":-29.74},{"time":3.1,"x":20.01,"y":13.07},{"time":3.2667,"x":12.51,"y":29.98},{"time":3.7,"x":-7.92,"y":-19.52},{"time":4,"x":7.33,"y":13.75},{"time":4.1,"x":14.02,"y":12.05},{"time":4.3333,"x":17.32,"y":-24.16,"curve":"stepped"},{"time":4.4,"x":17.32,"y":-24.16},{"time":5.2333,"x":0,"y":0},{"time":5.8667,"x":-6.5,"y":-9.71},{"time":6.3,"x":-8.07,"y":-14.28,"curve":"stepped"},{"time":6.4333,"x":-8.07,"y":-14.28},{"time":7.5,"x":0,"y":0}]},"matamata-neck":{"rotate":[{"time":0,"angle":0},{"time":1.1333,"angle":-2.37,"curve":"stepped"},{"time":1.2667,"angle":-2.37},{"time":2.2667,"angle":0},{"time":2.5667,"angle":14.89},{"time":2.9667,"angle":3.91},{"time":3.3333,"angle":15.31},{"time":3.7667,"angle":-0.72},{"time":4.1333,"angle":11.21},{"time":4.3667,"angle":10.43},{"time":4.5333,"angle":6.39},{"time":4.6667,"angle":10.54},{"time":4.8333,"angle":4.93},{"time":5.2333,"angle":0},{"time":6.3667,"angle":-2.37,"curve":"stepped"},{"time":6.5,"angle":-2.37},{"time":7.5,"angle":0}]},"bone4":{"rotate":[{"time":0,"angle":0},{"time":1.5,"angle":-5,"curve":"stepped"},{"time":1.6,"angle":-5},{"time":2.2667,"angle":0},{"time":2.6667,"angle":7.03},{"time":2.8667,"angle":-0.36},{"time":3.0333,"angle":-10.14},{"time":3.3,"angle":-0.5},{"time":3.4333,"angle":9.19},{"time":3.6333,"angle":9.79},{"time":3.8333,"angle":4.61},{"time":4.1,"angle":10.65},{"time":4.2,"angle":5.88},{"time":4.4,"angle":-7.82},{"time":4.7333,"angle":-4.69},{"time":4.9333,"angle":-8.8},{"time":5.2333,"angle":0},{"time":6.7333,"angle":-5,"curve":"stepped"},{"time":6.8333,"angle":-5},{"time":7.5,"angle":0}],"translate":[{"time":0,"x":0,"y":0},{"time":0.4,"x":-8.39,"y":-8.6},{"time":1.1333,"x":-19.75,"y":-26.02},{"time":2.2667,"x":0,"y":0,"curve":"stepped"},{"time":4.3667,"x":0,"y":0},{"time":4.5667,"x":-6.56,"y":-7.76},{"time":4.7,"x":-0.82,"y":0.98},{"time":4.8667,"x":-9.94,"y":-18.05},{"time":5.2333,"x":0,"y":0},{"time":5.6333,"x":-8.39,"y":-8.6},{"time":6.3667,"x":-19.75,"y":-26.02},{"time":7.5,"x":0,"y":0}]},"bone5":{"rotate":[{"time":0,"angle":0},{"time":1.3333,"angle":-6.65},{"time":2.2667,"angle":0,"curve":"stepped"},{"time":5.2333,"angle":0},{"time":6.5667,"angle":-6.65},{"time":7.5,"angle":0}],"translate":[{"time":2.2667,"x":0,"y":0,"curve":"stepped"},{"time":4.3667,"x":0,"y":0},{"time":4.6,"x":-14.94,"y":-6.41},{"time":4.7333,"x":-4.36,"y":-0.9},{"time":4.9,"x":-10.94,"y":-3.46},{"time":5.2333,"x":0,"y":0,"curve":"stepped"},{"time":7.5,"x":0,"y":0}]},"matamata-eyeball2":{"translate":[{"time":0,"x":0,"y":0},{"time":1.3,"x":-2.99,"y":-5.89},{"time":2.2667,"x":0,"y":0},{"time":2.6,"x":-8.23,"y":3.95},{"time":3,"x":4.53,"y":-2.09},{"time":3.3667,"x":-5.71,"y":3},{"time":3.8,"x":-1.64,"y":-5.95},{"time":4.1333,"x":-4.34,"y":7.84},{"time":4.2667,"x":-6.8,"y":7.84},{"time":4.4333,"x":0.11,"y":-2.03},{"time":4.6,"x":-3.5,"y":-7.89},{"time":4.7333,"x":-0.56,"y":-1.04},{"time":4.9333,"x":-5.36,"y":-7.03},{"time":5.2333,"x":0,"y":0},{"time":6.5333,"x":-2.99,"y":-5.89},{"time":7.5,"x":0,"y":0}]},"matamata-eyeball1":{"translate":[{"time":0,"x":0,"y":0},{"time":1.3,"x":-2.99,"y":-5.89},{"time":2.2667,"x":0,"y":0},{"time":2.6,"x":-8.23,"y":3.95},{"time":3,"x":4.53,"y":-2.09},{"time":3.3667,"x":-5.71,"y":3},{"time":3.8,"x":-1.64,"y":-5.95},{"time":4.1333,"x":-4.34,"y":7.84},{"time":4.2667,"x":-6.8,"y":7.84},{"time":4.4333,"x":0.11,"y":-2.03},{"time":4.6,"x":-3.5,"y":-7.89},{"time":4.7333,"x":-0.56,"y":-1.04},{"time":4.9333,"x":-5.36,"y":-7.03},{"time":5.2333,"x":0,"y":0},{"time":6.5333,"x":-2.99,"y":-5.89},{"time":7.5,"x":0,"y":0}]},"bone":{"rotate":[{"time":2.2667,"angle":0,"curve":"stepped"},{"time":3,"angle":0},{"time":3.1667,"angle":-10.85},{"time":3.3,"angle":6.65},{"time":3.3667,"angle":8.23},{"time":3.5667,"angle":-8.46},{"time":3.8333,"angle":-4.23},{"time":4.0333,"angle":-29.53},{"time":4.2,"angle":22.33},{"time":4.3333,"angle":0,"curve":"stepped"},{"time":5.2333,"angle":0,"curve":"stepped"},{"time":7.5,"angle":0}],"translate":[{"time":2.2667,"x":0,"y":0,"curve":"stepped"},{"time":3.0667,"x":0,"y":0},{"time":3.2667,"x":14.34,"y":46.33},{"time":3.4667,"x":-22.81,"y":17.52},{"time":3.6,"x":-25.65,"y":-14.69,"curve":"stepped"},{"time":3.9,"x":-25.65,"y":-14.69},{"time":4.1667,"x":1.1,"y":28.68},{"time":4.3333,"x":0,"y":0,"curve":"stepped"},{"time":5.2333,"x":0,"y":0,"curve":"stepped"},{"time":7.5,"x":0,"y":0}]},"matamata-pupil2":{"translate":[{"time":2.2667,"x":0,"y":0,"curve":"stepped"},{"time":2.4667,"x":0,"y":0},{"time":2.5333,"x":-1.54,"y":-4.03,"curve":"stepped"},{"time":2.7667,"x":-1.54,"y":-4.03},{"time":2.8667,"x":2.89,"y":0.78},{"time":3.3667,"x":-0.86,"y":2.65,"curve":"stepped"},{"time":3.5333,"x":-0.86,"y":2.65},{"time":3.6333,"x":-0.55,"y":-7.29,"curve":"stepped"},{"time":3.9667,"x":-0.55,"y":-7.29},{"time":4.0667,"x":2.44,"y":2.94},{"time":4.4333,"x":0.55,"y":3.09},{"time":4.5667,"x":-1.92,"y":-7.09},{"time":4.7333,"x":-1.61,"y":4.71},{"time":4.9333,"x":-5.32,"y":-7.78},{"time":5.2333,"x":0,"y":0,"curve":"stepped"},{"time":7.5,"x":0,"y":0}]},"matamata-pupil":{"translate":[{"time":2.2667,"x":0,"y":0,"curve":"stepped"},{"time":2.4667,"x":0,"y":0},{"time":2.5333,"x":-1.22,"y":-3.41,"curve":"stepped"},{"time":2.7667,"x":-1.22,"y":-3.41},{"time":2.8667,"x":1.94,"y":1.66},{"time":3.3667,"x":-2.46,"y":3.44,"curve":"stepped"},{"time":3.5333,"x":-2.46,"y":3.44},{"time":3.6333,"x":-2.96,"y":-10.82,"curve":"stepped"},{"time":3.9667,"x":-2.96,"y":-10.82},{"time":4.0667,"x":0.14,"y":1.38,"curve":"stepped"},{"time":4.4333,"x":0.14,"y":1.38},{"time":4.5667,"x":-3.48,"y":-8.38},{"time":4.7333,"x":-0.97,"y":4.62},{"time":4.9333,"x":-4.87,"y":-7.52},{"time":5.2333,"x":0,"y":0,"curve":"stepped"},{"time":7.5,"x":0,"y":0}]}},"deform":{"default":{"matamata-brow":{"matamata-brow":[{"time":0,"curve":"stepped"},{"time":0.3333},{"time":0.5333,"offset":8,"vertices":[-1.84662,-11.12938,-0.3251,-6.62026,1.17422,-8.13065,-0.31973,-5.11543],"curve":"stepped"},{"time":1.1667,"offset":8,"vertices":[-1.84662,-11.12938,-0.3251,-6.62026,1.17422,-8.13065,-0.31973,-5.11543]},{"time":1.5,"curve":"stepped"},{"time":2.2667,"curve":"stepped"},{"time":2.3667},{"time":2.4667,"offset":6,"vertices":[0.13895,1.23802,-0.20966,-8.95087,-1.85367,-7.40315,-1.02591,-6.90466,-1.76752,-5.69318],"curve":"stepped"},{"time":2.5667,"offset":6,"vertices":[0.13895,1.23802,-0.20966,-8.95087,-1.85367,-7.40315,-1.02591,-6.90466,-1.76752,-5.69318]},{"time":2.9667,"curve":"stepped"},{"time":3.0667},{"time":3.3667,"offset":6,"vertices":[0.13895,1.23802,-0.20966,-8.95087,-1.85367,-7.40315,-1.02591,-6.90466,-1.76752,-5.69318]},{"time":3.7667,"curve":"stepped"},{"time":3.9667},{"time":4.1333,"offset":6,"vertices":[0.13895,1.23802,-0.20966,-8.95087,-1.85367,-7.40315,-1.02591,-6.90466,-1.76752,-5.69318]},{"time":4.4333,"curve":"stepped"},{"time":5.2333,"curve":"stepped"},{"time":5.5667},{"time":5.7667,"offset":8,"vertices":[-1.84662,-11.12938,-0.3251,-6.62026,1.17422,-8.13065,-0.31973,-5.11543],"curve":"stepped"},{"time":6.4,"offset":8,"vertices":[-1.84662,-11.12938,-0.3251,-6.62026,1.17422,-8.13065,-0.31973,-5.11543]},{"time":6.7333,"curve":"stepped"},{"time":7.5}]},"matamata-eyeball1":{"matamata-eyeball1":[{"time":0,"curve":"stepped"},{"time":1.7},{"time":1.7667,"vertices":[1.92242,-0.2634,0,0,-6.11427,4.31441]},{"time":1.8333,"vertices":[-20.68909,4.48355,0,0,11.73647,0.56123],"curve":"stepped"},{"time":1.8667,"vertices":[-20.68909,4.48355,0,0,11.73647,0.56123]},{"time":1.9667,"vertices":[1.67155,-0.46666,0,0,-2.74072,-0.1357]},{"time":2.0333,"curve":"stepped"},{"time":2.2667,"curve":"stepped"},{"time":2.6},{"time":2.6667,"vertices":[-20.68909,4.48355,0,0,11.73647,0.56123]},{"time":2.7333,"curve":"stepped"},{"time":4.2667},{"time":4.4333,"vertices":[-8.83026,10.35745,0,0,8.33235,0.71625],"curve":"stepped"},{"time":4.9333,"vertices":[-8.83026,10.35745,0,0,8.33235,0.71625]},{"time":5.2333,"curve":"stepped"},{"time":6.9333},{"time":7,"vertices":[1.92242,-0.2634,0,0,-6.11427,4.31441]},{"time":7.0667,"vertices":[-20.68909,4.48355,0,0,11.73647,0.56123],"curve":"stepped"},{"time":7.1,"vertices":[-20.68909,4.48355,0,0,11.73647,0.56123]},{"time":7.2,"vertices":[1.67155,-0.46666,0,0,-2.74072,-0.1357]},{"time":7.2667,"curve":"stepped"},{"time":7.5}]},"matamata-eyeball2":{"matamata-eyeball1":[{"time":0,"curve":"stepped"},{"time":1.7},{"time":1.7667,"vertices":[1.32104,-0.00851,0,0,-4.61964,0.69083]},{"time":1.8333,"vertices":[-21.12239,9.04794,0,0,10.73662,1.38763],"curve":"stepped"},{"time":1.8667,"vertices":[-21.12239,9.04794,0,0,10.73662,1.38763]},{"time":1.9667,"vertices":[1.32104,-0.00851,0,0,-4.61964,0.69083]},{"time":2.0333,"curve":"stepped"},{"time":2.2667,"curve":"stepped"},{"time":2.6},{"time":2.6667,"vertices":[-21.12239,9.04794,0,0,10.73662,1.38763]},{"time":2.7333,"curve":"stepped"},{"time":4.2667},{"time":4.4333,"vertices":[-10.10381,7.35538,0,0,6.42815,-1.54596],"curve":"stepped"},{"time":4.9333,"vertices":[-10.10381,7.35538,0,0,6.42815,-1.54596]},{"time":5.2333,"curve":"stepped"},{"time":6.9333},{"time":7,"vertices":[1.32104,-0.00851,0,0,-4.61964,0.69083]},{"time":7.0667,"vertices":[-21.12239,9.04794,0,0,10.73662,1.38763],"curve":"stepped"},{"time":7.1,"vertices":[-21.12239,9.04794,0,0,10.73662,1.38763]},{"time":7.2,"vertices":[1.32104,-0.00851,0,0,-4.61964,0.69083]},{"time":7.2667,"curve":"stepped"},{"time":7.5}]},"matamata-hand1":{"matamata-hand1":[{"time":0},{"time":1.1667,"offset":4,"vertices":[1.69563,0.24538,0.61058,-1.60107,-1.54639,-0.19243,-0.52628,1.46708,0,0,0,0,0,0,0,0,-1.68444,-0.737,-1.08797,1.48264,-4.34853,-2.23878,-3.13669,3.75392,-8.08845,0.46481,-1.31677,7.99561]},{"time":2.2667,"curve":"stepped"},{"time":2.4667},{"time":2.7667,"offset":8,"vertices":[-1.60256,2.40738,2.448,1.54072,0,0,0,0,0,0,-29.58015,-39.21676,-3.82508,-3.21022,-2.97676,4.01057,-13.05325,-8.39924,-7.83422,13.41647,-23.41675,-3.51511,-2.31619,23.61372]},{"time":2.9667,"offset":14,"vertices":[16.32151,9.4246,11.5619,-14.88821,-16.32146,-9.42463,0,0,0,0,0,0,0,0,-12.71707,-1.8253,-3.54102,12.35214]},{"time":3.1},{"time":3.2667,"offset":18,"vertices":[-10.4304,-31.39236,0,0,0,0,0,0,0,0,-5.75744,-3.64405,-3.96806,5.54055]},{"time":3.6,"offset":18,"vertices":[-6.25824,-18.83541,0,0,0,0,0,0,0,0,-3.45446,-2.18643,-2.38084,3.32433]},{"time":3.7333,"offset":18,"vertices":[-10.66423,-16.53856,0,0,0,0,-1.12232,-0.69481,-0.813,1.04021,-7.80655,-2.28054,-2.99328,7.60701]},{"time":4.1},{"time":4.1667,"offset":2,"vertices":[5.89341,-9.29313,12.2794,4.22915,4.29936,-12.07071,0,0,0,0,0,0,0,0,0,0,-2.38964,-28.59184,0,0,0,0,0,0,0,0,-10.67213,-2.48782,-1.40083,10.86913]},{"time":4.2,"offset":2,"vertices":[1.11205,-6.41575,8.21821,1.89868,1.06172,-8.36815,0,0,0,0,0,0,0,0,0,0,-3.58447,-42.88777,0,0,0,0,0,0,0,0,-16.0082,-3.73173,-2.10124,16.30369]},{"time":4.3667,"offset":28,"vertices":[-10.42357,-3.71828,-5.89597,9.36795]},{"time":5.2333},{"time":6.4,"offset":4,"vertices":[1.69563,0.24538,0.61058,-1.60107,-1.54639,-0.19243,-0.52628,1.46708,0,0,0,0,0,0,0,0,-1.68444,-0.737,-1.08797,1.48264,-4.34853,-2.23878,-3.13669,3.75392,-8.08845,0.46481,-1.31677,7.99561]},{"time":7.5}]},"matamata-hand2":{"matamata-hand2":[{"time":0},{"time":1.2333,"offset":26,"vertices":[-2.79613,2.65508,-1.05219,3.65636,0,0,0,0,0.20534,0.74329,0.45594,0.56]},{"time":2.2667,"curve":"stepped"},{"time":2.5667},{"time":2.8,"offset":26,"vertices":[-11.41948,7.64392,-3.2052,13.22755,-8.67681,5.05278,-2.8568,9.47589,-6.43843,3.32324,-2.35787,6.70728,-6.91431,2.82007,-2.94995,6.63322]},{"time":2.9,"offset":26,"vertices":[-15.31981,7.99385,-5.47955,16.05568,-12.80254,5.5098,-5.21763,12.54007,-9.67238,2.98997,-4.49844,8.66882,-6.91431,2.82007,-2.94995,6.63322]},{"time":3.3},{"time":3.7,"offset":26,"vertices":[-15.29599,7.9948,-5.47951,16.05576,-12.36496,5.12732,-5.16699,11.97734,-1.97441,6.66139,2.46419,6.32979,-6.91431,2.82007,-2.94995,6.63322]},{"time":4.0667},{"time":4.5333,"offset":26,"vertices":[-15.24479,6.39537,-6.34624,14.81259,-12.48395,3.84264,-5.96732,11.08357,-5.75955,1.98962,-2.44225,5.39186,-6.91431,2.82007,-2.94995,6.63322]},{"time":4.6667,"offset":26,"vertices":[-12.34102,5.1772,-5.13743,11.99114,-10.10605,3.1107,-4.83068,8.97241,-4.66249,1.61065,-1.97706,4.36484,-5.59729,2.28291,-2.38806,5.36975]},{"time":4.8,"offset":26,"vertices":[-10.18255,6.22682,-3.04609,11.32505,-7.72816,2.37877,-3.69405,6.86126,-3.75891,3.62436,-0.21176,5.2026,-4.28029,1.74576,-1.82616,4.10628]},{"time":5.2333},{"time":6.4667,"offset":26,"vertices":[-2.79613,2.65508,-1.05219,3.65636,0,0,0,0,0.20534,0.74329,0.45594,0.56]},{"time":7.5}]},"matamata-head":{"matamata-head":[{"time":0},{"time":1.2333,"vertices":[0.3194,-24.05716,-4.98137,1.31299,8.8679,14.44458,10.20221,6.36807,1.43931,-10.95338,-4.44151,-16.85362,-3.86011,-12.42871,2.05828,-0.276,1.36501,4.16866]},{"time":2.2667},{"time":2.6,"offset":8,"vertices":[-8.2553,3.34496,-10.98383,2.08496,-9.61082,1.82428,0,0,2.46783,-0.11304]},{"time":3,"offset":8,"vertices":[12.49626,-5.07047,11.31808,-6.09628,8.43728,-6.1185,0,0,-0.41718,4.74875]},{"time":3.4333,"offset":8,"vertices":[-8.2553,3.34496,-14.97273,1.85428,-14.37572,1.70242,0,0,2.46783,-0.11304]},{"time":3.8333,"offset":8,"vertices":[6.26127,-9.64609,0.87685,-5.4328,-7.62865,-12.12944,0,0,-0.41718,4.74875]},{"time":4.2,"offset":8,"vertices":[-1.42777,8.51643,-6.48944,19.02324,-5.55505,10.00328,-8.06877,3.40886,2.46783,-0.11304]},{"time":4.5,"offset":8,"vertices":[9.30841,-12.19855,3.42864,-14.24373,-4.58764,-17.65091,0,0,-0.41718,4.74875]},{"time":4.5667,"vertices":[-5.95248,-13.92897,0,0,0,0,0,0,7.42576,-8.17104,0.25393,-18.05093,-5.66911,-18.77571,0,0,0.54449,3.12816]},{"time":4.7,"offset":8,"vertices":[3.66044,-0.11601,-1.97545,1.32567,-6.07112,0.37302,0,0,2.46783,-0.11304]},{"time":4.7333,"vertices":[3.69678,22.85498,0,0,0,0,0,0,3.58319,-1.92489,1.36548,8.59687,-5.72896,8.34048,0,0,2.05568,0.5815]},{"time":4.9333,"offset":8,"vertices":[3.11972,-12.7782,-3.71916,-10.87219,-7.57804,-14.11545,0,0,-0.41718,4.74875]},{"time":4.9667,"vertices":[-3.37113,-16.3701,0,0,0,0,0,0,2.07981,-8.5188,-4.5635,-16.19785,-6.34261,-20.19982,0,0,-0.27812,3.16583]},{"time":5.2333},{"time":6.4667,"vertices":[0.3194,-24.05716,-4.98137,1.31299,8.8679,14.44458,10.20221,6.36807,1.43931,-10.95338,-4.44151,-16.85362,-3.86011,-12.42871,2.05828,-0.276,1.36501,4.16866]},{"time":7.5}]},"matamata-leg1":{"matamata-leg1":[{"time":0},{"time":1.1667,"offset":14,"vertices":[1.37394,-1.68875,-1.56612,-2.33845,-0.8322,0.69551,0.54393,1.29221,0,0,0,0,0,0,0,0,0,0,1.3813,-2.27693,-2.29019,-2.57061,0,0,0,0,0,0,0,0,0,0,0,0,-1.23498,4.69032,5.32813,3.30479]},{"time":2.2667,"curve":"stepped"},{"time":2.4333},{"time":2.7667,"offset":18,"vertices":[-4.32925,-1.74907,-3.83034,4.66503,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-5.81664,0.20673,-1.99223,7.25549,0,0,0,0,0,0,0,0,-4.82042,0.80509,-0.86923,6.25767]},{"time":3.2667},{"time":3.6667,"offset":10,"vertices":[3.80626,0.31775,1.76553,-4.61124,0,0,0,0,-0.5737,1.5737,1.74709,1.27906,0,0,0,0,0,0,0,0,0,0,0.31472,0.11475,0.2558,-0.34942,-1.28866,0.59995,0.28049,1.81573,0,0,0,0,0,0,0,0,-3.88003,2.19405,1.32603,5.60712]},{"time":4.1},{"time":4.3333,"offset":18,"vertices":[-3.72527,-0.58746,-2.19405,4.35368,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-4.70521,1.3733,-0.16739,6.33408,0,0,0,0,0,0,0,0,-4.31331,0.19688,-1.46072,5.38723]},{"time":5.2333},{"time":6.4,"offset":14,"vertices":[1.37394,-1.68875,-1.56612,-2.33845,-0.8322,0.69551,0.54393,1.29221,0,0,0,0,0,0,0,0,0,0,1.3813,-2.27693,-2.29019,-2.57061,0,0,0,0,0,0,0,0,0,0,0,0,-1.23498,4.69032,5.32813,3.30479]},{"time":7.5}]},"matamata-ltongue":{"matamata-ltongue":[{"time":0,"curve":"stepped"},{"time":0.9667},{"time":1.3333,"vertices":[3.46371,-26.20889]},{"time":1.5,"vertices":[5.28198,-39.38304]},{"time":1.7667,"vertices":[-2.03481,-13.07393]},{"time":1.9,"vertices":[-5.41053,2.89232]},{"time":2.2667},{"time":2.6333,"vertices":[-4.43973,-74.09471]},{"time":2.7667,"vertices":[-6.74969,-30.3615]},{"time":2.8667,"vertices":[7.36572,-54.00793]},{"time":3.1667,"vertices":[-4.66533,5.80661]},{"time":3.3667,"vertices":[3.42645,-11.80691]},{"time":3.7,"vertices":[-1.99943,2.48855]},{"time":4.1,"vertices":[6.076,-25.71782]},{"time":4.2667},{"time":4.4333,"vertices":[-4.04576,-31.07315]},{"time":4.7,"vertices":[4.5687,-14.09827]},{"time":4.9333,"vertices":[0.42673,-43.17049]},{"time":5.2333,"curve":"stepped"},{"time":6.2},{"time":6.5667,"vertices":[3.46371,-26.20889]},{"time":6.7333,"vertices":[5.28198,-39.38304]},{"time":7,"vertices":[-2.03481,-13.07393]},{"time":7.1333,"vertices":[-5.41053,2.89232]},{"time":7.5}]},"matamata-top":{"matamata-top":[{"time":0},{"time":0.8333,"vertices":[7.17848,-3.42638,0,0,5.42572,-16.45878,1.74104,-18.09897,0,0,-5.78609,-0.73536,1.31149,7.94153,0,0,0,0,0,0,2.04854,-13.77925,-2.86462,-12.6759,-0.00009,-6.7542,4.08717,-22.09231,-1.06798,-6.20035,-0.08147,-12.28359,4.83891,-16.76678,2.81412,2.94277,0,0,1.89272,-8.76137,-3.07864,-10.13071,3.27611,-9.4468,3.44452,-5.13387,2.29398,-11.51661,0.54729,-9.71761,-0.72302,-2.72166,-0.18715,-2.20151,0,0,0.77553,2.91688,-0.72302,-2.72166,1.10143,-11.72056,2.14642,-9.16574,0,0,0,0,0.30415,-6.3732,-0.38916,8.84673,1.97226,-0.17814,0.05386,3.63963,0.93135,9.1413,1.3116,7.94161,16.28554,-7.96837,7.51735,-11.08024,12.55339,-16.26722,4.51735,-1.72686,4.38773,-12.12615,-0.00009,-6.7542,-0.40472,1.05265,0.38705,-16.98303,7.04602,-17.38546,1.63327,-16.2354,2.70557,-6.77269,5.12817,-10.27983,-0.21504,-14.5845,-1.09903,-6.38051,3.56792,-10.14278,1.36574,-15.42086,2.74464,-2.82684,-0.86632,-4.76375,4.62883,-10.01948],"curve":"stepped"},{"time":1.0333,"vertices":[7.17848,-3.42638,0,0,5.42572,-16.45878,1.74104,-18.09897,0,0,-5.78609,-0.73536,1.31149,7.94153,0,0,0,0,0,0,2.04854,-13.77925,-2.86462,-12.6759,-0.00009,-6.7542,4.08717,-22.09231,-1.06798,-6.20035,-0.08147,-12.28359,4.83891,-16.76678,2.81412,2.94277,0,0,1.89272,-8.76137,-3.07864,-10.13071,3.27611,-9.4468,3.44452,-5.13387,2.29398,-11.51661,0.54729,-9.71761,-0.72302,-2.72166,-0.18715,-2.20151,0,0,0.77553,2.91688,-0.72302,-2.72166,1.10143,-11.72056,2.14642,-9.16574,0,0,0,0,0.30415,-6.3732,-0.38916,8.84673,1.97226,-0.17814,0.05386,3.63963,0.93135,9.1413,1.3116,7.94161,16.28554,-7.96837,7.51735,-11.08024,12.55339,-16.26722,4.51735,-1.72686,4.38773,-12.12615,-0.00009,-6.7542,-0.40472,1.05265,0.38705,-16.98303,7.04602,-17.38546,1.63327,-16.2354,2.70557,-6.77269,5.12817,-10.27983,-0.21504,-14.5845,-1.09903,-6.38051,3.56792,-10.14278,1.36574,-15.42086,2.74464,-2.82684,-0.86632,-4.76375,4.62883,-10.01948]},{"time":2.2667},{"time":2.7,"vertices":[7.17848,-3.42638,0,0,5.42572,-16.45878,1.74104,-18.09897,0,0,-5.78609,-0.73536,1.31149,7.94153,0,0,0,0,0,0,2.04854,-13.77925,-2.86462,-12.6759,-0.00009,-6.7542,4.08717,-22.09231,-1.06798,-6.20035,-0.08147,-12.28359,4.83891,-16.76678,2.81412,2.94277,0,0,1.89272,-8.76137,-3.07864,-10.13071,3.27611,-9.4468,3.44452,-5.13387,2.29398,-11.51661,0.54729,-9.71761,-0.72302,-2.72166,-0.18715,-2.20151,0,0,0.77553,2.91688,-0.72302,-2.72166,1.10143,-11.72056,2.14642,-9.16574,0,0,0,0,0.30415,-6.3732,-0.38916,8.84673,1.97226,-0.17814,0.05386,3.63963,0.93135,9.1413,1.3116,7.94161,16.28554,-7.96837,7.51735,-11.08024,12.55339,-16.26722,4.51735,-1.72686,4.38773,-12.12615,-0.00009,-6.7542,-0.40472,1.05265,0.38705,-16.98303,7.04602,-17.38546,1.63327,-16.2354,2.70557,-6.77269,5.12817,-10.27983,-0.21504,-14.5845,-1.09903,-6.38051,3.56792,-10.14278,1.36574,-15.42086,2.74464,-2.82684,-0.86632,-4.76375,4.62883,-10.01948]},{"time":3.0333,"vertices":[-1.76822,0.0848,0,0,-0.16772,6.95595,0.37704,5.65701,0,0,2.05318,2.38856,0,0,0,0,0,0,0,0,0.00001,4.39987,2.17891,4.27421,0.00001,4.39987,0.00001,4.39987,-2.43681,7.1761,0.00001,4.39987,0.00001,4.39987,0,0,-2.13976,3.9918,-3.09316,-1.88854,-0.96019,3.68056,0.00001,4.39987,0.00001,4.39987,0.00001,4.39987,0.00001,4.39987,0,0,0,0,0,0,0,0,0,0,0,0,-0.35497,0.40567,0,0,0,0,0,0,-0.63007,0.52312,0.25067,5.24704,0,0,0,0,0,0,-4.30182,2.1929,-1.84497,1.41585,-0.29341,5.07035,-2.53148,0.81519,0,0,0.00001,4.39987,0.00001,4.39987,0.16969,7.0064,0.00001,4.39987,0.00001,4.39987,-1.91237,0.77886,0.26149,8.05748,2.76035,5.24092,-1.57222,5.07117,0.45898,6.88789,1.51866,6.81726,0,0,-1.3502,3.68002,-1.56204,6.48637]},{"time":3.7,"vertices":[7.17848,-3.42638,0,0,5.42572,-16.45878,1.74104,-18.09897,0,0,-5.78609,-0.73536,1.31149,7.94153,0,0,0,0,0,0,2.04854,-13.77925,-2.86462,-12.6759,-0.00009,-6.7542,4.08717,-22.09231,-1.06798,-6.20035,-0.08147,-12.28359,4.83891,-16.76678,2.81412,2.94277,0,0,1.89272,-8.76137,-3.07864,-10.13071,3.27611,-9.4468,3.44452,-5.13387,2.29398,-11.51661,0.54729,-9.71761,-0.72302,-2.72166,-0.18715,-2.20151,0,0,0.77553,2.91688,-0.72302,-2.72166,1.10143,-11.72056,2.14642,-9.16574,0,0,0,0,0.30415,-6.3732,-0.38916,8.84673,1.97226,-0.17814,0.05386,3.63963,0.93135,9.1413,1.3116,7.94161,16.28554,-7.96837,7.51735,-11.08024,12.55339,-16.26722,4.51735,-1.72686,4.38773,-12.12615,-0.00009,-6.7542,-0.40472,1.05265,0.38705,-16.98303,7.04602,-17.38546,1.63327,-16.2354,2.70557,-6.77269,5.12817,-10.27983,-0.21504,-14.5845,-1.09903,-6.38051,3.56792,-10.14278,1.36574,-15.42086,2.74464,-2.82684,-0.86632,-4.76375,4.62883,-10.01948]},{"time":4.0667,"vertices":[-1.76822,0.0848,0,0,-0.16772,6.95595,0.37704,5.65701,0,0,2.05318,2.38856,0,0,0,0,0,0,0,0,0.00001,4.39987,2.17891,4.27421,0.00001,4.39987,0.00001,4.39987,-2.43681,7.1761,0.00001,4.39987,0.00001,4.39987,0,0,-2.13976,3.9918,-3.09316,-1.88854,-0.96019,3.68056,0.00001,4.39987,0.00001,4.39987,0.00001,4.39987,0.00001,4.39987,0,0,0,0,0,0,0,0,0,0,0,0,-0.35497,0.40567,0,0,0,0,0,0,-0.63007,0.52312,0.25067,5.24704,0,0,0,0,0,0,-4.30182,2.1929,-1.84497,1.41585,-0.29341,5.07035,-2.53148,0.81519,0,0,0.00001,4.39987,0.00001,4.39987,0.16969,7.0064,0.00001,4.39987,0.00001,4.39987,-1.91237,0.77886,0.26149,8.05748,2.76035,5.24092,-1.57222,5.07117,0.45898,6.88789,1.51866,6.81726,0,0,-1.3502,3.68002,-1.56204,6.48637]},{"time":4.4,"vertices":[7.17848,-3.42638,0,0,5.42572,-16.45878,1.74104,-18.09897,0,0,-5.78609,-0.73536,1.31149,7.94153,0,0,0,0,0,0,2.04854,-13.77925,-2.86462,-12.6759,-0.00009,-6.7542,4.08717,-22.09231,-1.06798,-6.20035,-0.08147,-12.28359,4.83891,-16.76678,2.81412,2.94277,0,0,1.89272,-8.76137,-3.07864,-10.13071,3.27611,-9.4468,3.44452,-5.13387,2.29398,-11.51661,0.54729,-9.71761,-0.72302,-2.72166,-0.18715,-2.20151,0,0,0.77553,2.91688,-0.72302,-2.72166,1.10143,-11.72056,2.14642,-9.16574,0,0,0,0,0.30415,-6.3732,-0.38916,8.84673,1.97226,-0.17814,0.05386,3.63963,0.93135,9.1413,1.3116,7.94161,16.28554,-7.96837,7.51735,-11.08024,12.55339,-16.26722,4.51735,-1.72686,4.38773,-12.12615,-0.00009,-6.7542,-0.40472,1.05265,0.38705,-16.98303,7.04602,-17.38546,1.63327,-16.2354,2.70557,-6.77269,5.12817,-10.27983,-0.21504,-14.5845,-1.09903,-6.38051,3.56792,-10.14278,1.36574,-15.42086,2.74464,-2.82684,-0.86632,-4.76375,4.62883,-10.01948]},{"time":4.4667,"vertices":[11.74327,-3.68187,4.7377,-3.71867,5.70432,-19.13493,-0.46322,-20.38404,-5.27686,-2.89393,-10.62485,-1.59418,-3.54076,8.28222,-4.72627,3.79184,0.13995,3.39109,5.28828,2.96711,0.4997,-14.98729,-6.87443,-14.42881,-2.92172,-7.7296,4.11218,-22.98387,-2.4091,-4.43094,0.12011,-11.3843,1.96287,-16.0104,-0.5541,4.30926,-1.97913,3.10845,1.63998,-6.84303,-1.77196,-6.93063,4.98243,-8.13606,5.6986,-3.91065,3.4655,-11.56204,3.08778,-9.4063,1.98035,-0.25551,2.74338,-0.3475,3.58666,1.97372,4.63014,3.59557,1.23049,0.19272,2.33788,-8.78735,2.8056,-6.43972,-0.43085,2.8015,-0.93279,3.24313,-1.23176,-3.38932,-3.22755,10.653,-0.53963,2.08547,-2.96166,5.35121,-2.9946,10.5157,-2.59729,8.82595,19.30161,-9.62279,10.04065,-11.6135,14.38348,-18.34987,8.10802,-1.54709,6.15129,-13.21498,-4.06235,-6.84723,-4.27836,1.66678,-0.91152,-17.04574,3.30947,-16.79984,2.20965,-16.50776,1.78208,-5.40714,2.9863,-8.78538,0.52863,-12.5357,-2.92494,-3.93778,1.98259,-8.66321,-0.14685,-14.4991,-0.19865,-1.27871,-2.69971,-2.05912,2.53244,-8.20283]},{"time":4.6,"vertices":[-13.23585,-3.12182,-19.81581,12.6107,1.07667,-0.47931,8.44568,-2.03151,19.36623,13.25906,14.68945,4.83096,19.96692,5.6562,19.79907,-12.89907,0.75992,-13.21417,-19.38301,-13.54753,6.60028,-3.67388,12.7839,0.19748,10.82996,0.53741,1.76941,-10.92689,5.07129,-10.34282,-0.7319,-11.51509,14.25288,-12.77577,15.47563,-2.15974,8.87518,-11.30283,2.76995,-13.05478,-6.03343,-19.41658,-4.18462,-11.92057,-6.15021,-9.00371,-3.30676,-7.77199,-9.57732,-8.48396,-10.06542,-12.35689,-10.82524,-9.74249,-13.1611,-9.03837,-14.13935,-2.24311,-6.98299,-13.80827,-3.18959,-19.46515,-0.30252,-16.80648,2.74858,-10.70665,4.86633,-12.22762,7.17838,-15.12004,11.63197,-0.18624,11.89079,-7.9735,12.46701,-3.12914,16.54681,2.07226,16.51477,3.18382,-1.95923,-0.21632,-5.35149,-6.21897,-0.1001,-3.39545,-10.97691,-3.28437,-4.66245,-4.38596,15.59581,-2.44851,15.02758,-0.20534,4.93092,-10.2555,18.9429,-12.22617,-1.60497,-9.70325,5.72585,-9.38074,12.00243,-11.73,-2.52554,-17.67085,7.18767,-12.88549,8.8299,-11.76675,6.80396,-13.00219,13.73757,-6.76037,7.49999,-12.85738,11.63176,-12.81963]},{"time":4.7333,"vertices":[11.89211,-3.0747,6.35181,-4.87351,4.76218,-16.92696,-1.54126,-17.76088,-6.97619,-3.91303,-11.121,-1.78,-5.36615,6.83735,-6.335,4.98479,0.1414,4.51808,6.99301,4.02427,-0.4213,-12.81375,-7.67176,-12.66075,-3.89148,-6.81332,3.29655,-19.12686,-2.69236,-2.68902,0.15295,-8.76687,0.04316,-12.65371,-2.20229,4.15865,-2.67257,4.11338,1.14873,-4.56453,-0.83549,-3.93528,4.88294,-5.90658,5.76264,-2.51452,3.38651,-9.39459,3.78943,-7.43565,2.96713,1.1157,3.71425,0.72531,4.74384,2.68021,5.75645,3.32755,1.96389,1.70148,2.46349,-5.59476,2.55501,-3.8072,-0.6097,3.72631,-1.28315,4.30675,-1.85435,-1.2213,-4.08617,9.55369,-1.76896,2.83206,-3.97681,5.1966,-4.45339,9.19972,-4.11911,7.57305,17.23135,-8.67169,9.43264,-9.68684,12.60443,-15.98322,8.43567,-1.1212,5.88581,-11.27533,-5.4201,-5.65557,-5.4833,1.6267,-1.46291,-13.88326,0.69127,-13.40157,2.0471,-13.53339,0.93031,-3.69669,1.26439,-6.39667,0.74257,-9.09857,-3.37189,-1.94645,0.73838,-6.29281,-0.96149,-11.31179,-1.71405,-0.27802,-3.19152,-0.28638,0.91598,-5.75474]},{"time":4.8667,"vertices":[-17.04426,-2.89985,-22.36845,13.80482,-1.02729,4.31279,8.297,3.33351,21.43711,15.19497,18.07735,6.12436,22.12968,4.24776,22.36526,-14.04998,1.07929,-14.72546,-21.44049,-15.4401,6.32539,0.14491,14.70426,4.42361,11.86095,2.87116,0.12529,-5.60225,5.94962,-9.52271,-1.04071,-9.12404,14.08289,-9.09976,16.60209,-3.10828,10.12204,-12.45024,2.43144,-11.92609,-5.84808,-18.59351,-5.8093,-10.61845,-7.95087,-8.70347,-4.6758,-5.30094,-11.08099,-6.68531,-10.92098,-13.09911,-11.95867,-10.36563,-14.55919,-10.29203,-15.8973,-3.62208,-7.44939,-14.66979,-3.99229,-18.26992,-1.0325,-16.06038,3.26059,-11.8876,5.6547,-13.55249,7.96485,-14.82687,13.45655,-2.63971,12.83348,-8.69381,14.11628,-4.35411,18.52493,-0.16796,18.31128,1.42425,-7.40957,1.58574,-8.55645,-3.92162,-4.44744,0.71391,-13.6466,-3.46152,-6.90639,-1.42898,17.24123,-0.38706,16.97486,-0.24013,4.95721,-6.21177,18.62669,-8.29838,-2.7117,-5.97723,5.50058,-8.39981,11.69724,-9.94555,-2.98537,-15.33599,8.36238,-12.27458,8.62798,-10.02511,6.85869,-9.76078,14.54749,-6.53104,8.69949,-12.73633,11.46206,-11.23102]},{"time":4.9667,"vertices":[9.16511,-2.18739,5.29376,-4.60264,3.4974,-11.69504,-1.26214,-12.07568,-6.27839,-3.10671,-8.69583,-1.31784,-5.13844,4.85249,-5.27964,4.61876,0.34335,3.89193,6.29227,3.12294,-0.40084,-8.57196,-5.90977,-8.6246,-3.25656,-4.57492,2.74804,-12.62331,-1.85472,-1.21319,0.57686,-5.49082,-0.2785,-7.72246,-2.43026,3.3642,-2.12996,3.67818,1.05018,-2.36974,0.34057,-1.82739,4.03936,-3.50375,4.63974,-1.35249,2.88446,-6.1682,3.51946,-4.92634,2.96032,1.22377,3.45948,0.79096,4.265,2.06225,4.8351,2.10748,2.11469,1.7841,2.496,-2.85725,2.29647,-1.6885,-0.35065,3.23877,-0.90896,3.77809,-1.28599,0.15265,-3.64666,6.87508,-1.74707,2.68735,-3.47945,4.03722,-4.24222,6.62476,-4.01476,5.43233,12.22792,-5.87364,7.17236,-6.43217,9.08769,-10.79209,6.60639,-0.806,4.63747,-7.67448,-4.53212,-3.48996,-4.70462,1.43158,-0.83773,-8.99468,-0.10313,-8.13992,1.96328,-8.90959,0.6166,-1.90217,0.58655,-3.47223,1.26066,-5.40541,-2.39218,-0.50211,0.40344,-3.49011,-0.55935,-6.98919,-1.80487,0.50322,-2.30855,0.66238,0.3858,-2.9772]},{"time":5.0667,"vertices":[-8.33853,-1.27204,-10.63578,6.7992,-0.71201,2.29726,3.79427,1.82739,10.39,7.17119,8.79785,2.91248,10.7098,1.77986,10.63841,-6.86573,0.42153,-7.04647,-10.3875,-7.23768,2.86628,0.24181,7.00128,2.27161,5.64366,1.42624,-0.26308,-2.36772,2.74607,-4.47762,-0.68228,-4.15654,6.45274,-4.22865,7.93414,-1.65121,4.77528,-6.01581,0.97051,-5.59819,-2.98459,-8.66946,-3.00233,-4.91903,-3.9754,-4.0534,-2.42892,-2.33388,-5.46619,-2.9645,-5.34168,-6.13648,-5.824,-4.83146,-7.05134,-4.81418,-7.63039,-1.6576,-3.68663,-6.91339,-2.1722,-8.54523,-0.72704,-7.55479,1.48711,-5.69968,2.62457,-6.51453,3.65443,-7.04735,6.5375,-1.46252,6.06949,-4.24931,6.78242,-2.21457,8.96869,-0.32878,8.85883,0.45093,-3.8714,0.79116,-4.35661,-1.70611,-2.48407,0.51782,-6.65407,-1.56314,-3.51125,-0.47336,8.20282,-0.17313,8.16218,-0.21589,2.15966,-2.7328,8.59797,-3.8879,-1.5293,-2.59279,2.47475,-3.96575,5.36447,-4.72032,-1.67855,-7.08724,3.88375,-5.81105,3.91659,-4.72395,3.04906,-4.48213,6.8675,-3.19071,4.05534,-6.06188,5.25327,-5.33433]},{"time":5.2333},{"time":6.0667,"vertices":[7.17848,-3.42638,0,0,5.42572,-16.45878,1.74104,-18.09897,0,0,-5.78609,-0.73536,1.31149,7.94153,0,0,0,0,0,0,2.04854,-13.77925,-2.86462,-12.6759,-0.00009,-6.7542,4.08717,-22.09231,-1.06798,-6.20035,-0.08147,-12.28359,4.83891,-16.76678,2.81412,2.94277,0,0,1.89272,-8.76137,-3.07864,-10.13071,3.27611,-9.4468,3.44452,-5.13387,2.29398,-11.51661,0.54729,-9.71761,-0.72302,-2.72166,-0.18715,-2.20151,0,0,0.77553,2.91688,-0.72302,-2.72166,1.10143,-11.72056,2.14642,-9.16574,0,0,0,0,0.30415,-6.3732,-0.38916,8.84673,1.97226,-0.17814,0.05386,3.63963,0.93135,9.1413,1.3116,7.94161,16.28554,-7.96837,7.51735,-11.08024,12.55339,-16.26722,4.51735,-1.72686,4.38773,-12.12615,-0.00009,-6.7542,-0.40472,1.05265,0.38705,-16.98303,7.04602,-17.38546,1.63327,-16.2354,2.70557,-6.77269,5.12817,-10.27983,-0.21504,-14.5845,-1.09903,-6.38051,3.56792,-10.14278,1.36574,-15.42086,2.74464,-2.82684,-0.86632,-4.76375,4.62883,-10.01948],"curve":"stepped"},{"time":6.2667,"vertices":[7.17848,-3.42638,0,0,5.42572,-16.45878,1.74104,-18.09897,0,0,-5.78609,-0.73536,1.31149,7.94153,0,0,0,0,0,0,2.04854,-13.77925,-2.86462,-12.6759,-0.00009,-6.7542,4.08717,-22.09231,-1.06798,-6.20035,-0.08147,-12.28359,4.83891,-16.76678,2.81412,2.94277,0,0,1.89272,-8.76137,-3.07864,-10.13071,3.27611,-9.4468,3.44452,-5.13387,2.29398,-11.51661,0.54729,-9.71761,-0.72302,-2.72166,-0.18715,-2.20151,0,0,0.77553,2.91688,-0.72302,-2.72166,1.10143,-11.72056,2.14642,-9.16574,0,0,0,0,0.30415,-6.3732,-0.38916,8.84673,1.97226,-0.17814,0.05386,3.63963,0.93135,9.1413,1.3116,7.94161,16.28554,-7.96837,7.51735,-11.08024,12.55339,-16.26722,4.51735,-1.72686,4.38773,-12.12615,-0.00009,-6.7542,-0.40472,1.05265,0.38705,-16.98303,7.04602,-17.38546,1.63327,-16.2354,2.70557,-6.77269,5.12817,-10.27983,-0.21504,-14.5845,-1.09903,-6.38051,3.56792,-10.14278,1.36574,-15.42086,2.74464,-2.82684,-0.86632,-4.76375,4.62883,-10.01948]},{"time":7.5}]}}}},"idle-woman":{"slots":{"matamata-beads":{"attachment":[{"time":0,"name":"matamata-beads"},{"time":4.5333,"name":"matamata-beads"}]},"matamata-bow":{"attachment":[{"time":0,"name":"matamata-bow"},{"time":4.5333,"name":"matamata-bow"}]}},"bones":{"matamata-hand1":{"rotate":[{"time":2.2667,"angle":0,"curve":"stepped"},{"time":4.5333,"angle":0,"curve":"stepped"},{"time":4.7333,"angle":0},{"time":5.0667,"angle":-16.04},{"time":5.3667,"angle":4.02},{"time":5.5333,"angle":-10.94},{"time":5.8,"angle":0.79},{"time":6,"angle":-12.07},{"time":6.3667,"angle":0,"curve":"stepped"},{"time":7.5,"angle":0}]},"matamata-head":{"rotate":[{"time":0,"angle":0,"curve":"stepped"},{"time":0.8,"angle":0},{"time":1.2333,"angle":-1.74},{"time":2.2667,"angle":0,"curve":"stepped"},{"time":3.0667,"angle":0},{"time":3.5,"angle":-1.74},{"time":4.5333,"angle":0},{"time":4.7667,"angle":-22.46},{"time":4.8667,"angle":-22.97},{"time":5.4667,"angle":-22.65},{"time":6,"angle":-23.87},{"time":6.5667,"angle":0},{"time":6.7667,"angle":-8.64},{"time":6.9333,"angle":0.82},{"time":7.1667,"angle":-11.22},{"time":7.5,"angle":0}],"translate":[{"time":2.2667,"x":0,"y":0,"curve":"stepped"},{"time":4.5333,"x":0,"y":0},{"time":4.8667,"x":-2.15,"y":2.89},{"time":5.7333,"x":6.29,"y":1.65},{"time":6.3667,"x":0,"y":0,"curve":"stepped"},{"time":7.5,"x":0,"y":0}]},"matamata-brow":{"rotate":[{"time":2.2667,"angle":0,"curve":"stepped"},{"time":4.5333,"angle":0},{"time":4.8333,"angle":-8.66},{"time":5.3,"angle":-1.15},{"time":6.3667,"angle":0,"curve":"stepped"},{"time":7.5,"angle":0}],"translate":[{"time":0,"x":0,"y":0,"curve":"stepped"},{"time":0.3,"x":0,"y":0},{"time":0.4667,"x":-8.15,"y":1.61},{"time":1.2333,"x":-6.05,"y":-5.88},{"time":1.5667,"x":-1.15,"y":-6},{"time":2.2667,"x":0,"y":0,"curve":"stepped"},{"time":2.5667,"x":0,"y":0},{"time":2.7333,"x":-8.15,"y":1.61},{"time":3.5,"x":-6.05,"y":-5.88},{"time":3.8333,"x":-1.15,"y":-6},{"time":4.5333,"x":0,"y":0},{"time":4.6,"x":1.16,"y":-0.35},{"time":4.7,"x":-10.34,"y":6.63,"curve":"stepped"},{"time":4.8333,"x":-10.34,"y":6.63},{"time":5.2667,"x":12.1,"y":-2.76},{"time":5.7,"x":-9.85,"y":-0.84},{"time":6.0333,"x":5.54,"y":-4.54},{"time":6.1333,"x":3.88,"y":-3.18},{"time":6.3667,"x":-14.85,"y":7.59},{"time":6.8333,"x":4.22,"y":-7.63,"curve":"stepped"},{"time":7.3,"x":4.22,"y":-7.63},{"time":7.5,"x":0,"y":0}]},"matamata-hand2":{"rotate":[{"time":0,"angle":0},{"time":1.2333,"angle":24.01},{"time":2.2667,"angle":0},{"time":3.5,"angle":24.01},{"time":4.5333,"angle":0,"curve":"stepped"},{"time":7.5,"angle":0}],"translate":[{"time":0,"x":0,"y":0},{"time":1.2333,"x":3.5,"y":-14.81},{"time":2.2667,"x":0,"y":0},{"time":3.5,"x":3.5,"y":-14.81},{"time":4.5333,"x":0,"y":0},{"time":4.8,"x":11.39,"y":-19.22},{"time":5.2,"x":1.08,"y":-22.34},{"time":5.5667,"x":-0.66,"y":-8.91},{"time":6,"x":-0.3,"y":-4.08},{"time":6.3667,"x":6.17,"y":-13.66},{"time":6.6333,"x":-6.2,"y":-15.41},{"time":7.5,"x":0,"y":0}]},"matamata-top":{"rotate":[{"time":0,"angle":0},{"time":1.1333,"angle":-1.51,"curve":"stepped"},{"time":1.2333,"angle":-1.51},{"time":2.2667,"angle":0},{"time":3.4,"angle":-1.51,"curve":"stepped"},{"time":3.5,"angle":-1.51},{"time":4.5333,"angle":0},{"time":4.8,"angle":3.98},{"time":4.9,"angle":0.5},{"time":5.1667,"angle":-2.88},{"time":5.4667,"angle":3.67},{"time":5.8333,"angle":-3.53},{"time":6.4333,"angle":3.23},{"time":6.7667,"angle":-4.83},{"time":6.9,"angle":-2.86},{"time":7.0667,"angle":-4.8},{"time":7.5,"angle":0}],"translate":[{"time":0,"x":0,"y":0},{"time":0.6333,"x":-6.5,"y":-9.71},{"time":1.0667,"x":-8.07,"y":-14.28,"curve":"stepped"},{"time":1.2,"x":-8.07,"y":-14.28},{"time":2.2667,"x":0,"y":0},{"time":2.9,"x":-6.5,"y":-9.71},{"time":3.3333,"x":-8.07,"y":-14.28,"curve":"stepped"},{"time":3.4667,"x":-8.07,"y":-14.28},{"time":4.5333,"x":0,"y":0},{"time":4.7333,"x":9.61,"y":22.14},{"time":5.0333,"x":20.3,"y":-24.48},{"time":5.1667,"x":21.14,"y":-29.74},{"time":5.3667,"x":20.01,"y":13.07},{"time":5.5333,"x":12.51,"y":29.98},{"time":5.9667,"x":-7.92,"y":-19.52},{"time":6.2667,"x":7.33,"y":13.75},{"time":6.3667,"x":14.02,"y":12.05},{"time":6.6,"x":17.32,"y":-24.16,"curve":"stepped"},{"time":6.6667,"x":17.32,"y":-24.16},{"time":7.5,"x":0,"y":0}]},"matamata-neck":{"rotate":[{"time":0,"angle":0},{"time":1.1333,"angle":-2.37,"curve":"stepped"},{"time":1.2667,"angle":-2.37},{"time":2.2667,"angle":0},{"time":3.4,"angle":-2.37,"curve":"stepped"},{"time":3.5333,"angle":-2.37},{"time":4.5333,"angle":0},{"time":4.8333,"angle":14.89},{"time":5.2333,"angle":3.91},{"time":5.6,"angle":15.31},{"time":6.0333,"angle":-0.72},{"time":6.4,"angle":11.21},{"time":6.6333,"angle":10.43},{"time":6.8,"angle":6.39},{"time":6.9333,"angle":10.54},{"time":7.1,"angle":4.93},{"time":7.5,"angle":0}]},"bone4":{"rotate":[{"time":0,"angle":0},{"time":1.5,"angle":-5,"curve":"stepped"},{"time":1.6,"angle":-5},{"time":2.2667,"angle":0},{"time":3.7667,"angle":-5,"curve":"stepped"},{"time":3.8667,"angle":-5},{"time":4.5333,"angle":0},{"time":4.9333,"angle":7.03},{"time":5.1333,"angle":-0.36},{"time":5.3,"angle":-10.14},{"time":5.5667,"angle":-0.5},{"time":5.7,"angle":9.19},{"time":5.9,"angle":9.79},{"time":6.1,"angle":4.61},{"time":6.3667,"angle":10.65},{"time":6.4667,"angle":5.88},{"time":6.6667,"angle":-7.82},{"time":7,"angle":-4.69},{"time":7.2,"angle":-8.8},{"time":7.5,"angle":0}],"translate":[{"time":0,"x":0,"y":0},{"time":0.4,"x":-8.39,"y":-8.6},{"time":1.1333,"x":-19.75,"y":-26.02},{"time":2.2667,"x":0,"y":0},{"time":2.6667,"x":-8.39,"y":-8.6},{"time":3.4,"x":-19.75,"y":-26.02},{"time":4.5333,"x":0,"y":0,"curve":"stepped"},{"time":6.6333,"x":0,"y":0},{"time":6.8333,"x":-6.56,"y":-7.76},{"time":6.9667,"x":-0.82,"y":0.98},{"time":7.1333,"x":-9.94,"y":-18.05},{"time":7.5,"x":0,"y":0}]},"bone5":{"rotate":[{"time":0,"angle":0},{"time":1.3333,"angle":-6.65},{"time":2.2667,"angle":0},{"time":3.6,"angle":-6.65},{"time":4.5333,"angle":0,"curve":"stepped"},{"time":7.5,"angle":0}],"translate":[{"time":2.2667,"x":0,"y":0,"curve":"stepped"},{"time":4.5333,"x":0,"y":0,"curve":"stepped"},{"time":6.6333,"x":0,"y":0},{"time":6.8667,"x":-14.94,"y":-6.41},{"time":7,"x":-4.36,"y":-0.9},{"time":7.1667,"x":-10.94,"y":-3.46},{"time":7.5,"x":0,"y":0}]},"matamata-eyeball2":{"translate":[{"time":0,"x":0,"y":0},{"time":1.3,"x":-2.99,"y":-5.89},{"time":2.2667,"x":0,"y":0},{"time":3.5667,"x":-2.99,"y":-5.89},{"time":4.5333,"x":0,"y":0},{"time":4.8667,"x":-8.23,"y":3.95},{"time":5.2667,"x":4.53,"y":-2.09},{"time":5.6333,"x":-5.71,"y":3},{"time":6.0667,"x":-1.64,"y":-5.95},{"time":6.4,"x":-4.34,"y":7.84},{"time":6.5333,"x":-6.8,"y":7.84},{"time":6.7,"x":0.11,"y":-2.03},{"time":6.8667,"x":-3.5,"y":-7.89},{"time":7,"x":-0.56,"y":-1.04},{"time":7.2,"x":-5.36,"y":-7.03},{"time":7.5,"x":0,"y":0}]},"matamata-eyeball1":{"translate":[{"time":0,"x":0,"y":0},{"time":1.3,"x":-2.99,"y":-5.89},{"time":2.2667,"x":0,"y":0},{"time":3.5667,"x":-2.99,"y":-5.89},{"time":4.5333,"x":0,"y":0},{"time":4.8667,"x":-8.23,"y":3.95},{"time":5.2667,"x":4.53,"y":-2.09},{"time":5.6333,"x":-5.71,"y":3},{"time":6.0667,"x":-1.64,"y":-5.95},{"time":6.4,"x":-4.34,"y":7.84},{"time":6.5333,"x":-6.8,"y":7.84},{"time":6.7,"x":0.11,"y":-2.03},{"time":6.8667,"x":-3.5,"y":-7.89},{"time":7,"x":-0.56,"y":-1.04},{"time":7.2,"x":-5.36,"y":-7.03},{"time":7.5,"x":0,"y":0}]},"bone":{"rotate":[{"time":2.2667,"angle":0,"curve":"stepped"},{"time":4.5333,"angle":0,"curve":"stepped"},{"time":5.2667,"angle":0},{"time":5.4333,"angle":-10.85},{"time":5.5667,"angle":6.65},{"time":5.6333,"angle":8.23},{"time":5.8333,"angle":-8.46},{"time":6.1,"angle":-4.23},{"time":6.3,"angle":-29.53},{"time":6.4667,"angle":22.33},{"time":6.6,"angle":0,"curve":"stepped"},{"time":7.5,"angle":0}],"translate":[{"time":2.2667,"x":0,"y":0,"curve":"stepped"},{"time":4.5333,"x":0,"y":0,"curve":"stepped"},{"time":5.3333,"x":0,"y":0},{"time":5.5333,"x":14.34,"y":46.33},{"time":5.7333,"x":-22.81,"y":17.52},{"time":5.8667,"x":-25.65,"y":-14.69,"curve":"stepped"},{"time":6.1667,"x":-25.65,"y":-14.69},{"time":6.4333,"x":1.1,"y":28.68},{"time":6.6,"x":0,"y":0,"curve":"stepped"},{"time":7.5,"x":0,"y":0}]},"matamata-pupil2":{"translate":[{"time":2.2667,"x":0,"y":0,"curve":"stepped"},{"time":4.5333,"x":0,"y":0,"curve":"stepped"},{"time":4.7333,"x":0,"y":0},{"time":4.8,"x":-1.54,"y":-4.03,"curve":"stepped"},{"time":5.0333,"x":-1.54,"y":-4.03},{"time":5.1333,"x":2.89,"y":0.78},{"time":5.6333,"x":-0.86,"y":2.65,"curve":"stepped"},{"time":5.8,"x":-0.86,"y":2.65},{"time":5.9,"x":-0.55,"y":-7.29,"curve":"stepped"},{"time":6.2333,"x":-0.55,"y":-7.29},{"time":6.3333,"x":2.44,"y":2.94},{"time":6.7,"x":0.55,"y":3.09},{"time":6.8333,"x":-1.92,"y":-7.09},{"time":7,"x":-1.61,"y":4.71},{"time":7.2,"x":-5.32,"y":-7.78},{"time":7.5,"x":0,"y":0}]},"matamata-pupil":{"translate":[{"time":2.2667,"x":0,"y":0,"curve":"stepped"},{"time":4.5333,"x":0,"y":0,"curve":"stepped"},{"time":4.7333,"x":0,"y":0},{"time":4.8,"x":-1.22,"y":-3.41,"curve":"stepped"},{"time":5.0333,"x":-1.22,"y":-3.41},{"time":5.1333,"x":1.94,"y":1.66},{"time":5.6333,"x":-2.46,"y":3.44,"curve":"stepped"},{"time":5.8,"x":-2.46,"y":3.44},{"time":5.9,"x":-2.96,"y":-10.82,"curve":"stepped"},{"time":6.2333,"x":-2.96,"y":-10.82},{"time":6.3333,"x":0.14,"y":1.38,"curve":"stepped"},{"time":6.7,"x":0.14,"y":1.38},{"time":6.8333,"x":-3.48,"y":-8.38},{"time":7,"x":-0.97,"y":4.62},{"time":7.2,"x":-4.87,"y":-7.52},{"time":7.5,"x":0,"y":0}]}},"deform":{"default":{"matamata-brow":{"matamata-brow":[{"time":0,"curve":"stepped"},{"time":0.3333},{"time":0.5333,"offset":8,"vertices":[-1.84662,-11.12938,-0.3251,-6.62026,1.17422,-8.13065,-0.31973,-5.11543],"curve":"stepped"},{"time":1.1667,"offset":8,"vertices":[-1.84662,-11.12938,-0.3251,-6.62026,1.17422,-8.13065,-0.31973,-5.11543]},{"time":1.5,"curve":"stepped"},{"time":2.2667,"curve":"stepped"},{"time":2.6},{"time":2.8,"offset":8,"vertices":[-1.84662,-11.12938,-0.3251,-6.62026,1.17422,-8.13065,-0.31973,-5.11543],"curve":"stepped"},{"time":3.4333,"offset":8,"vertices":[-1.84662,-11.12938,-0.3251,-6.62026,1.17422,-8.13065,-0.31973,-5.11543]},{"time":3.7667,"curve":"stepped"},{"time":4.5333,"curve":"stepped"},{"time":4.6333},{"time":4.7333,"offset":6,"vertices":[0.13895,1.23802,-0.20966,-8.95087,-1.85367,-7.40315,-1.02591,-6.90466,-1.76752,-5.69318],"curve":"stepped"},{"time":4.8333,"offset":6,"vertices":[0.13895,1.23802,-0.20966,-8.95087,-1.85367,-7.40315,-1.02591,-6.90466,-1.76752,-5.69318]},{"time":5.2333,"curve":"stepped"},{"time":5.3333},{"time":5.6333,"offset":6,"vertices":[0.13895,1.23802,-0.20966,-8.95087,-1.85367,-7.40315,-1.02591,-6.90466,-1.76752,-5.69318]},{"time":6.0333,"curve":"stepped"},{"time":6.2333},{"time":6.4,"offset":6,"vertices":[0.13895,1.23802,-0.20966,-8.95087,-1.85367,-7.40315,-1.02591,-6.90466,-1.76752,-5.69318]},{"time":6.7,"curve":"stepped"},{"time":7.5}]},"matamata-eyeball1":{"matamata-eyeball1":[{"time":0,"curve":"stepped"},{"time":1.7},{"time":1.7667,"vertices":[1.92242,-0.2634,0,0,-6.11427,4.31441]},{"time":1.8333,"vertices":[-20.68909,4.48355,0,0,11.73647,0.56123],"curve":"stepped"},{"time":1.8667,"vertices":[-20.68909,4.48355,0,0,11.73647,0.56123]},{"time":1.9667,"vertices":[1.67155,-0.46666,0,0,-2.74072,-0.1357]},{"time":2.0333,"curve":"stepped"},{"time":2.2667,"curve":"stepped"},{"time":3.9667},{"time":4.0333,"vertices":[1.92242,-0.2634,0,0,-6.11427,4.31441]},{"time":4.1,"vertices":[-20.68909,4.48355,0,0,11.73647,0.56123],"curve":"stepped"},{"time":4.1333,"vertices":[-20.68909,4.48355,0,0,11.73647,0.56123]},{"time":4.2333,"vertices":[1.67155,-0.46666,0,0,-2.74072,-0.1357]},{"time":4.3,"curve":"stepped"},{"time":4.5333,"curve":"stepped"},{"time":4.8667},{"time":4.9333,"vertices":[-20.68909,4.48355,0,0,11.73647,0.56123]},{"time":5,"curve":"stepped"},{"time":6.5333},{"time":6.7,"vertices":[-8.83026,10.35745,0,0,8.33235,0.71625],"curve":"stepped"},{"time":7.2,"vertices":[-8.83026,10.35745,0,0,8.33235,0.71625]},{"time":7.5}]},"matamata-eyeball2":{"matamata-eyeball1":[{"time":0,"curve":"stepped"},{"time":1.7},{"time":1.7667,"vertices":[1.32104,-0.00851,0,0,-4.61964,0.69083]},{"time":1.8333,"vertices":[-21.12239,9.04794,0,0,10.73662,1.38763],"curve":"stepped"},{"time":1.8667,"vertices":[-21.12239,9.04794,0,0,10.73662,1.38763]},{"time":1.9667,"vertices":[1.32104,-0.00851,0,0,-4.61964,0.69083]},{"time":2.0333,"curve":"stepped"},{"time":2.2667,"curve":"stepped"},{"time":3.9667},{"time":4.0333,"vertices":[1.32104,-0.00851,0,0,-4.61964,0.69083]},{"time":4.1,"vertices":[-21.12239,9.04794,0,0,10.73662,1.38763],"curve":"stepped"},{"time":4.1333,"vertices":[-21.12239,9.04794,0,0,10.73662,1.38763]},{"time":4.2333,"vertices":[1.32104,-0.00851,0,0,-4.61964,0.69083]},{"time":4.3,"curve":"stepped"},{"time":4.5333,"curve":"stepped"},{"time":4.8667},{"time":4.9333,"vertices":[-21.12239,9.04794,0,0,10.73662,1.38763]},{"time":5,"curve":"stepped"},{"time":6.5333},{"time":6.7,"vertices":[-10.10381,7.35538,0,0,6.42815,-1.54596],"curve":"stepped"},{"time":7.2,"vertices":[-10.10381,7.35538,0,0,6.42815,-1.54596]},{"time":7.5}]},"matamata-hand1":{"matamata-hand1":[{"time":0},{"time":1.1667,"offset":4,"vertices":[1.69563,0.24538,0.61058,-1.60107,-1.54639,-0.19243,-0.52628,1.46708,0,0,0,0,0,0,0,0,-1.68444,-0.737,-1.08797,1.48264,-4.34853,-2.23878,-3.13669,3.75392,-8.08845,0.46481,-1.31677,7.99561]},{"time":2.2667},{"time":3.4333,"offset":4,"vertices":[1.69563,0.24538,0.61058,-1.60107,-1.54639,-0.19243,-0.52628,1.46708,0,0,0,0,0,0,0,0,-1.68444,-0.737,-1.08797,1.48264,-4.34853,-2.23878,-3.13669,3.75392,-8.08845,0.46481,-1.31677,7.99561]},{"time":4.5333,"curve":"stepped"},{"time":4.7333},{"time":5.0333,"offset":8,"vertices":[-1.60256,2.40738,2.448,1.54072,0,0,0,0,0,0,-29.58015,-39.21676,-3.82508,-3.21022,-2.97676,4.01057,-13.05325,-8.39924,-7.83422,13.41647,-23.41675,-3.51511,-2.31619,23.61372]},{"time":5.2333,"offset":14,"vertices":[16.32151,9.4246,11.5619,-14.88821,-16.32146,-9.42463,0,0,0,0,0,0,0,0,-12.71707,-1.8253,-3.54102,12.35214]},{"time":5.3667},{"time":5.5333,"offset":18,"vertices":[-10.4304,-31.39236,0,0,0,0,0,0,0,0,-5.75744,-3.64405,-3.96806,5.54055]},{"time":5.8667,"offset":18,"vertices":[-6.25824,-18.83541,0,0,0,0,0,0,0,0,-3.45446,-2.18643,-2.38084,3.32433]},{"time":6,"offset":18,"vertices":[-10.66423,-16.53856,0,0,0,0,-1.12232,-0.69481,-0.813,1.04021,-7.80655,-2.28054,-2.99328,7.60701]},{"time":6.3667},{"time":6.4333,"offset":2,"vertices":[5.89341,-9.29313,12.2794,4.22915,4.29936,-12.07071,0,0,0,0,0,0,0,0,0,0,-2.38964,-28.59184,0,0,0,0,0,0,0,0,-10.67213,-2.48782,-1.40083,10.86913]},{"time":6.4667,"offset":2,"vertices":[1.11205,-6.41575,8.21821,1.89868,1.06172,-8.36815,0,0,0,0,0,0,0,0,0,0,-3.58447,-42.88777,0,0,0,0,0,0,0,0,-16.0082,-3.73173,-2.10124,16.30369]},{"time":6.6333,"offset":28,"vertices":[-10.42357,-3.71828,-5.89597,9.36795]},{"time":7.5}]},"matamata-hand2":{"matamata-hand2":[{"time":0},{"time":1.2333,"offset":26,"vertices":[-2.79613,2.65508,-1.05219,3.65636,0,0,0,0,0.20534,0.74329,0.45594,0.56]},{"time":2.2667},{"time":3.5,"offset":26,"vertices":[-2.79613,2.65508,-1.05219,3.65636,0,0,0,0,0.20534,0.74329,0.45594,0.56]},{"time":4.5333,"curve":"stepped"},{"time":4.8333},{"time":5.0667,"offset":26,"vertices":[-11.41948,7.64392,-3.2052,13.22755,-8.67681,5.05278,-2.8568,9.47589,-6.43843,3.32324,-2.35787,6.70728,-6.91431,2.82007,-2.94995,6.63322]},{"time":5.1667,"offset":26,"vertices":[-15.31981,7.99385,-5.47955,16.05568,-12.80254,5.5098,-5.21763,12.54007,-9.67238,2.98997,-4.49844,8.66882,-6.91431,2.82007,-2.94995,6.63322]},{"time":5.5667},{"time":5.9667,"offset":26,"vertices":[-15.29599,7.9948,-5.47951,16.05576,-12.36496,5.12732,-5.16699,11.97734,-1.97441,6.66139,2.46419,6.32979,-6.91431,2.82007,-2.94995,6.63322]},{"time":6.3333},{"time":6.8,"offset":26,"vertices":[-15.24479,6.39537,-6.34624,14.81259,-12.48395,3.84264,-5.96732,11.08357,-5.75955,1.98962,-2.44225,5.39186,-6.91431,2.82007,-2.94995,6.63322]},{"time":6.9333,"offset":26,"vertices":[-12.34102,5.1772,-5.13743,11.99114,-10.10605,3.1107,-4.83068,8.97241,-4.66249,1.61065,-1.97706,4.36484,-5.59729,2.28291,-2.38806,5.36975]},{"time":7.0667,"offset":26,"vertices":[-10.18255,6.22682,-3.04609,11.32505,-7.72816,2.37877,-3.69405,6.86126,-3.75891,3.62436,-0.21176,5.2026,-4.28029,1.74576,-1.82616,4.10628]},{"time":7.5}]},"matamata-head":{"matamata-head":[{"time":0},{"time":1.2333,"vertices":[0.3194,-24.05716,-4.98137,1.31299,8.8679,14.44458,10.20221,6.36807,1.43931,-10.95338,-4.44151,-16.85362,-3.86011,-12.42871,2.05828,-0.276,1.36501,4.16866]},{"time":2.2667},{"time":3.5,"vertices":[0.3194,-24.05716,-4.98137,1.31299,8.8679,14.44458,10.20221,6.36807,1.43931,-10.95338,-4.44151,-16.85362,-3.86011,-12.42871,2.05828,-0.276,1.36501,4.16866]},{"time":4.5333},{"time":4.8667,"offset":8,"vertices":[-8.2553,3.34496,-10.98383,2.08496,-9.61082,1.82428,0,0,2.46783,-0.11304]},{"time":5.2667,"offset":8,"vertices":[12.49626,-5.07047,11.31808,-6.09628,8.43728,-6.1185,0,0,-0.41718,4.74875]},{"time":5.7,"offset":8,"vertices":[-8.2553,3.34496,-14.97273,1.85428,-14.37572,1.70242,0,0,2.46783,-0.11304]},{"time":6.1,"offset":8,"vertices":[6.26127,-9.64609,0.87685,-5.4328,-7.62865,-12.12944,0,0,-0.41718,4.74875]},{"time":6.4667,"offset":8,"vertices":[-1.42777,8.51643,-6.48944,19.02324,-5.55505,10.00328,-8.06877,3.40886,2.46783,-0.11304]},{"time":6.7667,"offset":8,"vertices":[9.30841,-12.19855,3.42864,-14.24373,-4.58764,-17.65091,0,0,-0.41718,4.74875]},{"time":6.8333,"vertices":[-5.95248,-13.92897,0,0,0,0,0,0,7.42576,-8.17104,0.25393,-18.05093,-5.66911,-18.77571,0,0,0.54449,3.12816]},{"time":6.9667,"offset":8,"vertices":[3.66044,-0.11601,-1.97545,1.32567,-6.07112,0.37302,0,0,2.46783,-0.11304]},{"time":7,"vertices":[3.69678,22.85498,0,0,0,0,0,0,3.58319,-1.92489,1.36548,8.59687,-5.72896,8.34048,0,0,2.05568,0.5815]},{"time":7.2,"offset":8,"vertices":[3.11972,-12.7782,-3.71916,-10.87219,-7.57804,-14.11545,0,0,-0.41718,4.74875]},{"time":7.2333,"vertices":[-3.37113,-16.3701,0,0,0,0,0,0,2.07981,-8.5188,-4.5635,-16.19785,-6.34261,-20.19982,0,0,-0.27812,3.16583]},{"time":7.5}]},"matamata-leg1":{"matamata-leg1":[{"time":0},{"time":1.1667,"offset":14,"vertices":[1.37394,-1.68875,-1.56612,-2.33845,-0.8322,0.69551,0.54393,1.29221,0,0,0,0,0,0,0,0,0,0,1.3813,-2.27693,-2.29019,-2.57061,0,0,0,0,0,0,0,0,0,0,0,0,-1.23498,4.69032,5.32813,3.30479]},{"time":2.2667},{"time":3.4333,"offset":14,"vertices":[1.37394,-1.68875,-1.56612,-2.33845,-0.8322,0.69551,0.54393,1.29221,0,0,0,0,0,0,0,0,0,0,1.3813,-2.27693,-2.29019,-2.57061,0,0,0,0,0,0,0,0,0,0,0,0,-1.23498,4.69032,5.32813,3.30479]},{"time":4.5333,"curve":"stepped"},{"time":4.7},{"time":5.0333,"offset":18,"vertices":[-4.32925,-1.74907,-3.83034,4.66503,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-5.81664,0.20673,-1.99223,7.25549,0,0,0,0,0,0,0,0,-4.82042,0.80509,-0.86923,6.25767]},{"time":5.5333},{"time":5.9333,"offset":10,"vertices":[3.80626,0.31775,1.76553,-4.61124,0,0,0,0,-0.5737,1.5737,1.74709,1.27906,0,0,0,0,0,0,0,0,0,0,0.31472,0.11475,0.2558,-0.34942,-1.28866,0.59995,0.28049,1.81573,0,0,0,0,0,0,0,0,-3.88003,2.19405,1.32603,5.60712]},{"time":6.3667},{"time":6.6,"offset":18,"vertices":[-3.72527,-0.58746,-2.19405,4.35368,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-4.70521,1.3733,-0.16739,6.33408,0,0,0,0,0,0,0,0,-4.31331,0.19688,-1.46072,5.38723]},{"time":7.5}]},"matamata-ltongue":{"matamata-ltongue":[{"time":0,"curve":"stepped"},{"time":0.9667},{"time":1.3333,"vertices":[3.46371,-26.20889]},{"time":1.5,"vertices":[5.28198,-39.38304]},{"time":1.7667,"vertices":[-2.03481,-13.07393]},{"time":1.9,"vertices":[-5.41053,2.89232]},{"time":2.2667,"curve":"stepped"},{"time":3.2333},{"time":3.6,"vertices":[3.46371,-26.20889]},{"time":3.7667,"vertices":[5.28198,-39.38304]},{"time":4.0333,"vertices":[-2.03481,-13.07393]},{"time":4.1667,"vertices":[-5.41053,2.89232]},{"time":4.5333},{"time":4.9,"vertices":[-4.43973,-74.09471]},{"time":5.0333,"vertices":[-6.74969,-30.3615]},{"time":5.1333,"vertices":[7.36572,-54.00793]},{"time":5.4333,"vertices":[-4.66533,5.80661]},{"time":5.6333,"vertices":[3.42645,-11.80691]},{"time":5.9667,"vertices":[-1.99943,2.48855]},{"time":6.3667,"vertices":[6.076,-25.71782]},{"time":6.5333},{"time":6.7,"vertices":[-4.04576,-31.07315]},{"time":6.9667,"vertices":[4.5687,-14.09827]},{"time":7.2,"vertices":[0.42673,-43.17049]},{"time":7.5}]},"matamata-top":{"matamata-top":[{"time":0},{"time":0.8333,"vertices":[7.17848,-3.42638,0,0,5.42572,-16.45878,1.74104,-18.09897,0,0,-5.78609,-0.73536,1.31149,7.94153,0,0,0,0,0,0,2.04854,-13.77925,-2.86462,-12.6759,-0.00009,-6.7542,4.08717,-22.09231,-1.06798,-6.20035,-0.08147,-12.28359,4.83891,-16.76678,2.81412,2.94277,0,0,1.89272,-8.76137,-3.07864,-10.13071,3.27611,-9.4468,3.44452,-5.13387,2.29398,-11.51661,0.54729,-9.71761,-0.72302,-2.72166,-0.18715,-2.20151,0,0,0.77553,2.91688,-0.72302,-2.72166,1.10143,-11.72056,2.14642,-9.16574,0,0,0,0,0.30415,-6.3732,-0.38916,8.84673,1.97226,-0.17814,0.05386,3.63963,0.93135,9.1413,1.3116,7.94161,16.28554,-7.96837,7.51735,-11.08024,12.55339,-16.26722,4.51735,-1.72686,4.38773,-12.12615,-0.00009,-6.7542,-0.40472,1.05265,0.38705,-16.98303,7.04602,-17.38546,1.63327,-16.2354,2.70557,-6.77269,5.12817,-10.27983,-0.21504,-14.5845,-1.09903,-6.38051,3.56792,-10.14278,1.36574,-15.42086,2.74464,-2.82684,-0.86632,-4.76375,4.62883,-10.01948],"curve":"stepped"},{"time":1.0333,"vertices":[7.17848,-3.42638,0,0,5.42572,-16.45878,1.74104,-18.09897,0,0,-5.78609,-0.73536,1.31149,7.94153,0,0,0,0,0,0,2.04854,-13.77925,-2.86462,-12.6759,-0.00009,-6.7542,4.08717,-22.09231,-1.06798,-6.20035,-0.08147,-12.28359,4.83891,-16.76678,2.81412,2.94277,0,0,1.89272,-8.76137,-3.07864,-10.13071,3.27611,-9.4468,3.44452,-5.13387,2.29398,-11.51661,0.54729,-9.71761,-0.72302,-2.72166,-0.18715,-2.20151,0,0,0.77553,2.91688,-0.72302,-2.72166,1.10143,-11.72056,2.14642,-9.16574,0,0,0,0,0.30415,-6.3732,-0.38916,8.84673,1.97226,-0.17814,0.05386,3.63963,0.93135,9.1413,1.3116,7.94161,16.28554,-7.96837,7.51735,-11.08024,12.55339,-16.26722,4.51735,-1.72686,4.38773,-12.12615,-0.00009,-6.7542,-0.40472,1.05265,0.38705,-16.98303,7.04602,-17.38546,1.63327,-16.2354,2.70557,-6.77269,5.12817,-10.27983,-0.21504,-14.5845,-1.09903,-6.38051,3.56792,-10.14278,1.36574,-15.42086,2.74464,-2.82684,-0.86632,-4.76375,4.62883,-10.01948]},{"time":2.2667},{"time":3.1,"vertices":[7.17848,-3.42638,0,0,5.42572,-16.45878,1.74104,-18.09897,0,0,-5.78609,-0.73536,1.31149,7.94153,0,0,0,0,0,0,2.04854,-13.77925,-2.86462,-12.6759,-0.00009,-6.7542,4.08717,-22.09231,-1.06798,-6.20035,-0.08147,-12.28359,4.83891,-16.76678,2.81412,2.94277,0,0,1.89272,-8.76137,-3.07864,-10.13071,3.27611,-9.4468,3.44452,-5.13387,2.29398,-11.51661,0.54729,-9.71761,-0.72302,-2.72166,-0.18715,-2.20151,0,0,0.77553,2.91688,-0.72302,-2.72166,1.10143,-11.72056,2.14642,-9.16574,0,0,0,0,0.30415,-6.3732,-0.38916,8.84673,1.97226,-0.17814,0.05386,3.63963,0.93135,9.1413,1.3116,7.94161,16.28554,-7.96837,7.51735,-11.08024,12.55339,-16.26722,4.51735,-1.72686,4.38773,-12.12615,-0.00009,-6.7542,-0.40472,1.05265,0.38705,-16.98303,7.04602,-17.38546,1.63327,-16.2354,2.70557,-6.77269,5.12817,-10.27983,-0.21504,-14.5845,-1.09903,-6.38051,3.56792,-10.14278,1.36574,-15.42086,2.74464,-2.82684,-0.86632,-4.76375,4.62883,-10.01948],"curve":"stepped"},{"time":3.3,"vertices":[7.17848,-3.42638,0,0,5.42572,-16.45878,1.74104,-18.09897,0,0,-5.78609,-0.73536,1.31149,7.94153,0,0,0,0,0,0,2.04854,-13.77925,-2.86462,-12.6759,-0.00009,-6.7542,4.08717,-22.09231,-1.06798,-6.20035,-0.08147,-12.28359,4.83891,-16.76678,2.81412,2.94277,0,0,1.89272,-8.76137,-3.07864,-10.13071,3.27611,-9.4468,3.44452,-5.13387,2.29398,-11.51661,0.54729,-9.71761,-0.72302,-2.72166,-0.18715,-2.20151,0,0,0.77553,2.91688,-0.72302,-2.72166,1.10143,-11.72056,2.14642,-9.16574,0,0,0,0,0.30415,-6.3732,-0.38916,8.84673,1.97226,-0.17814,0.05386,3.63963,0.93135,9.1413,1.3116,7.94161,16.28554,-7.96837,7.51735,-11.08024,12.55339,-16.26722,4.51735,-1.72686,4.38773,-12.12615,-0.00009,-6.7542,-0.40472,1.05265,0.38705,-16.98303,7.04602,-17.38546,1.63327,-16.2354,2.70557,-6.77269,5.12817,-10.27983,-0.21504,-14.5845,-1.09903,-6.38051,3.56792,-10.14278,1.36574,-15.42086,2.74464,-2.82684,-0.86632,-4.76375,4.62883,-10.01948]},{"time":4.5333},{"time":4.9667,"vertices":[7.17848,-3.42638,0,0,5.42572,-16.45878,1.74104,-18.09897,0,0,-5.78609,-0.73536,1.31149,7.94153,0,0,0,0,0,0,2.04854,-13.77925,-2.86462,-12.6759,-0.00009,-6.7542,4.08717,-22.09231,-1.06798,-6.20035,-0.08147,-12.28359,4.83891,-16.76678,2.81412,2.94277,0,0,1.89272,-8.76137,-3.07864,-10.13071,3.27611,-9.4468,3.44452,-5.13387,2.29398,-11.51661,0.54729,-9.71761,-0.72302,-2.72166,-0.18715,-2.20151,0,0,0.77553,2.91688,-0.72302,-2.72166,1.10143,-11.72056,2.14642,-9.16574,0,0,0,0,0.30415,-6.3732,-0.38916,8.84673,1.97226,-0.17814,0.05386,3.63963,0.93135,9.1413,1.3116,7.94161,16.28554,-7.96837,7.51735,-11.08024,12.55339,-16.26722,4.51735,-1.72686,4.38773,-12.12615,-0.00009,-6.7542,-0.40472,1.05265,0.38705,-16.98303,7.04602,-17.38546,1.63327,-16.2354,2.70557,-6.77269,5.12817,-10.27983,-0.21504,-14.5845,-1.09903,-6.38051,3.56792,-10.14278,1.36574,-15.42086,2.74464,-2.82684,-0.86632,-4.76375,4.62883,-10.01948]},{"time":5.3,"vertices":[-1.76822,0.0848,0,0,-0.16772,6.95595,0.37704,5.65701,0,0,2.05318,2.38856,0,0,0,0,0,0,0,0,0.00001,4.39987,2.17891,4.27421,0.00001,4.39987,0.00001,4.39987,-2.43681,7.1761,0.00001,4.39987,0.00001,4.39987,0,0,-2.13976,3.9918,-3.09316,-1.88854,-0.96019,3.68056,0.00001,4.39987,0.00001,4.39987,0.00001,4.39987,0.00001,4.39987,0,0,0,0,0,0,0,0,0,0,0,0,-0.35497,0.40567,0,0,0,0,0,0,-0.63007,0.52312,0.25067,5.24704,0,0,0,0,0,0,-4.30182,2.1929,-1.84497,1.41585,-0.29341,5.07035,-2.53148,0.81519,0,0,0.00001,4.39987,0.00001,4.39987,0.16969,7.0064,0.00001,4.39987,0.00001,4.39987,-1.91237,0.77886,0.26149,8.05748,2.76035,5.24092,-1.57222,5.07117,0.45898,6.88789,1.51866,6.81726,0,0,-1.3502,3.68002,-1.56204,6.48637]},{"time":5.9667,"vertices":[7.17848,-3.42638,0,0,5.42572,-16.45878,1.74104,-18.09897,0,0,-5.78609,-0.73536,1.31149,7.94153,0,0,0,0,0,0,2.04854,-13.77925,-2.86462,-12.6759,-0.00009,-6.7542,4.08717,-22.09231,-1.06798,-6.20035,-0.08147,-12.28359,4.83891,-16.76678,2.81412,2.94277,0,0,1.89272,-8.76137,-3.07864,-10.13071,3.27611,-9.4468,3.44452,-5.13387,2.29398,-11.51661,0.54729,-9.71761,-0.72302,-2.72166,-0.18715,-2.20151,0,0,0.77553,2.91688,-0.72302,-2.72166,1.10143,-11.72056,2.14642,-9.16574,0,0,0,0,0.30415,-6.3732,-0.38916,8.84673,1.97226,-0.17814,0.05386,3.63963,0.93135,9.1413,1.3116,7.94161,16.28554,-7.96837,7.51735,-11.08024,12.55339,-16.26722,4.51735,-1.72686,4.38773,-12.12615,-0.00009,-6.7542,-0.40472,1.05265,0.38705,-16.98303,7.04602,-17.38546,1.63327,-16.2354,2.70557,-6.77269,5.12817,-10.27983,-0.21504,-14.5845,-1.09903,-6.38051,3.56792,-10.14278,1.36574,-15.42086,2.74464,-2.82684,-0.86632,-4.76375,4.62883,-10.01948]},{"time":6.3333,"vertices":[-1.76822,0.0848,0,0,-0.16772,6.95595,0.37704,5.65701,0,0,2.05318,2.38856,0,0,0,0,0,0,0,0,0.00001,4.39987,2.17891,4.27421,0.00001,4.39987,0.00001,4.39987,-2.43681,7.1761,0.00001,4.39987,0.00001,4.39987,0,0,-2.13976,3.9918,-3.09316,-1.88854,-0.96019,3.68056,0.00001,4.39987,0.00001,4.39987,0.00001,4.39987,0.00001,4.39987,0,0,0,0,0,0,0,0,0,0,0,0,-0.35497,0.40567,0,0,0,0,0,0,-0.63007,0.52312,0.25067,5.24704,0,0,0,0,0,0,-4.30182,2.1929,-1.84497,1.41585,-0.29341,5.07035,-2.53148,0.81519,0,0,0.00001,4.39987,0.00001,4.39987,0.16969,7.0064,0.00001,4.39987,0.00001,4.39987,-1.91237,0.77886,0.26149,8.05748,2.76035,5.24092,-1.57222,5.07117,0.45898,6.88789,1.51866,6.81726,0,0,-1.3502,3.68002,-1.56204,6.48637]},{"time":6.6667,"vertices":[7.17848,-3.42638,0,0,5.42572,-16.45878,1.74104,-18.09897,0,0,-5.78609,-0.73536,1.31149,7.94153,0,0,0,0,0,0,2.04854,-13.77925,-2.86462,-12.6759,-0.00009,-6.7542,4.08717,-22.09231,-1.06798,-6.20035,-0.08147,-12.28359,4.83891,-16.76678,2.81412,2.94277,0,0,1.89272,-8.76137,-3.07864,-10.13071,3.27611,-9.4468,3.44452,-5.13387,2.29398,-11.51661,0.54729,-9.71761,-0.72302,-2.72166,-0.18715,-2.20151,0,0,0.77553,2.91688,-0.72302,-2.72166,1.10143,-11.72056,2.14642,-9.16574,0,0,0,0,0.30415,-6.3732,-0.38916,8.84673,1.97226,-0.17814,0.05386,3.63963,0.93135,9.1413,1.3116,7.94161,16.28554,-7.96837,7.51735,-11.08024,12.55339,-16.26722,4.51735,-1.72686,4.38773,-12.12615,-0.00009,-6.7542,-0.40472,1.05265,0.38705,-16.98303,7.04602,-17.38546,1.63327,-16.2354,2.70557,-6.77269,5.12817,-10.27983,-0.21504,-14.5845,-1.09903,-6.38051,3.56792,-10.14278,1.36574,-15.42086,2.74464,-2.82684,-0.86632,-4.76375,4.62883,-10.01948]},{"time":6.7333,"vertices":[11.74327,-3.68187,4.7377,-3.71867,5.70432,-19.13493,-0.46322,-20.38404,-5.27686,-2.89393,-10.62485,-1.59418,-3.54076,8.28222,-4.72627,3.79184,0.13995,3.39109,5.28828,2.96711,0.4997,-14.98729,-6.87443,-14.42881,-2.92172,-7.7296,4.11218,-22.98387,-2.4091,-4.43094,0.12011,-11.3843,1.96287,-16.0104,-0.5541,4.30926,-1.97913,3.10845,1.63998,-6.84303,-1.77196,-6.93063,4.98243,-8.13606,5.6986,-3.91065,3.4655,-11.56204,3.08778,-9.4063,1.98035,-0.25551,2.74338,-0.3475,3.58666,1.97372,4.63014,3.59557,1.23049,0.19272,2.33788,-8.78735,2.8056,-6.43972,-0.43085,2.8015,-0.93279,3.24313,-1.23176,-3.38932,-3.22755,10.653,-0.53963,2.08547,-2.96166,5.35121,-2.9946,10.5157,-2.59729,8.82595,19.30161,-9.62279,10.04065,-11.6135,14.38348,-18.34987,8.10802,-1.54709,6.15129,-13.21498,-4.06235,-6.84723,-4.27836,1.66678,-0.91152,-17.04574,3.30947,-16.79984,2.20965,-16.50776,1.78208,-5.40714,2.9863,-8.78538,0.52863,-12.5357,-2.92494,-3.93778,1.98259,-8.66321,-0.14685,-14.4991,-0.19865,-1.27871,-2.69971,-2.05912,2.53244,-8.20283]},{"time":6.8667,"vertices":[-13.23585,-3.12182,-19.81581,12.6107,1.07667,-0.47931,8.44568,-2.03151,19.36623,13.25906,14.68945,4.83096,19.96692,5.6562,19.79907,-12.89907,0.75992,-13.21417,-19.38301,-13.54753,6.60028,-3.67388,12.7839,0.19748,10.82996,0.53741,1.76941,-10.92689,5.07129,-10.34282,-0.7319,-11.51509,14.25288,-12.77577,15.47563,-2.15974,8.87518,-11.30283,2.76995,-13.05478,-6.03343,-19.41658,-4.18462,-11.92057,-6.15021,-9.00371,-3.30676,-7.77199,-9.57732,-8.48396,-10.06542,-12.35689,-10.82524,-9.74249,-13.1611,-9.03837,-14.13935,-2.24311,-6.98299,-13.80827,-3.18959,-19.46515,-0.30252,-16.80648,2.74858,-10.70665,4.86633,-12.22762,7.17838,-15.12004,11.63197,-0.18624,11.89079,-7.9735,12.46701,-3.12914,16.54681,2.07226,16.51477,3.18382,-1.95923,-0.21632,-5.35149,-6.21897,-0.1001,-3.39545,-10.97691,-3.28437,-4.66245,-4.38596,15.59581,-2.44851,15.02758,-0.20534,4.93092,-10.2555,18.9429,-12.22617,-1.60497,-9.70325,5.72585,-9.38074,12.00243,-11.73,-2.52554,-17.67085,7.18767,-12.88549,8.8299,-11.76675,6.80396,-13.00219,13.73757,-6.76037,7.49999,-12.85738,11.63176,-12.81963]},{"time":7,"vertices":[11.89211,-3.0747,6.35181,-4.87351,4.76218,-16.92696,-1.54126,-17.76088,-6.97619,-3.91303,-11.121,-1.78,-5.36615,6.83735,-6.335,4.98479,0.1414,4.51808,6.99301,4.02427,-0.4213,-12.81375,-7.67176,-12.66075,-3.89148,-6.81332,3.29655,-19.12686,-2.69236,-2.68902,0.15295,-8.76687,0.04316,-12.65371,-2.20229,4.15865,-2.67257,4.11338,1.14873,-4.56453,-0.83549,-3.93528,4.88294,-5.90658,5.76264,-2.51452,3.38651,-9.39459,3.78943,-7.43565,2.96713,1.1157,3.71425,0.72531,4.74384,2.68021,5.75645,3.32755,1.96389,1.70148,2.46349,-5.59476,2.55501,-3.8072,-0.6097,3.72631,-1.28315,4.30675,-1.85435,-1.2213,-4.08617,9.55369,-1.76896,2.83206,-3.97681,5.1966,-4.45339,9.19972,-4.11911,7.57305,17.23135,-8.67169,9.43264,-9.68684,12.60443,-15.98322,8.43567,-1.1212,5.88581,-11.27533,-5.4201,-5.65557,-5.4833,1.6267,-1.46291,-13.88326,0.69127,-13.40157,2.0471,-13.53339,0.93031,-3.69669,1.26439,-6.39667,0.74257,-9.09857,-3.37189,-1.94645,0.73838,-6.29281,-0.96149,-11.31179,-1.71405,-0.27802,-3.19152,-0.28638,0.91598,-5.75474]},{"time":7.1333,"vertices":[-17.04426,-2.89985,-22.36845,13.80482,-1.02729,4.31279,8.297,3.33351,21.43711,15.19497,18.07735,6.12436,22.12968,4.24776,22.36526,-14.04998,1.07929,-14.72546,-21.44049,-15.4401,6.32539,0.14491,14.70426,4.42361,11.86095,2.87116,0.12529,-5.60225,5.94962,-9.52271,-1.04071,-9.12404,14.08289,-9.09976,16.60209,-3.10828,10.12204,-12.45024,2.43144,-11.92609,-5.84808,-18.59351,-5.8093,-10.61845,-7.95087,-8.70347,-4.6758,-5.30094,-11.08099,-6.68531,-10.92098,-13.09911,-11.95867,-10.36563,-14.55919,-10.29203,-15.8973,-3.62208,-7.44939,-14.66979,-3.99229,-18.26992,-1.0325,-16.06038,3.26059,-11.8876,5.6547,-13.55249,7.96485,-14.82687,13.45655,-2.63971,12.83348,-8.69381,14.11628,-4.35411,18.52493,-0.16796,18.31128,1.42425,-7.40957,1.58574,-8.55645,-3.92162,-4.44744,0.71391,-13.6466,-3.46152,-6.90639,-1.42898,17.24123,-0.38706,16.97486,-0.24013,4.95721,-6.21177,18.62669,-8.29838,-2.7117,-5.97723,5.50058,-8.39981,11.69724,-9.94555,-2.98537,-15.33599,8.36238,-12.27458,8.62798,-10.02511,6.85869,-9.76078,14.54749,-6.53104,8.69949,-12.73633,11.46206,-11.23102]},{"time":7.2333,"vertices":[9.16511,-2.18739,5.29376,-4.60264,3.4974,-11.69504,-1.26214,-12.07568,-6.27839,-3.10671,-8.69583,-1.31784,-5.13844,4.85249,-5.27964,4.61876,0.34335,3.89193,6.29227,3.12294,-0.40084,-8.57196,-5.90977,-8.6246,-3.25656,-4.57492,2.74804,-12.62331,-1.85472,-1.21319,0.57686,-5.49082,-0.2785,-7.72246,-2.43026,3.3642,-2.12996,3.67818,1.05018,-2.36974,0.34057,-1.82739,4.03936,-3.50375,4.63974,-1.35249,2.88446,-6.1682,3.51946,-4.92634,2.96032,1.22377,3.45948,0.79096,4.265,2.06225,4.8351,2.10748,2.11469,1.7841,2.496,-2.85725,2.29647,-1.6885,-0.35065,3.23877,-0.90896,3.77809,-1.28599,0.15265,-3.64666,6.87508,-1.74707,2.68735,-3.47945,4.03722,-4.24222,6.62476,-4.01476,5.43233,12.22792,-5.87364,7.17236,-6.43217,9.08769,-10.79209,6.60639,-0.806,4.63747,-7.67448,-4.53212,-3.48996,-4.70462,1.43158,-0.83773,-8.99468,-0.10313,-8.13992,1.96328,-8.90959,0.6166,-1.90217,0.58655,-3.47223,1.26066,-5.40541,-2.39218,-0.50211,0.40344,-3.49011,-0.55935,-6.98919,-1.80487,0.50322,-2.30855,0.66238,0.3858,-2.9772]},{"time":7.3333,"vertices":[-8.33853,-1.27204,-10.63578,6.7992,-0.71201,2.29726,3.79427,1.82739,10.39,7.17119,8.79785,2.91248,10.7098,1.77986,10.63841,-6.86573,0.42153,-7.04647,-10.3875,-7.23768,2.86628,0.24181,7.00128,2.27161,5.64366,1.42624,-0.26308,-2.36772,2.74607,-4.47762,-0.68228,-4.15654,6.45274,-4.22865,7.93414,-1.65121,4.77528,-6.01581,0.97051,-5.59819,-2.98459,-8.66946,-3.00233,-4.91903,-3.9754,-4.0534,-2.42892,-2.33388,-5.46619,-2.9645,-5.34168,-6.13648,-5.824,-4.83146,-7.05134,-4.81418,-7.63039,-1.6576,-3.68663,-6.91339,-2.1722,-8.54523,-0.72704,-7.55479,1.48711,-5.69968,2.62457,-6.51453,3.65443,-7.04735,6.5375,-1.46252,6.06949,-4.24931,6.78242,-2.21457,8.96869,-0.32878,8.85883,0.45093,-3.8714,0.79116,-4.35661,-1.70611,-2.48407,0.51782,-6.65407,-1.56314,-3.51125,-0.47336,8.20282,-0.17313,8.16218,-0.21589,2.15966,-2.7328,8.59797,-3.8879,-1.5293,-2.59279,2.47475,-3.96575,5.36447,-4.72032,-1.67855,-7.08724,3.88375,-5.81105,3.91659,-4.72395,3.04906,-4.48213,6.8675,-3.19071,4.05534,-6.06188,5.25327,-5.33433]},{"time":7.5}]}}}}}}',
'files/assets/18517118/1/species-matamata-baby.json': '{"skeleton":{"hash":"65GfpYITTwoYr0ZK3JP2fTeKEo4","spine":"3.5.51","width":468.55,"height":263.03,"images":"./images/"},"bones":[{"name":"species-matamata-baby","color":"ff3f00ff"},{"name":"_0009_matamata-baby-foot4","parent":"species-matamata-baby","length":40.52,"rotation":-31.48,"x":-25.06,"y":30.91},{"name":"matamata-baby-top","parent":"species-matamata-baby","x":-3.46,"y":82.77},{"name":"_0009_matamata-baby-leg2","parent":"matamata-baby-top","length":70.2,"rotation":-98.07,"x":-11.96,"y":14.05},{"name":"matamata15","parent":"species-matamata-baby","length":28.89,"rotation":-54.48,"x":79.88,"y":20.74},{"name":"matamata-baby-neck","parent":"matamata-baby-top","length":94.86,"rotation":-7.18,"x":77.52,"y":-26.13},{"name":"matamata-baby-head","parent":"matamata-baby-neck","length":77.7,"rotation":-29.89,"x":112.44,"y":69.42},{"name":"matamata-baby-brown2","parent":"matamata-baby-head","x":-41.53,"y":-26.27},{"name":"matamata-baby-eyelid6","parent":"matamata-baby-head","x":10.6,"y":-30.07},{"name":"matamata-baby-eyelid1","parent":"matamata-baby-eyelid6","x":-4.58,"y":69.58},{"name":"matamata-baby-hand2","parent":"matamata-baby-top","length":45.44,"rotation":-94.56,"x":87.12,"y":-11.74},{"name":"matamata-baby-hand2a","parent":"matamata-baby-top","length":48.61,"rotation":-102,"x":31.99,"y":-60.67},{"name":"matamata-baby-hand2b","parent":"species-matamata-baby","length":33.72,"rotation":-40.36,"x":18.3,"y":-27.07},{"name":"matamata-baby-hightlight","parent":"matamata-baby-eyelid6","x":-7.72,"y":-23.03},{"name":"matamata-baby-leg","parent":"matamata-baby-top","length":72.48,"rotation":-111.1,"x":-62.62,"y":-29.8},{"name":"matamata-baby-leg2","parent":"species-matamata-baby","length":43.46,"rotation":-26.54,"x":-93.16,"y":-15.53},{"name":"matamata-baby-leg3","parent":"species-matamata-baby","x":-98.47,"y":-27.21,"color":"ff3f00ff"},{"name":"matamata-baby-leg4","parent":"species-matamata-baby","x":-38.47,"y":18.46,"color":"ff3f00ff"},{"name":"matamata-baby-pink","parent":"matamata-baby-head","length":120.53,"rotation":-110.31,"x":62.34,"y":45.95},{"name":"matamata-baby-pupil","parent":"matamata-baby-eyelid6","x":2.57,"y":-6.36},{"name":"matamata-baby-tongue","parent":"matamata-baby-head","length":73.92,"rotation":-7.62,"x":14.86,"y":-13.89}],"slots":[{"name":"matamata-baby-shadow","bone":"species-matamata-baby","attachment":"matamata-baby-shadow"},{"name":"matamata-baby-leg2","bone":"_0009_matamata-baby-foot4","attachment":"matamata-baby-leg"},{"name":"matamata-baby-leg","bone":"matamata-baby-leg3","color":"bdbdbdff","attachment":"matamata-baby-leg"},{"name":"matamata-baby-hand2","bone":"matamata-baby-hand2","attachment":"matamata-baby-hand"},{"name":"matamata-baby-neck","bone":"matamata-baby-neck","attachment":"matamata-baby-neck"},{"name":"matamata-baby-hand","bone":"species-matamata-baby","color":"d9d9d9ff","attachment":"matamata-baby-hand"},{"name":"matamata-baby-top","bone":"matamata-baby-top","attachment":"matamata-baby-top"},{"name":"matamata-baby-tongue","bone":"matamata-baby-tongue","attachment":"matamata-baby-tongue"},{"name":"matamata-baby-head","bone":"matamata-baby-head","attachment":"matamata-baby-head"},{"name":"matamata-baby-pink","bone":"matamata-baby-pink","attachment":"matamata-baby-pink"},{"name":"matamata-baby-eyeball1","bone":"matamata-baby-eyelid6","attachment":"matamata-baby-eyeball"},{"name":"matamata-baby-pupuil1","bone":"matamata-baby-pupil","attachment":"matamata-baby-pupuil"},{"name":"matamata-baby-highlight1","bone":"matamata-baby-hightlight","attachment":"matamata-baby-highlight"},{"name":"matamata-baby-eyelid1","bone":"matamata-baby-eyelid1","attachment":"matamata-baby-eyelid"},{"name":"matamata-baby-brow1","bone":"matamata-baby-brown2","attachment":"matamata-baby-brow"},{"name":"matamata-baby-eyeball2","bone":"matamata-baby-eyelid6","attachment":"matamata-baby-eyeball"},{"name":"matamata-baby-pupuil2","bone":"matamata-baby-pupil","attachment":"matamata-baby-pupuil"},{"name":"matamata-baby-highlight2","bone":"matamata-baby-hightlight","attachment":"matamata-baby-highlight"},{"name":"matamata-baby-eyelid","bone":"matamata-baby-eyelid1","attachment":"matamata-baby-eyelid"},{"name":"matamata-baby-brow2","bone":"matamata-baby-brown2","attachment":"matamata-baby-brow"}],"skins":{"default":{"matamata-baby-brow1":{"matamata-baby-brow":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0],"triangles":[1,2,3,1,3,0],"vertices":[64.07,72.25,37.27,52,22.09,72.1,48.88,92.34],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":8,"height":6}},"matamata-baby-brow2":{"matamata-baby-brow":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0],"triangles":[1,2,3,1,3,0],"vertices":[29.77,-1.98,1.88,-23.05,-13.93,-2.13,13.96,18.94],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":8,"height":6}},"matamata-baby-eyeball1":{"matamata-baby-eyeball":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0],"triangles":[1,2,3,1,3,0],"vertices":[62.42,55.78,15.35,20.2,-20.22,67.27,26.85,102.85],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":17,"height":17}},"matamata-baby-eyeball2":{"matamata-baby-eyeball":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0],"triangles":[1,2,3,1,3,0],"vertices":[41.24,-11.53,-5.83,-47.1,-41.4,-0.03,5.67,35.54],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":17,"height":17}},"matamata-baby-eyelid":{"matamata-baby-eyelid":{"type":"mesh","uvs":[1,1,0,1,0,0.3509,0,0,0.53324,0,1,0,0.5756,0.29701,0.34567,0.57992],"triangles":[6,4,5,2,3,4,2,4,6,7,2,6,1,2,7,6,5,0,7,6,0,1,7,0],"vertices":[33.25,-75.4,-13.82,-110.97,-34.56,-83.53,-45.77,-68.69,-20.67,-49.72,1.3,-33.12,-9.19,-60.77,-10.97,-80.92],"hull":6,"edges":[0,2,0,10,6,8,8,10,2,4,4,6],"width":17,"height":15}},"matamata-baby-eyelid1":{"matamata-baby-eyelid":{"type":"mesh","uvs":[1,1,0,1,0,0.34164,0,0,0.4811,0,1,0,0.63262,0.32477,0.26139,0.679],"triangles":[6,4,5,2,3,4,2,4,6,7,2,6,1,2,7,6,5,0,7,6,0,1,7,0],"vertices":[54.38,-7.04,7.31,-42.61,-13.73,-14.78,-24.65,-0.33,-2,16.78,22.43,35.24,15.51,8.44,9.36,-19.74],"hull":6,"edges":[0,2,0,10,6,8,8,10,2,4,4,6],"width":17,"height":15}},"matamata-baby-hand":{"matamata-baby-hand":{"type":"mesh","uvs":[1,0.71914,1,1,0.4508,1,0,1,0,0,1,0,0.52489,0.53394,0.12802,0.63683,0.52753,0.48862,0.12537,0.59151,0.13331,0.68617,0.33174,0.56476,0.34233,0.60592,0.34497,0.64502,0.32381,0.51949,0.11479,0.5483,0.59103,0.56888,0.3874,0.68305,0.66066,0.17028,0.35837,0.06805],"triangles":[2,0,1,3,10,2,2,10,17,10,13,17,2,16,0,16,2,17,3,7,10,7,3,15,10,7,13,7,12,13,17,13,12,16,17,6,7,15,9,15,3,4,16,18,0,18,5,0,6,17,12,7,11,12,7,9,11,12,11,6,9,14,11,9,15,14,6,8,16,16,8,18,11,14,6,14,15,19,6,14,8,14,19,8,19,15,4,8,19,18,18,19,5,19,4,5],"vertices":[1,12,46.91,28.55,1,2,11,77.05,61.33,0.0015,12,66.54,5.42,0.9985,2,11,86.63,16.2,0,12,31.37,-24.45,1,1,12,2.51,-48.96,1,1,11,-11.15,-43.27,1,1,11,-28.6,38.9,1,2,11,36.1,11.84,0.97969,12,3.53,17.96,0.02031,2,11,53.89,-18.47,0.41837,12,-14.69,-12.1,0.58163,1,11,31.27,11.04,1,2,11,49.15,-19.7,0.41837,12,-18.03,-8.51,0.58163,2,11,59.01,-16.93,0.16842,12,-10.9,-15.87,0.83158,1,11,42.73,-3.34,1,1,11,46.89,-1.55,1,1,12,-0.22,-0.97,1,1,11,38.08,-5.01,1,2,11,44.77,-21.54,0.69018,12,-21.73,-5.53,0.30982,1,11,38.64,18.05,1,1,12,5.15,-1.8,1,1,11,-4.69,14.84,1,1,11,-10.21,-12.3,1],"hull":6,"edges":[6,8,8,10,2,0,0,10,2,4,4,6],"width":22,"height":29}},"matamata-baby-hand2":{"matamata-baby-hand":{"type":"mesh","uvs":[1,0.7496,1,1,0.56142,1,0,1,0,0,1,0,0.4666,0.09077,0.63728,0.21368,0.48556,0.49885,0.49188,0.58243,0.15685,0.44477,0.15685,0.52343,0.16317,0.6021,0.15685,0.68568,0.35281,0.72993,0.34017,0.64143,0.32753,0.55785,0.31488,0.47427],"triangles":[12,16,15,13,11,12,13,12,15,14,15,9,13,15,14,3,11,13,2,9,0,14,9,2,3,13,14,2,3,14,2,0,1,6,4,5,7,6,5,10,4,6,17,10,6,8,17,6,7,8,6,11,10,17,16,17,8,11,17,16,0,9,8,16,8,9,12,11,16,15,16,9,7,5,0,0,8,7,11,3,4,11,4,10],"vertices":[2,10,61.44,51.42,0.24708,4,41.4,32.11,0.75292,2,10,88.4,53.56,0.00263,4,63.41,16.39,0.99737,1,4,42,-13.6,1,1,4,14.59,-51.99,1,1,10,-12.62,-38.72,1,1,10,-19.27,45.02,1,1,10,-5.95,1.13,1,1,10,6.15,16.47,1,1,10,37.86,6.2,1,2,10,46.82,7.44,0.66192,4,1.89,7.86,0.33808,2,10,34.22,-21.79,0.84439,4,-26.56,-6.41,0.15561,2,10,42.69,-21.11,0.66434,4,-19.65,-11.35,0.33566,2,10,51.12,-19.91,0.4003,4,-12.42,-15.86,0.5997,2,10,60.16,-19.73,0.1221,4,-5.38,-21.53,0.8779,2,10,63.62,-2.94,0.00011,4,8.07,-10.91,0.99989,2,10,54.18,-4.76,0.02883,4,-0.33,-6.22,0.97117,2,10,45.26,-6.53,0.81345,4,-8.29,-1.84,0.18655,2,10,36.35,-8.3,0.96327,4,-16.26,2.54,0.03673],"hull":6,"edges":[6,8,8,10,2,0,0,10,2,4,4,6],"width":22,"height":29}},"matamata-baby-head":{"matamata-baby-head":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0,0.89105,0.63177,0.40531,0.21686,0.68105,0.46384],"triangles":[5,2,3,6,5,3,4,6,3,1,2,5,1,5,6,3,0,4,1,6,4,0,1,4],"vertices":[115.59,-24.84,-8.87,-118.9,-79.41,-25.55,45.05,68.5,76.06,-0.72,-13.67,-7.68,38.07,-4.79],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":46,"height":35}},"matamata-baby-highlight1":{"matamata-baby-highlight":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0],"triangles":[1,2,3,1,3,0],"vertices":[35.72,77.31,23.52,68.09,14.71,79.76,26.9,88.97],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":7,"height":6}},"matamata-baby-highlight2":{"matamata-baby-highlight":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0],"triangles":[1,2,3,1,3,0],"vertices":[12.15,10.37,0.07,1.24,-8.66,12.8,3.42,21.92],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":7,"height":6}},"matamata-baby-leg":{"matamata-baby-leg":{"type":"mesh","uvs":[1,0.78743,1,1,0.45799,1,0,1,0,0.66995,0,0.56187,0,0.46319,0,0,0.42211,0,1,0,0.75219,0.10606,0.67326,0.49139,0.70196,0.59477,0.40776,0.78743,0.37188,0.66056,0.37906,0.52428],"triangles":[2,0,1,3,13,2,2,12,0,2,13,12,13,4,14,13,3,4,0,12,9,9,11,10,13,14,12,12,15,11,15,12,14,4,5,14,14,5,15,9,12,11,5,6,15,11,15,8,15,6,8,11,8,10,6,7,8,10,8,9],"vertices":[2,14,61.96,57.77,0.21615,15,57.03,17.18,0.78385,1,15,67.76,-4.32,1,2,14,98.8,28.98,0.00044,15,31.86,-22.23,0.99956,2,14,110.99,-2.64,0.00012,15,1.53,-37.36,0.99988,2,14,76.19,-16.06,0.03216,15,-15.12,-3.98,0.96784,2,14,64.79,-20.45,0.59348,15,-20.57,6.95,0.40652,2,14,54.39,-24.46,0.96397,15,-25.55,16.93,0.03603,1,14,5.55,-43.29,1,1,14,-5.69,-14.14,1,1,14,-21.07,25.76,1,1,14,-3.29,12.96,1,2,14,39.44,23.17,0.99937,15,20.46,36.32,0.00063,2,14,49.58,29.36,0.97663,15,27.57,26.81,0.02337,1,15,17.81,-2.39,1,2,14,65.3,9.24,0.94455,15,9.03,9.25,0.05545,1,14,50.74,4.2,1],"hull":10,"edges":[2,0,0,18,2,4,4,6,14,16,16,18,6,8,8,10,10,12,12,14],"width":22,"height":33}},"matamata-baby-leg2":{"matamata-baby-leg":{"type":"mesh","uvs":[1,0.77802,1,1,0.44496,1,0,1,0,0.71224,0,0.59946,0,0.46318,0,0,0.45214,0,1,0,0.73917,0.09195,0.67458,0.45379,0.69611,0.56656,0.70329,0.64645,0.35168,0.51018,0.38038,0.66055,0.41626,0.81562],"triangles":[10,8,9,11,8,10,14,6,7,8,14,7,11,14,8,9,12,11,5,6,14,9,13,12,12,15,14,12,14,11,15,12,13,5,14,15,4,5,15,10,9,11,0,13,9,16,15,13,16,3,4,16,4,15,2,16,13,3,16,2,13,0,1,2,13,1],"vertices":[55.27,32.75,72.61,14.62,42.92,-13.78,19.12,-36.54,-3.36,-13.04,-12.17,-3.83,-22.81,7.3,-59,45.13,-34.81,68.27,-5.51,96.29,-12.28,75.44,12.54,42.58,22.5,34.47,29.12,28.31,-0.33,21.46,12.95,10.64,26.99,-0.19],"hull":10,"edges":[14,16,16,18,6,8,8,10,10,12,12,14,2,4,4,6,2,0,0,18],"width":22,"height":33}},"matamata-baby-neck":{"matamata-baby-neck":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0],"triangles":[1,2,3,1,3,0],"vertices":[124.9,-43.9,-21.94,-62.38,-31.93,17,114.91,35.48],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":44,"height":24}},"matamata-baby-pink":{"matamata-baby-pink":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0,0.40037,0.44953,0.43658,0.5837,0.49089,0.72953,0.56129,0.31537,0.60152,0.43204,0.67394,0.52537],"triangles":[7,2,3,8,7,3,4,2,7,4,7,8,9,8,3,5,4,8,5,8,9,6,5,9,1,2,4,1,4,5,1,5,6,9,3,0,6,9,0,1,6,0],"vertices":[19.84,91.87,166.4,-1.92,101.71,-102.99,-44.84,-9.2,72.12,-20.01,75.49,-3.05,76.96,16.78,39.85,-18.47,41.5,-2.91,36.93,13.32],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":51,"height":34}},"matamata-baby-pupuil1":{"matamata-baby-pupuil":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0],"triangles":[1,2,3,1,3,0],"vertices":[49.48,67.11,16.77,42.39,-7.35,74.3,25.36,99.02],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":13,"height":12}},"matamata-baby-pupuil2":{"matamata-baby-pupuil":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0],"triangles":[1,2,3,1,3,0],"vertices":[25.26,0.68,-6.33,-23.19,-28.36,5.97,3.23,29.84],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":13,"height":12}},"matamata-baby-shadow":{"matamata-baby-shadow":{"x":8.71,"y":-4.51,"scaleX":2.218,"scaleY":2.042,"rotation":-0.55,"width":30,"height":13}},"matamata-baby-tongue":{"matamata-baby-tongue":{"type":"mesh","uvs":[1,1,0,1,0,0,1,0,0.49313,0.48739],"triangles":[4,2,3,1,2,4,4,3,0,1,4,0],"vertices":[100.57,-1.03,-4.62,-105.13,-78.48,-30.5,26.71,73.6,9.39,-15.54],"hull":4,"edges":[0,2,2,4,4,6,0,6],"width":44,"height":31}},"matamata-baby-top":{"matamata-baby-top":{"type":"mesh","uvs":[1,0.51338,1,1,0.43468,1,0,1,0,0.72099,0,0,0.2801,0,0.62009,0,1,0,0.46539,0.55236,0.73072,0.22051,0.47977,0.17232,0.84675,0.14266,0.89802,0.30949,0.22343,0.24276,0.44119,0.29623,0.64529,0.33735],"triangles":[12,7,8,11,6,7,10,7,12,11,7,10,14,5,6,14,6,11,15,14,11,13,12,8,10,12,13,16,11,10,15,11,16,13,8,0,9,15,16,4,5,14,3,4,2,14,9,4,15,9,14,9,2,4,16,10,13,16,13,0,9,16,0,9,0,1,2,9,1],"vertices":[144.45,0.26,144.45,-107.77,-27.97,-107.77,-160.55,-107.77,-160.55,-45.83,-160.55,114.23,-75.12,114.23,28.58,114.23,144.45,114.23,-18.6,-8.39,62.32,65.28,-14.22,75.98,97.71,82.56,113.35,45.52,-92.4,60.34,-25.98,48.47,36.26,39.34],"hull":9,"edges":[2,4,4,6,14,16,10,12,12,14,2,0,0,16,6,8,8,10],"width":91,"height":66}}}},"animations":{"idle":{"bones":{"matamata-baby-top":{"rotate":[{"time":0,"angle":0},{"time":0.4333,"angle":1.75},{"time":1.4667,"angle":-1.88},{"time":2.0667,"angle":0}],"translate":[{"time":0,"x":0,"y":0},{"time":0.6667,"x":6.51,"y":10.59,"curve":"stepped"},{"time":0.7667,"x":6.51,"y":10.59},{"time":1.9333,"x":0.35,"y":-0.92},{"time":2.0667,"x":0,"y":0}]},"_0009_matamata-baby-leg2":{"rotate":[{"time":0,"angle":0},{"time":1.8333,"angle":0.36},{"time":2.0667,"angle":0}]},"matamata-baby-neck":{"rotate":[{"time":0,"angle":0,"curve":"stepped"},{"time":0.2667,"angle":0},{"time":0.9,"angle":-4.83},{"time":2.0667,"angle":0}]},"matamata-baby-eyelid6":{"translate":[{"time":0,"x":0,"y":0},{"time":0.5667,"x":-5.29,"y":3.93},{"time":1.5667,"x":3.43,"y":-0.91},{"time":2.0667,"x":0,"y":0}]},"matamata-baby-head":{"rotate":[{"time":0,"angle":0},{"time":0.1333,"angle":1.78},{"time":2.0667,"angle":0}],"translate":[{"time":0,"x":0,"y":0},{"time":0.7667,"x":7.02,"y":-0.11},{"time":1.1,"x":2.9,"y":-1.98},{"time":1.7,"x":-2.09,"y":0.74},{"time":2.0667,"x":0,"y":0}]},"matamata-baby-pupil":{"translate":[{"time":0,"x":0,"y":0},{"time":0.2667,"x":-2.1,"y":0.73},{"time":0.8667,"x":-1.4,"y":0.49},{"time":1.0667,"x":-3.84,"y":-13.26,"curve":"stepped"},{"time":1.7,"x":-3.84,"y":-13.26},{"time":1.8667,"x":-1.4,"y":0.49},{"time":2.0667,"x":0,"y":0}]},"matamata-baby-eyelid1":{"translate":[{"time":0,"x":0,"y":0},{"time":0.7333,"x":1.23,"y":-2.05},{"time":2.0667,"x":0,"y":0}]},"matamata-baby-pink":{"translate":[{"time":0,"x":0,"y":0},{"time":1.1333,"x":-0.37,"y":0.44,"curve":"stepped"},{"time":2.0667,"x":-0.37,"y":0.44}]}},"deform":{"default":{"matamata-baby-eyeball1":{"matamata-baby-eyeball":[{"time":0,"curve":"stepped"},{"time":0.8},{"time":0.9,"vertices":[-8.42966,1.74588]},{"time":1,"curve":"stepped"},{"time":2.0667}]},"matamata-baby-eyeball2":{"matamata-baby-eyeball":[{"time":0,"curve":"stepped"},{"time":0.8},{"time":0.9,"vertices":[-9.96667,1.69832]},{"time":1,"curve":"stepped"},{"time":2.0667}]},"matamata-baby-eyelid":{"matamata-baby-eyelid":[{"time":0,"curve":"stepped"},{"time":0.8},{"time":0.9,"offset":2,"vertices":[7.97973,-1.54327,-1.4461,-1.09221,0,0,-1.09236,1.44624,0,0,19.63355,0.06732,20.11573,0.4314]},{"time":1,"curve":"stepped"},{"time":2.0667}]},"matamata-baby-eyelid1":{"matamata-baby-eyelid":[{"time":0,"curve":"stepped"},{"time":0.8},{"time":0.9,"offset":2,"vertices":[1.14314,0.61884,0.4482,4.08548,5.86732,-1.55441,0,0,0,0,19.25012,-1.69971,12.70708,2.73956]},{"time":1,"curve":"stepped"},{"time":2.0667}]},"matamata-baby-hand":{"matamata-baby-hand":[{"time":0},{"time":1,"offset":46,"vertices":[12.27778,0.99891]},{"time":2.0667}]},"matamata-baby-head":{"matamata-baby-head":[{"time":0},{"time":0.6,"offset":2,"vertices":[-3.06075,12.37827,0,0.00002,0,0.00002,-2.67721,-2.09317,0,0.00002,-3.15701,5.12818]},{"time":1,"offset":2,"vertices":[-0.86988,9.56258,0,0.00002,0,0.00002,-4.46201,-3.48863,0,0.00002,1.31536,0.05716]},{"time":1.6667,"offset":2,"vertices":[-0.32621,3.58598,-7.96195,2.23981,0,0.00002,1.55896,-1.71367,3.08524,1.19412,4.43924,-1.46669]},{"time":2.0667}]},"matamata-baby-leg":{"matamata-baby-leg":[{"time":0},{"time":0.9333,"offset":34,"vertices":[9.25027,3.49936,4.41568,-8.85115,9.25027,3.49936,4.41568,-8.85115,0,0,9.25027,3.49936,4.41568,-8.85115,9.25027,3.49936]},{"time":2.0667}]},"matamata-baby-tongue":{"matamata-baby-tongue":[{"time":0},{"time":0.2667,"vertices":[-1.02456,-7.6016,2.35419,4.77238]},{"time":0.5333,"vertices":[0.8537,-17.31848,-3.28277,8.08463]},{"time":0.6,"vertices":[0.35522,-15.19326,-4.36193,8.46733]},{"time":0.8,"vertices":[-1.14024,-8.81759,-3.34897,5.32266]},{"time":1.4,"vertices":[-5.86215,0.44766]},{"time":2.0667}]},"matamata-baby-top":{"matamata-baby-top":[{"time":0},{"time":0.7333,"vertices":[5.90775,0.6209,0,0,-8.23544,-0.89308,0,0,0,0,0,0,5.91559,1.93289,-4.43543,-1.74368,9.82422,-2.68248,-6.01417,-0.00005,0,0,-2.01007,-1.86116,3.28384,0.63651,3.2721,-1.33146,0,0,0.3583,-1.45603,-6.01417]},{"time":2.0667}]}}}}}}',
}
function getJSONSrcByKey(key) {
 return strJSONs[key];
}
var strTxts ={
'files/assets/18515964/1/species-matamata.atlas': '\nspecies-matamata.png\nsize: 256,128\nformat: RGBA8888\nfilter: Linear,Linear\nrepeat: none\nmatamata-beads\n  rotate: false\n  xy: 216, 47\n  size: 19, 46\n  orig: 19, 46\n  offset: 0, 0\n  index: -1\nmatamata-bow\n  rotate: false\n  xy: 97, 15\n  size: 37, 38\n  orig: 37, 38\n  offset: 0, 0\n  index: -1\nmatamata-brow\n  rotate: false\n  xy: 158, 15\n  size: 26, 20\n  orig: 26, 20\n  offset: 0, 0\n  index: -1\nmatamata-elipse\n  rotate: true\n  xy: 136, 14\n  size: 39, 20\n  orig: 39, 20\n  offset: 0, 0\n  index: -1\nmatamata-eyeball1\n  rotate: false\n  xy: 232, 113\n  size: 12, 13\n  orig: 12, 13\n  offset: 0, 0\n  index: -1\nmatamata-hand1\n  rotate: true\n  xy: 111, 55\n  size: 27, 45\n  orig: 27, 45\n  offset: 0, 0\n  index: -1\nmatamata-hand2\n  rotate: true\n  xy: 184, 95\n  size: 31, 46\n  orig: 31, 46\n  offset: 0, 0\n  index: -1\nmatamata-head\n  rotate: false\n  xy: 41, 12\n  size: 54, 41\n  orig: 54, 41\n  offset: 0, 0\n  index: -1\nmatamata-leg1\n  rotate: false\n  xy: 158, 37\n  size: 27, 45\n  orig: 27, 45\n  offset: 0, 0\n  index: -1\nmatamata-leg2\n  rotate: false\n  xy: 187, 49\n  size: 27, 44\n  orig: 27, 44\n  offset: 0, 0\n  index: -1\nmatamata-ltongue\n  rotate: true\n  xy: 2, 2\n  size: 51, 37\n  orig: 51, 37\n  offset: 0, 0\n  index: -1\nmatamata-neck\n  rotate: false\n  xy: 111, 84\n  size: 71, 42\n  orig: 71, 42\n  offset: 0, 0\n  index: -1\nmatamata-pupil\n  rotate: false\n  xy: 41, 4\n  size: 7, 6\n  orig: 7, 6\n  offset: 0, 0\n  index: -1\nmatamata-top\n  rotate: false\n  xy: 2, 55\n  size: 107, 71\n  orig: 107, 71\n  offset: 0, 0\n  index: -1\n',
'files/assets/18517116/1/species-matamata-baby.atlas': '\nspecies-matamata-baby.png\nsize: 256,128\nformat: RGBA8888\nfilter: Linear,Linear\nrepeat: none\nmatamata-baby-brow\n  rotate: false\n  xy: 34, 9\n  size: 8, 6\n  orig: 8, 6\n  offset: 0, 0\n  index: -1\nmatamata-baby-eyeball\n  rotate: false\n  xy: 213, 102\n  size: 17, 17\n  orig: 17, 17\n  offset: 0, 0\n  index: -1\nmatamata-baby-eyelid\n  rotate: false\n  xy: 232, 104\n  size: 17, 15\n  orig: 17, 15\n  offset: 0, 0\n  index: -1\nmatamata-baby-hand\n  rotate: false\n  xy: 189, 90\n  size: 22, 29\n  orig: 22, 29\n  offset: 0, 0\n  index: -1\nmatamata-baby-head\n  rotate: false\n  xy: 95, 84\n  size: 46, 35\n  orig: 46, 35\n  offset: 0, 0\n  index: -1\nmatamata-baby-highlight\n  rotate: false\n  xy: 213, 94\n  size: 7, 6\n  orig: 7, 6\n  offset: 0, 0\n  index: -1\nmatamata-baby-leg\n  rotate: false\n  xy: 55, 18\n  size: 22, 33\n  orig: 22, 33\n  offset: 0, 0\n  index: -1\nmatamata-baby-neck\n  rotate: false\n  xy: 95, 58\n  size: 44, 24\n  orig: 44, 24\n  offset: 0, 0\n  index: -1\nmatamata-baby-pink\n  rotate: false\n  xy: 2, 17\n  size: 51, 34\n  orig: 51, 34\n  offset: 0, 0\n  index: -1\nmatamata-baby-pupuil\n  rotate: false\n  xy: 79, 39\n  size: 13, 12\n  orig: 13, 12\n  offset: 0, 0\n  index: -1\nmatamata-baby-shadow\n  rotate: false\n  xy: 2, 2\n  size: 30, 13\n  orig: 30, 13\n  offset: 0, 0\n  index: -1\nmatamata-baby-tongue\n  rotate: false\n  xy: 143, 88\n  size: 44, 31\n  orig: 44, 31\n  offset: 0, 0\n  index: -1\nmatamata-baby-top\n  rotate: false\n  xy: 2, 53\n  size: 91, 66\n  orig: 91, 66\n  offset: 0, 0\n  index: -1\n',
}
function getTxtSrcByKey(key) {
 return strTxts[key];
}
</script>
    <script>(function () {
    var CANVAS_ID = 'application-canvas';

    var canvas, devices, app;

    var createCanvas = function () {
        canvas = document.createElement('canvas');
        canvas.setAttribute('id', CANVAS_ID);
        canvas.setAttribute('tabindex', 0);
        // canvas.style.visibility = 'hidden';

        // Disable I-bar cursor on click+drag
        canvas.onselectstart = function () { return false; };

        document.body.appendChild(canvas);

        return canvas;
    };

    var createInputDevices = function (canvas) {
        var devices = {
            elementInput: new pc.ElementInput(canvas, {
                useMouse: INPUT_SETTINGS.useMouse,
                useTouch: INPUT_SETTINGS.useTouch
            }),
            keyboard: INPUT_SETTINGS.useKeyboard ? new pc.Keyboard(window) : null,
            mouse: INPUT_SETTINGS.useMouse ? new pc.Mouse(canvas) : null,
            gamepads: INPUT_SETTINGS.useGamepads ? new pc.GamePads() : null,
            touch: INPUT_SETTINGS.useTouch && pc.platform.touch ? new pc.TouchDevice(canvas) : null
        };

        return devices;
    };

    var configureCss = function (fillMode, width, height) {
        // Configure resolution and resize event
        if (canvas.classList) {
            canvas.classList.add('fill-mode-' + fillMode);
        }

        // css media query for aspect ratio changes
        var css  = "@media screen and (min-aspect-ratio: " + width + "/" + height + ") {";
        css += "    #application-canvas.fill-mode-KEEP_ASPECT {";
        css += "        width: auto;";
        css += "        height: 100%;";
        css += "        margin: 0 auto;";
        css += "    }";
        css += "}";

        // append css to style
        if (document.head.querySelector) {
            console.log(">>>> INNER HTML 3");
            // document.head.querySelector('style').innerHTML += css;

            console.log("<<<<< INNER HTML 3");
        }
    };

    var reflow = function () {
        app.resizeCanvas(canvas.width, canvas.height);
        canvas.style.width = '';
        canvas.style.height = '';

        var fillMode = app._fillMode;

        if (fillMode == pc.FILLMODE_NONE || fillMode == pc.FILLMODE_KEEP_ASPECT) {
            if ((fillMode == pc.FILLMODE_NONE && canvas.clientHeight < window.innerHeight) || (canvas.clientWidth / canvas.clientHeight >= window.innerWidth / window.innerHeight)) {
                canvas.style.marginTop = Math.floor((window.innerHeight - canvas.clientHeight) / 2) + 'px';
            } else {
                canvas.style.marginTop = '';
            }
        }
    };

    var displayError = function (html) {
        var div = document.createElement('div');

        console.log(">>>> INNER HTML 4");

        div.innerHTML  = [
            '<table style="background-color: #8CE; width: 100%; height: 100%;">',
            '  <tr>',
            '      <td align="center">',
            '          <div style="display: table-cell; vertical-align: middle;">',
            '              <div style="">' + html + '</div>',
            '          </div>',
            '      </td>',
            '  </tr>',
            '</table>'
        ].join('\n');

        console.log("<<<<< INNER HTML 4");


        document.body.appendChild(div);
    };

    canvas = createCanvas();
    devices = createInputDevices(canvas);

    try {
        app = new pc.Application(canvas, {
            elementInput: devices.elementInput,
            keyboard: devices.keyboard,
            mouse: devices.mouse,
            gamepads: devices.gamepads,
            touch: devices.touch,
            graphicsDeviceOptions: window.CONTEXT_OPTIONS,
            assetPrefix: window.ASSET_PREFIX || "",
            scriptPrefix: window.SCRIPT_PREFIX || "",
            scriptsOrder: window.SCRIPTS || []
        });
    } catch (e) {
        if (e instanceof pc.UnsupportedBrowserError) {
            displayError('This page requires a browser that supports WebGL.<br/>' +
                    '<a href="http://get.webgl.org">Click here to find out more.</a>');
        } else if (e instanceof pc.ContextCreationError) {
            displayError("It doesn't appear your computer can support WebGL.<br/>" +
                    '<a href="http://get.webgl.org/troubleshooting/">Click here for more information.</a>');
        } else {
            displayError('Could not initialize application. Error: ' + e);
        }

        return;
    }

    app.configure(CONFIG_FILENAME, function (err) {
        if (err) {
            console.error(err);
        }

        configureCss(app._fillMode, app._width, app._height);
        reflow();

        window.addEventListener('resize', reflow, false);
        window.addEventListener('orientationchange', reflow, false);

        app.preload(function (err) {
            if (err) {
                console.error(err);
            }

            app.loadScene(SCENE_PATH, function (err, scene) {
                if (err) {
                    console.error(err);
                }

                app.start();
            });
        });
    });
}());
</script>
    <script>pc.script.createLoadingScreen(function (app) {
    console.log("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");

    var showSplash = function () {
        // splash wrapper
        var wrapper = document.createElement('div');
        wrapper.id = 'application-splash-wrapper';
        document.body.appendChild(wrapper);

        // splash
        var splash = document.createElement('div');
        splash.id = 'application-splash';
        wrapper.appendChild(splash);
        splash.style.display = 'none';

        var logo = document.createElement('img');
        logo.src = getImageSrcByKey('files/assets/18583364/1/logo.png'); //todo find image instead hardcoded value
        splash.appendChild(logo);
        logo.onload = function () {
            splash.style.display = 'block';
        };
    };

    var hideSplash = function () {
        var splash = document.getElementById('application-splash-wrapper');
        splash.parentElement.removeChild(splash);
    };

    var setProgress = function (value) {};

    var createCss = function () {
        var css = [
            'body {',
            '    background-color: #283538;',
            '}',

            '#application-splash-wrapper {',
            '    position: absolute;',
            '    top: 0;',
            '    left: 0;',
            '    height: 100%;',
            '    width: 100%;',
            '    background: radial-gradient(circle, rgba(255,172,103,1) 0%, rgba(255,131,54,1) 100%);',
            '}',

            '#application-splash {',
            '    position: absolute;',
            '    top: calc(50% - 28px);',
            '    width: 264px;',
            '    left: calc(50% - 132px);',
            '}',

            '#application-splash img {',
            '    height: 240px;',
            '    width: 350px;',
            '    position: absolute;',
            '    left: 50%;',
            '    top: 50%;',
            '    margin-top: -120px;',
            '    margin-left: -175px;',
            '}'

        ].join('\n');

        var style = document.createElement('style');
        style.type = 'text/css';
        if (style.styleSheet) {
            style.styleSheet.cssText = css;
        } else {
            style.appendChild(document.createTextNode(css));
        }

        document.head.appendChild(style);
    };


    createCss();

    showSplash();

    app.on('preload:end', function () {
        app.off('preload:progress');
    });
    app.on('preload:progress', setProgress);
    app.on('start', hideSplash);
});
</script>
</body>
</html>
